<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concurrency on Morgoth</title>
    <link>https://canuxcheng.com/tags/concurrency/</link>
    <description>Recent content in Concurrency on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jan 2018 10:49:21 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/tags/concurrency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go_Concurrency</title>
      <link>https://canuxcheng.com/post/go_concurrency/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_concurrency/</guid>
      <description>&lt;h1 id=&#34;并发concurrency&#34;&gt;并发/concurrency&lt;/h1&gt;&#xA;&lt;p&gt;CSP: communicating sequential processes, 通信顺序进程。&lt;/p&gt;&#xA;&lt;p&gt;go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.&lt;/p&gt;&#xA;&lt;p&gt;concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。&lt;/p&gt;&#xA;&lt;p&gt;所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.&lt;/p&gt;&#xA;&lt;p&gt;parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。&lt;/p&gt;&#xA;&lt;p&gt;process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。&lt;/p&gt;&#xA;&lt;p&gt;thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。&lt;/p&gt;&#xA;&lt;p&gt;co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。&lt;/p&gt;&#xA;&lt;p&gt;goroutine: go语言的协程，是并行的，通过channel来通信.&lt;/p&gt;&#xA;&lt;p&gt;GMP: goroutine的实现模型。&lt;/p&gt;&#xA;&lt;p&gt;G: goroutine。&lt;/p&gt;&#xA;&lt;p&gt;M: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。&lt;/p&gt;&#xA;&lt;p&gt;P: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。&lt;/p&gt;&#xA;&lt;p&gt;不要通过共享内存通信，通过通信来共享内存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;goroutines&#34;&gt;goroutines&lt;/h2&gt;&#xA;&lt;p&gt;go关键字会启动一个新的goroutine并执行.&lt;/p&gt;&#xA;&lt;p&gt;每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。&lt;/p&gt;&#xA;&lt;p&gt;当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.&lt;/p&gt;&#xA;&lt;p&gt;当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go FuncName(...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;主进程main结束了，goroutine也结束．&lt;/p&gt;&#xA;&lt;h2 id=&#34;竟态&#34;&gt;竟态&lt;/h2&gt;&#xA;&lt;p&gt;race condition: 竞争状态，多个goroutine同时操作同一资源.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 检测竞争状态&#xA;$ go build -race&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;所以要解决goroutine间的消息传递和同步的问题.&lt;/p&gt;&#xA;&lt;p&gt;通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。&lt;/p&gt;&#xA;&lt;p&gt;channel还是mutex,选择的依据是他们的能力/特性.&lt;/p&gt;&#xA;&lt;p&gt;channel的能力是让数据流动起来，擅长的是数据流动的场景:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传递数据的所有权，即把某个数据发送给其他协程&lt;/li&gt;&#xA;&lt;li&gt;分发任务，每个任务都是一个数据&lt;/li&gt;&#xA;&lt;li&gt;交流异步结果，结果是一个数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缓存&lt;/li&gt;&#xA;&lt;li&gt;状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;&#xA;&lt;p&gt;goroutine通过channel来传递消息.&lt;/p&gt;&#xA;&lt;p&gt;channels是引用类型,chan是线程安全的，并且不会有数据冲突。&lt;/p&gt;&#xA;&lt;p&gt;channel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.&lt;/p&gt;&#xA;&lt;p&gt;chan通过make来创建，通过close来关闭．&lt;/p&gt;&#xA;&lt;p&gt;chan是先进先出的.&lt;/p&gt;&#xA;&lt;p&gt;如果chan指定了容量(有缓存), 就是异步，非阻塞模式．&lt;/p&gt;&#xA;&lt;p&gt;默认是无缓存的，同步的,　阻塞模式.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_concurrency</title>
      <link>https://canuxcheng.com/post/gsl_concurrency/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_concurrency/</guid>
      <description>&lt;h1 id=&#34;sync&#34;&gt;sync&lt;/h1&gt;&#xA;&lt;p&gt;sync用于goroutine同步.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;locker&#34;&gt;Locker&lt;/h2&gt;&#xA;&lt;p&gt;一个可以加锁和解锁的接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Locker interface {&#xA;    Lock()&#xA;    Unlock()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pool&#34;&gt;Pool&lt;/h2&gt;&#xA;&lt;p&gt;Pool是一个可以分别存取的临时对象的集合。&lt;/p&gt;&#xA;&lt;h2 id=&#34;once&#34;&gt;Once&lt;/h2&gt;&#xA;&lt;p&gt;只执行一次动作的对象(单例模式)&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Once struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 只有第一次调用才执行&#xA;func (o *Once) Do(f func())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;&#xA;&lt;p&gt;互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.&lt;/p&gt;&#xA;&lt;p&gt;Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。&lt;/p&gt;&#xA;&lt;p&gt;同一时刻只能有一个线程进入临界区.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Mutex struct {}&#xA;&#xA;Mutex&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 加锁，如果已经加锁，阻塞至m解锁．&#xA;func (m *Mutex) Lock()&#xA;&#xA;// 解锁，如果没有加锁，导致panic&#xA;func (m *Mutex) Unlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;rwmutex&#34;&gt;RWMutex&lt;/h2&gt;&#xA;&lt;p&gt;读写互斥锁,可以由不同的线程加锁和解锁.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type RWMutex struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。&#xA;func (rw *RWMutex) Lock()&#xA;&#xA;// 解除写入锁定，如果没有加锁，导致panic&#xA;func (rw *RWMutex) Unlock()&#xA;&#xA;// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。&#xA;func (rw *RWMutex) RLock()&#xA;&#xA;// 解除读取锁，如果没有加锁，导致panic.&#xA;func (rw *RWMutex) RUnlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cond&#34;&gt;Cond&lt;/h2&gt;&#xA;&lt;p&gt;条件变量.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Concurrency</title>
      <link>https://canuxcheng.com/post/psl_concurrency/</link>
      <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_concurrency/</guid>
      <description>&lt;h1 id=&#34;concurrent-execution&#34;&gt;Concurrent Execution&lt;/h1&gt;&#xA;&lt;p&gt;进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。&lt;/p&gt;&#xA;&lt;p&gt;线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。&lt;/p&gt;&#xA;&lt;p&gt;IPC: 进程/线程之间交换信息叫进程间通信．&lt;/p&gt;&#xA;&lt;p&gt;python的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.&lt;/p&gt;&#xA;&lt;p&gt;IO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.&lt;/p&gt;&#xA;&lt;p&gt;python的多进程可以并行,每个进程启动一个解释器进程.&lt;/p&gt;&#xA;&lt;p&gt;多进程开销大，消耗内存.&lt;/p&gt;&#xA;&lt;p&gt;计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.&lt;/p&gt;&#xA;&lt;h2 id=&#34;multiprocessing&#34;&gt;multiprocessing&lt;/h2&gt;&#xA;&lt;p&gt;多进程就是同时执行多个任务.&lt;/p&gt;&#xA;&lt;p&gt;python可以通过多进程取代多线程，从而绕过多线程的GIL.&lt;/p&gt;&#xA;&lt;p&gt;python是静态语言，&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import multiprocessing&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# multiprocessing.Process&#xA;proc = Process(group=None, target=None, name=None, args=(), kwargs={})&#xA;# methods:&#xA;run(self)&#xA;start(self) # 启动一个进程&#xA;join(self, timeout=None) # 父进程等待子进程结束&#xA;is_alive()&#xA;terminate(self)&#xA;# data descriptor:&#xA;authkey&#xA;daemon # proc.daemon = True 后台运行&#xA;exitcode&#xA;ident&#xA;name&#xA;pid&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 普通函数&#xA;active_children()&#xA;allow_connection_pickling()&#xA;cpu_count() # 获取cpu个数&#xA;current_process()&#xA;freeze_support()&#xA;get_logger()&#xA;log_to_stderr(level=None)&#xA;&#xA;Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)&#xA;pool = Pool()&#xA;# func只能是顶层函数，不能是方法和内部函数.&#xA;# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())&#xA;# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.&#xA;apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,&#xA;map_async(func, iterable, chunksize=None, callback=None) # 非阻塞&#xA;# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.&#xA;apply(func, args=(), kwargs={}) # 阻塞&#xA;map(func, itreable, chunksize=None) # 阻塞&#xA;terminate() # 终止所有任务&#xA;close() # 关闭pool,不接受新任务&#xA;join() # 等待pool中子进程结束，要在close/terminate之后调用.&#xA;&#xA;# IPC: 管道&#xA;Pipe(duplex=True) # duplex=True表示默认是双向pipe.&#xA;receiver, sender = Pipe()&#xA;sender.send(obj)&#xA;receiver.recv()&#xA;close()&#xA;&#xA;# IPC: 消息队列&#xA;# 来自于Queue.Queue, 具体方法参考Queue.Queue&#xA;Queue(maxsize=0) # return a queue object&#xA;q = Queue()&#xA;&#xA;# IPC: 共享内存&#xA;Manager()&#xA;list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array&#xA;&#xA;Array(typecode_or_type, size_or_initializer, **kwds)&#xA;&#xA;RawArray(typecode_or_type, size_or_initializer)&#xA;&#xA;Value(typecode_or_type, *args, **kwds)&#xA;&#xA;RawValue(typecode_or_type, *args)&#xA;&#xA;Event()&#xA;&#xA;# 同步：　条件变量&#xA;Condition(lock=None)&#xA;&#xA;# 同步：信号量&#xA;Semaphore(value=1)&#xA;&#xA;# 同步：有界信号量&#xA;BoundedSemaphore(value=1)&#xA;&#xA;# 同步： 锁&#xA;Lock()&#xA;&#xA;# 同步: 锁&#xA;RLock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
