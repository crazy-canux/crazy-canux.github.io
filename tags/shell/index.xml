<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on Morgoth</title>
    <link>https://canuxcheng.com/tags/shell/</link>
    <description>Recent content in Shell on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Dec 2016 00:55:37 +0800</lastBuildDate>
    <atom:link href="https://canuxcheng.com/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Awk</title>
      <link>https://canuxcheng.com/post/shell_awk/</link>
      <pubDate>Wed, 14 Dec 2016 00:55:37 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_awk/</guid>
      <description>&lt;h1 id=&#34;awk&#34;&gt;awk&lt;/h1&gt;&#xA;&lt;p&gt;awk 是一门编程语言&lt;/p&gt;&#xA;&lt;p&gt;awk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。&lt;/p&gt;&#xA;&lt;p&gt;nawk： new awk。&lt;/p&gt;&#xA;&lt;p&gt;mawk： awk的解释器&lt;/p&gt;&#xA;&lt;p&gt;gawk是gnu的awk，功能更全面。&lt;/p&gt;&#xA;&lt;p&gt;awk命令格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;awk [-v var=value [-F *] [–] &#39;/pattern/ {action}&#39;  file&#xA;awk [-v var=value [-F *] [-f scriptfile ...] [–] file&#xA;awk [-v var=value [-F *] [-] &#39;BEGIN {} /pattern/ {action} END {}&#39;  file&#xA;BEGIN { }  在读取输入之前就操作&#xA;END { }    在读物输入之后操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;awk的指令需要用单引号包围；&#xA;模式需要用/pattern/包围；&#xA;过程需要用{command1；command2}包围，多个过程需要用；隔开。&lt;/p&gt;&#xA;&lt;p&gt;脚本中传递参数格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;awk [-f scriptfile]OR[&#39;/pattern/{action}&#39;] val1=value1 val2=value2 … file1   vala=valuea valb=valueb... file2 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果通过shell传参数，把value改成$n即可。&#xA;可以通过命令返回值作为参数value。&#xA;也可以使用环境变量作为value，也可以给awk的环境变量赋值。&#xA;可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。&#xA;只有在-v和在BEGIN中定义的变量能在BEGIN中使用。&#xA;在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。&#xA;在任何位置定义的变量在END中都可以使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Find</title>
      <link>https://canuxcheng.com/post/shell_find/</link>
      <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_find/</guid>
      <description>&lt;h1 id=&#34;find&#34;&gt;find&lt;/h1&gt;&#xA;&lt;p&gt;Find     查找，用于在目录中查找。&#xA;find  path  options  tests  actions&#xA;path 路径&#xA;options 选项&#xA;tests 测试&#xA;actions 动作&lt;/p&gt;&#xA;&lt;p&gt;optioins选项:&#xA;-follow&#xA;-depth&#xA;-maxdepth&#xA;-mindepth&#xA;find   dir  -mindepth  n     指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。&#xA;find   dir   -maxdepth  n      指定最大目录深度，不搜索n级之后的目录。&lt;/p&gt;&#xA;&lt;p&gt;test选项很多：&#xA;-newer   pattern   比pattern文件要新&#xA;-user    pattern      文件属主是pattern&#xA;-name   pattern    查找和type匹配的&#xA;-iname  pattern    查找和type匹配的，会忽略大小写&#xA;-iwholename&#xA;-path   pattern     按照文件路径匹配&#xA;-type   c           c是文件类型，按照文件类型匹配文件&#xA;-size   +/-    nk/c/w/k/b/M/G    匹配大于或小于n  kb/..  的文件&#xA;-perm   XXX       基于文件权限的匹配&#xA;find dir  –atime/mtime/ctime    +/-n    根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。&#xA;-a/-and   pattern&#xA;-o/-or     pattern&#xA;！/-not    pattern&#xA;find  dir  !  test   pattern   列出所有没有按照-options  pattern模式的项&#xA;(&amp;hellip;)    使用括号需要用引号来引用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grep</title>
      <link>https://canuxcheng.com/post/shell_grep/</link>
      <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_grep/</guid>
      <description>&lt;h1 id=&#34;grep&#34;&gt;grep&lt;/h1&gt;&#xA;&lt;p&gt;grep相关的命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;grep&#xA;egrep == grep -E&#xA;fgrep == grep -F&#xA;rgrep == grep -r&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;grep:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;grep [OPTIONS] PATTERN [FILE/DIR...]&#xA;grep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;options:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Matcher Selection&#xA;-G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE&#xA;-E, --extended-regexp 选择ERE, 可以使用扩展的RE&#xA;# grep -E &amp;quot;pattern1|pattern2&amp;quot; 比如支持或运算&#xA;-F, --fixed-strings&#xA;-P, --perl-regexp perl RE&#xA;&#xA;# Matching Control&#xA;-e PATTERN, --regexp=PATTERN    可以指定多个pattern&#xA;# grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来&#xA;-f FILE, --file=FILE    文件的每一行就是一个pattern.&#xA;-i, --ignore-case    忽略大小写&#xA;-v, --invert-match   忽略含有pattern的行&#xA;-w, --word-regexp    精确匹配一个单词&#xA;-x, --line-regexp    精确匹配一行&#xA;-y&#xA;&#xA;# General Output Control&#xA;-c, --count    统计匹配到的行数&#xA;--color[=WHEN], --colour[=WHEN]    输出匹配的pattern高亮&#xA;-L, --files-without-match    列出没有匹配到的文件名&#xA;-l, --files-with-matches    列出匹配到的文件的文件名&#xA;# grep -rl pattern1 | xargs grep -r pattern2    相当于与运算，过滤同时满足两个pattern&#xA;-m NUM, --max-count=NUM&#xA;-o, --only-matching    只输出匹配的部分&#xA;# grep -o pattern filename | wc -l 统计匹配的行数&#xA;-q, --quiet, --silent    不打印查找的结果&#xA;-s, --no-messages&#xA;&#xA;# Output Line Prefix Control&#xA;-b, --byte-offset    打印匹配的字符数或偏移量&#xA;-H, --with-filename&#xA;-h, --no-filename&#xA;--label=LABEL&#xA;-n, --line-number    打印匹配的行的行号&#xA;-T, --initial-tab&#xA;-u, --unix-byte-offsets&#xA;-Z, --null&#xA;&#xA;# Context Line Control&#xA;-A NUM, --after-context=NUM    打印匹配到的行的后NUM行&#xA;-B NUM, --before-context=NUM    打印匹配到的行的前NUM行j&#xA;-C NUM, -NUM, --context=NUM    打印匹配到的行的前NUM行和后NUM行&#xA;&#xA;# File and Directory Selection&#xA;-a, --text&#xA;--binary-files=TYPE&#xA;-D ACTION, --devices=ACTION&#xA;-d ACTION, --directories=ACTION&#xA;--exclude=GLOB    排除查找指定的文件&#xA;--exclude-from=FILE&#xA;--exclude-dir=DIR   排除查找指定的目录&#xA;-I&#xA;--include=GLOB     指定查找的文件&#xA;-r, --recursive    递归查找&#xA;-R, --dereference-recursive    递归查找&#xA;# grep -nR/-nr pattern filename    阅读源码可以递归查找并打印行号&#xA;&#xA;# Other Options&#xA;--line-buffered&#xA;--mmap&#xA;-U, --binary&#xA;-z, --null-data&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ack&#34;&gt;ack&lt;/h1&gt;&#xA;&lt;p&gt;ack/ack2是grep的升级版&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sed</title>
      <link>https://canuxcheng.com/post/shell_sed/</link>
      <pubDate>Sat, 02 Apr 2016 11:15:57 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_sed/</guid>
      <description>&lt;h1 id=&#34;sed&#34;&gt;sed&lt;/h1&gt;&#xA;&lt;p&gt;sed：stream editor  流编辑器 ，主要用于文本处理。&lt;/p&gt;&#xA;&lt;p&gt;sed命令格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sed   -options   ’expression1;expression2’     file           执行多个命令&#xA;sed   -options   [-e ‘expression1’] [-e ‘expression2’]  file  执行多个命令&#xA;sed   -options   [-f   scriptfile]   file                     通过脚本执行命令&#xA;sed   -options   [-f   scriptfile]   file  &amp;gt;  newfile  #sed修改后重定向到新文件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;sed指令需要用单引号包围。使用双引号“”可以传递变量。&#xA;Sed默认并没有修改文件file中的数据。&#xA;sed默认在stdout输出文件的所有行。&#xA;Sed地址需要使用/address/来包围。&#xA;sed使用正则表达式可以用\BRE\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。&lt;/p&gt;&#xA;&lt;p&gt;options：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;-e：指定多个命令或脚本&#xA;-f：指定执行命令的脚本&#xA;-n：阻止自动输出，p可以打印匹配的行。&#xA;-i: 直接修改读入的文件的内容.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;experssion：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;expression：指令由模式和过程组成。&#xA;[address]/[line-address][!]command[arguments]&#xA;[address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。&#xA;[line-address]表示只能是一个地址。&#xA;[!] 表示不匹配该地址的所有行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Command:&lt;/p&gt;&#xA;&lt;p&gt;sed有25个命令。&lt;/p&gt;&#xA;&lt;p&gt;使用大括号{}在一个地址中做嵌套操作：例如：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/address1/,/address2/{&#xA;    /^$/d&#xA;    s/string1/string2/&#xA;    …&#xA;}             // 单独一行，后面不能有空格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;s命令：替换，替换模式空间中的行。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sed &#39;[address]s/oldpattern/newpattern/[flag]&#39; filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;flag:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shell</title>
      <link>https://canuxcheng.com/post/shell/</link>
      <pubDate>Fri, 01 Apr 2016 20:42:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell/</guid>
      <description>&lt;h1 id=&#34;shell&#34;&gt;Shell&lt;/h1&gt;&#xA;&lt;p&gt;Linux的shell有很多种,大多数linux发行版的默认登录shell是BASH。&lt;/p&gt;&#xA;&lt;p&gt;查看当前使用的shell：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;echo $SHELL&#xA;echo $0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看安装了哪些shell：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cat /etc/shells&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;设置登陆shell:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$chsh -s $(which shellname)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;shell分为登陆shell和交互式shell:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 输出有i的就是交互shell&#xA;$echo $-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;非交互登陆shell:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh)&lt;/li&gt;&#xA;&lt;li&gt;然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin)&lt;/li&gt;&#xA;&lt;li&gt;最后退出用户登陆~/.bash_logout&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;交互非登陆shell:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh))&lt;/li&gt;&#xA;&lt;li&gt;然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;shell相关项目&#34;&gt;shell相关项目&lt;/h1&gt;&#xA;&lt;h2 id=&#34;bash-it&#34;&gt;bash-it&lt;/h2&gt;&#xA;&lt;p&gt;大部分发行版默认使用bash,无需额外安装。&lt;/p&gt;&#xA;&lt;p&gt;bash的优化项目bash-it：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Bash-it/bash-it&#34;&gt;https://github.com/Bash-it/bash-it&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;zsh&#34;&gt;zsh&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.zsh.org/&#34;&gt;http://www.zsh.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;fish-shell&#34;&gt;fish-shell&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fish-shell/fish-shell&#34;&gt;https://github.com/fish-shell/fish-shell&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;oh-my-fish&#34;&gt;oh-my-fish&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/oh-my-fish/oh-my-fish&#34;&gt;https://github.com/oh-my-fish/oh-my-fish&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;thefuck&#34;&gt;thefuck&lt;/h2&gt;&#xA;&lt;p&gt;一个纠正shell命令输错的命令&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nvbn/thefuck&#34;&gt;https://github.com/nvbn/thefuck&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;shellcheck&#34;&gt;shellcheck&lt;/h2&gt;&#xA;&lt;p&gt;一个debug脚本的工具．&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/koalaman/shellcheck&#34;&gt;https://github.com/koalaman/shellcheck&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;shell-script&#34;&gt;shell script&lt;/h1&gt;&#xA;&lt;p&gt;基本语法&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash&#xA;&#xA;command1 &amp;amp;&amp;amp; command2    # 当command1执行成功（返回0)才会执行command2&#xA;command1 || command2    # 当command1执行失败（返回非0)才会执行command2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;shell注释&#34;&gt;shell注释&lt;/h2&gt;&#xA;&lt;p&gt;单行注释：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# comment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;多行注释：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Coreutils</title>
      <link>https://canuxcheng.com/post/shell_coreutils/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_coreutils/</guid>
      <description>&lt;h1 id=&#34;linux的外部命令&#34;&gt;Linux的外部命令&lt;/h1&gt;&#xA;&lt;p&gt;Linux外部命令的项目是coreutils。&lt;/p&gt;&#xA;&lt;p&gt;外部命令在coreutils目录中&lt;/p&gt;&#xA;&lt;p&gt;查看外部命令所在目录：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;echo $PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;外部命令在下列目录中：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;~/bin # 用户自定义&#xA;&#xA;/sbin&#xA;&#xA;/bin&#xA;&#xA;/usr/sbin&#xA;&#xA;/usr/bin&#xA;&#xA;/usr/local/sbin&#xA;&#xA;/usr/local/bin&#xA;&#xA;/usr/games&#xA;&#xA;/usr/local/games&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看外部命令手册的在线手册：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;man [command]&#xA;info [command]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;自定义外部命令：&lt;/p&gt;&#xA;&lt;p&gt;添加$PATH变量，然后放到该目录。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;系统管理&#34;&gt;系统管理&lt;/h1&gt;&#xA;&lt;p&gt;cpu/mem/load&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 查看cpu/mem/swap/system信息&#xA;vmstat&#xA;vmstat 1&#xA;&#xA;# 查看进程消耗的cpu/mem/swap/system等系统信息&#xA;top&#xA;top -H  # 查看线程&#xA;%cpu = cputime/realtime * 100%&#xA;cpu_usage = %cpu/cpu-number&#xA;%mem = RES/physicalMem * 100%&#xA;&#xA;htop&#xA;$ sudo apt-get install htop&#xA;&#xA;$ sudo apt-get install sysstat (包括pidstat)&#xA;pidstat -u -p pid // cpu&#xA;pidstat -r -p pid //mem&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;cpu/load:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Utils</title>
      <link>https://canuxcheng.com/post/shell_utils/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_utils/</guid>
      <description>&lt;h1 id=&#34;linux的第三方命令&#34;&gt;Linux的第三方命令&lt;/h1&gt;&#xA;&lt;p&gt;Linux外部命令的项目是coreutils.&lt;/p&gt;&#xA;&lt;p&gt;外部命令在coreutils目录中.&lt;/p&gt;&#xA;&lt;p&gt;第三方命令(相当于外部命令)．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;文件和目录管理&#34;&gt;文件和目录管理&lt;/h1&gt;&#xA;&lt;p&gt;autojump:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wting/autojump&#34;&gt;https://github.com/wting/autojump&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;fasd:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clvv/fasd&#34;&gt;https://github.com/clvv/fasd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;fzf:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;压缩备份&#34;&gt;压缩备份&lt;/h1&gt;&#xA;&lt;h1 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h1&gt;&#xA;&lt;h1 id=&#34;设备管理&#34;&gt;设备管理&lt;/h1&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Builtins</title>
      <link>https://canuxcheng.com/post/shell_builtins/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:03 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_builtins/</guid>
      <description>&lt;h1 id=&#34;linux内置命令&#34;&gt;Linux内置命令&lt;/h1&gt;&#xA;&lt;p&gt;内置命令在bash/builtins目录中&lt;/p&gt;&#xA;&lt;p&gt;shell命令分为内置命令和外部命令.&lt;/p&gt;&#xA;&lt;p&gt;查看一个命令是内置命令还是外部命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type -a [command]&#xA;&#xA;提示&amp;quot;[command] is a shell builtin&amp;quot;就表示是内置命令，否则就是外部命令。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看所有内置命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;help&#xA;enable -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看内置命令的帮助：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;help [command]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre&gt;&lt;code&gt;type&#xA;enable&#xA;help&#xA;&#xA;caller&#xA;alias&#xA;bg&#xA;bind&#xA;break&#xA;builtin&#xA;command&#xA;compgen&#xA;complete&#xA;compopt&#xA;continue&#xA;declare&#xA;disown&#xA;let&#xA;local&#xA;logout&#xA;mapfile&#xA;popd&#xA;printf&#xA;pushd&#xA;read&#xA;readarray&#xA;readonly&#xA;return&#xA;shift&#xA;shopt&#xA;source&#xA;suspend&#xA;times&#xA;trap&#xA;true&#xA;typeset&#xA;ulimit&#xA;umask&#xA;unalias&#xA;unset&#xA;wait&#xA;eval&#xA;exec&#xA;exit&#xA;export&#xA;false&#xA;fc&#xA;fg&#xA;getopts&#xA;hash&#xA;history&#xA;jobs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;路径相关:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
