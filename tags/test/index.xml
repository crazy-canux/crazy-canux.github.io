<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test on Morgoth</title>
    <link>https://canuxcheng.com/tags/test/</link>
    <description>Recent content in Test on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jan 2018 10:49:21 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/tags/test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GSL_test</title>
      <link>https://canuxcheng.com/post/gsl_test/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_test/</guid>
      <description>&lt;h1 id=&#34;testing&#34;&gt;testing&lt;/h1&gt;&#xA;&lt;p&gt;go的测试由go test命令和testing包组成．&lt;/p&gt;&#xA;&lt;p&gt;测试程序命名：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;XXX.go # 测试文件和源码放在一个包中&#xA;XXX_test.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;测试程序结构：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;testing&amp;quot;&#xA;&#xA;# 单元测试&#xA;# go test 会自动执行&#xA;func TestXXX(t *testing.T) {}&#xA;&#xA;# 性能测试&#xA;# go test XXX_test.go -test.bench=&amp;quot;.*&amp;quot;  压力测试需要指定才能执行&#xA;func BenchmarkXXX(b *testing.B) {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;t&#34;&gt;T&lt;/h2&gt;&#xA;&lt;p&gt;管理测试状态并支持格式化测试的日志．&lt;/p&gt;&#xA;&lt;p&gt;struct:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type T struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;methods:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 将当前测试标识为失败，但继续执行该文件剩下的测试&#xA;func (c *T) Fail()&#xA;&#xA;// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.&#xA;func (c *T) FailNow()&#xA;&#xA;// 用于报告测试函数是否失败&#xA;func (c *T) Failed() bool&#xA;&#xA;func (c *T) Log(args ...interface{})&#xA;func (c *T) Logf(format string, args ...interface{})&#xA;&#xA;# 相当于Log/Logf之后调用Fail.(当前case失败)&#xA;func (c *T) Error(args ...interface{})&#xA;func (c *T) Errorf(format string, args ...interface{})&#xA;&#xA;# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)&#xA;func (c *T) Fatal(args ...interface{})&#xA;func (c *T) Fatalf(format string, args ...interface{})&#xA;&#xA;func (c *T) Skip(args ...interface{})&#xA;func (c *T) SkipNow()&#xA;func (c *T) Skipf(format string, args ...interface{})&#xA;func (c *T) Skipped() bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;b&#34;&gt;B&lt;/h2&gt;&#xA;&lt;p&gt;管理基准测试的计时行为，并指示应该迭代的运行测试多少次.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Test</title>
      <link>https://canuxcheng.com/post/django_test/</link>
      <pubDate>Tue, 04 Oct 2016 04:51:30 +0000</pubDate>
      <guid>https://canuxcheng.com/post/django_test/</guid>
      <description>&lt;h1 id=&#34;testspy&#34;&gt;tests.py&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/&#34;&gt;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/&#34;&gt;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;单个测试文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;vim app/tests.py&#xA;from django.test import TestCase&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;多个测试文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;mkdir -p app/tests&#xA;vi test_case1.py&#xA;vi test_case2.py&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置和运行&#34;&gt;配置和运行&lt;/h1&gt;&#xA;&lt;p&gt;默认情况下运行 manage.py test 会创建测试数据库运行testcase，完成后自动销毁测试数据库.&lt;/p&gt;&#xA;&lt;p&gt;测试相关配置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;vim project/settings.py&#xA;&#xA;DATABASES = {&#xA;    &#39;default&#39;: {&#xA;        &#39;NAME&#39;: &#39;mydb&#39;,&#xA;        &#39;TEST&#39;: {&#xA;            // 默认测试数据库是&#39;NAME&#39;前加&#39;test_&#39; (eg: &#39;test_mydb&#39;)&#xA;            // 可以通过TEST.NAME指定测试数据库&#xA;            &#39;NAME&#39;: &#39;mytestdb&#39;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;# 指定runner&#xA;## 默认 django.test.runner.DiscoverRunner&#xA;TEST_RUNNER = &#39;site_main.base_tests.TestRunner&#xA;&#xA;# 指定fixture文件路径&#xA;FIXTURE_DIRS = (os.path.join(BASE_DIR, &#39;app&#39;, &#39;fixtures&#39;), )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行测试程序：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ python3 manage.py test // 查找test 开头的文件运行里面的 unittest.TestCase的子类.&#xA;$ python3 manage.py test &amp;lt;package&amp;gt; // 运行指️定应用内的测试&#xA;$ python3 manage.py test &amp;lt;module&amp;gt; // 运行指定模块内的测试&#xA;$ python3 manage.py test &amp;lt;module&amp;gt;.tests.MyTestCase // 运行一个指定的testcase&#xA;$ python3 manage.py test &amp;lt;module&amp;gt;.tests.MyTestCase.test_method // 运行一个指定的test method&#xA;&#xA;--keepdb // 保留测试数据库&#xA;--parallel // 并行运行测试。&#xA;-v/--verbosity 0/1/2/3  测试输出信息级别，默认为1， 0表示不输出。&#xA;-d/--debug-sql 输出测试执行的sql语句.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;client&#34;&gt;Client&lt;/h1&gt;&#xA;&lt;p&gt;测试客户端是一个 Python 类，它充当一个虚拟的 Web 浏览器，&#xA;允许你测试视图并以编程方式与 Django 驱动的应用程序交互。&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Test</title>
      <link>https://canuxcheng.com/post/psl_test/</link>
      <pubDate>Mon, 11 Apr 2016 22:58:13 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_test/</guid>
      <description>&lt;h1 id=&#34;development-tools&#34;&gt;Development Tools&lt;/h1&gt;&#xA;&lt;h2 id=&#34;typing&#34;&gt;typing&lt;/h2&gt;&#xA;&lt;h2 id=&#34;2to3&#34;&gt;2to3&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;$2to3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pydoc&#34;&gt;pydoc&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import pydoc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;doctest&#34;&gt;doctest&lt;/h2&gt;&#xA;&lt;p&gt;python内置的文档测试库．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import doctest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;unittest&#34;&gt;unittest&lt;/h2&gt;&#xA;&lt;p&gt;python内置的单元测试库．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import unittest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;p&gt;相关的第三方库&lt;/p&gt;&#xA;&lt;h2 id=&#34;unittest2&#34;&gt;unittest2&lt;/h2&gt;&#xA;&lt;p&gt;unittest2是unittest的升级版．&lt;/p&gt;&#xA;&lt;p&gt;python3集成了unittest2到unittest,像使用unittest一样使用即可．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python2.7&#xA;$pip install unittest2&#xA;import unittest2&#xA;&#xA;# python3&#xA;import unittest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．&lt;/p&gt;&#xA;&lt;p&gt;测试结果：&lt;/p&gt;&#xA;&lt;p&gt;OK 表示测试通过&lt;/p&gt;&#xA;&lt;p&gt;FAIL 表示测试没有通过，并引发一个AssertionError异常．&lt;/p&gt;&#xA;&lt;p&gt;ERROR 表示测试过程引发一个不是AssertionError的异常．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是标准库的unittest.&#xA;import unittest&#xA;import MyClass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;unittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．&#xA;unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.&#xA;unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.&#xA;unittest.TestResult: 用来保存测试的结果．&#xA;&#xA;unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．&#xA;fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．&#xA;&#xA;unittest.TextTestRunner: 用来执行测试用例．&#xA;unittest.TextTestResult: 用来打印格式化的测试结果．&#xA;&#xA;# unittest.TestCase&#xA;# methods:&#xA;assertXXX　系列方法．&#xA;failXXX 系列方法&#xA;fail(self, msg=None) # test立即失败&#xA;addCleanup(self, function, *args, **kwargs)&#xA;addTypeEqualityFunc(self, typeobj, function)&#xA;countTestCases(self)&#xA;debug(self)&#xA;defaultTestResult() # return unittest.TestResult()&#xA;doCleanups(self)&#xA;id(self)&#xA;run(self, result=None) # 可以在子类覆盖该方法．&#xA;shortDescription(self)&#xA;skipTest(self, reason)&#xA;setUp(self) # 重写之后，每个case运行之前都会调用一次．&#xA;tearDown(self) # 同上&#xA;&#xA;# classmethods:&#xA;setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．&#xA;tearDownClass(cls) # 同上&#xA;&#xA;# data:&#xA;failureException = AssertionError&#xA;longMessage = False&#xA;maxDiff = 640&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
