<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Re on Morgoth</title>
    <link>https://canuxcheng.com/tags/re/</link>
    <description>Recent content in Re on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Apr 2016 11:16:16 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/tags/re/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Regular Expression</title>
      <link>https://canuxcheng.com/post/regularexpression/</link>
      <pubDate>Sat, 02 Apr 2016 11:16:16 +0000</pubDate>
      <guid>https://canuxcheng.com/post/regularexpression/</guid>
      <description>&lt;h1 id=&#34;re&#34;&gt;RE&lt;/h1&gt;&#xA;&lt;p&gt;在线检测：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.regexpal.com/&#34;&gt;https://www.regexpal.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;RE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).&lt;/p&gt;&#xA;&lt;p&gt;在BRE中+?(){}|没有特殊含义，除非用\转义．&lt;/p&gt;&#xA;&lt;p&gt;在ERE中+?(){}被保留有特殊含义，除非用\转义才表示普通字符．&lt;/p&gt;&#xA;&lt;p&gt;命令find, grep, sed, awk等都可以使用正则表达式．&lt;/p&gt;&#xA;&lt;p&gt;特殊字符含义：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;()      对正则表达式分组, ERE&#xA;\n      再匹配前面的分组n次&#xA;&#xA;.       匹配任意单个字符, 换行符除外&#xA;^tux    匹配以tux开始的行&#xA;tux$    匹配以tux结束的行&#xA;&#xA;*+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配&#xA;*           匹配前面一个字符0次或多次，包括前面这个字符本身&#xA;+           匹配前面一个字符1次或多次，包括前面这个字符, ERE&#xA;?           匹配前面一个字符0次或1次，包括前面这个字符, ERE&#xA;{n}         匹配前面一个字符n次，包括前面这个字符, ERE&#xA;{min,}      匹配前面一个字符至少min次，包括前面这个字符, ERE&#xA;{min,max}   匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE&#xA;&#xA;下面是非贪婪匹配模式&#xA;*?    匹配0个或多个&#xA;+?    匹配1个或多个&#xA;??    匹配０个或１个&#xA;{n}?        只匹配n个&#xA;{min,}?     至少min个&#xA;{min,max}?  至少min个，最多max个&#xA;&#xA;[abc]   匹配包含在[]中的任意一个字符，除了\, ^, -三个特殊字符&#xA;[^abc]  匹配不包含在[]中的任意一个字符(和上面相反)&#xA;[a-z]   匹配[]中指定范围内的任意一个字符&#xA;[abc\?] 用＼转义[]中的特殊字符&#xA;&#xA;|       表示逻辑或, ERE&#xA;&#xA;\       转义字符，将特殊字符转义成普通字符&#xA;&#xA;小括号表示分组&#xA;(...)&#xA;(?...)&#xA;(?iLmsux)&#xA;(?:...)&#xA;(?P&amp;lt;name&amp;gt;...)&#xA;(?P=name)&#xA;(?#...)&#xA;(?=...)&#xA;(?!...)&#xA;(?&amp;lt;=...)&#xA;(?&amp;lt;!...)&#xA;(?(id/name)yes-pattern|no-pattern)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
