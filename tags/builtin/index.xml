<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Builtin on Morgoth</title>
    <link>https://canuxcheng.com/tags/builtin/</link>
    <description>Recent content in Builtin on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jan 2018 10:49:21 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/tags/builtin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GSL_builtin</title>
      <link>https://canuxcheng.com/post/gsl_builtin/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_builtin/</guid>
      <description>&lt;h1 id=&#34;builtin&#34;&gt;builtin&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/builtin/&#34;&gt;https://golang.org/pkg/builtin/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;go的builtin package.&lt;/p&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;true&#xA;false&#xA;iota&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;p&gt;pointer, slice, map, channel, func, interface的零值：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;nil&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分配并初始化各种类型的对象, 返回一个指针．&#xA;new(Type) *Type&#xA;&#xA;# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.&#xA;make(t Type, size ...IntegerType) Type&#xA;&#xA;# 返回容量，　Array/ArrayPointer/Slice/Channel&#xA;cap(v Type) int&#xA;&#xA;# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel&#xA;len(v Type) int&#xA;&#xA;print(args ...Type)&#xA;&#xA;println(args ...Type)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;complex:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 把两个浮点数构造成一个复数&#xA;complex(r, i FloatType) ComplexType&#xA;&#xA;# 返回复数c的实部&#xA;real(c ComplexType) FloatType&#xA;&#xA;# 返回复数c的虚部&#xA;imag(c ComplexType) FloatType&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;slice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 向切片末尾追加元素，返回新的切片．切片长度增加.&#xA;# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．&#xA;# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.&#xA;append(slice []Type, elems ...Type) []Type&#xA;&#xA;# 复制一个切片, 返回复制的元素的个数&#xA;copy(dst, src []Type) int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;map:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_builtins</title>
      <link>https://canuxcheng.com/post/psl_builtins/</link>
      <pubDate>Mon, 15 Aug 2016 11:16:29 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_builtins/</guid>
      <description>&lt;h1 id=&#34;_builtins_&#34;&gt;_&lt;em&gt;builtins&lt;/em&gt;_&lt;/h1&gt;&#xA;&lt;p&gt;python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。&lt;/p&gt;&#xA;&lt;p&gt;包括内置类类型以及所属的内置方法，和内置函数.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;builtin&lt;/strong&gt; - 包括内置类类型以及所属的内置方法，和内置函数.解释器不会自动导入．&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;builtins&lt;/strong&gt; - 仅仅是__builtin__的一个引用．解释器自动导入的．&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;内置常量&lt;/p&gt;&#xA;&lt;p&gt;内置函数(BIF)&lt;/p&gt;&#xA;&lt;p&gt;内置类型(BIT)&lt;/p&gt;&#xA;&lt;p&gt;工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．&lt;/p&gt;&#xA;&lt;p&gt;内置类型的内置方法(BIM)&lt;/p&gt;&#xA;&lt;p&gt;内置异常&lt;/p&gt;&#xA;&lt;p&gt;该模块是通过C/C++实现的．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;内置函数&#34;&gt;内置函数&lt;/h1&gt;&#xA;&lt;p&gt;python2和python3共同的内置函数：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数&#xA;&#xA;compile(source, filename, mode[, flags[, dont_inherit]])&#xA;# 编译source返回一个code对象(代码对象)．&#xA;# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;&#xA;module = &amp;quot;for i in xrange(10): print(i)&amp;quot;&#xA;code = compile(module, &#39;&#39;, &#39;exec&#39;)&#xA;type(code) # code&#xA;exec code&#xA;# mode: single, 用于单行语句, 也是用exec执行;&#xA;code = compile(&amp;quot;print &#39;test&#39;&amp;quot;, &#39;&#39;, single)&#xA;type(code) # code&#xA;exec code&#xA;# mode: eval, 用于表达式 可以用eval()函数执行． eg:&#xA;expression = &amp;quot;3 * 4&amp;quot;&#xA;code = compile(expression, &#39;&#39;, &#39;eval&#39;)&#xA;type(code) # code&#xA;eval(code)&#xA;&#xA;eval(source[, globals[, locals]])&#xA;# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．&#xA;&#xA;format(value[, format_spec]) # 返回格式化后的字符串形式．&#xA;&#xA;## 环境变量相关&#xA;globals() # 返回当前作用域的全局名称空间的字典．&#xA;locals() # 返回当前作用域的局部名称空间的字典．&#xA;&#xA;## 数字类型的数学运算&#xA;abs(number) # 返回int/long的绝对值&#xA;divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组&#xA;pow(x, y[, z]) # 返回x**y或(x**y) % z&#xA;round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.&#xA;chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 &amp;lt;= i &amp;lt; 256.&#xA;ord(c) # 返回字符ASCII字符c对应的整数.&#xA;bin(number) # 返回int/long的二进制的字符串形式&#xA;oct(number) # 返回int/long的八进制的字符串形式．&#xA;hex(number) # 返回int/long的十六进制的字符串形式.&#xA;&#xA;## 对象相关的操作&#xA;id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.&#xA;repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.&#xA;callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()&#xA;hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.&#xA;len(object) # 返回序列（str, tuple, list)或映射（dict)的长度&#xA;dir([object]) # 查看对象的信息&#xA;getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．&#xA;hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.&#xA;setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value&#xA;delattr(object, name) # 删除对象object的属性name&#xA;isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.&#xA;issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．&#xA;vars([object]) # 没有参数等于locals()，有参数等于object.__dict__.&#xA;&#xA;## related to iterable&#xA;min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素&#xA;min(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素&#xA;max(iterable[, key=func]) # 和min相反&#xA;max(a, b, c, ...[, key=func]) # 和min相反&#xA;all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,&#39;&#39;则返回True,iterable为空也返回True,否则返回False&#xA;any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,&#39;&#39;则返回False,　否则返回True&#xA;sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．&#xA;&#xA;## related to iterator&#xA;iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.&#xA;iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．&#xA;next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．&#xA;&#xA;## related to input&#xA;input([prompt]) # 等于eval(raw_input(prompt))&#xA;# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.&#xA;&#xA;## related to file&#xA;open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;[New]python3新增的内置函数：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
