<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="single-post">
    <article>
        <header>
            <h1>OOP</h1>
            <div class="post-meta">
                <time>January 1, 2018</time>
                
                    
                        <span class="category">Golang</span>
                    
                
                
                    
                        <span class="tag">#oop</span>
                    
                
            </div>
        </header>
        
        <div class="post-content">
            <h1 id="go面向对象">Go面向对象</h1>
<p>golang通过方法和接口实现面向对象.</p>
<hr>
<h1 id="方法method">方法/method</h1>
<p>go中没有类，但是可以为结构体定义方法．</p>
<p>方法就是一类带有特殊的　接收者参数　的函数．</p>
<p>只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．</p>
<p>除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．</p>
<p>方法有两种接收者,值接收者和指针接收者.</p>
<pre><code>type Vertex struct {
    ...
}
</code></pre>
<p>值接收者:</p>
<p>值接收者操作的是值的副本.</p>
<pre><code>func (v Vertex) MethodName() rType {
    ...
}

var v Vertex
v.MethodName() // 操作值的副本

# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换
vp := new(Vertex)
vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.
</code></pre>
<p>指针接收者：</p>
<p>指针接收者，调用方法的时候操作的是该指针指向的值.</p>
<pre><code># 指针接收者的方法可以修改接收者指向的值
func (v *Vertex) MethodName() rType {
    ...
}

vp := new(Vertex)
vp.MethodName() // 操作实际的值

# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.
var v Vertex
v.MethodName() // (&amp;v).MethodName() , 操作的是实际的值
</code></pre>
<hr>
<h1 id="接口interface">接口/Interface</h1>
<p>接口是引用类型.</p>
<p>接口类型是由一组方法签名定义的集合．</p>
<p>接口类型的值可以保存任何实现了这些方法的值．</p>
<p>某个类型实现了该接口的所有方法签名，就算实现了该接口,无需显示申明实现了哪个接口.</p>
<p>接口可以匿名嵌入其它接口，或嵌入到结构中．</p>
<p>一般只有一个方法的接口命名为MethodName + &rsquo;er'.</p>
<p>接口存储两个数据接口：</p>
<ul>
<li>iTable, 包含存储值的类型信息以及和该值关联的方法.</li>
<li>指向存储的值的指针.</li>
</ul>
<p>定义接口：</p>
<pre><code>type IName interface {
    MethodName()
    ...
}

type SName struct {
    ...
}
</code></pre>
<p>值接收者方法:</p>
<p>接口类型的值为值或指针都可以调用该方法.</p>
<pre><code>func (s SName) MethodName() {}
</code></pre>
<p>指针接收者方法:</p>
<p>接口类型的值必须为指针才能调用该方法.</p>
<pre><code>func (s *SName) MethodName() {
    ...
}

s := &amp;SName{...}
// i = &amp;SName{...} //接口变量能保存实现了该接口的任意类型的对象
i = s
i.MethodName()

# 接口类型为值时，调用失败
var s SName
i = s
i.MethodName() // 调用失败
</code></pre>
<p>底层值为nil的接口值:</p>
<pre><code>var i IName
var s SName
i = s    # 接口值为nil
</code></pre>
<p>空接口：</p>
<p>所有类型都实现了空接口.</p>
<p>指定了零个方法的接口值被称为空接口,一般用来处理未知类型的值.</p>
<p>当接口储存的类型和对象都为nil，接口才为nil</p>
<p>以空接口为参数的函数可以接收任意类型的值作为参数.</p>
<p>如果一个函数返回空接口就可以返回任意类型的值.</p>
<pre><code># 空接口可以保存任何类型的值
var i interface{}
# 空接口作为形参
func FuncName(i interface{}) {}
</code></pre>
<p>指针的类型断言/comma-ok断言：</p>
<p>断言接口值i保存了具体类型Type, 并将底层类型为Type的值赋予变量t.</p>
<pre><code>只返回一个值，断言失败会触发panic.
t := i.(Type)

返回两个值，断言成功返回true, 失败返回false.
t, ok := i.(Type)
</code></pre>
<p>指针的类型选择/switch测试：</p>
<pre><code>// i.(type) 是固定写法
switch TypeValue := i.(type) {
case Type1:
    ...
case Type2:
    ...
...
default:
    ...
}
</code></pre>
<p>嵌入接口:</p>
<p>接口中可以嵌入其它接口，这样实现了该接口的对象就隐式包含嵌入接口的所有方法.</p>
<pre><code>type Interface interface {}
</code></pre>
<hr>
<h2 id="封装">封装</h2>
<p>小写字母开头的标识符（类型/属性/方法&hellip;)是未公开的，只能在当前包引用，不能在其它包引用。</p>
<p>可以通过创建工厂函数对外暴露未公开的标识符:</p>
<ul>
<li>标识符才有公开或未公开属性，值没有</li>
<li>短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量；显示声明的变量不能引用未公开类型。</li>
</ul>
<p>通过工厂函数返回未公开类型的值:</p>
<pre><code># packageA
type privateType  Type
func New(args) privateType {
    return privateType(args)
}
# packageB
import packageA
func main() {
    b := packageA.New(args) // 返回一个值，而不是标识符
}
</code></pre>
<p>公开类型的未公开属性:</p>
<pre><code># packageA
type Public struct {
    private Type
}

# packageB
import packageA
func main() {
    b := packageA.Public{
        private: value, // panic, 公开类型的未公开属性不能通过字面量直接赋值
    }
}
</code></pre>
<p>类型嵌套中的未公开类型的公开属性会提升到外部类型:</p>
<pre><code># packageA
type inner struct { // inner private
    In Type  // In public
}
type Outer struct {
    inner
    Out Type
}

# packageB
import packageA
func main() {
    b := packageA.Outer{
        Out: value, // 外部类型中的未公开内部类型不能通过字面量直接赋值
    }
    b.In = value // 内部类型的公开属性提升到外部类型。
}
</code></pre>
<h2 id="多态">多态</h2>
<p>形式参数是接口的函数，叫做多态函数.</p>
<pre><code>func FuncName(iVar IName) {}
</code></pre>
<p>所有实现了接口的方法的实体类型，就可以作为参数传给多态函数.</p>
<h2 id="继承">继承</h2>
<p>通过类型嵌套实现继承，外部类型可以访问内部类型的属性和方法</p>
<p>如果外部类型实现同名的属性或方法，就会覆盖内部类型的属性或方法（不过内部类型的属性和方法还在，可以通过内部类型访问）</p>
<p>内部类型实现的接口，也会自动提升到外部类型。只要内部类型实现了某接口，外部类型相当于也实现了该接口。</p>
<p>如果匿名字段实现了一个方法，那么包含这个匿名字段的结构也可以调用该方法.</p>
<pre><code>type Inner struct {
    in Type
}

func (i *Inner) InnerMethod() {}

type Outer struct {
    Inner    // 只需要类型名称，不需要声明变量
    out Type
    ...
}

outer := Outer{}

outer.Inner.InnerMethod() //始终可以访问内部类型的方法，即使外部类型实现同名方法
outer.Inner.in // 同上

outer.InnerMethod() //如果外部类型没有实现同名方法，就是内部类型方法，否则是外部类型方法
outer.in // 同上
</code></pre>
<hr>
<h1 id="反射reflact">反射/reflact</h1>
<p>反射就是检查程序在运行时的状态.</p>
<p>使用反射一般使用标准库reflect.</p>

        </div>
    </article>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
