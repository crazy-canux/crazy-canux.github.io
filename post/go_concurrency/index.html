<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go_Concurrency - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="single-post">
    <article>
        <header>
            <h1>Go_Concurrency</h1>
            <div class="post-meta">
                <time>January 1, 2018</time>
                
                    
                        <span class="category">Golang</span>
                    
                
                
                    
                        <span class="tag">#concurrency</span>
                    
                
            </div>
        </header>
        
        <div class="post-content">
            <h1 id="并发concurrency">并发/concurrency</h1>
<p>CSP: communicating sequential processes, 通信顺序进程。</p>
<p>go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.</p>
<p>concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。</p>
<p>所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.</p>
<p>parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。</p>
<p>process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。</p>
<p>thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。</p>
<p>co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。</p>
<p>goroutine: go语言的协程，是并行的，通过channel来通信.</p>
<p>GMP: goroutine的实现模型。</p>
<p>G: goroutine。</p>
<p>M: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。</p>
<p>P: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。</p>
<p>不要通过共享内存通信，通过通信来共享内存。</p>
<h2 id="goroutines">goroutines</h2>
<p>go关键字会启动一个新的goroutine并执行.</p>
<p>每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。</p>
<p>当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.</p>
<p>当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.</p>
<pre><code>go FuncName(...)
</code></pre>
<p>主进程main结束了，goroutine也结束．</p>
<h2 id="竟态">竟态</h2>
<p>race condition: 竞争状态，多个goroutine同时操作同一资源.</p>
<pre><code># 检测竞争状态
$ go build -race
</code></pre>
<p>所以要解决goroutine间的消息传递和同步的问题.</p>
<p>通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。</p>
<p>channel还是mutex,选择的依据是他们的能力/特性.</p>
<p>channel的能力是让数据流动起来，擅长的是数据流动的场景:</p>
<ul>
<li>传递数据的所有权，即把某个数据发送给其他协程</li>
<li>分发任务，每个任务都是一个数据</li>
<li>交流异步结果，结果是一个数据</li>
</ul>
<p>sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:</p>
<ul>
<li>缓存</li>
<li>状态</li>
</ul>
<hr>
<h2 id="channel">channel</h2>
<p>goroutine通过channel来传递消息.</p>
<p>channels是引用类型,chan是线程安全的，并且不会有数据冲突。</p>
<p>channel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.</p>
<p>chan通过make来创建，通过close来关闭．</p>
<p>chan是先进先出的.</p>
<p>如果chan指定了容量(有缓存), 就是异步，非阻塞模式．</p>
<p>默认是无缓存的，同步的,　阻塞模式.</p>
<p>申明一个变量:</p>
<pre><code>var ChanName chan Type
</code></pre>
<p>定义一个chan:</p>
<pre><code>var ch = make(chan Type, cap)
ch := make(chan Type, cap)
</code></pre>
<p>操作chan:</p>
<pre><code>ch &lt;- v    # 发送值到ch

&lt;- ch    # 从ch接收值
v := &lt;- ch    # 从ch接收值并赋予Type类型变量v

v, ok = &lt;- ch # 从ch接收值，如果ch关闭或没有数据，ok就为false.
</code></pre>
<p>无缓冲的chan:</p>
<pre><code>ch := make(chan Type)
</code></pre>
<p>无缓冲的chan生产者会阻塞unbuffered，直到消费者接收数据, 也就是说是同步的synchronous.</p>
<p>只有消费者或者只有生产者的chan会导致死锁，产生panic.</p>
<p>带缓冲的chan:</p>
<p>带缓冲的chan，在缓冲区满之前，都不会阻塞buffered，是异步的asynchronous.</p>
<p>只有通道中没有要接收的值，接收动作才会阻塞.</p>
<p>只有在通道没有可用缓冲区容纳被发送的值，发送动作才会阻塞．</p>
<pre><code>ch := make(chan Type, cap)

// 带缓冲的chan可以通过range遍历
for i := range ch {...}
</code></pre>
<p>chan的方向：</p>
<p>默认chan都是双向的，但是也可以指定方向</p>
<p>只接收的chan无法关闭</p>
<pre><code>var recv_only chan&lt;- Type
</code></pre>
<p>只发送的chan</p>
<pre><code>var send_only &lt;-chan Type
</code></pre>
<p>显示关闭chan:</p>
<p>通道关闭后，不能再向通道发送值，但是已经发送的值可以被接收.</p>
<pre><code>// 一般在生产者(发送动作)关闭chan
close(ch)

// 如果chan关闭ok=false, v为零值.
v, ok := &lt;-ch
</code></pre>
<h2 id="sync">sync</h2>
<p>通过对资源上锁来保持同步.</p>
<p>golang的同步通过sync和sync/atomic两个包实现.</p>
<hr>
<h2 id="select">select</h2>
<p>监听chan的数据流，类似于switch-case, 可用于处理多个chan的情况</p>
<p>运行规则：</p>
<ol>
<li>
<p>每次执行select都只会执行一个case或者执行default；当有case可以执行，default不会执行；没有case执行时才执行default。</p>
</li>
<li>
<p>当没有case或default可以执行，select阻塞等待。</p>
</li>
<li>
<p>当有多个case可以执行，select随机选择一个执行。</p>
</li>
<li>
<p>case后面必须是读或写chan的操作，否则编译出错。</p>
<p>select {
case condition1:
do something
case condition2:
do something
&hellip;
default:    // default可以省略
do default thing.
}</p>
</li>
</ol>
<hr>
<h2 id="退出goroutine">退出goroutine</h2>
<h3 id="for-range">for-range</h3>
<p>range能感知channel关闭，当channel被发送数据的goroutine关闭时，range就会结束，然后退出for循环。</p>
<pre><code>go func(in &lt;-chan int) {
    for x := range in {
        ...
    }
}(inCh)
</code></pre>
<h3 id="for-select">for-select</h3>
<p>select有多路复用能力，for-select 可以持续处理多路多个channel的能力。但select不能感知channel的关闭.</p>
<p>通道关闭退出goroutine：</p>
<pre><code>go func() {
    for {
        select {
        case x, ok := &lt;-in:
            if !ok {
                return
            }
        case &lt;-t.C:
            ...
        }
    }
}
</code></pre>
<p>某个通道关闭，不再处理该通道，但是继续处理其它channel,select不会在nil的通道上进行等待:</p>
<pre><code>go func() {
    for {
        select {
        case x, ok := in1:
            if !ok {
                in1 = nil   把只读channel设置为nil,select不会在这里阻塞。
            }
        case y, ok :=&lt;-in2:
            if !ok {
                in2 = nil
            }
        if in1 == nil &amp;&amp; in2 == nil {
            return
        }
    }
}()
</code></pre>
<p>使用专门channel发送退出信号,只需要在main中关闭channel，所有goroutine都会接收到信号退出:</p>
<pre><code>go func() {
    for {
        select {
        case &lt;- stopCh:
            ...
            return
        case &lt;- t.C:
            ...
        }
    }
}()
</code></pre>

        </div>
    </article>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
