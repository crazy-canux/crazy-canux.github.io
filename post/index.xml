<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Morgoth</title>
        <link>https://canuxcheng.com/post/</link>
        <description>Recent content in Posts on Morgoth</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 10 Jan 2025 09:41:39 +0000</lastBuildDate><atom:link href="https://canuxcheng.com/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>DevOps Metrics</title>
        <link>https://canuxcheng.com/post/devops_metrics/</link>
        <pubDate>Fri, 10 Jan 2025 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_metrics/</guid>
        <description>&lt;h1 id=&#34;devops-metrics&#34;&gt;DevOps Metrics&lt;/h1&gt;
&lt;p&gt;从业务角度来看，公司希望更准确地度量其开发人员的生产力，原因如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monitoring progress over time&lt;/li&gt;
&lt;li&gt;Creation of benchmarks&lt;/li&gt;
&lt;li&gt;Rewarding top performers&lt;/li&gt;
&lt;li&gt;Determining resource allocation&lt;/li&gt;
&lt;li&gt;Identification of more productive development processes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;框架是想法、概念和关系的简单总结，因此基于您的上下文、环境和团队，您可以选择一组您可以解释的指标，以确定团队是否在它应该在的地方。&lt;/p&gt;
&lt;h2 id=&#34;dora&#34;&gt;DORA&lt;/h2&gt;
&lt;p&gt;DevOps Research and Assessment.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://getdx.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://getdx.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;speed-metrics&#34;&gt;Speed metrics&lt;/h3&gt;
&lt;p&gt;Deployment frequency: This measures how often a team deploys code to production.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Low performance: once per month - once per semester. (inadequate integration, lack of automation.)&lt;/li&gt;
&lt;li&gt;Medium performance: once per month - once per week.&lt;/li&gt;
&lt;li&gt;High performance: daily for multiple times per day.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lead time for change: This measures the time it takes from the moment a code change is made until it is successfully deployed to production.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Low performance: one - six months. (time-consuming manual testing, lack of automation.)&lt;/li&gt;
&lt;li&gt;Medium performance: one week - one month.&lt;/li&gt;
&lt;li&gt;High performance: less than one day.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stability-metrics&#34;&gt;Stability metrics&lt;/h3&gt;
&lt;p&gt;change failure rate: This metric measures the proportion of deployments that result in failures.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Poor performance: 46% - 60%. (quality and reliability issues).&lt;/li&gt;
&lt;li&gt;Average performance: 15%-45%.&lt;/li&gt;
&lt;li&gt;High performance: 0% - 15%.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mean time to restore: This metric helps assess team’s ability to handle incidents and failures.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Low performance: one week - one month. (lack of adequate monitoring and diagnostic tools).&lt;/li&gt;
&lt;li&gt;Medium performance: one day - one week.&lt;/li&gt;
&lt;li&gt;High performance: less than one day.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;space&#34;&gt;SPACE&lt;/h2&gt;
&lt;p&gt;S: Satisfaction and well-being&lt;/p&gt;
&lt;p&gt;P: Performance&lt;/p&gt;
&lt;p&gt;A: Activity&lt;/p&gt;
&lt;p&gt;C: Collaboration and communication&lt;/p&gt;
&lt;p&gt;E: Efficiency and flow&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;devex&#34;&gt;DevEx&lt;/h2&gt;
&lt;p&gt;Developer Experience: DevEx captures how developers feel, how they think, and how they value their work.&lt;/p&gt;
&lt;h3 id=&#34;feedback-loops&#34;&gt;Feedback loops&lt;/h3&gt;
&lt;p&gt;perceptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;satisfaction with automated test speed and output.&lt;/li&gt;
&lt;li&gt;satisfaction with time it takes to validate a local change.&lt;/li&gt;
&lt;li&gt;satisfaction with time it takes to deploy a change to production.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;workflows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time it takes to generate CI results.&lt;/li&gt;
&lt;li&gt;code review turnaround time.&lt;/li&gt;
&lt;li&gt;deployment lead time.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cognitive-load&#34;&gt;Cognitive load&lt;/h3&gt;
&lt;p&gt;perceptions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;perceive complexity of codebase.&lt;/li&gt;
&lt;li&gt;ease of debugging production systems&lt;/li&gt;
&lt;li&gt;easy of understanding documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;workflows&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time it takes to get answers to technical questions.&lt;/li&gt;
&lt;li&gt;manual steps required to deploy a change.&lt;/li&gt;
&lt;li&gt;frequency of documentation improvements.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flow-state&#34;&gt;Flow state&lt;/h3&gt;
&lt;p&gt;perceptions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;perceived ability to focus and avoid interruptions.&lt;/li&gt;
&lt;li&gt;satisfaction with clarity of task or project goals.&lt;/li&gt;
&lt;li&gt;perceived disruptiveness of being on-call.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;workflows&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number of blocks of time without meetings or interruptions.&lt;/li&gt;
&lt;li&gt;frequency of unplanned tasks or requests.&lt;/li&gt;
&lt;li&gt;frequency of incidents requiring team attention.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Secret</title>
        <link>https://canuxcheng.com/post/sec_secret/</link>
        <pubDate>Sun, 28 Jul 2024 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_secret/</guid>
        <description>&lt;h1 id=&#34;secret&#34;&gt;Secret&lt;/h1&gt;
&lt;p&gt;secret scan tools&lt;/p&gt;
&lt;h2 id=&#34;trufflehog&#34;&gt;trufflehog&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/trufflesecurity/trufflehog&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/trufflesecurity/trufflehog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>React</title>
        <link>https://canuxcheng.com/post/js_react/</link>
        <pubDate>Sat, 27 Jan 2024 22:19:20 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_react/</guid>
        <description>&lt;h1 id=&#34;react&#34;&gt;React&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://react.dev/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://react.dev/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AWS Development</title>
        <link>https://canuxcheng.com/post/aws_development/</link>
        <pubDate>Tue, 23 Jan 2024 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_development/</guid>
        <description>&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;h3 id=&#34;cloud9&#34;&gt;Cloud9&lt;/h3&gt;
&lt;h3 id=&#34;codeartifact&#34;&gt;CodeArtifact&lt;/h3&gt;
&lt;h3 id=&#34;codebuild&#34;&gt;CodeBuild&lt;/h3&gt;
&lt;h3 id=&#34;codecommit&#34;&gt;CodeCommit&lt;/h3&gt;
&lt;h3 id=&#34;codedeploy&#34;&gt;CodeDeploy&lt;/h3&gt;
&lt;h3 id=&#34;codeguru&#34;&gt;CodeGuru&lt;/h3&gt;
&lt;h3 id=&#34;codepipeline&#34;&gt;CodePipeline&lt;/h3&gt;
&lt;h3 id=&#34;codestar&#34;&gt;CodeStar&lt;/h3&gt;
&lt;h3 id=&#34;x-ray&#34;&gt;X-Ray&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;blockchain&#34;&gt;Blockchain&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;multimedia&#34;&gt;Multimedia&lt;/h2&gt;
&lt;h3 id=&#34;elastic-transcoder&#34;&gt;Elastic Transcoder&lt;/h3&gt;
&lt;h3 id=&#34;kinesis-video-streams&#34;&gt;Kinesis Video Streams&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;webmobile&#34;&gt;Web&amp;amp;Mobile&lt;/h2&gt;
&lt;h3 id=&#34;amplify&#34;&gt;Amplify&lt;/h3&gt;
&lt;h3 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h3&gt;
&lt;h3 id=&#34;device-farm&#34;&gt;Device Farm&lt;/h3&gt;
&lt;h3 id=&#34;pinpoint&#34;&gt;Pinpoint&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iot&#34;&gt;IoT&lt;/h2&gt;
&lt;h3 id=&#34;iot-analytics&#34;&gt;IoT Analytics&lt;/h3&gt;
&lt;h3 id=&#34;iot-core&#34;&gt;IoT Core&lt;/h3&gt;
&lt;h3 id=&#34;iot-events&#34;&gt;IoT Events&lt;/h3&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mlai&#34;&gt;ML&amp;amp;AI&lt;/h2&gt;
&lt;h3 id=&#34;comprehend&#34;&gt;Comprehend&lt;/h3&gt;
&lt;h3 id=&#34;forecast&#34;&gt;Forecast&lt;/h3&gt;
&lt;h3 id=&#34;fraud-detector&#34;&gt;Fraud Detector&lt;/h3&gt;
&lt;h3 id=&#34;kendra&#34;&gt;Kendra&lt;/h3&gt;
&lt;h3 id=&#34;lex&#34;&gt;Lex&lt;/h3&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Security</title>
        <link>https://canuxcheng.com/post/devops_security/</link>
        <pubDate>Thu, 19 Oct 2023 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_security/</guid>
        <description>&lt;h1 id=&#34;devops-security&#34;&gt;DevOps Security&lt;/h1&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&#34;trivy&#34;&gt;Trivy&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/aquasecurity/trivy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aquasecurity/trivy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more&lt;/p&gt;
&lt;h2 id=&#34;tetragon&#34;&gt;Tetragon&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cilium/tetragon&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cilium/tetragon&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;falco&#34;&gt;Falco&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/falcosecurity/falco&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/falcosecurity/falco&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>API Gateway</title>
        <link>https://canuxcheng.com/post/k8s_apigateway/</link>
        <pubDate>Fri, 04 Aug 2023 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_apigateway/</guid>
        <description>&lt;h1 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/gateway-api&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/gateway-api&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GatewayClass没有namespace&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;emissary ingress&lt;/li&gt;
&lt;li&gt;kong&lt;/li&gt;
&lt;li&gt;higress&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>First_Aid</title>
        <link>https://canuxcheng.com/post/first_aid/</link>
        <pubDate>Mon, 17 Jul 2023 14:46:57 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/first_aid/</guid>
        <description>&lt;h1 id=&#34;first-aid&#34;&gt;First Aid&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/fa1.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic0&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/fa2.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic1&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确认现场环境安全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断呼吸和意识&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先跪下判断意识和呼吸情况，两手拍肩膀呼叫，判断意识，看胸口起伏判断呼吸，数数1001，1002，&amp;hellip; 1008 八秒；如果没有意识和呼吸才需要心肺复苏。否则可能是气道梗阻。&lt;/p&gt;
&lt;h2 id=&#34;气道梗阻&#34;&gt;气道梗阻&lt;/h2&gt;
&lt;p&gt;不完全气道梗阻：&lt;/p&gt;
&lt;p&gt;有意识，能沟通，优先咳嗽排出。
其次采用背部叩击。
最后才使用腹部冲击（海姆利克法）。&lt;/p&gt;
&lt;p&gt;完全气道梗阻：&lt;/p&gt;
&lt;p&gt;没有意识，没有呼吸，需要心肺复苏。&lt;/p&gt;
&lt;h2 id=&#34;心肺复苏&#34;&gt;心肺复苏&lt;/h2&gt;
&lt;p&gt;来人啊，救命啊，有人晕倒了，我是急救员，请你拨打120，有AED一并带来，会急救的和我一起。&lt;/p&gt;
&lt;p&gt;胸部按压30次01，02&amp;hellip; 30，深度5cm左右，确保完全回弹。&lt;/p&gt;
&lt;p&gt;然后清理口腔异物，吹气两次。&lt;/p&gt;
&lt;p&gt;胸部按压和吹气连续做5组。&lt;/p&gt;
&lt;p&gt;每做完5组检查脉搏和呼吸。一只手放头部，另一只手两个指头放劲动脉。计数1001，1002，&amp;hellip; 1008；若有呼吸抢救成功，否则重复上述步骤。&lt;/p&gt;
&lt;p&gt;如果有AED，随到随用，先打开电源，一个贴片用于病人右侧胸部上方，一个用于左侧胸部侧方，提醒旁人离开，开始分析是否需要除颤，若需要提示旁人离开，按下按钮。提示完成后继续心肺复苏。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Arduino</title>
        <link>https://canuxcheng.com/post/hardware_arduino/</link>
        <pubDate>Mon, 15 May 2023 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/hardware_arduino/</guid>
        <description>&lt;h1 id=&#34;arduino-uno&#34;&gt;Arduino Uno&lt;/h1&gt;
&lt;p&gt;tinogo-windows开发环境配置&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tinygo.org/getting-started/install/windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://tinygo.org/getting-started/install/windows/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scoop install go
scoop install tinygo
scoop install avrdude
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows烧写程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tinygo flash -monitor -baudrate=9600 -target arduino -port COMX /path/to/blinky1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;macos烧写程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tinygo flash --target arduino -port /dev/cu.usbserial-0001 ./blinking.go
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;microcontroller&#34;&gt;Microcontroller&lt;/h2&gt;
&lt;p&gt;Arduino Uno 使用的是ATmega328p 控制器&lt;/p&gt;
&lt;p&gt;支持的外设接口:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPIO：general-purpose input/output，数字接口&lt;/li&gt;
&lt;li&gt;UART：Universal asynchronous receiver-transmitter，异步串行接口&lt;/li&gt;
&lt;li&gt;SPI：Serial Peripheral Interface，同步串行接口&lt;/li&gt;
&lt;li&gt;I2C：Inter-Integrated Circuit, 同步串行接口&lt;/li&gt;
&lt;li&gt;ADC：Analog-to-digital, 模拟转数字接口&lt;/li&gt;
&lt;li&gt;PWM: Pulse-width modulation,&lt;/li&gt;
&lt;li&gt;USB：不支持，异步串行接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;machine-包&#34;&gt;machine 包&lt;/h2&gt;
&lt;p&gt;machine包是tinygo中核心包&lt;/p&gt;
&lt;h2 id=&#34;driver&#34;&gt;Driver&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tinygo.org/docs/reference/devices/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://tinygo.org/docs/reference/devices/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装支持的driver&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get tinygo.org/x/drivers
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCP</title>
        <link>https://canuxcheng.com/post/gcp/</link>
        <pubDate>Sun, 23 Apr 2023 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gcp/</guid>
        <description>&lt;h1 id=&#34;gcp&#34;&gt;GCP&lt;/h1&gt;
&lt;p&gt;gcp certification:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Cloud Certified Cloud Digital Leader&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Associate Cloud Engineer&lt;/li&gt;
&lt;li&gt;Google Cloud Certified DevOps Engineer&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Machine Learning Engineer&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Professional Cloud Architect&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Professional Data Engineer&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Professional Network Engineer&lt;/li&gt;
&lt;li&gt;Google Cloud Certified Professional Security Engineer&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cloud-sdk&#34;&gt;Cloud SDK&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/sdk/docs/install&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.google.com/sdk/docs/install&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;默认安装的组件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bq&lt;/li&gt;
&lt;li&gt;bundled-python3-unix&lt;/li&gt;
&lt;li&gt;gsutil&lt;/li&gt;
&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;gcloud-crc32c&lt;/li&gt;
&lt;li&gt;alpha&lt;/li&gt;
&lt;li&gt;beta&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装其它组件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud components install app-engine-go docker-credential-gcr kustomize log-streaming terraform-tools app-engine-python app-engine-python-extras gke-gcloud-auth-plugin kubectl kubectl-oidc 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;卸载:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud components remove &amp;lt;component_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;升级&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud components update
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gcp-command-line-interface&#34;&gt;GCP Command Line Interface&lt;/h2&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud --help   
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cli-credentials&#34;&gt;CLI credentials&lt;/h3&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud init
gcloud init --no-launch-browser
gcloud init --console-only
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;p&gt;配置存储位置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;linux/unix: ~/.config/gcloud
windows: %APPDATA%\gcloud
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建配置
gcloud config configurations create [name]

// 列出配置
gcloud config configurations list

// 查看配置属性
gcloud config configurations describe [name]

// 激活配置
gcloud config configurations activate [name]

// 删除配置
gcloud config configurations delete [name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看属性
gcloud config list

// 切换account
gcloud config set account [account]
// 切换project
gcloud config set project [project]

// 查看可用属性
gcloud config set --help

// 显示可用属性的列表
gcloud topic configurations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 默认打开浏览器授权
gcloud auth login

// 用于没有浏览器的机器
// 复制gcloud auth login --remote-bootstrap=&amp;quot;命令在另外一台安装了浏览器和gcloud cli的机器打开。
// 将浏览器的输出帖回没有浏览器的机器。
gcloud auth login --no-browser

// 用于没有浏览器的机器，复制Https网址打开浏览器授权。
gcloud auth login --no-launch-browser

// 列出账号.
gcloud auth list

// 禁止通过cli登录
gcloud auth revoke [account]

// 查找凭据文件位置
gcloud info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Application Default Credentials（ADC):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将用户凭据提供给ADC(用于sdk或者terraform等交互）。
gcloud auth application-default login --no-launch-browser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;交互式shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud beta interactive
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;compute&#34;&gt;compute&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes: GKE(EKS)&lt;/li&gt;
&lt;li&gt;Compute engine(EC2): compute engine&lt;/li&gt;
&lt;li&gt;Batch&lt;/li&gt;
&lt;li&gt;workload manager&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;serverless&#34;&gt;ServerLess&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cloud run&lt;/li&gt;
&lt;li&gt;cloud functions&lt;/li&gt;
&lt;li&gt;app engine&lt;/li&gt;
&lt;li&gt;api gateway&lt;/li&gt;
&lt;li&gt;endpoints&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;network&#34;&gt;network&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;VPC&lt;/li&gt;
&lt;li&gt;cloud router&lt;/li&gt;
&lt;li&gt;cloud DNS(route53)&lt;/li&gt;
&lt;li&gt;cloud domains(route53)&lt;/li&gt;
&lt;li&gt;cloud firewall(DNS firewall, network firewall, SG, ACL)&lt;/li&gt;
&lt;li&gt;cloud interconnect(direct connect)&lt;/li&gt;
&lt;li&gt;cloud VPN&lt;/li&gt;
&lt;li&gt;cloud NAT&lt;/li&gt;
&lt;li&gt;cloud CDN&lt;/li&gt;
&lt;li&gt;cloud load balancing&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cloud-load-balancer&#34;&gt;Cloud Load balancer&lt;/h3&gt;
&lt;p&gt;Application LB(http/https):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external LB(gce): external global lb(gke-l7-global-external-managed), external classic global lb(gke-l7-gxlb), external regional lb（gke-l7-regional-external-managed）.&lt;/li&gt;
&lt;li&gt;internal LB(gce-internal, gke-l7-rilb): internal regional lb.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proxy LB(TCP/SSL):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external&lt;/li&gt;
&lt;li&gt;internal&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Passthrough LB(TCP/UDP):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;external&lt;/li&gt;
&lt;li&gt;internal&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;storage&#34;&gt;storage&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;persistent disk(EBS): (balanced/extreme/ssd/standard) 创建vm的时候创建块存储。&lt;/li&gt;
&lt;li&gt;cloud storage(S3): (standard/nearline/coldline/archive) 可以在全球范围内随时存储和检索任意数量的数据&lt;/li&gt;
&lt;li&gt;cloud storage for filebase(S3): 专为需要存储和提供用户生成的内容（如照片或视频）的应用开发者而打造的&lt;/li&gt;
&lt;li&gt;filestore(EFS): file storage&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;database&#34;&gt;Database&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cloud SQL(RDS, Aurora): RDBMA&lt;/li&gt;
&lt;li&gt;Cloud Spanner(Aurora): RDBMS&lt;/li&gt;
&lt;li&gt;Cloud Bigtable(dynamoDB): NoSQL: Key-value&lt;/li&gt;
&lt;li&gt;datastore(dynamoDB): NoSQL: Indexed&lt;/li&gt;
&lt;li&gt;memorystore(elastiCache): In-memory data store, memcached/redis&lt;/li&gt;
&lt;li&gt;BigQuery&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;security&#34;&gt;Security&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;certificate authority service(ACM): Certificate management&lt;/li&gt;
&lt;li&gt;cloud identity(IAM):&lt;/li&gt;
&lt;li&gt;Identity and access management(IAM):&lt;/li&gt;
&lt;li&gt;Identity-Aware Proxy(IAM):&lt;/li&gt;
&lt;li&gt;cloud key management service(KMS):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IAM members:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;google account&lt;/li&gt;
&lt;li&gt;google service account&lt;/li&gt;
&lt;li&gt;google groups&lt;/li&gt;
&lt;li&gt;cloud identity domain&lt;/li&gt;
&lt;li&gt;google workspace domain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IAM basic roles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Owner&lt;/li&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;Viewer&lt;/li&gt;
&lt;li&gt;Billing Administrator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service account types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user created&lt;/li&gt;
&lt;li&gt;built-in (compute engine or gke default SA)&lt;/li&gt;
&lt;li&gt;Google APIs SA&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;operation&#34;&gt;Operation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Monitoring&lt;/li&gt;
&lt;li&gt;Debugger&lt;/li&gt;
&lt;li&gt;Logging&lt;/li&gt;
&lt;li&gt;Error reporting&lt;/li&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Profiler&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;analytics&#34;&gt;Analytics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BigQuery&lt;/li&gt;
&lt;li&gt;Pub/Sub&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cicd&#34;&gt;CI/CD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cloud build&lt;/li&gt;
&lt;li&gt;cloud deploy&lt;/li&gt;
&lt;li&gt;container registry&lt;/li&gt;
&lt;li&gt;artifact registry&lt;/li&gt;
&lt;li&gt;source repositories&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;how-to-ssh-to-vm&#34;&gt;how to ssh to vm&lt;/h2&gt;
&lt;h3 id=&#34;metadata&#34;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;分为Project metadata和instance metadata。&lt;/p&gt;
&lt;h4 id=&#34;ssh&#34;&gt;ssh&lt;/h4&gt;
&lt;p&gt;Only for external IP (public IP).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssh key for vm: add ssh pub key to instance metadata.&lt;/li&gt;
&lt;li&gt;ssh key for project: add ssh pub key to project metadata.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh to vm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh username_from_metadata@external_IP
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gcloud&#34;&gt;gcloud&lt;/h4&gt;
&lt;p&gt;首次运行会创建ssh 密钥对，用户名是本地机器用户名,google_compute_engine.&lt;/p&gt;
&lt;p&gt;公钥会自动上传到project/instance metadata.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh public-instance \
--project=PJ \
--zone=RZ
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;os-login&#34;&gt;OS Login&lt;/h3&gt;
&lt;p&gt;设置 OS Login 元数据时，Compute Engine 会删除虚拟机的 authorized_keys 文件，并且不再接受来自项目或实例元数据中存储的 SSH 密钥的连接。&lt;/p&gt;
&lt;p&gt;用户名为canuxcheng@gmail.com =&amp;gt; canuxcheng_gmail_com&lt;/p&gt;
&lt;h4 id=&#34;ssh-1&#34;&gt;ssh&lt;/h4&gt;
&lt;p&gt;使用ssh需要将公钥上传到OS Login配置(忽略密钥中的用户名）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute os-login ssh-keys add \
--key-file=public_KEY_FILE_PATH \
--project=PROJECT \
--ttl=EXPIRE_TIME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh canuxcheng_gmail_com@IP
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gcloud-1&#34;&gt;gcloud&lt;/h4&gt;
&lt;p&gt;首次运行会创建ssh 密钥对，公钥会自动上传到os login config.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh instance --internal-ip --project=PJ --zone=RZ
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;iap&#34;&gt;IAP&lt;/h3&gt;
&lt;p&gt;Identity-Aware Proxy&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.google.com/iap/docs/using-tcp-forwarding?_ga=2.127808461.-1134224509.1683858043&amp;amp;hl=zh-cn#firewall&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.google.com/iap/docs/using-tcp-forwarding?_ga=2.127808461.-1134224509.1683858043&amp;hl=zh-cn#firewall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;use internal ip directly:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh private-instance --project=PJ --zone=europe-west4-a --internal-ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;use iap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh private-instance \
--project=PJ \
--zone=RZ \
--tunnel-through-iap 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Auth</title>
        <link>https://canuxcheng.com/post/django_auth/</link>
        <pubDate>Fri, 14 Jan 2022 04:29:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_auth/</guid>
        <description>&lt;h1 id=&#34;authpy&#34;&gt;auth.py&lt;/h1&gt;
&lt;p&gt;自定义authentication backend.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request):
        ...
    def get_user(self, user_id):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置使用自定义backend&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AUTHENTICATION_BACKENDS =  (&amp;quot;apps.ldap_auth.auth.MyBackend&amp;quot;,)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/etianen/django-python3-ldap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/etianen/django-python3-ldap&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;auth&#34;&gt;auth&lt;/h1&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = (
    &#39;django.contrib.auth&#39;，
    &#39;django.contrib.contenttypes&#39;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lsquo;django.contrib.auth&amp;rsquo; 包含了验证框架的内核和它的默认模型。&lt;/p&gt;
&lt;p&gt;&amp;lsquo;django.contrib.contenttypes&amp;rsquo; 是 Django content type system ，允许你创建的模型和权限相关联。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MIDDLEWARE_CLASSES = (
    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,
    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户登录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib.auth import authenticate, login
user = authenticate(username=&#39;name&#39;, password=&#39;pw&#39;)
login(request, user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆时的默认验证后端:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AUTHENTICATION_BACKENDS = [&#39;django.contrib.auth.backends.ModelBackend&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户登出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib.auth import logout
logout(request)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Application</title>
        <link>https://canuxcheng.com/post/cncf_application/</link>
        <pubDate>Sat, 04 Dec 2021 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_application/</guid>
        <description>&lt;h1 id=&#34;application-definition--image-build&#34;&gt;Application Definition &amp;amp; Image Build&lt;/h1&gt;
&lt;p&gt;application choreography.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;helm&lt;/li&gt;
&lt;li&gt;backstage&lt;/li&gt;
&lt;li&gt;buildpack.io&lt;/li&gt;
&lt;li&gt;operatorframework&lt;/li&gt;
&lt;li&gt;dapr&lt;/li&gt;
&lt;li&gt;kubevela&lt;/li&gt;
&lt;li&gt;kubevirt&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;backstage&#34;&gt;backstage&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>AWS CLF</title>
        <link>https://canuxcheng.com/post/aws_clf/</link>
        <pubDate>Sat, 23 Oct 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_clf/</guid>
        <description>&lt;h1 id=&#34;clf&#34;&gt;CLF&lt;/h1&gt;
&lt;p&gt;Foundational: 6个月经验. Cloud Practitioner Foundational(CLF).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fundamental cloud concepts for AWS&lt;/li&gt;
&lt;li&gt;Understanding AWS core services&lt;/li&gt;
&lt;li&gt;Introduction to security &amp;amp; architecture on AWS&lt;/li&gt;
&lt;li&gt;AWS certified cloud practitioner exam prep&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>AWS Management</title>
        <link>https://canuxcheng.com/post/aws_management/</link>
        <pubDate>Thu, 23 Sep 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_management/</guid>
        <description>&lt;h1 id=&#34;aws-monitor&#34;&gt;AWS Monitor&lt;/h1&gt;
&lt;h2 id=&#34;cli&#34;&gt;CLI&lt;/h2&gt;
&lt;h2 id=&#34;management-console&#34;&gt;Management Console&lt;/h2&gt;
&lt;h2 id=&#34;quotas&#34;&gt;Quotas&lt;/h2&gt;
&lt;h2 id=&#34;service-catalog&#34;&gt;Service Catalog&lt;/h2&gt;
&lt;h2 id=&#34;cloudwatch&#34;&gt;CloudWatch&lt;/h2&gt;
&lt;p&gt;监控和管理服务，收集logs, metrics 和 events，支持基于metrics的alert。&lt;/p&gt;
&lt;p&gt;MTTR
TCO&lt;/p&gt;
&lt;h2 id=&#34;cloudwatch-logs&#34;&gt;CloudWatch Logs&lt;/h2&gt;
&lt;h2 id=&#34;cloudtrail&#34;&gt;CloudTrail&lt;/h2&gt;
&lt;p&gt;可以用来记录，持续监控和保留与AWS基础设施中的操作相关的账户活动。&lt;/p&gt;
&lt;p&gt;将审计记录插入S3或者cloudwatch log， 记录突发事件。&lt;/p&gt;
&lt;h2 id=&#34;aws-config&#34;&gt;AWS Config&lt;/h2&gt;
&lt;p&gt;提供基础设施的历史配置。基于规则持续评估基础设施。&lt;/p&gt;
&lt;h2 id=&#34;aws-trusted-advisor&#34;&gt;AWS Trusted Advisor&lt;/h2&gt;
&lt;p&gt;优化性能和安全性&lt;/p&gt;
&lt;h2 id=&#34;amazon-grafana&#34;&gt;Amazon Grafana&lt;/h2&gt;
&lt;h2 id=&#34;amazon-prometheus&#34;&gt;Amazon Prometheus&lt;/h2&gt;
&lt;h2 id=&#34;cloudformation&#34;&gt;CloudFormation&lt;/h2&gt;
&lt;p&gt;提供基于模板(yaml/json)的基础设施服务(IaaS).&lt;/p&gt;
&lt;h2 id=&#34;compute-optimizer&#34;&gt;Compute Optimizer&lt;/h2&gt;
&lt;h2 id=&#34;control-tower&#34;&gt;Control Tower&lt;/h2&gt;
&lt;h2 id=&#34;health-dashboard&#34;&gt;Health Dashboard&lt;/h2&gt;
&lt;h2 id=&#34;aws-systems-manager&#34;&gt;AWS Systems Manager&lt;/h2&gt;
&lt;p&gt;提供运维数据，并且在跨基础设施中进行自动化操作。&lt;/p&gt;
&lt;h2 id=&#34;aws-organizations&#34;&gt;AWS Organizations&lt;/h2&gt;
&lt;p&gt;账号集中管理。&lt;/p&gt;
&lt;h2 id=&#34;aws-license-manager&#34;&gt;AWS License Manager&lt;/h2&gt;
&lt;h2 id=&#34;proton&#34;&gt;Proton&lt;/h2&gt;
&lt;h2 id=&#34;aws-well-architected-tool&#34;&gt;AWS Well-Architected Tool&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;financial-management&#34;&gt;Financial Management&lt;/h1&gt;
&lt;h2 id=&#34;budgets&#34;&gt;Budgets&lt;/h2&gt;
&lt;h2 id=&#34;cost-explorer&#34;&gt;Cost Explorer&lt;/h2&gt;
&lt;h2 id=&#34;savings-plans&#34;&gt;Savings Plans&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>CORS</title>
        <link>https://canuxcheng.com/post/sec_cors/</link>
        <pubDate>Wed, 28 Jul 2021 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_cors/</guid>
        <description>&lt;h1 id=&#34;cors&#34;&gt;CORS&lt;/h1&gt;
&lt;p&gt;CORS: Cross-Origin resource sharing, 跨域资源共享.&lt;/p&gt;
&lt;p&gt;是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;same-origin-policy&#34;&gt;same-origin policy&lt;/h2&gt;
&lt;p&gt;同源策略，是一种关键的安全机制，它限制由一个源加载的文档或脚本如何与来自另一个源的资源进行交互。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;protocal (http, https, &amp;hellip;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;host&lt;/li&gt;
&lt;li&gt;port(80, 443, &amp;hellip;&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简单请求&#34;&gt;简单请求&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求方法是以下三种方法之一：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;HTTP的头信息不超出以下几种字段：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Last-Event-ID&lt;/li&gt;
&lt;li&gt;Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单请求在header添加Origin字段说明请求的源(协议，域名，端口):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Origin: https://domain.com:port
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;预检请求&#34;&gt;预检请求&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对其它方法或字段类型.&lt;/p&gt;
&lt;h2 id=&#34;http-headers&#34;&gt;http headers&lt;/h2&gt;
&lt;p&gt;响应header中可以带以下字段：&lt;/p&gt;
&lt;p&gt;Access-Control-Allow-Origin&lt;/p&gt;
&lt;p&gt;Access-Control-Max-Age&lt;/p&gt;
&lt;p&gt;Access-Control-Allow-Credentials&lt;/p&gt;
&lt;p&gt;Access-Control-Allow-Methods&lt;/p&gt;
&lt;p&gt;Access-Control-Expose-Headers
Access-Control-Allow-Headers&lt;/p&gt;
&lt;p&gt;请求header中的字段：&lt;/p&gt;
&lt;p&gt;Origin&lt;/p&gt;
&lt;p&gt;Access-Control-Request-Method&lt;/p&gt;
&lt;p&gt;Access-Control-Request-Headers&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Let&#39;s Encrypt</title>
        <link>https://canuxcheng.com/post/sec_letsencrypt/</link>
        <pubDate>Wed, 28 Jul 2021 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_letsencrypt/</guid>
        <description>&lt;h1 id=&#34;lets-encrypt&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://letsencrypt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://letsencrypt.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/letsencrypt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/letsencrypt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是非盈利组织ISRG提供的免费的证书颁发机构。&lt;/p&gt;
&lt;p&gt;let&amp;rsquo;s encrypt生成证书的工具很多certbot, acme.sh等.&lt;/p&gt;
&lt;h1 id=&#34;certbot&#34;&gt;certbot&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/certbot/certbot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/certbot/certbot&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;acmesh&#34;&gt;acme.sh&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/acmesh-official/acme.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/acmesh-official/acme.sh&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>BSP</title>
        <link>https://canuxcheng.com/post/hardware_bsp/</link>
        <pubDate>Sat, 15 May 2021 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/hardware_bsp/</guid>
        <description>&lt;h1 id=&#34;bsp&#34;&gt;BSP&lt;/h1&gt;
&lt;p&gt;BSP，Board Support Package，板级支持包.&lt;/p&gt;
&lt;p&gt;熟悉常见的接口协议，如I2C, SPI, UART, USB等。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>FPGA</title>
        <link>https://canuxcheng.com/post/hardware_fpga/</link>
        <pubDate>Sat, 15 May 2021 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/hardware_fpga/</guid>
        <description>&lt;h1 id=&#34;fpga&#34;&gt;FPGA&lt;/h1&gt;
&lt;p&gt;FPGA: Field Programmable Gate Array, 现场可编程逻辑门阵列.&lt;/p&gt;
&lt;p&gt;下面介绍各家厂商和对应的产品系列.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;xilinx赛灵思&#34;&gt;xilinx/赛灵思&lt;/h1&gt;
&lt;p&gt;Spartan&lt;/p&gt;
&lt;p&gt;Artix&lt;/p&gt;
&lt;p&gt;Kintex&lt;/p&gt;
&lt;p&gt;Virtex&lt;/p&gt;
&lt;p&gt;SoC/MPSoC&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;altera阿尔特拉&#34;&gt;Altera/阿尔特拉&lt;/h1&gt;
&lt;p&gt;被Intel英特尔收购&lt;/p&gt;
&lt;p&gt;MAXII&lt;/p&gt;
&lt;p&gt;Cyclone&lt;/p&gt;
&lt;p&gt;Stratix&lt;/p&gt;
&lt;p&gt;Arria&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;lattice莱迪思&#34;&gt;Lattice/莱迪思&lt;/h1&gt;
&lt;p&gt;ECP&lt;/p&gt;
&lt;p&gt;ICE&lt;/p&gt;
&lt;p&gt;Mach&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;synplicity&#34;&gt;Synplicity&lt;/h1&gt;
&lt;p&gt;被Synopsys新思科技收购&lt;/p&gt;
&lt;h2 id=&#34;haps&#34;&gt;HAPS&lt;/h2&gt;
&lt;p&gt;HAPS系列产品是专为ASIC/SOC设计者提供的高性能、高容量的基于FPGA的原型验证板.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hardware</title>
        <link>https://canuxcheng.com/post/hardware/</link>
        <pubDate>Sat, 15 May 2021 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/hardware/</guid>
        <description>&lt;h1 id=&#34;hardware&#34;&gt;Hardware&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/micropython/micropython&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/micropython/micropython&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tinygo-org/tinygo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tinygo-org/tinygo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;soc&#34;&gt;SoC&lt;/h1&gt;
&lt;p&gt;SOC：（System-On-Chip)片上系统。可以简单的理解为把系统做在一块芯片上。&lt;/p&gt;
&lt;p&gt;AP: application processor, CPU, GPU, NPU, ISP, DSP, ROM/RAM.&lt;/p&gt;
&lt;p&gt;BP: base-band processor, BBU.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/chip.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/ISP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;EUV: Extreme Ultraviolet Lithography，极紫外光刻&lt;/p&gt;
&lt;p&gt;DSP: Digital Signal Processing.&lt;/p&gt;
&lt;p&gt;ISP: image signal process.&lt;/p&gt;
&lt;p&gt;厂商：紫光展锐，华为海思，全志科技，瑞芯微。&lt;/p&gt;
&lt;h1 id=&#34;rfic&#34;&gt;RFIC&lt;/h1&gt;
&lt;p&gt;射频芯片&lt;/p&gt;
</description>
        </item>
        <item>
        <title>KubeVirt</title>
        <link>https://canuxcheng.com/post/k8s_kubevirt/</link>
        <pubDate>Mon, 10 May 2021 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_kubevirt/</guid>
        <description>&lt;h1 id=&#34;kubevirt&#34;&gt;KubeVirt&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubevirt.io/quickstart_cloud/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubevirt.io/quickstart_cloud/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://quay.io/organization/kubevirt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://quay.io/organization/kubevirt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;virtctl&#34;&gt;virtctl&lt;/h2&gt;
&lt;h2 id=&#34;vm&#34;&gt;VM&lt;/h2&gt;
&lt;p&gt;创建vm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kubevirt.io/v1
kind: VirtualMachine
metadata:
name: testvm
spec:
running: false
template:
    metadata:
    labels:
        kubevirt.io/size: small
        kubevirt.io/domain: testvm
    spec:
    domain:
        devices:
        disks:
            - name: containerdisk
            disk:
                bus: virtio
            - name: cloudinitdisk
            disk:
                bus: virtio
        interfaces:
        - name: default
            masquerade: {}
        resources:
        requests:
            memory: 64M
    networks:
    - name: default
        pod: {}
    volumes:
        - name: containerdisk
        containerDisk:
            image: quay.io/kubevirt/cirros-container-disk-demo
        - name: cloudinitdisk
        cloudInitNoCloud:
            userDataBase64: SGkuXG4=
    nodeSelector:
        kubernetes.io/arch: arm64
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Cache</title>
        <link>https://canuxcheng.com/post/django_cache/</link>
        <pubDate>Tue, 04 May 2021 04:51:30 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_cache/</guid>
        <description>&lt;h1 id=&#34;cache&#34;&gt;cache&lt;/h1&gt;
&lt;p&gt;缓存的backend可以是django内置的，也可以是第三方的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存整个站点&lt;/p&gt;
&lt;p&gt;MIDDLEWARE = [
&amp;lsquo;django.middleware.cache.UpdateCacheMiddleware&amp;rsquo;,
&amp;lsquo;django.middleware.common.CommonMiddleware&amp;rsquo;,
&amp;lsquo;django.middleware.cache.FetchFromCacheMiddleware&amp;rsquo;,
]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;视图缓存&lt;/p&gt;
&lt;p&gt;from django.views.decorators.cache import cache_page&lt;/p&gt;
&lt;p&gt;@cache_page(60 * 2)
def my_view(request):
&amp;hellip;&lt;/p&gt;
&lt;p&gt;或者在URLconf中指定
urlpatterns = [
path(&amp;lsquo;foo/&lt;a class=&#34;link&#34; href=&#34;int:code&#34; &gt;int:code&lt;/a&gt;/&amp;rsquo;, cache_page(60 * 2)(my_view)),
]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板片段缓存&lt;/p&gt;
&lt;p&gt;{% load cache %}
{% cache &amp;hellip; %}
&amp;hellip;
{% endcache %}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CACHES = {
    &amp;quot;default&amp;quot;: {
        &amp;quot;BACKEND&amp;quot;: &amp;quot;django_redis.cache.RedisCache&amp;quot;,
        &amp;quot;LOCATION&amp;quot;: os.environ.get(&amp;quot;REDIS_URL&amp;quot;, &#39;&#39;),
        &amp;quot;OPTIONS&amp;quot;: {
            &amp;quot;CLIENT_CLASS&amp;quot;: &amp;quot;django_redis.client.DefaultClient&amp;quot;,
        },
        &amp;quot;TIMEOUT&amp;quot;: 60,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;memcached&#34;&gt;memcached&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CACHES = {
    &#39;default&#39;: {
        &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,
        &#39;LOCATION&#39;: &#39;127.0.0.1:11211&#39;,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;database&#34;&gt;database&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CACHES = {
    &#39;default&#39;: {
        &#39;BACKEND&#39;: &#39;django.core.cache.backends.db.DatabaseCache&#39;,
        &#39;LOCATION&#39;: &#39;my_cache_table&#39;,
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>AWS</title>
        <link>https://canuxcheng.com/post/aws/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws/</guid>
        <description>&lt;h1 id=&#34;aws&#34;&gt;AWS&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/donnemartin/awesome-aws&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/donnemartin/awesome-aws&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;aws certification:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Foundational: 6个月经验. Cloud Practitioner Foundational(CLF).&lt;/li&gt;
&lt;li&gt;Associate: 一年经验. Solutions Architect Associate(SAA); Developer, SysOps Administrator&lt;/li&gt;
&lt;li&gt;Professional: 两年经验. Solutions Architect Professional(SAP), Devops Engineer.&lt;/li&gt;
&lt;li&gt;Specialty: 特殊领域.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sdk&#34;&gt;SDK&lt;/h2&gt;
&lt;p&gt;python&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/boto/boto3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/boto/boto3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;golang&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/aws/aws-sdk-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aws/aws-sdk-go&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;aws-management-console&#34;&gt;AWS Management Console&lt;/h2&gt;
&lt;p&gt;通过webUI管理资源.
kkkkjjkijijijkkjddkkkkjj&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;aws-command-line-interface&#34;&gt;AWS Command Line Interface&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/aws/aws-cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aws/aws-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/awslabs/aws-shell&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/awslabs/aws-shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐使用awscli-V2:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws [-h] [--profile PROFILE] [--debug]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;option:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-h, --help
--profile PROFILE
--debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comand option:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws &amp;lt;service&amp;gt; &amp;lt;subcommand&amp;gt; help 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cli-credentials&#34;&gt;CLI credentials&lt;/h3&gt;
&lt;p&gt;优先级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令行选项&lt;/li&gt;
&lt;li&gt;credentials文件&lt;/li&gt;
&lt;li&gt;config文件&lt;/li&gt;
&lt;li&gt;容器凭证&lt;/li&gt;
&lt;li&gt;实例配置文件凭证&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CLI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置default profile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$aws configure
AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE
AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
Default region name [None]: us-west-2
Default output format [None]: json/yaml/text/table/yaml-stream

// 配置指定用户
$aws configure --profile canux

// 查看配置
$aws configure  list
$aws configure --profile canux list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令行选项指定配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$aws --profile canux ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;环境变量指定配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export AWS_PROFILE=canux
export AWS_DEFAULT_PROFILE=canux
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Shared credentials file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// windows
%USERPROFILE%\.aws\credentials

// linux
~/.aws/credentials 

// 默认账号配置
[default]
aws_access_key_id=AKIAIOSFODNN7EXAMPLE
aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

// 指定用户配置
[canux]
aws_access_key_id=AKIAI44QH8DHBEXAMPLE
aws_secret_access_key=je7MtGbClwBF/2Zp9Utk/h3yCo8nvbEXAMPLEKEY
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过环境变量配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export AWS_ACCESS_KEY_ID=&amp;quot;id&amp;quot;
export AWS_SECRET_ACCESS_KEY=&amp;quot;key&amp;quot;
export AWS_SESSION_TOKEN=&amp;quot;token&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Config file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// linux
~/.aws/config

[default]
region = eu-west-1
output = yaml

[profile pro]
sso_start_url = https://lz.awsapps.com/start
sso_region = eu-west-1
sso_role_name = ProjAdmins
sso_account_id = 123404000510
region = us-west-2
output = json

// windows
%USERPROFILE%\.aws\config
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;IAM role&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;how to check:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$aws sts get-caller-identity --profile pro
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;services&#34;&gt;services&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;iam
ec2
sts
eks

aws eks describe-addon-versions --addon-name aws-ebs-csi-driver
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>AWS Compute Services</title>
        <link>https://canuxcheng.com/post/aws_cs/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_cs/</guid>
        <description>&lt;h1 id=&#34;aws-compute-service&#34;&gt;AWS Compute Service&lt;/h1&gt;
&lt;h2 id=&#34;ec2&#34;&gt;EC2&lt;/h2&gt;
&lt;p&gt;Elastic Compute.&lt;/p&gt;
&lt;p&gt;AMI: Amazon Machine Image.&lt;/p&gt;
&lt;p&gt;EC2实例类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用型实例&lt;/li&gt;
&lt;li&gt;计算优化型实例&lt;/li&gt;
&lt;li&gt;内存优化型实例&lt;/li&gt;
&lt;li&gt;加速计算型实例&lt;/li&gt;
&lt;li&gt;存储优化型实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EC2付费类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按需(on-demand)&lt;/li&gt;
&lt;li&gt;预留实例(reserved)&lt;/li&gt;
&lt;li&gt;储蓄计划(savings plans)&lt;/li&gt;
&lt;li&gt;Spot实例&lt;/li&gt;
&lt;li&gt;专用主机(dedicated)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;elastic-beanstalk&#34;&gt;Elastic Beanstalk&lt;/h2&gt;
&lt;p&gt;features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;monitoring&lt;/li&gt;
&lt;li&gt;deployment&lt;/li&gt;
&lt;li&gt;scaling&lt;/li&gt;
&lt;li&gt;EC2 customization&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;
&lt;h2 id=&#34;lightsail&#34;&gt;Lightsail&lt;/h2&gt;
&lt;h2 id=&#34;batch&#34;&gt;Batch&lt;/h2&gt;
&lt;h2 id=&#34;app-runner&#34;&gt;App Runner&lt;/h2&gt;
&lt;h2 id=&#34;auto-scaling&#34;&gt;Auto Scaling&lt;/h2&gt;
&lt;h2 id=&#34;fargate&#34;&gt;Fargate&lt;/h2&gt;
&lt;h2 id=&#34;outposts&#34;&gt;Outposts&lt;/h2&gt;
&lt;h2 id=&#34;wavelength&#34;&gt;Wavelength&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;app-integration&#34;&gt;App Integration&lt;/h1&gt;
&lt;h2 id=&#34;appflow&#34;&gt;AppFlow&lt;/h2&gt;
&lt;h2 id=&#34;appsync&#34;&gt;AppSync&lt;/h2&gt;
&lt;h2 id=&#34;eventbridge&#34;&gt;EventBridge&lt;/h2&gt;
&lt;h2 id=&#34;step-functions&#34;&gt;Step Functions&lt;/h2&gt;
&lt;p&gt;无服务架构.&lt;/p&gt;
&lt;h2 id=&#34;sns&#34;&gt;SNS&lt;/h2&gt;
&lt;p&gt;Simple Notification Service是消息发布订阅服务.&lt;/p&gt;
&lt;h2 id=&#34;sqs&#34;&gt;SQS&lt;/h2&gt;
&lt;p&gt;Simple Queue Service是消息队列服务.&lt;/p&gt;
&lt;p&gt;支持256KB的payload.&lt;/p&gt;
&lt;p&gt;提供两种类型的queues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;standard queue&lt;/li&gt;
&lt;li&gt;FIFO queue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mq&#34;&gt;MQ&lt;/h2&gt;
&lt;p&gt;activeMQ 和 rabbitmq 托管服务。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;business-app-integration&#34;&gt;Business app integration&lt;/h1&gt;
&lt;h2 id=&#34;simple-email-service&#34;&gt;Simple Email Service&lt;/h2&gt;
&lt;p&gt;SES&lt;/p&gt;
&lt;h2 id=&#34;alexa-for-business&#34;&gt;Alexa for Business&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;终端用户计算&#34;&gt;终端用户计算&lt;/h1&gt;
&lt;h2 id=&#34;appstream&#34;&gt;AppStream&lt;/h2&gt;
&lt;h2 id=&#34;workspaces&#34;&gt;WorkSpaces&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>AWS Containers</title>
        <link>https://canuxcheng.com/post/aws_containers/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_containers/</guid>
        <description>&lt;h1 id=&#34;aws-containers&#34;&gt;AWS Containers&lt;/h1&gt;
&lt;h2 id=&#34;ecr&#34;&gt;ECR&lt;/h2&gt;
&lt;p&gt;Elastic Container Registry.&lt;/p&gt;
&lt;h2 id=&#34;ecs-anywhere&#34;&gt;ECS Anywhere&lt;/h2&gt;
&lt;h2 id=&#34;ecs&#34;&gt;ECS&lt;/h2&gt;
&lt;p&gt;Elastic Container Service.&lt;/p&gt;
&lt;h2 id=&#34;eks-distro&#34;&gt;EKS Distro&lt;/h2&gt;
&lt;h2 id=&#34;eks-anywhere&#34;&gt;EKS Anywhere&lt;/h2&gt;
&lt;h2 id=&#34;eks&#34;&gt;EKS&lt;/h2&gt;
&lt;p&gt;Elastic Kubernetes Service.&lt;/p&gt;
&lt;h3 id=&#34;通过aws-cli创建eks&#34;&gt;通过AWS CLI创建EKS&lt;/h3&gt;
&lt;p&gt;通过MC创建的资源都可以通过CLI(aws)创建.&lt;/p&gt;
&lt;p&gt;创建具有公有和私有子网且符合 Amazon EKS 要求的 Amazon VPC&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ aws cloudformation create-stack \
--stack-name my-eks-vpc-stack \
--region region-code \
--template-url https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建集群 IAM 角色并向其附加所需的 Amazon EKS IAM 托管策略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建EKS IAM role
aws iam create-role \
--role-name my-EKSClusterRole \
--assume-role-policy-document file://cluster-role-trust-policy.json&amp;quot; \
--permissions-boundary arn:aws:iam::&amp;lt;Your AWS ID&amp;gt;:policy/ProjAdminsPermBoundaryv2

{
    &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
    &amp;quot;Statement&amp;quot;: [
        {
            &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
            &amp;quot;Principal&amp;quot;: {
                &amp;quot;Service&amp;quot;: &amp;quot;eks.amazonaws.com&amp;quot;
            },
            &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;,
            &amp;quot;Condition&amp;quot;: {}
        }
    ]
}

// 绑定role和eks策略
aws iam attach-role-policy \
--policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy \
--role-name my-EKSClusterRole
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建EKS cluster:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws eks create-cluster --name my-cluster \
--role-arn arn:aws:iam::&amp;lt;ID&amp;gt;:role/my-EKSClusterRole \
--resources-vpc-config vpc.json / --resources-vpc-config subnetIds=subnet-6782e71e,subnet-e7e761ac,securityGroupIds=sg-6979fe18 \
--kubernetes-network-config eks.json / --kubernetes-network-config serviceIpv4Cidr=string,ipFamily=string \
--kubernetes-version &amp;lt;version&amp;gt; --tags &amp;lt;tags&amp;gt; --logging &amp;lt;logging&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给集群创建节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建节点IAM role
aws iam create-role \
--role-name my-EKSNodeRole \
--assume-role-policy-document file://node-role-trust-policy.json&amp;quot; \
--permissions-boundary arn:aws:iam::&amp;lt;ID&amp;gt;:policy/ProjAdminsPermBoundaryv2

{
    &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
    &amp;quot;Statement&amp;quot;: [
        {
            &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
            &amp;quot;Principal&amp;quot;: {
                &amp;quot;Service&amp;quot;: &amp;quot;ec2.amazonaws.com&amp;quot;
            },
            &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;,
            &amp;quot;Condition&amp;quot;: {}
        }
    ]
}

// 绑定role和node策略
aws iam attach-role-policy \
--policy-arn arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy \
--role-name my-EKSNodeRole 

aws iam attach-role-policy \
--policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly \
--role-name my-EKSNodeRole 

aws iam attach-role-policy \
--policy-arn arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy \
--role-name my-EKSNodeRole 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建managed node group:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws eks create-nodegroup \
--cluster-name my-cluster --nodegroup-name my-mng  --subnets &amp;lt;value&amp;gt; --node-role &amp;lt;value&amp;gt; \
--scaling-config minSize=integer,maxSize=integer,desiredSize=integer \
--instance-types &amp;lt;value&amp;gt; --ami-type &amp;lt;value&amp;gt; --remote-access &amp;lt;value&amp;gt; --disk-size &amp;lt;value&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将计算机配置为与您的集群通信&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws eks describe-cluster --name my-cluster
// 通过aws eks自动更新kube.config文件.
// 需要该role具有可以操作eks cluster的policy.
$ aws eks update-kubeconfig --name my-cluster --role-arn &amp;lt;role&amp;gt; --region eu-west-1 --verbose

$ kubectl get svc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除集群和节点:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws eks delete-nodegroup --nodegroup-name my-mng --cluster-name my-cluster
aws eks delete-cluster --name my-cluster
aws cloudformation delete-stack --stack-name my-stack
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通过eksctl创建eks&#34;&gt;通过eksctl创建EKS&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/weaveworks/eksctl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/weaveworks/eksctl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://eksctl.io/usage/schema/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://eksctl.io/usage/schema/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建集群和节点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ eksctl create cluster -f/--config-file ./cluster.yaml
$ eksctl create nodegroup -f/--config-file ./nodegroup.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除集群和节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ eksctl delete cluster --name my-cluster --region us-west-2
$ eksctl delete nodegroup --cluster my-cluster --region us-west-2 --name my-ng
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通过terraform创建eks&#34;&gt;通过Terraform创建EKS&lt;/h3&gt;
</description>
        </item>
        <item>
        <title>AWS Data</title>
        <link>https://canuxcheng.com/post/aws_data/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_data/</guid>
        <description>&lt;h1 id=&#34;data-processing&#34;&gt;Data Processing&lt;/h1&gt;
&lt;h2 id=&#34;athena&#34;&gt;Athena&lt;/h2&gt;
&lt;p&gt;serverless交互式分析&lt;/p&gt;
&lt;h2 id=&#34;data-exchange&#34;&gt;Data Exchange&lt;/h2&gt;
&lt;h2 id=&#34;glue&#34;&gt;Glue&lt;/h2&gt;
&lt;p&gt;AWS上的ETL(extract, transform and load)服务，提供数据的提取，转换，加载服务。&lt;/p&gt;
&lt;h2 id=&#34;data-pipeline&#34;&gt;Data pipeline&lt;/h2&gt;
&lt;p&gt;也是ETL服务。&lt;/p&gt;
&lt;h2 id=&#34;emr&#34;&gt;EMR&lt;/h2&gt;
&lt;p&gt;EMR: Elastic MapReduce.&lt;/p&gt;
&lt;p&gt;AWS的大数据平台。支持spark, hive, hbase, flink, hudi 和presto.&lt;/p&gt;
&lt;h2 id=&#34;kinesis&#34;&gt;Kinesis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Data Analytics&lt;/li&gt;
&lt;li&gt;Data Firehose&lt;/li&gt;
&lt;li&gt;Data Streams&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lake-formation&#34;&gt;Lake Formation&lt;/h2&gt;
&lt;h2 id=&#34;quicksight&#34;&gt;QuickSight&lt;/h2&gt;
&lt;h2 id=&#34;opensearch&#34;&gt;OpenSearch&lt;/h2&gt;
&lt;h2 id=&#34;msk&#34;&gt;MSK&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-analysis&#34;&gt;Data Analysis&lt;/h1&gt;
&lt;h2 id=&#34;athena-1&#34;&gt;Athena&lt;/h2&gt;
&lt;p&gt;serverless服务&lt;/p&gt;
&lt;h2 id=&#34;quicksight-1&#34;&gt;Quicksight&lt;/h2&gt;
&lt;h2 id=&#34;aws-cloudsearch&#34;&gt;AWS CloudSearch&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>AWS Database</title>
        <link>https://canuxcheng.com/post/aws_database/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_database/</guid>
        <description>&lt;h1 id=&#34;aws-database&#34;&gt;AWS Database&lt;/h1&gt;
&lt;h2 id=&#34;rds&#34;&gt;RDS&lt;/h2&gt;
&lt;p&gt;Relational Database Service， 关系型数据库服务.&lt;/p&gt;
&lt;p&gt;支持的数据库引擎：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amazon Aurora&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;MariaDB&lt;/li&gt;
&lt;li&gt;Oracle Database&lt;/li&gt;
&lt;li&gt;Microsoft SQL Server&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aurora-serverless&#34;&gt;Aurora Serverless&lt;/h2&gt;
&lt;h2 id=&#34;aurora&#34;&gt;Aurora&lt;/h2&gt;
&lt;p&gt;兼容mysql和postgresql.&lt;/p&gt;
&lt;h2 id=&#34;dynamodb&#34;&gt;DynamoDB&lt;/h2&gt;
&lt;p&gt;非关系数据库(NoSQL).&lt;/p&gt;
&lt;p&gt;DynamoDB是一项键值数据库服务. 无服务器，自动扩展。&lt;/p&gt;
&lt;p&gt;具有Key-Value数据库和Document数据库的功能。&lt;/p&gt;
&lt;h2 id=&#34;documentdb&#34;&gt;DocumentDB&lt;/h2&gt;
&lt;p&gt;兼容MongoDB.&lt;/p&gt;
&lt;h2 id=&#34;elasticcache&#34;&gt;ElasticCache&lt;/h2&gt;
&lt;p&gt;内存数据库(in-memory). 兼容redis和memcached.&lt;/p&gt;
&lt;h2 id=&#34;keyspaces&#34;&gt;Keyspaces&lt;/h2&gt;
&lt;p&gt;兼容cassandra的无服务器数据库。&lt;/p&gt;
&lt;h2 id=&#34;redshift&#34;&gt;Redshift&lt;/h2&gt;
&lt;p&gt;Amazon Redshift 是一项数据仓库服务，可用于进行大数据分析。&lt;/p&gt;
&lt;h2 id=&#34;neptune&#34;&gt;Neptune&lt;/h2&gt;
&lt;p&gt;图形数据库&lt;/p&gt;
&lt;h2 id=&#34;timesteam&#34;&gt;Timesteam&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>AWS Network</title>
        <link>https://canuxcheng.com/post/aws_network/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_network/</guid>
        <description>&lt;h1 id=&#34;aws-network&#34;&gt;AWS Network&lt;/h1&gt;
&lt;h2 id=&#34;vpc&#34;&gt;VPC&lt;/h2&gt;
&lt;p&gt;Virtual Private Cloud.&lt;/p&gt;
&lt;p&gt;EC2的私有内部网络.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;subnets&lt;/li&gt;
&lt;li&gt;route tables&lt;/li&gt;
&lt;li&gt;internet gateways&lt;/li&gt;
&lt;li&gt;nat gateways&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ENI: Elastic network interfaces.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://canuxcheng.com/images/vpc.png&#34; &gt;pic&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;elb&#34;&gt;ELB&lt;/h2&gt;
&lt;p&gt;ELB: Elastic Load Balancing&lt;/p&gt;
&lt;p&gt;弹性负载均衡，可以和EC2,ECS和lambda集成.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/cn/elasticloadbalancing/features/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://aws.amazon.com/cn/elasticloadbalancing/features/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持四种负载均衡器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Classic Load Balancer(默认)&lt;/li&gt;
&lt;li&gt;Gateway Load Balancer&lt;/li&gt;
&lt;li&gt;Application Load Balancer(ALB)&lt;/li&gt;
&lt;li&gt;Network Load Balancer(NLB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以使用aws默认自带的NLB controller.也可以通过安装aws-load-balancer-controller。推荐后者。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/aws-load-balancer-controller&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/aws-load-balancer-controller&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要给vpc上的node的subnet打tag:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.io/role/elb: 1
kubernetes.io/role/internal-elb: 1
kubernetes.io/cluster/${cluster-name}: owned/shared
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;route-53&#34;&gt;Route 53&lt;/h2&gt;
&lt;p&gt;DNS服务.&lt;/p&gt;
&lt;p&gt;在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。&lt;/p&gt;
&lt;p&gt;申请好了证书，需要在route 53创建记录.&lt;/p&gt;
&lt;p&gt;可以通过external-DNS 自动同步eks上的service和ingress到dns。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws route53 list-hosted-zones
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cloudfront&#34;&gt;CloudFront&lt;/h2&gt;
&lt;p&gt;CDN服务.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;direct-connect&#34;&gt;Direct Connect&lt;/h2&gt;
&lt;p&gt;提供数据中心和AWS直连。&lt;/p&gt;
&lt;h2 id=&#34;global-accelerator&#34;&gt;Global Accelerator&lt;/h2&gt;
&lt;h2 id=&#34;privatelink&#34;&gt;PrivateLink&lt;/h2&gt;
&lt;h2 id=&#34;transit-gateway&#34;&gt;Transit Gateway&lt;/h2&gt;
&lt;h2 id=&#34;vpn&#34;&gt;VPN&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>AWS Security</title>
        <link>https://canuxcheng.com/post/aws_security/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_security/</guid>
        <description>&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;
&lt;p&gt;Acceptable Use Policy.&lt;/p&gt;
&lt;h2 id=&#34;iam&#34;&gt;IAM&lt;/h2&gt;
&lt;p&gt;IAM: Identity and Access Management.&lt;/p&gt;
&lt;p&gt;STS: Security Token Service.&lt;/p&gt;
&lt;p&gt;ACL: Access control list.&lt;/p&gt;
&lt;p&gt;SG: Security Group.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/cn/iam/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://aws.amazon.com/cn/iam/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$aws iam list-users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IAM的三种身份类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Users&lt;/li&gt;
&lt;li&gt;Groups&lt;/li&gt;
&lt;li&gt;Roles&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IAM通过Policy(json)分配权限。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sso&#34;&gt;SSO&lt;/h2&gt;
&lt;p&gt;sso登陆:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws configure sso
aws sso login --no-browser 
aws sso logout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;secrets-manager&#34;&gt;Secrets Manager&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;acm&#34;&gt;ACM&lt;/h2&gt;
&lt;p&gt;AWS Certificate Manager.&lt;/p&gt;
&lt;p&gt;在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。&lt;/p&gt;
&lt;p&gt;申请好了证书，需要在route 53创建记录.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aws acm list-certificates --region eu-west-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;aws-load-balancer-controller可以自动关联ACM的证书和ingress.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;artifact&#34;&gt;Artifact&lt;/h2&gt;
&lt;p&gt;自助的合规报告。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;waf&#34;&gt;WAF&lt;/h2&gt;
&lt;h2 id=&#34;shield&#34;&gt;Shield&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;kms&#34;&gt;KMS&lt;/h2&gt;
&lt;p&gt;Key Management Service.&lt;/p&gt;
&lt;h2 id=&#34;inspector&#34;&gt;Inspector&lt;/h2&gt;
&lt;h2 id=&#34;guardduty&#34;&gt;GuardDuty&lt;/h2&gt;
&lt;h2 id=&#34;cognito&#34;&gt;Cognito&lt;/h2&gt;
&lt;p&gt;支持google/amazon/MS-AD/SAML 登陆。&lt;/p&gt;
&lt;h2 id=&#34;audit-manager&#34;&gt;Audit Manager&lt;/h2&gt;
&lt;h2 id=&#34;cloudhsm&#34;&gt;CloudHSM&lt;/h2&gt;
&lt;h2 id=&#34;detective&#34;&gt;Detective&lt;/h2&gt;
&lt;h2 id=&#34;directory-service&#34;&gt;Directory Service&lt;/h2&gt;
&lt;h2 id=&#34;firewall-manager&#34;&gt;Firewall Manager&lt;/h2&gt;
&lt;h2 id=&#34;macie&#34;&gt;Macie&lt;/h2&gt;
&lt;h2 id=&#34;network-firewall&#34;&gt;Network Firewall&lt;/h2&gt;
&lt;h2 id=&#34;ram&#34;&gt;RAM&lt;/h2&gt;
&lt;p&gt;Resource Access Manager&lt;/p&gt;
&lt;h2 id=&#34;security-hub&#34;&gt;Security Hub&lt;/h2&gt;
&lt;h2 id=&#34;sts&#34;&gt;STS&lt;/h2&gt;
&lt;p&gt;Security Token Service&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AWS Storage</title>
        <link>https://canuxcheng.com/post/aws_storage/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/aws_storage/</guid>
        <description>&lt;h1 id=&#34;aws-storage&#34;&gt;AWS Storage&lt;/h1&gt;
&lt;h2 id=&#34;s3&#34;&gt;S3&lt;/h2&gt;
&lt;p&gt;Simple Storage Service.&lt;/p&gt;
&lt;p&gt;S3分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S3标准&lt;/li&gt;
&lt;li&gt;S3标准-IA&lt;/li&gt;
&lt;li&gt;S3单区-IA&lt;/li&gt;
&lt;li&gt;S3智能分层&lt;/li&gt;
&lt;li&gt;S3 Glacier&lt;/li&gt;
&lt;li&gt;S3 Glacire Deep Archive&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限存储&lt;/li&gt;
&lt;li&gt;单个对象达到5Tb&lt;/li&gt;
&lt;li&gt;一次写入，多次读取&lt;/li&gt;
&lt;li&gt;99%持久性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;s3-glacier&#34;&gt;S3 Glacier&lt;/h2&gt;
&lt;p&gt;用于存放归档文件，按照访问量收费。&lt;/p&gt;
&lt;h2 id=&#34;ebs&#34;&gt;EBS&lt;/h2&gt;
&lt;p&gt;Elastic Block Store.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;EBS可以连接到EC2实例，可用区级资源，需要位于同一可用区中才能连接到EC2实例，卷不会自动扩展。&lt;/p&gt;
&lt;p&gt;EBS只能被单个EC2实例访问。&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小高达16Tb&lt;/li&gt;
&lt;li&gt;EC2实例终止后仍然存在&lt;/li&gt;
&lt;li&gt;默认情况下为固态(SSD)&lt;/li&gt;
&lt;li&gt;提供IOPS SSD和HDD选项&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;efs&#34;&gt;EFS&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/aws-efs-csi-driver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/aws-efs-csi-driver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Elastic File System 是linux的NFS服务.&lt;/p&gt;
&lt;p&gt;EFS是区域性服务，将数据存储在多个可用区中。可以被上千个EC2实例同时访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全托管的NFS文件系统&lt;/li&gt;
&lt;li&gt;为linux负载而设计&lt;/li&gt;
&lt;li&gt;支持PB级别数据&lt;/li&gt;
&lt;li&gt;可以跨多个区域存储数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EFS提供两种存储类型(StorageClass): Standard, Infrequent access.&lt;/p&gt;
&lt;h2 id=&#34;fsx&#34;&gt;FSx&lt;/h2&gt;
&lt;p&gt;FSx是windows File Server服务.&lt;/p&gt;
&lt;h2 id=&#34;storage-gateway&#34;&gt;Storage Gateway&lt;/h2&gt;
&lt;p&gt;支持三种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tape gateway&lt;/li&gt;
&lt;li&gt;Volume gateway&lt;/li&gt;
&lt;li&gt;File Gateway&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aws-backup&#34;&gt;AWS Backup&lt;/h2&gt;
&lt;h2 id=&#34;aws-edr&#34;&gt;AWS EDR&lt;/h2&gt;
&lt;p&gt;Elastic Disaster Recovery.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;snow-family&#34;&gt;Snow Family&lt;/h1&gt;
&lt;h2 id=&#34;snowcone&#34;&gt;Snowcone&lt;/h2&gt;
&lt;h2 id=&#34;snowball&#34;&gt;Snowball&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;针对large-scale 数据传输&lt;/li&gt;
&lt;li&gt;支持PB级别数据&lt;/li&gt;
&lt;li&gt;通过物理设备上传数据到S3&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;snowmobile&#34;&gt;Snowmobile&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;针对large-scale数据传输&lt;/li&gt;
&lt;li&gt;支持EB级别数据&lt;/li&gt;
&lt;li&gt;通过工作站上传数据到S3&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;transfer-family&#34;&gt;Transfer family&lt;/h1&gt;
&lt;p&gt;SFTP, FTPS, FTP.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;aws-migration-and-transfer&#34;&gt;AWS Migration and Transfer&lt;/h1&gt;
&lt;h2 id=&#34;ads&#34;&gt;ADS&lt;/h2&gt;
&lt;p&gt;Application Discovery Service.&lt;/p&gt;
&lt;h2 id=&#34;ams&#34;&gt;AMS&lt;/h2&gt;
&lt;p&gt;Application Migration Service.&lt;/p&gt;
&lt;h2 id=&#34;dms&#34;&gt;DMS&lt;/h2&gt;
&lt;p&gt;Database Migration Service.&lt;/p&gt;
&lt;p&gt;让您能够迁移关系数据库、非关系数据库和其他类型的数据存储。&lt;/p&gt;
&lt;h2 id=&#34;sct&#34;&gt;SCT&lt;/h2&gt;
&lt;p&gt;Schema Conversion Tool&lt;/p&gt;
&lt;h2 id=&#34;datasync&#34;&gt;DataSync&lt;/h2&gt;
&lt;h2 id=&#34;migration-hub&#34;&gt;Migration Hub&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>CDK</title>
        <link>https://canuxcheng.com/post/cloud_cdk/</link>
        <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cloud_cdk/</guid>
        <description>&lt;h1 id=&#34;cdk&#34;&gt;CDK&lt;/h1&gt;
&lt;p&gt;Cloud Development Kit&lt;/p&gt;
&lt;p&gt;SDK一般是和service交互的。
CDK用来和基础设施交互的。&lt;/p&gt;
&lt;h2 id=&#34;aws-cdk&#34;&gt;AWS CDK&lt;/h2&gt;
&lt;p&gt;The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/aws/aws-cdk&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aws/aws-cdk&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cdk8s&#34;&gt;CDK8S&lt;/h2&gt;
&lt;p&gt;cdk8s is an open-source software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s apps synthesize into standard Kubernetes manifests which can be applied to any Kubernetes cluster.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cdk8s-team/cdk8s&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cdk8s-team/cdk8s&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;ckdtf&#34;&gt;CKDTF&lt;/h1&gt;
&lt;p&gt;Cloud Development Kit for Terraform (CDKTF) allows you to use familiar programming languages to define cloud infrastructure and provision it through HashiCorp Terraform. This gives you access to the entire Terraform ecosystem without learning HashiCorp Configuration Language (HCL) and lets you leverage the power of your existing toolchain for testing, dependency management, etc.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.terraform.io/cdktf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.terraform.io/cdktf&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install --global cdktf-cli@latest
$ cd cdktf-demo
$ cdktf init --template=&amp;quot;go&amp;quot; --local

$ cdktf get
$ go mod tidy

$ cdktf synth
$ cdktf deploy
$ cdktf destroy
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>TypeScript</title>
        <link>https://canuxcheng.com/post/js_ts/</link>
        <pubDate>Fri, 05 Mar 2021 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_ts/</guid>
        <description>&lt;h1 id=&#34;typescript&#34;&gt;TypeScript&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/TypeScript&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/microsoft/TypeScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.typescriptlang.org/zh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.typescriptlang.org/zh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/tsdoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/microsoft/tsdoc&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tsx&#34;&gt;TSX&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;*.tsx&amp;rdquo; 是js的扩展，允许使用xml语法。&lt;/p&gt;
&lt;p&gt;typescript支持interface。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jsc&#34;&gt;jsc&lt;/h2&gt;
&lt;p&gt;将TS编译成JS, tsconfig.json是配置文件。&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>BitBake</title>
        <link>https://canuxcheng.com/post/linux_bitbake/</link>
        <pubDate>Sun, 12 Jul 2020 21:18:33 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_bitbake/</guid>
        <description>&lt;h1 id=&#34;bitbake&#34;&gt;BitBake&lt;/h1&gt;
&lt;p&gt;bitbake是类似于make的构建工具，主要用于OpenEmbedded和yocto构建linux发行版.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openembedded/bitbake&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openembedded/bitbake&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;bitbake:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bitbake python -c devshell/devpyshell
$ bitbake python -c clean/cleanall/cleanstate
$ bitbake python -c compile
$ bitbake python -c fetch/fetchall

# 查找下载地址
$ bitbake -e python | grep ^SRC_URI

# 根据文件查找包名
bitbake&amp;gt; oe-pkgdata-util find-path /usr/bin/python3

# 包名查找recipe
bitbake&amp;gt; oe-pkgdata-util lookup-recipe python3-core
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;openembedded&#34;&gt;openembedded&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openembedded/openembedded-core&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openembedded/openembedded-core&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;yoctopoky&#34;&gt;yocto(poky)&lt;/h1&gt;
&lt;p&gt;poky是一个开源的最小构建示例，内置bitbake，可直接编译.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/poky&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/poky&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;toaster&#34;&gt;toaster&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>kernel</title>
        <link>https://canuxcheng.com/post/linux_kernel/</link>
        <pubDate>Wed, 27 May 2020 22:29:00 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_kernel/</guid>
        <description>&lt;h1 id=&#34;kernel&#34;&gt;Kernel&lt;/h1&gt;
&lt;h1 id=&#34;command&#34;&gt;command&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;lsmod 查看已加载的模块    # /proc/modules
rmmod &amp;lt;name&amp;gt; 删除模块

modprobe -c 查看已编译可加载的内核模块
modprobe &amp;lt;name&amp;gt; 加载模块 # /etc/modules
modprobe -r &amp;lt;name&amp;gt; 删除模块

// modprobe 重启就没了
echo &amp;quot;ipmi_devintf&amp;quot; &amp;gt;&amp;gt; /etc/modules
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Linux Security</title>
        <link>https://canuxcheng.com/post/linux_security/</link>
        <pubDate>Sun, 24 May 2020 15:30:42 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_security/</guid>
        <description>&lt;h1 id=&#34;selinux&#34;&gt;SeLinux&lt;/h1&gt;
&lt;p&gt;Security-Enhanced Linux&lt;/p&gt;
&lt;h1 id=&#34;seccomp&#34;&gt;SecComp&lt;/h1&gt;
&lt;p&gt;Secure computing mode (seccomp) is a Linux kernel feature.&lt;/p&gt;
&lt;h1 id=&#34;apparmor&#34;&gt;AppArmor&lt;/h1&gt;
&lt;p&gt;AppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>K8S CNI</title>
        <link>https://canuxcheng.com/post/k8s_cni/</link>
        <pubDate>Thu, 26 Mar 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_cni/</guid>
        <description>&lt;h1 id=&#34;network-add-ons&#34;&gt;Network add-ons&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/containernetworking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/containernetworking&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flannel&lt;/li&gt;
&lt;li&gt;cilium&lt;/li&gt;
&lt;li&gt;calico&lt;/li&gt;
&lt;li&gt;vpc-cni (aws)&lt;/li&gt;
&lt;li&gt;kube-router&lt;/li&gt;
&lt;li&gt;weavenet&lt;/li&gt;
&lt;li&gt;antrea&lt;/li&gt;
&lt;li&gt;romana&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cilium&#34;&gt;cilium&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cilium/cilium&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cilium/cilium&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;flannel&#34;&gt;Flannel&lt;/h2&gt;
&lt;p&gt;flannel是k8s最常用的网络插件.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/coreos/flannel&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/coreos/flannel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在所有node上部署cni-plugin:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/containernetworking/plugins/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/containernetworking/plugins/releases&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /opt/cni/bin
// 下载并解压所有插件命令到该目录.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;network-addon(master上操作即可):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;veryfy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl get nodes
$ kubectl get pod --all-namespaces
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除插件:&lt;/p&gt;
&lt;p&gt;删除插件会影响已经部署的pod.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 删除flannel 
$ kubectl delete -f X.yml  
$ sudo systemctl stop kubelet docker

// 第二步，在node节点清理flannel网络留下的文件
ifconfig cni0 down
ip link delete cni0 
ifconfig flannel.1 down
ip link delete flannel.1 
rm -rf /var/lib/cni /etc/cni /run/flannel
$ sudo rm -rf /var/lib/kubelet /var/lib/etcd

// 重启kubelet
$ sudo systemctl start kubelet docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改配置:&lt;/p&gt;
&lt;p&gt;/etc/kube-flannel/net-conf.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;Network&amp;quot;: &amp;quot;10.244.0.0/16&amp;quot;,
  &amp;quot;SubnetLen&amp;quot;: 24,
  &amp;quot;SubnetMin&amp;quot;: &amp;quot;10.244.0.0&amp;quot;,
  &amp;quot;SubnetMax&amp;quot;: &amp;quot;10.244.255.0&amp;quot;,
  &amp;quot;Backend&amp;quot;: {
    &amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用kubeadm：&lt;/p&gt;
&lt;p&gt;kubeadm init必须指定flannel的Network参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要修改其它参数，同时需要修改kubeadm的配置&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>K8S CSI</title>
        <link>https://canuxcheng.com/post/k8s_csi/</link>
        <pubDate>Wed, 25 Mar 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_csi/</guid>
        <description>&lt;h1 id=&#34;csi&#34;&gt;CSI&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/container-storage-interface/spec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/container-storage-interface/spec&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rook&lt;/li&gt;
&lt;li&gt;cubefs&lt;/li&gt;
&lt;li&gt;longhorn&lt;/li&gt;
&lt;li&gt;ceph&lt;/li&gt;
&lt;li&gt;minio&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;卷volume&#34;&gt;卷Volume&lt;/h2&gt;
&lt;p&gt;和docker中的一样。&lt;/p&gt;
&lt;p&gt;volume支持的卷类型有: awsEBS, azureDisk, azureFile, gcePD, secret, configMap, emptyDir, hostPath, local, nfs等.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-ebs
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-ebs
      name: test-volume
  volumes:
  - name: test-volume
    # 此 AWS EBS 卷必须已经存在
    awsElasticBlockStore:
      volumeID: &amp;quot;&amp;lt;volume-id&amp;gt;&amp;quot;
      fsType: ext4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AWS的EBS和EFS需要安装驱动:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/aws-efs-csi-driver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/aws-efs-csi-driver&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;存储类storageclass&#34;&gt;存储类StorageClass&lt;/h2&gt;
&lt;p&gt;storageclass没有namespace.&lt;/p&gt;
&lt;p&gt;每个存储类包含provisioner, parameters和reclaimPolicy.&lt;/p&gt;
&lt;p&gt;内置provisioner的卷插件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;awsEBS&lt;/li&gt;
&lt;li&gt;azureFile&lt;/li&gt;
&lt;li&gt;azureDisk&lt;/li&gt;
&lt;li&gt;gcePD&lt;/li&gt;
&lt;li&gt;openstack cinder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有provisioner的卷类型可以使用外部插件或者自己开发.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;awsEBS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: sourcegraph
labels:
  deploy: sourcegraph
# provisioner: ebs.csi.aws.com
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2 # This configures SSDs (default).
  fsType: ext4 # (default)
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nfs:&lt;/p&gt;
&lt;p&gt;kubernetes不包含nfs驱动，需要使用外部驱动创建nfs存储类.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: example-nfs
provisioner: example.com/external-nfs
parameters:
  server: nfs-server.example.com
  path: /share
  readOnly: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;local:&lt;/p&gt;
&lt;p&gt;本地卷不支持动态制备.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;持久卷pv&#34;&gt;持久卷PV&lt;/h2&gt;
&lt;p&gt;persistentvolume没有namespace, 用来指定具体的存储资源。有静态和动态两种方式，最终需要绑定到pvc上。&lt;/p&gt;
&lt;p&gt;pv的回收策略ReclaimPolicy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Retained保留&lt;/li&gt;
&lt;li&gt;Deleted删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pv的卷绑定模式volumeBindingMode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WaitForFirstConsumer&lt;/li&gt;
&lt;li&gt;Immediate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;卷模式volumeMode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Filesystem(默认)&lt;/li&gt;
&lt;li&gt;Block&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问模式accessMode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RWO: ReadWriteOnce&lt;/li&gt;
&lt;li&gt;ROX: ReadOnlyMany&lt;/li&gt;
&lt;li&gt;RWX: ReadWriteMany&lt;/li&gt;
&lt;li&gt;RWOP: ReadWriteOncePod&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;卷的阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Avaliable&lt;/li&gt;
&lt;li&gt;Bound&lt;/li&gt;
&lt;li&gt;Released&lt;/li&gt;
&lt;li&gt;Failed&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;static-volume-provisioning&#34;&gt;static volume provisioning&lt;/h3&gt;
&lt;p&gt;静态pvc和pv的绑定通过storageClassName, accessMode和capacity来判断。&lt;/p&gt;
&lt;p&gt;pv中的capacity必须大于等于pvc。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: nas-csi-pv
  labels:
    app: demo
spec:
  storageClassName: 
  persistentVolumeReclaimPolicy: Retained/Recycled
  accessModes:
  - ReadWriteMany
  capacity:
    storage: 5Gi
  hostPath:
    path: &amp;quot;/home/path&amp;quot;
  csi:
    driver: ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dynamic-volume-provisioning&#34;&gt;dynamic volume provisioning&lt;/h3&gt;
&lt;p&gt;动态pv需要storageclass, 由StorageClass动态的创建PV, 不需要手动创建pv，只需要在pvc中指定storageclass即可.&lt;/p&gt;
&lt;p&gt;storageclass没有namespace&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: sourcegraph
labels:
  deploy: sourcegraph
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2 
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pgsql
  labels:
    deploy: sourcegraph
    sourcegraph-resource-requires: no-cluster-admin
    app.kubernetes.io/component: pgsql
spec:
  // 通过storageClassName自动给pvc创建pv
  storageClassName: sourcegraph
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
    storage: 200Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pvc&#34;&gt;PVC&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nsa-pvc
  namespace: test
labels:
  app: demo
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 5Gi 
  // 通过selector让PVC使用指定的PV。
  selector:
    app: demo
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;volumesnapshotclass&#34;&gt;VolumeSnapshotClass&lt;/h2&gt;
&lt;h2 id=&#34;volumesnapshot&#34;&gt;VolumeSnapshot&lt;/h2&gt;
&lt;p&gt;VS是对资源的请求.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: new-snapshot-test
spec:
  volumeSnapshotClassName: csi-hostpath-snapclass
  source:
    persistentVolumeClaimName: pvc-test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;volumesnapshotcontent&#34;&gt;VolumeSnapshotContent&lt;/h2&gt;
&lt;p&gt;VSC实际中资源管理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotContent
metadata:
  name: snapcontent-72d9a349-aacd-42d2-a240-d775650d2455
spec:
  deletionPolicy: Delete
  driver: hostpath.csi.k8s.io
  source:
    volumeHandle: ee0cfb94-f8d4-11e9-b2d8-0242ac110002
  volumeSnapshotClassName: csi-hostpath-snapclass
  volumeSnapshotRef:
    name: new-snapshot-test
    namespace: default
    uid: 72d9a349-aacd-42d2-a240-d775650d2455
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Kubectl</title>
        <link>https://canuxcheng.com/post/k8s_kubectl/</link>
        <pubDate>Fri, 10 Jan 2020 20:58:01 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_kubectl/</guid>
        <description>&lt;h1 id=&#34;kubectl&#34;&gt;kubectl&lt;/h1&gt;
&lt;p&gt;kubectl是kubernetes的管理工具.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/tasks/tools/#kubectl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/tasks/tools/#kubectl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cloudnativelabs/kube-shell&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cloudnativelabs/kube-shell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jonmosco/kube-ps1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jonmosco/kube-ps1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ahmetb/kubectx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ahmetb/kubectx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在master上通过kubectl命令管理集群.&lt;/p&gt;
&lt;p&gt;kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.24 版本的客户端能与 v1.23、 v1.24 和 v1.25 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。&lt;/p&gt;
&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;kubectl options # 查看所有命令可用选项

--kubeconfig
kubectl --kubeconfig=$HOME/.kube.config (default)

-n/--namespace
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;basic-command&#34;&gt;basic command&lt;/h2&gt;
&lt;p&gt;create:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过yaml或json文件创建资源
$ kubectl create -f FILENAME [options]

options:
-f/--filename

kubectl create secret tls kubernetes-dashboard-tls --key ca.key --cert ca.crt -n kubernetes-dashboard

// 输出一个资源的yaml格式.
kubectl create deployment &amp;lt;name&amp;gt; --image=&amp;lt;img-name&amp;gt; --dry-run=client --output=yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;delete:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 删除资源
$ kubectl delete (-f FILENAME | -k DICT | TYPE [(NAME|-l label|--all)]) [optiions]

options:
-f/--filename
--all  
--all-namespaces
--force

$ kubectl delete pods --all
$ kubectl delete pod &amp;lt;name&amp;gt;
// 删除指定ns下所有资源.
$ kubectl delete all --all -n {namespace}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除带有finalizers字段的对象，对象实际被更新了，没有真的被删除。可以通过patch来删除。&lt;/p&gt;
&lt;p&gt;删除带有ownerReferences字段的对象，删除父对象默认会删除所有子对象，通过&amp;ndash;cascade=false只删除父对象。&lt;/p&gt;
&lt;p&gt;expose:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建serivce:
$ kubectl expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP|SCTP] [--target-port=...] [--name=...] [--external-ip=...] [--type=type] [options]

# 创建service，并且使用NodePort
# nodeport可以使用任意节点的IP访问.
$ kubectl expose deployment hello-world --type=NodePort --name=example-service

// 获取service的yaml
kubectl expose deployment &amp;lt;deploy-name&amp;gt; --type=LoadBalancer --port=80 --dry-run=client --output=yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建pod/container(docker run):
$ kubectl run NAME --image=image [--env=&amp;quot;key=value&amp;quot;] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...] [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl set SUBCOMMAND [options]

// 更新镜像
$ kubectl set image deployment.v1.apps/&amp;lt;deploy-name&amp;gt; &amp;lt;container-name&amp;gt;=&amp;lt;image:tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取resource信息(docker ps)
$ kubectl [-n &amp;lt;namespace&amp;gt;] get [resource] [flags] [options]

options:
-A/--all-namespaces
-f/--filename
-o/--output json/yaml/json/wide/name/...
-w/--watch
--watch-only

kubectl get nodes --show-labels

kubectl get nodes/no # 获取node节点信息
kubectl get namespace/ns # 获取namespace信息
kubectl get componentstatuses/cs

kubectl get all --all-namespaces
kubectl -n kube-system get all 

kubectl get pod/pods/po 
kubectl get po -w/--watch
kubectl get po -o wide

kubectl get deployment/deployments/deploy

kubectl get service/services/svc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;explain:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看资源解析
$ kubectl explain RESOURCE [options]

kubectl explain deploy.spec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;edit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在线修改资源，直接生效.
$ kubectl edit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;advanced-commands&#34;&gt;advanced commands&lt;/h2&gt;
&lt;p&gt;apply:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;diff:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;patch&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl patch

// 删除terminating状态的resource
$ kubectl patch  persistentvolumeclaim/storage -p &#39;{&amp;quot;metadata&amp;quot;:{&amp;quot;finalizers&amp;quot;:null}}&#39; -n &amp;lt;ns&amp;gt;

$ kubectl replace

$ kubectl wait

$ kubectl kustomize
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;deploy-command&#34;&gt;deploy command&lt;/h2&gt;
&lt;p&gt;scale:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl scale
$ kubectl scale deployment &amp;lt;deploy-name&amp;gt; -n &amp;lt;ns&amp;gt; --replicas=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;autoscale:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl autoscale
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rollout:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 回滚
$ kubectl rollout

// 暂停/恢复/重启 deployment.
kubectl rollout pause/resume/restart  deploy/katib-mysql -n kubeflow
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;debugtroubleshoot&#34;&gt;debug&amp;amp;troubleshoot&lt;/h2&gt;
&lt;p&gt;describe:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// like docker inspect
$ kubectl describe (-f FILENAME | TYPE ... | TYPE/NAME) [options]

options:
-A/--all-namespaces
-f/--filename

// 查看node信息
$ kubectl describe nodes &amp;lt;name&amp;gt;

//查看pod详细信息
$ kubectl describe pods &amp;lt;name&amp;gt; 

// 获取k8s-dashboard的token
$ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;logs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# like docker logs
$ kubectl logs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER] [options]

options:
--all-containers
-f/--follow
-p/--previous

// 查看pod中指定container log
kubectl logs -f &amp;lt;pod&amp;gt; -c &amp;lt;container&amp;gt; -n &amp;lt;ns&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exec:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# like docker exec
$ kubectl exec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] [options]

options:
-c/--container
-i/--stdin
-t/--tty

$ kubectl exec -it &amp;lt;pod&amp;gt; -n &amp;lt;ns&amp;gt; -- /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;port-forward:&lt;/p&gt;
&lt;p&gt;由于已知的限制，目前的端口转发仅适用于 TCP 协议.&lt;/p&gt;
&lt;p&gt;只能通过运行转发命令的IP/FQDN访问。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl port-forward

// 转发本地端口到deploy/rs/svc/pod
$ kubectl port-forward svc/redis-service 6379:6379 -n redis

$ kubectl port-forward --address 0.0.0.0 -n kubernetes-dashboard service/kubernetes-dashboard 8080:443
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proxy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl proxy

// 通过proxy可以访问默认的clusterIP服务.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attach:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl attach
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cp:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl cp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;auth:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl auth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl debug

// debug node -- 直接进入node的shell，log在/host/var/log
kubectl debug node/&amp;lt;name&amp;gt;  -it   --image=ubuntu
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cluster-management&#34;&gt;cluster management&lt;/h2&gt;
&lt;p&gt;top:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl top

$ kubectl cluster-info

$ kubectl certificate

// 节点变成unschedulable
$ kubectl cordon

// 节点变成schedulable
$ kubectl uncordon

// 安全下线节点：Ready,SchedulingDisabled
$ kubectl drain
kubectl drain &amp;lt;node&amp;gt; --delete-emptydir-data --ignore-daemonsets

//定义污点
$ kubectl taint
kubectl taint nodes &amp;lt;node&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;:NoSchedule-
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;settings-commands&#34;&gt;Settings Commands&lt;/h2&gt;
&lt;p&gt;label&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label          Update the labels on a resource

kubectl label nodes &amp;lt;your-node-name&amp;gt; disktype=ssd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;annotate:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;annotate       Update the annotations on a resource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;completion:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;completion     Output shell completion code for the specified shell (bash or zsh)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;others&#34;&gt;others&lt;/h2&gt;
&lt;p&gt;api-resources:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// api-resources  Print the supported API resources on the server.
kubectl api-resources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;api-versions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// api-versions   Print the supported API versions on the server, in the form of &amp;quot;group/version&amp;quot;.
kubectl api-versions
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参考kubectx
config         Modify kubeconfig files.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参考krew
plugin         Provides utilities for interacting with plugins.

// 查看安装的plugin
$ kubectl plugin list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;version:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version        Print the client and server version information.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;shell-auotcompletion&#34;&gt;shell-auotcompletion&lt;/h2&gt;
&lt;p&gt;bash/zsh 自动补全工具.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;krew&#34;&gt;krew&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/krew&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/krew&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装kubectl plugin的工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下载插件列表
$ kubectl krew update

// 查找插件
$ kubectl krew search

// 安装插件
$ kubectl krew install &amp;lt;name&amp;gt;

// 升级插件
$ kubectl krew upgrade

// 卸载插件
$ kubectl krew uninstall &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kubectx&#34;&gt;kubectx&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ahmetb/kubectx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ahmetb/kubectx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在cluster和namespace之间切换的命令行工具.&lt;/p&gt;
&lt;p&gt;包括kubectx 和 kubedns&lt;/p&gt;
&lt;p&gt;通过krew安装，作为kubectl的plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl krew install ctx
$ kubectl krew install ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;circtl&#34;&gt;circtl&lt;/h1&gt;
&lt;p&gt;用于对node调试.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/cri-tools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/cri-tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nerdctl&#34;&gt;nerdctl&lt;/h2&gt;
&lt;p&gt;调试node。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/containerd/nerdctl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/containerd/nerdctl&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;telepresence&#34;&gt;telepresence&lt;/h2&gt;
&lt;p&gt;用于本地调试集群上的服务.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/telepresenceio/telepresence&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/telepresenceio/telepresence&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CI/CD</title>
        <link>https://canuxcheng.com/post/devops_cicd/</link>
        <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_cicd/</guid>
        <description>&lt;h1 id=&#34;ci&#34;&gt;CI&lt;/h1&gt;
&lt;h2 id=&#34;jenkins&#34;&gt;jenkins&lt;/h2&gt;
&lt;h2 id=&#34;gitlab&#34;&gt;gitlab&lt;/h2&gt;
&lt;h2 id=&#34;github-actions&#34;&gt;github actions&lt;/h2&gt;
&lt;h2 id=&#34;cloudbees&#34;&gt;cloudbees&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cd&#34;&gt;CD&lt;/h1&gt;
&lt;h2 id=&#34;argo-cd&#34;&gt;argo-cd&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/argoproj/argo-cd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/argoproj/argo-cd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;flux-cd&#34;&gt;flux-cd&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/fluxcd/flux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/fluxcd/flux&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Contribution</title>
        <link>https://canuxcheng.com/post/k8s_oss/</link>
        <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_oss/</guid>
        <description>&lt;h1 id=&#34;kubernetes-contribution&#34;&gt;Kubernetes Contribution&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建google账号&#34;&gt;创建google账号&lt;/h2&gt;
&lt;p&gt;推荐申请一个google邮箱。&lt;/p&gt;
&lt;p&gt;在开发机配置git&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.email name@gmail.com   
$ git config user.email name@gmail.com            
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;签cla并阅读coc&#34;&gt;签CLA并阅读CoC&lt;/h2&gt;
&lt;p&gt;个人开发者需要签署CLA, 选择individual contributors并用github账号登陆，然后去邮箱授权；之后重新进入，再去邮箱签字。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://identity.linuxfoundation.org/projects/cncf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://identity.linuxfoundation.org/projects/cncf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;读一下CoC和CV&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/community/blob/master/values.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/community/blob/master/values.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置开发环境&#34;&gt;配置开发环境&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以在docker里面编译，也可以直接在操作系统上编译。&lt;/p&gt;
&lt;p&gt;在docker里面编译&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;build/run.sh make 只编译linux平台
build/run.sh make cross 编译所有平台
build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64 编译指定平台的指定组件

build/run.sh make test 单元测试
build/run.sh make test-integration 集成测试
build/run.sh make test-cmd  命令行测试

build/copy-output.sh 将编译的binary从_output/dockerized/bin拷贝到本地

build/make-clean.sh 清空_output

build.shell.sh 交互模式进入编译的container

build/release.sh 编译，测试，打包，kubernetes.tar.gz
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在操作系统上编译&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install build-essential
// apt: docker, rsync, jq, go, 
// python: pyyaml,

// 安装etcd用于集成测试
./hack/install-etcd.sh
export PATH=&amp;quot;$GOPATH/src/k8s.io/kubernetes/third_party/etcd:${PATH}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译和测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make all  全部编译
make WHAT=cmd/kubectl  指定编译组件
make cross 编译所有平台
make cross KUBE_BUILD_PLATFORMS=windows/amd64 编译指定平台

make verify  presubmission verification测试
make test  单元测试
make test-integration  集成测试依赖etcd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/test-infra&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/test-infra&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;了解社区&#34;&gt;了解社区&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/community&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为项目组件很多，所以通过特别兴趣小组来分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIG: Special Interest Groups&lt;/li&gt;
&lt;li&gt;WG: Working Group&lt;/li&gt;
&lt;li&gt;UG: User Group&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KEP: Kubernetes Enhancement Proposal&lt;/p&gt;
&lt;p&gt;对于功能和API的修改需要在KEP提交议案讨论。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/enhancements&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/enhancements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://slack.k8s.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://slack.k8s.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://discuss.kubernetes.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://discuss.kubernetes.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;选取修改的cl&#34;&gt;选取修改的CL&lt;/h2&gt;
&lt;p&gt;从github选取一个Issue进行修改。&lt;/p&gt;
&lt;p&gt;推荐新手从“good first issue&amp;quot; 开始。&lt;/p&gt;
&lt;p&gt;也可以通过sig或者kind标签过滤。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen&amp;#43;is%3Aissue&amp;#43;label%3A%22good&amp;#43;first&amp;#43;issue%22&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;提交patch&#34;&gt;提交patch&lt;/h2&gt;
&lt;p&gt;github用户直接fork到自己账号，clone下来即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/kubernetes/kubernetes.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建开发分支并修改代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b canux_dev
...
git add -A
git commit -m &amp;quot;...&amp;quot;
git push ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;code-review&#34;&gt;code review&lt;/h2&gt;
&lt;p&gt;提交之后trybots会自动构建，可以通过build dashboard查看各个平台build结果:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://build.golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://build.golang.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看自己的patch的review情况：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go-review.googlesource.com/dashboard/self&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;显示随时间变化的历史测试结果：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://testgrid.k8s.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://testgrid.k8s.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;显示pow中的自动化测试情况：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://prow.k8s.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://prow.k8s.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看所有PR:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gubernator.k8s.io/pr/all&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gubernator.k8s.io/pr/all&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把相似的失败聚合在一起以便排除故障:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://storage.googleapis.com/k8s-triage/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://storage.googleapis.com/k8s-triage/index.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>K8S API</title>
        <link>https://canuxcheng.com/post/k8s_api/</link>
        <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_api/</guid>
        <description>&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;
&lt;p&gt;api-server统一的操作入口.&lt;/p&gt;
&lt;p&gt;kubectl, UI, 等都是通过api-server操作资源.&lt;/p&gt;
&lt;p&gt;payload可以是json，也可以是yaml.&lt;/p&gt;
&lt;p&gt;yaml文件中#表示行注释。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;yaml&#34;&gt;yaml&lt;/h1&gt;
&lt;p&gt;部署k8s可以通过yaml文件来配置资源.&lt;/p&gt;
&lt;p&gt;资源对象组成部分:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: 
kind: 
metadata: 元数据
spec: 期望的状态
status: 观测到的状态
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看apiVersion:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl api-versions
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看Kind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl api-resources

# In a namespace
kubectl api-resources --namespaced=true

# Not in a namespace
kubectl api-resources --namespaced=false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;metadata:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:

  name:
  namespace:

  labels/标签: 用户筛选资源，唯一的资源组合方法, 可以使用selector来查询.

  annotations/注解: 存储资源的非标识性信息，扩展资源的spec/status.

  ownerReference/关系: 方便反向查找创建资源的对象，方便进行级联删除。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;spec:&lt;/p&gt;
&lt;p&gt;status:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;调度抢占驱逐&#34;&gt;调度，抢占，驱逐&lt;/h1&gt;
&lt;p&gt;taints: 污点，使节点排斥特定pod。应用于node。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;taints:
- effect: NoSchedule
  key: kubernetes.io/arch
  value: arm64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tolerations: 容忍度，使pod被吸引到特定节点。应用于pod。
这个只能让pod能部署到加了污点的node，pod也能部署到其它没有加污点的node。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tolerations:
- key: &amp;quot;key1&amp;quot;
  operator: &amp;quot;Equal&amp;quot;/&amp;quot;Exists&amp;quot;
  value: &amp;quot;value1&amp;quot;
  effect: &amp;quot;NoSchedule&amp;quot;/&amp;quot;NoExecute&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;affinity: 亲和力，affinity可以通过label指定pod部署到node。
但是不能保证其它pod不部署到这个node。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/arch
            operator: In
            values:
            - arm64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nodeSelector: 节点选择，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; nodeSelector:
   kubernetes.io/arch: arm64
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pod&#34;&gt;Pod&lt;/h1&gt;
&lt;p&gt;pod模板， 通常使用deployment, job和statefulset, daemonset来管理pod.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test
  namespace: test
  labels:
      app: test
spec:

  //// containers
  os:  // 操作系统模板
    name:

  imagePullSecrets:  // 私有镜像授权
  - name: my-harbor

  initContainers: //  initcontainer模板
  - name: init
    image: my-image
    command: ...
    args: ...

  containers: // container 模板
  - name: test
    // image
    image: image
    imagePullPolicy: Always/IfNotPresent/Never

    // entrypoint
    command:
    args:
    workingDir:

    // port
    ports:

    // resources
    resources:
      requests:  // 申明需要的资源
        memory: &amp;quot;64Mi&amp;quot;  // byte
        cpu: &amp;quot;250m&amp;quot;     // millicore (1 core = 1000 millicore)
        ephemeral-storage: &amp;quot;2Gi&amp;quot; // byte
      limits:
        memory: &amp;quot;128Mi&amp;quot;
        cpu: &amp;quot;500m&amp;quot;
        ephemeral-storage: &amp;quot;4Gi&amp;quot;

    // environment variables, 针对单个键值对.
    env:
    - name: key
      value: value
    - name: key
      valueFrom: // 将cm-name中的值cm-key传给key
        configMapKeyRef:
          name: cm-name
          key: cm-key
          optional:
    - name: key
      valueFrom: // 挂载secret
        secretKeyRef:
          key:
          name:
          optional:
        fieldRef:
        resourceFieldRef:

    // 环境变量，针对文件中所有键值对.
    envFrom:
    - configMapRef    // 将my-cm中的所有键值对变成环境变量.
        name: my-cm
        optional:
    - secretRef
        name: 
        optional:
     
    // volumeMounts (去Volume找对应资源)
    // 如果没有subpath，整个目录会被覆盖，目录下只有secret/configmap挂载的文件.
    volumeMounts: // secret以文件形式挂载到/etc/foo
    - name: my-secret
      mountPath: &amp;quot;/etc/foo&amp;quot; // 挂载之后覆盖整个目录
      readOnly: true
    - name: my-configmap
      mountPath: &amp;quot;/etc/bar&amp;quot; // 挂载之后覆盖整个目录
      // 如果有subpath, secret/configmap里的data里的文件名需要与subpath和mountpath指定的文件名一致.
    - name: config
      mountPath: /etc/app/app.conf  // 是文件，文件名要和subpath一致。
      subPath: app.conf // 挂载之后只覆盖目录中同名文件,其它文件不影响.

    // lifecycle
    livenessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      httpGet:
        path: /admin
        port: django
        # httpHeaders:
        # - name: Authorization
          # value: Basic $LDAP_ACCOUNT
    readinessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      httpGet:
        path: /admin
        port: django
        # httpHeaders:
        # - name: Authorization
          # value: Basic $LDAP_ACCOUNT

    // securityContext
    securityContext:

    // debugging
    stdin: false
    stdinOnce: false
    tty: false

  //// security context
  securityContext: // pod级别security context定义
    runAsuser: 1000
    runAsGroup: 3000
    fsGroup: 2000

  //// volumes
  volumes:
  - name: my-secret // 指定要挂载的secret
    secret:
      secretName: mysecret
  - name: my-configmap
    configMap:
      name: myconfigmap

  //// lifecycle
  restartPolicy:

  //// scheduling
  nodeName:
  nodeSelector: // 将pod部署到指定node
    key: value
  affinity:
  tolerations:

  //// others
  hostname:
  hostNetwork:
  serviceAccountName:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pod中的container共享存储(pod volume):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
Kind: Pod
medadata:
spec:

  # 两种pod volume
  volumes:
  # emptyDir： pod删除之后该目录也会被删除
  - name: cache-volume
    emptyDir: {}
  # hostPath: pod删除之后该目录还在host上. 
  - name: hostpath-volume
    hostPath:
      path: /path/on/host

  containers:
  - name: container1
    image: test
    volumeMounts:
    - name: cache-volume
      mountpath: /path/on/container
      # subPath会在emptyDir或hostPath目录下创建子目录
      subPath: cache1
  - name: container2
    image: test
    volumeMounts:
    - name: hostpath-volume
      mountpath: /path/on/container
      readOnly: true
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;deployment&#34;&gt;Deployment&lt;/h1&gt;
&lt;p&gt;用于部署无状态服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deploy
  namespace: my-ns
  lables:
    app: my-app
spec:
  replicas: 3
  # 选择器
  selector: 
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: image:latest
        imagePullPolicy: IfNotPresent/Always
        ports:
        - containerPort: 443
        volumeMounts:
        - name: my-hostpath
          mountPath: /path/on/cpod
        - name: my-pvc
          mountPath: /data 
      volumes:
      - name: my-hostpath
        hostPath: 
          path: /path/on/host
      - name: my-pvc
        persistentVolumeClaim:
          claimName: nfs-pvc
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;daemonset&#34;&gt;DaemonSet&lt;/h1&gt;
&lt;p&gt;每个node上部署一个pod，用于部署agent。&lt;/p&gt;
&lt;p&gt;DaemonSet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: my-ds
  namespace: my-ns
  labels:
    k8s-app: my-app
  spec:
    selector:
      matchLabels:
        name: my-app
    template:
      metadata:
        labels:
          name: my-app
      spec:
        containers:
        - name: my-container
          image: my-img
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;statefulset&#34;&gt;StatefulSet&lt;/h1&gt;
&lt;p&gt;用于部署有状态服务。&lt;/p&gt;
&lt;p&gt;StatefulSet 中的 Pod 拥有一个唯一的顺序索引和稳定的网络身份标识。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
  namespace: test
  labels:
    k8s-app: my-app
spec:
  serviceName: &amp;quot;nginx&amp;quot;
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ &amp;quot;ReadWriteOnce&amp;quot; ]
      resources:
        requests:
          storage: 1Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;job&#34;&gt;Job&lt;/h1&gt;
&lt;p&gt;Job&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appVersion: batch/v1
kind: Job
metadata:
  name: my-job
spec:
  # 代表本pod队列执行此次数(被执行8次)
  completions: 8
  # 代表并行执行个数(同时有两个在运行)
  parallelism: 2
  backoffLimit: 4
  template:
    spec:
      containers:
      - name: my-job
        image: my-image
        conmand: [&#39;test&#39;]
      restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cronjob&#34;&gt;CronJob&lt;/h1&gt;
&lt;p&gt;CronJob&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: batch/v1
kind: CronJob
metadata:
  name: my-cj
spec:
  schedule: &amp;quot;* * * * *&amp;quot;
  startingDeadlineSeconds: None(default)/10
  concurrencyPolicy: Allow(default)/Forbid/Replace
  suspend: false(default)/true
  successfulJobsHistoryLimit: 3(default)
  failedJobsHistoryLimit: 1(default)
  jobTemplate:
    spec:
      template:
        metadata:
          annotations: ...
          labels: ...
        spec:
          nodeSelector:
            ...
          imagePullSecrets:
            ...
          restartPolicy: OnFailure
          containers:
          - name: image
            image: image
            args:
            - /bin/sh
            - -c
            - date
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;configmap&#34;&gt;ConfigMap&lt;/h1&gt;
&lt;p&gt;configmap只能在当前namespace使用.&lt;/p&gt;
&lt;p&gt;configmap的配置在pod中无法修改绑定的文件.&lt;/p&gt;
&lt;p&gt;data里面的文件名就是挂载之后的文件名。&lt;/p&gt;
&lt;p&gt;ConfigMap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app: flanel
    tier: node
  name: flannel-cfg
  namespace: kube-system
data:
  cni-conf.json: |
    {
      &amp;quot;name&amp;quot;: &amp;quot;n1&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建配置文件的configmap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl -n app create cm my-conf --from-file ./config.ini -o yaml &amp;gt; myconf-configmap.yaml
$ kubectl -n influxdata create cm dashboard-docker --from-file Docker.json -o yaml &amp;gt; grafana-dashboard-docker-configmap.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;secret&#34;&gt;Secret&lt;/h1&gt;
&lt;p&gt;secret只能在当前namespace使用.&lt;/p&gt;
&lt;p&gt;data里的文件名就是挂载之后的文件名。&lt;/p&gt;
&lt;p&gt;Opaque是用户自定义格式&lt;/p&gt;
&lt;p&gt;generic secret&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret generic empty-secret

apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: mysecret
  namespace: kube-system
data:
  username: name 
  password: pw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建tls secret账号:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kubernetes-dashboard create secret tls \
kubernetes-dashboard-tls --key ca.key --cert ca.crt 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型为 kubernetes.io/tls 的 Secret 中包含密钥和证书的 DER 数据，以 Base64 格式编码。 如果你熟悉私钥和证书的 PEM 格式，base64 与该格式相同，只是你需要略过 PEM 数据中所包含的第一行和最后一行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Secret
metadata:
  name: secret-tls
type: kubernetes.io/tls
data:
  tls.crt: |
    MIIC2DCCAcCgAwIBAgIBATANBgkqh ...    
  tls.key: |
    MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建docker secret:&lt;/p&gt;
&lt;p&gt;kubernetes.io/dockercfg	~/.dockercfg 文件的序列化形式&lt;/p&gt;
&lt;p&gt;kubernetes.io/dockerconfigjson	~/.docker/config.json 文件的序列化形式&lt;/p&gt;
&lt;p&gt;给一个private registry创建secret:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl -n ns create secret docker-registry &amp;lt;name&amp;gt; \
--docker-server=https://harbor.domain.com --docker-username=user --docker-password=pw --docker-email=canuxcheng@gmail.com 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据本地的文件创建secret（如果需要多个registry，可以先在本地登陆）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl -n ns create secret generic regcred \
--from-file=.dockerconfigjson=$HOME/.docker/config.json \
--type=kubernetes.io/dockerconfigjson

apiVersion: v1
kind: Secret
metadata:
  name: artifactory-cred
  namespace: ...
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: ewoJImF1d......
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;service&#34;&gt;Service&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: grafana-service
  namespace: influxdata
spec:
  type: NodePort
  ports:
  - name: https
    port: 3000 // 集群内部访问的port.
    targetPort: 3000 // pod指定的port.
    nodePort: 32000 // 集群外部访问内部service的port.
  selector:   // 匹配资源的metadata.labels
    app: grafana
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;externalname-service&#34;&gt;ExternalName Service&lt;/h2&gt;
&lt;p&gt;ExternalName Service 是 Service 的特例，它没有选择算符，但是使用 DNS 名称, 将服务映射到 DNS 名称，而不是selector.&lt;/p&gt;
&lt;p&gt;访问其它namespace的service.&lt;/p&gt;
&lt;p&gt;当查找主机 my-service.my-ns.svc.cluster.local 时，集群 DNS 服务返回 CNAME 记录， 其值为 out-service.out-ns.svc.cluster.local。
访问 my-service 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: my-ns
spec:
  type: ExternalName
  externalName: out-service.out-ns.svc.cluster.local // 指向其它namespace的service.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;endpoint&#34;&gt;Endpoint&lt;/h2&gt;
&lt;p&gt;下面场景可以使用Endpoint.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。&lt;/li&gt;
&lt;li&gt;希望服务指向另一个 命名空间 中或其它集群中的服务。&lt;/li&gt;
&lt;li&gt;您正在将工作负载迁移到 Kubernetes。 在评估该方法时，您仅在 Kubernetes 中运行一部分后端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先创建service:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: influxdata
spec:
  ports:
    - protocol: TCP
      port: 3306
      targetPort: 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再创建endpoint：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Endpoints
metadata:
  name: mysql-service
  namespace: influxdata
subsets:
  - addresses:
      - ip: 10.103.X.X // 指向外部服务的IP
    ports:
      - port: 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hpc&#34;&gt;HPC&lt;/h1&gt;
&lt;p&gt;Horizontal Pod Autoscaler&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: 
  labels: 
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: d-name
  minReplicas: 2
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        targetAverageUtilization: 80
    - type: Resource
      resource:
        name: memory
        targetAverageUtilization: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;authentication&#34;&gt;Authentication&lt;/h1&gt;
&lt;p&gt;默认的ClusterRole和ClusterRoleBinding大部分是system:开头。&lt;/p&gt;
&lt;h2 id=&#34;serviceaccont&#34;&gt;ServiceAccont&lt;/h2&gt;
&lt;p&gt;服务账户是在具体名字空间的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  name: default
  namespace: default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.22之前k8s会自动给SA创建token.&lt;/p&gt;
&lt;p&gt;1.24之后使用TokenRequest获取有时间限制的token。&lt;/p&gt;
&lt;p&gt;创建持久化token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
    kubernetes.io/service-account.name: myserviceaccount
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;role&#34;&gt;Role&lt;/h2&gt;
&lt;p&gt;通过role来给指定ns内的资源授权.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [&amp;quot;&amp;quot;] # &amp;quot;&amp;quot; 标明 core API 组
  resources: [&amp;quot;pods&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;list&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rolebinding&#34;&gt;RoleBinding&lt;/h2&gt;
&lt;p&gt;将role或clusterrole权限赋予具体的角色.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
# 此角色绑定允许 &amp;quot;jane&amp;quot; 读取 &amp;quot;default&amp;quot; 名字空间中的 Pods
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects:
# 你可以指定不止一个“subject（主体）”
- kind: User
  name: jane # &amp;quot;name&amp;quot; 是区分大小写的
  apiGroup: rbac.authorization.k8s.io
roleRef:
  # &amp;quot;roleRef&amp;quot; 指定与某 Role 或 ClusterRole 的绑定关系
  kind: Role # 此字段必须是 Role 或 ClusterRole
  name: pod-reader     # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;clusterrole&#34;&gt;ClusterRole&lt;/h2&gt;
&lt;p&gt;clusterrole给整个集群授权.不需要namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # &amp;quot;namespace&amp;quot; 被忽略，因为 ClusterRoles 不受名字空间限制
  name: secret-reader
rules:
- apiGroups: [&amp;quot;&amp;quot;]
  # 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &amp;quot;secrets&amp;quot;
  resources: [&amp;quot;secrets&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;list&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;clusterrolebinding&#34;&gt;ClusterRoleBinding&lt;/h2&gt;
&lt;p&gt;跨集群授权（也就是要访问不同ns的资源).不需要namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
# 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager # &#39;name&#39; 是区分大小写的
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Operator</title>
        <link>https://canuxcheng.com/post/k8s_operator/</link>
        <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_operator/</guid>
        <description>&lt;h1 id=&#34;operator&#34;&gt;Operator&lt;/h1&gt;
&lt;p&gt;TPR(Third Party Resource) 在k8s 1.7 被集成，并命名为CRD(Custom Resource Definition).&lt;/p&gt;
&lt;p&gt;通过CRD，K8S可以动态的添加和管理资源，controller跟踪这些资源。&lt;/p&gt;
&lt;p&gt;CRD+custom Controller = decalartive API(声明式API),一般分为通用性controller和operator.&lt;/p&gt;
&lt;p&gt;通用型controller一般用于平台需求，operator一般用于部署特定应用.&lt;/p&gt;
&lt;p&gt;用于开发operator的工具有kubebuilder和operator-sdk, 他们都是基于controller-runtime开发.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/operator-framework/awesome-operators&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/operator-framework/awesome-operators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://operatorhub.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://operatorhub.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发示例:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/sample-controller&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/sample-controller&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;operator的build三种模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go&lt;/li&gt;
&lt;li&gt;ansible&lt;/li&gt;
&lt;li&gt;helm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;operator的run三种模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在集群外部本地运行（开发测试).&lt;/li&gt;
&lt;li&gt;作为deployment在集群内部运行.&lt;/li&gt;
&lt;li&gt;通过OLM部署.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;operator-sdk&#34;&gt;operator-sdk&lt;/h1&gt;
&lt;p&gt;redhat的operator-sdk可以方便的开发opeartor.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/operator-framework/operator-sdk&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/operator-framework/operator-sdk&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://sdk.operatorframework.io/docs/installation/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sdk.operatorframework.io/docs/installation/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;kubebuilder&#34;&gt;kubebuilder&lt;/h1&gt;
&lt;p&gt;sig维护的kubebuilder也能方便的开发operator.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/kubebuilder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/kubebuilder&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Service Discovery</title>
        <link>https://canuxcheng.com/post/k8s_servicediscovery/</link>
        <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_servicediscovery/</guid>
        <description>&lt;h1 id=&#34;coordination--service-discovery&#34;&gt;Coordination &amp;amp; Service Discovery&lt;/h1&gt;
&lt;p&gt;微服务的服务注册和服务发现.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coredns&lt;/li&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;zookeeper&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;etcd&#34;&gt;Etcd&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/etcd-io/etcd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/etcd-io/etcd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似的有consul和zoomkeeper.&lt;/p&gt;
&lt;h3 id=&#34;etcdctl&#34;&gt;etcdctl&lt;/h3&gt;
&lt;p&gt;使用证书访问:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ etcdctl \
--cacert=/etc/kubernetes/pki/etcd/ca.crt \
--cert=/etc/kubernetes/pki/etcd/server.crt  \
--key=/etc/kubernetes/pki/etcd/server.key \
--insecure-skip-tls-verify=true \
&amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ etcdctl get / --prefix --keys-only
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;zookeeper&#34;&gt;zookeeper&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Compose</title>
        <link>https://canuxcheng.com/post/cncf_compose/</link>
        <pubDate>Sat, 04 Jan 2020 21:53:40 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_compose/</guid>
        <description>&lt;h1 id=&#34;docker-compose&#34;&gt;docker-compose&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/compose&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker/compose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过一个yaml文件来管理容器中的服务，包括网络和存储。&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://docs.docker.com/compose/install/
$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;docker-compose命令&#34;&gt;docker-compose命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;docker-compose [-f &amp;lt;arg&amp;gt;...] [options] [COMMAND] [ARGS...]
-f/--file
-p/--project-name # 默认目录名
-H/--host

# 拉取compose文件中指定的镜像
$ docker-compose -f service.yml pull

# 根据docker-compose.yml把stack打包成一个Distributed Application Bundles文件.
$ docker-compose bundle -o &amp;lt;project name&amp;gt;.dab

$ docker-compose start [servoce...]
$ docker-compose stop [service...]
$ docker-compose restart [service...]
$ docker-compose up -d [service...]
$ docker-compose down -v

$ docker-compose logs -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;docker-composeyml&#34;&gt;docker-compose.yml&lt;/h1&gt;
&lt;p&gt;compose中的变量：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;x-&amp;ldquo;开头的会被compose忽略，但是会被yaml解析.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x-var-name: &amp;amp;default-label
  key1: val1
  key2: val2
  
services:
  mysql:
    &amp;lt;&amp;lt;: *default-label
    image: mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;compose文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &amp;quot;3.6&amp;quot;
services:
  mongo:
    image: mongo:latest
    hostname: hostname
    init
    dns
    dns_search
    expose
    extra_hosts

    healthcheck:
      test: curl -f https://host/ping || exit 1
      test: wget --no-verbose --tries=1 --spider https://host/ping || exit 1
      interval:
      timeout:
      retries:
      stat_period:

    stop_grrace_period
    isolation
    pid
    profiles
    stop_signal
    labels:
      com.example.key: value

    // start: 下列选项不能用于swarm stack部署.
    sysctls(19.03+)
    privileged: true
    depends_on:
      - service-name
    build
    cgroup_parent
    container_name
    devices:
      - /dev/vboxdrv:/dev/vboxdrv
    tmpfs
    external_links
    links
    network_mode: bridge/host/none
    restart: no(default)
    security_opt
    userns_mode
    ulimits
    cap_add
    cap_drop
    // end

    networks:
    - mynetwork
    // 只有自定义网络可以指定静态IP
    networks:
      mynetwork:
        ipv4_address: 172.19.0.100

    volumes: // short syntax
    - /container/dir // 自动创建volume
    - myvolume:/container/dir 
    - /host/dir:/container/dir
    volumes: // long syntax
    - type: valume/bind/tmpfs
      source: 
      target:
      read_only:
      bind:
      volume:
      tmpfs:
      consistency:
    volumes:
    - &amp;quot;/path/to/file:/path/to/file 挂载文件
    
    configs:
    - my-conf
    configs:
    - source: config-name
      target: file-name
     
    secrets:
    - my-sec
    secrets:
    - source: secret-name
      target: file-name in /run/secrets/
    
    logging:
      driver: syslog
      options:
        syslog-address: &amp;quot;tcp://192.168.0.42:123&amp;quot;

    ports:  // long syntax
    - target: 80
      published: 8080
      mode: host
      protocol: tcp/udp
    ports: // short syntax
      - 80  // host上的port没有指定就是一个随机的port
      - 80:80
      - 1234:1234/udp

    // 设置环境变量
    environment:
      RABBITMQ_DEFAULT_USER: sandbox
      RABBITMQ_DEFAULT_PASS: password
    environment:
      - RABBITMQ_DEFAULT_USER=sandbox
      - RABBITMQ_DEFAULT_PASS=password
      - TZ=UTC   // 设置时区
    &amp;lt;https://docs.docker.com/compose/compose-file/#env_file&amp;gt;
    # When you set the same environment variable in multiple files, 
    # here’s the priority used by Compose to choose which value to use:
    # 1. Compose file (environment)
    # 2. Shell environment variables(export key=value)
    # 3. Environment file (env_file)
    # 4. Dockerfile
    # 5. Variable is not defined
    env_file:

    entrypoint:

    command: [&amp;quot;./wait-for-it.sh&amp;quot;, &amp;quot;db:5432&amp;quot;, &amp;quot;--&amp;quot;, &amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]

    // 块结构，和上面的[]等效.
    command: 
    - &amp;quot;./wait-for-it.sh&amp;quot;
    - &amp;quot;:b:5432&amp;quot;
    - &amp;quot;--&amp;quot;
    - &amp;quot;python&amp;quot;
    - &amp;quot;app.py&amp;quot;

    // 解析为: &amp;quot;line1 line2\n&amp;quot;,  会自动加换行符.
    command: &amp;gt;
    line1
    line2

    // 解析为: &amp;quot;line1 line2&amp;quot;, 没有换行符.
    command: &amp;gt;-
    line1
    line2

    // start:  下面三个deploy下面的字段，也能用于非swarm模式.
    // 在compose v3 中针对非swarm模式的container做资源限制等操作.
    // --compatibility If set, Compose will attempt to convert keys in v3 files to their non-Swarm equivalent
    $ docker-compose --compatibility up -d
    // --compatibility 支持下面三种key:
    replicas:
    restart_policy:
      condition: any(default)
      max_attempts:
    resources:
      limits:
        cpus: &#39;0.5&#39;
        memory: 1G
      reservations:
        cpus: &#39;0.25&#39;
        memory: 20M


// start: 定义config/secret/volume/netework资源
configs:
  c-name:
    // 根据文件创建
    file: ./httpd.conf
    // 使用已经创建好的
    external: true

secrets:
  s-name:
    // 根据文件创建
    file: ./server.cert
    // 使用已经创建好的
    external: true

volumes:
  data-volume:

// 以定义好的volume
volumes:
  data:
    external: true

// (推荐)使用已经创建好的网络
// 通过命令行或者api 创建网络
networks:
  mynetwork:
    external: true
    name: lan0 // 通过docker network ls 查看名字

// 创建bridge网络
// 会在网络名字自动加namespace
networks:
  mynetwork:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: lan0
    ipam:
      driver: default
      config:
        - subnet: 192.168.1.0/24

// 创建overlay网络
// 会在网络名字自动加namespace
networks:
  ol0:
    driver: overlay
    attachable: true
    driver_opts:
      com.docker.network.bridge.name: ol0
    ipam:
      driver: default
      config:
      - subnet: 172.12.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;compose文件中用到的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.Service.ID Service ID 
.Service.Name Service name 
.Service.Labels Service labels 
.Node.ID Node ID 
.Node.Hostname Node Hostname 
.Task.ID Task ID 
.Task.Name Task name 
.Task.Slot Task slot 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yaml变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: &amp;amp;varhash    value
key1: *varhash

# 定义变量
list: 
  &amp;amp;varlist
  key1: value1
  key2: value2
# 将list的元素赋值给list1
list1: 
  &amp;lt;&amp;lt;: *varlist   
  key3: value2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;kompose&#34;&gt;Kompose&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kompose&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kompose&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -L https://github.com/kubernetes/kompose/releases/download/v1.19.0/kompose-linux-amd64 -o kompose

$ chmod +x kompose
$ sudo mv ./kompose /usr/local/bin/kompose
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>API Access Control</title>
        <link>https://canuxcheng.com/post/k8s_accesscontrol/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_accesscontrol/</guid>
        <description>&lt;h1 id=&#34;api-access-control&#34;&gt;API Access Control&lt;/h1&gt;
&lt;h2 id=&#34;admission-controllers&#34;&gt;Admission Controllers&lt;/h2&gt;
&lt;h3 id=&#34;mutatingadmissionwebhook&#34;&gt;MutatingAdmissionWebhook&lt;/h3&gt;
&lt;h3 id=&#34;validatingadmissionwebhook&#34;&gt;ValidatingAdmissionWebhook&lt;/h3&gt;
&lt;h3 id=&#34;validatingwebhookconfiguration&#34;&gt;ValidatingWebhookConfiguration&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  annotations:
    meta.helm.sh/release-name: ingress-nginx-internal
    meta.helm.sh/release-namespace: ingress-nginx
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx-internal
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.9.1
    helm.sh/chart: ingress-nginx-4.8.1
  name: ingress-nginx-internal-admission
webhooks:
- admissionReviewVersions:
  - v1
  clientConfig:
    caBundle: 
    service:
      name: ingress-nginx-internal-controller-admission
      namespace: ingress-nginx
      path: /networking/v1/ingresses
      port: 443
  failurePolicy: Fail
  matchPolicy: Equivalent
  name: validate.nginx.ingress.kubernetes.io
  namespaceSelector: {}
  objectSelector: {}
  rules:
  - apiGroups:
    - networking.k8s.io
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - ingresses
    scope: &#39;*&#39;
  sideEffects: None
  timeoutSeconds: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mutatingwebhookconfiguration&#34;&gt;MutatingWebhookConfiguration&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  annotations:
    meta.helm.sh/release-name: vault-secrets-webhook
    meta.helm.sh/release-namespace: vault-secrets-webhook
  labels:
    app.kubernetes.io/managed-by: Helm
  name: vault-secrets-webhook
webhooks:
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /pods
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: pods.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - &#39;*&#39;
    apiVersions:
    - &#39;*&#39;
    operations:
    - CREATE
    resources:
    - pods
    scope: &#39;*&#39;
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /secrets
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: secrets.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: owner
      operator: NotIn
      values:
      - helm
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - &#39;*&#39;
    apiVersions:
    - &#39;*&#39;
    operations:
    - CREATE
    - UPDATE
    resources:
    - secrets
    scope: &#39;*&#39;
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /configmaps
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: configmaps.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: owner
      operator: NotIn
      values:
      - helm
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - &#39;*&#39;
    apiVersions:
    - &#39;*&#39;
    operations:
    - CREATE
    - UPDATE
    resources:
    - configmaps
    scope: &#39;*&#39;
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Automation &amp; Configuration</title>
        <link>https://canuxcheng.com/post/cncf_platform/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_platform/</guid>
        <description>&lt;h1 id=&#34;automation--configuration&#34;&gt;Automation &amp;amp; Configuration&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Cloud Custodian&lt;/li&gt;
&lt;li&gt;kubeedge&lt;/li&gt;
&lt;li&gt;pulumi&lt;/li&gt;
&lt;li&gt;terraform&lt;/li&gt;
&lt;li&gt;opentofu&lt;/li&gt;
&lt;li&gt;kratix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;platform orchestration.&lt;/p&gt;
&lt;h2 id=&#34;kratix&#34;&gt;kratix&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Dashboard</title>
        <link>https://canuxcheng.com/post/k8s_dashboard/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_dashboard/</guid>
        <description>&lt;h1 id=&#34;dashboard-add-ons&#34;&gt;dashboard add-ons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;kubernetes-dashboard&lt;/li&gt;
&lt;li&gt;lens&lt;/li&gt;
&lt;li&gt;octant&lt;/li&gt;
&lt;li&gt;weave scope&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;kubernetes-dashboard&#34;&gt;kubernetes-dashboard&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/dashboard&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/dashboard&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 部署dashboard
$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml

// check
$ kubectl -n kubernetes-dashboard get pods --watch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 删除已安装的dashboard
$ kubectl delete ns kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dashboard-arguments&#34;&gt;dashboard arguments&lt;/h3&gt;
&lt;p&gt;使用basic auth:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--enable-skip-login
--enable-insecure-login
--system-banner=&amp;quot;Welcome to Kubernetes&amp;quot;
--authentication-mode=&amp;quot;basic&amp;quot; // 默认是 token 登陆.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;access-control&#34;&gt;access control&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kubeconfig&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;authorization header&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;token&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;basic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;username/password login&lt;/p&gt;
&lt;h3 id=&#34;access-dashboard&#34;&gt;access dashboard&lt;/h3&gt;
&lt;p&gt;本机访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl proxy
#&amp;gt; http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;远程访问&lt;/p&gt;
&lt;p&gt;port-forward:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 --address 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nodePort:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  type: NodePort
  ports:
    - port: 443
    targetPort: 8443
    nodePort: 30001
selector:
  k8s-app: kubernetes-dashboard

#&amp;gt; https://&amp;lt;node-ip&amp;gt;:30001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ingress:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; https://&amp;lt;ingress-host&amp;gt;:&amp;lt;ingress-port&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;metrics-server&#34;&gt;metrics-server&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/metrics-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/metrics-server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--kubelet-preferred-address-types
--kubelet-insecure-tls
--requestheader-client-ca-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;部署:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# deploy 0.3.6
# 修改image为  registry.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6
$ kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Key Management</title>
        <link>https://canuxcheng.com/post/k8s_km/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_km/</guid>
        <description>&lt;h1 id=&#34;key-management&#34;&gt;Key Management&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;spiffe&lt;/li&gt;
&lt;li&gt;spire&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Microservivce</title>
        <link>https://canuxcheng.com/post/k8s_microservice/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_microservice/</guid>
        <description>&lt;h1 id=&#34;microservivce&#34;&gt;Microservivce&lt;/h1&gt;
&lt;p&gt;微服务是一种架构。&lt;/p&gt;
&lt;p&gt;常见的架构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monolithic application 单体应用.&lt;/li&gt;
&lt;li&gt;SOA(service-oriented architecture) 面向服务的体系结构.&lt;/li&gt;
&lt;li&gt;MicroServices 微服务.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务架构的服务治理包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;service registry 服务注册&lt;/li&gt;
&lt;li&gt;service discovery 服务发现&lt;/li&gt;
&lt;li&gt;observability 可观测性(metrics,logging,trace)&lt;/li&gt;
&lt;li&gt;流量管理&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务应用可以通过容器化(docker, k8s)部署，也可以通过serverless方式部署.&lt;/p&gt;
&lt;p&gt;不同的语言有不同的微服务框架.
java的dubbo, sprint boot.
golang的go-kit,  go-zero, kratos.
python的zappa, nameko.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dapr&#34;&gt;Dapr&lt;/h2&gt;
&lt;p&gt;Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Scheduling &amp; Orchestration</title>
        <link>https://canuxcheng.com/post/cncf_orchestration/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_orchestration/</guid>
        <description>&lt;h1 id=&#34;scheduling--orchestration&#34;&gt;Scheduling &amp;amp; Orchestration&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;docker swarm.&lt;/li&gt;
&lt;li&gt;KEDA&lt;/li&gt;
&lt;li&gt;Crossplane&lt;/li&gt;
&lt;li&gt;Knative&lt;/li&gt;
&lt;li&gt;Kubeflow&lt;/li&gt;
&lt;li&gt;Volcano&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;crossplane&#34;&gt;Crossplane&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Serverless</title>
        <link>https://canuxcheng.com/post/k8s_serverless/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_serverless/</guid>
        <description>&lt;h1 id=&#34;serverless&#34;&gt;Serverless&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;knative&#34;&gt;Knative&lt;/h2&gt;
&lt;p&gt;Knative is a developer-focused serverless application layer which is a great complement to the existing Kubernetes application constructs. Knative consists of three components: an HTTP-triggered autoscaling container runtime called “Knative Serving”, a CloudEvents-over-HTTP asynchronous routing layer called “Knative Eventing”, and a developer-focused function framework which leverages the Serving and Eventing components, called &amp;ldquo;Knative Functions&amp;rdquo;.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Service Mesh</title>
        <link>https://canuxcheng.com/post/k8s_servicemesh/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_servicemesh/</guid>
        <description>&lt;h1 id=&#34;service-mesh&#34;&gt;Service Mesh&lt;/h1&gt;
&lt;p&gt;servivce mesh是cncf基于sidecar推出的下一代面向云原生的微服务架构，是微服务基础设施, 用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性.&lt;/p&gt;
&lt;p&gt;sidecar: 边车模式，就是把业务无关的功能，日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制和服务调用可视化等独立出来。&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序通信的中间层&lt;/li&gt;
&lt;li&gt;轻量级网络代理&lt;/li&gt;
&lt;li&gt;应用程序无感知&lt;/li&gt;
&lt;li&gt;解耦应用程序的重试、超时、监控、追踪和服务发现.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service Mesh是建立在物理或者虚拟网络层之上的，基于策略的微服务的流量控制，与一般的网络协议不同的是它有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者驱动&lt;/li&gt;
&lt;li&gt;可配置策略&lt;/li&gt;
&lt;li&gt;服务优先的网络配置而不是协议&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;linkerd&#34;&gt;Linkerd&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Service Proxy</title>
        <link>https://canuxcheng.com/post/k8s_proxy/</link>
        <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_proxy/</guid>
        <description>&lt;h1 id=&#34;service-proxy&#34;&gt;Service Proxy&lt;/h1&gt;
&lt;p&gt;ingress =&amp;gt; gateway api&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;envoy&lt;/li&gt;
&lt;li&gt;contour&lt;/li&gt;
&lt;li&gt;traefik proxy&lt;/li&gt;
&lt;li&gt;haproxy&lt;/li&gt;
&lt;li&gt;metaLB&lt;/li&gt;
&lt;li&gt;nginx&lt;/li&gt;
&lt;li&gt;openelb&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ingress-controller&#34;&gt;ingress controller&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ingress-nginx(nginx)&lt;/li&gt;
&lt;li&gt;aws-load-balancer-controller(alb)&lt;/li&gt;
&lt;li&gt;ingress-gce&lt;/li&gt;
&lt;li&gt;Traefik&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The kubernetes.io/ingress.class annotation is deprecated from kubernetes v1.22+.通过IngressClasses来选择ingress controller。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ingressClassName: nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ingress 语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: minimal-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx-example
  defaultBackend:
    resource:
      apiGroup: k8s.example.com
      kind: StorageBucket
      name: static-assets
  rules:
  - http:
      paths:
      - path: /testpath
        pathType: Prefix
        backend:
          service:
            name: test
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ImplementationSpecific：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 pathType 处理或者与 Prefix 或 Exact 类型作相同处理。&lt;/p&gt;
&lt;p&gt;Exact：精确匹配 URL 路径，且区分大小写。&lt;/p&gt;
&lt;p&gt;Prefix：基于以 / 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 / 分隔符分隔的路径中的标签列表。 如果每个 p 都是请求路径 p 的元素前缀，则请求与路径 p 匹配。&lt;/p&gt;
&lt;p&gt;ingressclass没有namespace。&lt;/p&gt;
&lt;h2 id=&#34;gateway-api-controller&#34;&gt;gateway api controller&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cilium&lt;/li&gt;
&lt;li&gt;contour&lt;/li&gt;
&lt;li&gt;GKE&lt;/li&gt;
&lt;li&gt;EKS&lt;/li&gt;
&lt;li&gt;kong&lt;/li&gt;
&lt;li&gt;traefik&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ingress-nginx&#34;&gt;ingress-nginx&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/ingress-nginx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/ingress-nginx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 部署
 $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.34.1/deploy/static/provider/baremetal/deploy.yaml

// 验证部署
$ kubectl get pods --all-namespaces -l app.kubernetes.io/name=ingress-nginx --watch

// Detect installed version
POD_NAMESPACE=ingress-nginx
POD_NAME=$(kubectl get pods -n $POD_NAMESPACE -l app.kubernetes.io/name=ingress-nginx -o jsonpath=&#39;{.items[0].metadata.name}&#39;)
$ kubectl exec -it $POD_NAME -n $POD_NAMESPACE -- /nginx-ingress-controller --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tls:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/tls/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.github.io/ingress-nginx/user-guide/tls/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;traefik&#34;&gt;traefik&lt;/h2&gt;
&lt;p&gt;traefik2.2+&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/traefik/traefik&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/traefik/traefik&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install with helm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add traefik https://helm.traefik.io/traefik
helm repo update
helm install --create-namespace traefik -n traefik traefik traefik/traefik -f ./value.yaml

# expose dashboard:
kubectl port-forward -n traefik $(kubectl get pods -n traefik --selector &amp;quot;app.kubernetes.io/name=traefik&amp;quot; --output=name) 9000:9000 --address 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请求模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Client =&amp;gt; Traefik =&amp;gt; Backend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;端口:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9000: traefik管理页面端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重要组件&#34;&gt;重要组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Providers: 自动发现平台上的服务.&lt;/li&gt;
&lt;li&gt;Entrypoints: 监听传入的流量，定义接受请求的端口.&lt;/li&gt;
&lt;li&gt;Routers: 分析请求，负责将传入请求连接到负责处理的服务上.&lt;/li&gt;
&lt;li&gt;Middlewares: 在routers转给services之前修改请求.&lt;/li&gt;
&lt;li&gt;Services/LB: 将请求转给应用, 负责配置处理请求的实际服务.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;两种配置类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态配置: 启动时的配置，通过配置文件(/etc/traefik/traefik.[toml|yaml]，环境变量或命令行参数配置 providers和entrypoints等.&lt;/li&gt;
&lt;li&gt;动态配置: 动态的路由配置，定义系统如何处理请求,从providers获取动态配置.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态配置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entrypoints&lt;/li&gt;
&lt;li&gt;providers&lt;/li&gt;
&lt;li&gt;servertransport&lt;/li&gt;
&lt;li&gt;certificatesresolvers&lt;/li&gt;
&lt;li&gt;api&lt;/li&gt;
&lt;li&gt;ping&lt;/li&gt;
&lt;li&gt;experimental&lt;/li&gt;
&lt;li&gt;hostresolver&lt;/li&gt;
&lt;li&gt;accesslog&lt;/li&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;li&gt;metrics(datadog, influxdb, prometheus,statsd)&lt;/li&gt;
&lt;li&gt;tracing(datadog, elastic, haystack, instana, jaeger, zipkin)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全局配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--global.checknewversion
--global.sendanonymoususagge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制Traefik到Backend的连接的参数serversTransport:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--serversTransport.insecureSkipVerify=true
# self-signed TLS CA.
--serversTransport.rootCAs=foo.crt,bar.crt
--serversTransport.maxIdleConnsPerHost=7
--serversTransport.forwardingTimeouts.dialTimeout=1s
--serversTransport.forwardingTimeouts.responseHeaderTimeout=1s
--serversTransport.forwardingTimeouts.idleConnTimeout=1s
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;kubernetes-provider&#34;&gt;kubernetes provider&lt;/h3&gt;
&lt;p&gt;kubernetes provider有三种类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ingress&lt;/li&gt;
&lt;li&gt;IngressRoute&lt;/li&gt;
&lt;li&gt;Gateway API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;https--tls&#34;&gt;https &amp;amp; tls&lt;/h3&gt;
&lt;p&gt;traefik的证书可以是手动创建证书，也可以通过let&amp;rsquo;s encrypt自动创建&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: name
  namespace: ns
spec:
  tls:
    secretName: my-tls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过Let&amp;rsquo;s encrypt来自动创建证书有三种验证方式（tls, http, dns).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- &amp;quot;--certificatesresolvers.myresolver.acme.httpchallenge=true&amp;quot;
- &amp;quot;--certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web&amp;quot;
- &amp;quot;--certificatesresolvers.myresolver.acme.tlschallenge=true&amp;quot;
- &amp;quot;--certificatesresolvers.myresolver.acme.tlschallenge.entrypoint=websecure&amp;quot;
- &amp;quot;--certificatesresolvers.myresolver.acme.email=canux.cheng@arm.com&amp;quot;
- &amp;quot;--certificatesresolvers.myresolver.acme.storage=acme.json&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Kubeadm</title>
        <link>https://canuxcheng.com/post/k8s_kubeadm/</link>
        <pubDate>Mon, 30 Dec 2019 21:47:17 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_kubeadm/</guid>
        <description>&lt;h1 id=&#34;kubeadm&#34;&gt;kubeadm&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubeadm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubeadm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kubeadm是k8s自带的部署集群的工具.&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装runtime&#34;&gt;安装runtime&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;默认的cgroup驱动时cgroupfs,如果系统是systemd，就会有两个cgroup driver，会出问题.&lt;/p&gt;
&lt;p&gt;如果修改cgroup driver需要同时修改CRI和kubelet.&lt;/p&gt;
&lt;p&gt;修改containerd的cgroup driver:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/containerd/config.toml
#disabled_plugins = [&amp;quot;cri&amp;quot;]
[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.runc.options]
  SystemdCgroup = true

$ sudo systemctl restart containerd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改kubelet的cgroup driver(kubeadm-config.yaml):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# kubeadm-config.yaml
kind: ClusterConfiguration
apiVersion: kubeadm.k8s.io/v1beta3
kubernetesVersion: v1.21.0    // kubelet --version
---
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装kubeadm-kubelet-kubectl&#34;&gt;安装kubeadm, kubelet, kubectl&lt;/h2&gt;
&lt;p&gt;在每台机器上安装 kubeadm, kubelet, kubectl:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y apt-transport-https ca-certificates curl
$ sudo curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - 
$ echo &amp;quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&amp;quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list
$ sudo apt-get update
$ sudo apt-get --yes --allow-unauthenticated install kubeadm kubelet kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl
$ sudo systemctl enable kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;kubeadm-cli&#34;&gt;Kubeadm CLI&lt;/h1&gt;
&lt;p&gt;init:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm init 
--config kubeadm-config.yaml
--kubernetes-version &amp;lt;version&amp;gt; // kubelet --version
--apiserver-advertise-address &amp;lt;master&amp;gt; // 多网卡指定网卡IP
--image-repository &amp;lt;registry&amp;gt; // default: k8s.gcr.io
--pod-network-cidr &amp;lt;cidr&amp;gt; // 指定pod的cidr
--service-cidr &amp;lt;cidr&amp;gt; // default: 10.96.0.0/12
--service-dns-domain // default: cluster.local
--cri-socket // 如果安装了多个cri需要指定.
--ignore-preflight-errors
--upload-certs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;join:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm join [apiserver-advertise-address] --token &amp;lt;token&amp;gt; --discovery-token-ca-cert-hash &amp;lt;hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reset:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm reset -f/--force
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;token:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm token create/delete/generate/list
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;部署cluster&#34;&gt;部署Cluster&lt;/h1&gt;
&lt;h2 id=&#34;部署master&#34;&gt;部署master&lt;/h2&gt;
&lt;p&gt;关闭swap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo swapoff -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm init \
--pod-network-cidr=10.244.0.0/16 \
--apiserver-advertise-address=&amp;lt;IP&amp;gt; \
--kubernetes-version=v1.17.0 \
--image-repository=registry.aliyuncs.com/google_containers \
--cri-socket=/run/containerd/containerd.sock \
-v=6
// --config 一般使用默认即可.
// --pod-network-cidr=10.244.0.0/16 是固定用法，表示选择flannel为网络插件。
// --image-repository 指定registry, 默认是gcr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置当前帐号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;部署网络插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在所有node上部署cni-plugin:
// &amp;lt;https://github.com/containernetworking/plugins/releases&amp;gt;
$ sudo mkdir -p /opt/cni/bin
// 下载并解压所有插件命令到该目录. 默认CNI_PATH=/opt/cni/bin

// &amp;lt;https://docs.cilium.io/en/stable/installation/k8s-install-kubeadm/&amp;gt;
// cilium会自动下载plugins到/opt/cni/bin.

// &amp;lt;https://github.com/flannel-io/flannel&amp;gt;
$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置master是否部署pod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# enable master deploy pod (默认不部署pod到master)
kubectl taint nodes --all node-role.kubernetes.io/control-plane-

# disable master deploy pod
kubectl taint nodes &amp;lt;node&amp;gt; node-role.kubernetes.io/master=true:NoSchedule
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;部署node&#34;&gt;部署node&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo swapoff -a

// 如果有vpn，kubeadm会自动下载安装
// 在所有node上部署cni-plugin:
// &amp;lt;https://github.com/containernetworking/plugins/releases&amp;gt;
$ sudo mkdir -p /opt/cni/bin
// 下载并解压所有插件命令到该目录.

$ sudo kubeadm join 192.168.1.1:6443 \
--token 8po0v5.m1qlbc7w0btq15of \
--discovery-token-ca-cert-hash sha256:21d8365e336d5218637ddf26e2ec5d91c7dd2de518dbe47973e089837b13265b
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;验证&#34;&gt;验证&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl get pods -n kube-system
$ kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除cluster&#34;&gt;删除cluster&lt;/h2&gt;
&lt;p&gt;所有node运行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm reset -f
// 自动停止kubelet并且删除下列文件和目录
[/etc/kubernetes/manifests /etc/kubernetes/pki]
[/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]
[/var/lib/etcd /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要手动删除:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo rm -rf /etc/cni/net.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有node上删除flannel的网络配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo ifconfig cni0 down
$ sudo ip link delete cni0
$ sudo ifconfig flannel.1 down
$ sudo ip link delete flannel.1
$ sudo rm -rf /run/flannel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有node清空iptables&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo iptables -F
$ sudo iptables -X
$ sudo iptables -t nat -F
$ sudo iptables -t nat -X
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用了IPVS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipvsadm --clear
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rm -rf $HOME/.kube
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;部署ha-cluster&#34;&gt;部署HA Cluster&lt;/h1&gt;
&lt;p&gt;ha需要在所有master节点安装haproxy和keepalived.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在master1上初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm init --config ./kubeadm.yaml -v=6 --upload-certs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入其它master:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm join 192.168.1.200:8443 --token &amp;lt;token&amp;gt; --discovery-token-ca-cert-hash &amp;lt;hash&amp;gt; --control-plane --certificate-key &amp;lt;key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入node:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm join 192.168.1.200:8443 --token &amp;lt;token&amp;gt; --discovery-token-ca-cert-hash &amp;lt;hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用自定义配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo kubeadm init --config ./config.yaml -v=6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看默认配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubeadm config print init-defaults
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置kubeadm：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kubeadm.k8s.io/v1beta2
kind: InitConfiguration
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
localAPIEndpoint:
  advertiseAddress: 10.103.1.1 // master IP
  bindPort: 6443
nodeRegistration:
  criSocket: /run/containerd/containerd.sock
  name: debug // master hostname
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置kubernetes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定制control plane
&amp;lt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/&amp;gt;
apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
certificatesDir: /etc/kubernetes/pki
clusterName: kubernetes
controlPlaneEndpoint: 10.58.203.200:8443 // HA中haproxy的VIP和port
dns:
  type: CoreDNS
etcd:
  local:
    dataDir: /var/lib/etcd
networking:
  dnsDomain: cluster.local
  serviceSubnet: 10.96.0.0/12
  podSubnet: 10.244.0.0/16 // for flannel
imageRepository: k8s.gcr.io
kubernetesVersion: v1.18.6
controllerManager:
  ...
  extraArgs:
    &amp;lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/&amp;gt;
    allocate-node-cidrs: &#39;true&#39;
    node-cidr-mask-size: &#39;16&#39; // flannel的SubNetLen
    cluster-cidr: &#39;10.0.0.0/8&#39; // flannel的Network
apiServer:
  timeoutForControlPlane: 4m0s
  &amp;lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/&amp;gt;
    extraArgs:
      advertise-address: 192.168.0.103
      ...
scheduler:
  ...
  &amp;lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/&amp;gt;
  extraArgs:
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改kubelet的cgroup driver:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Minikube</title>
        <link>https://canuxcheng.com/post/k8s_minikube/</link>
        <pubDate>Mon, 30 Dec 2019 21:47:17 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_minikube/</guid>
        <description>&lt;h1 id=&#34;minikube&#34;&gt;minikube&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/learning-environment/minikube/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/learning-environment/minikube/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;minikube 能快速创建k8s的开发集群，支持在虚拟机上创建，也支持裸机创建.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在裸机上创建：
sudo minikube start --vm-driver=none
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Image</title>
        <link>https://canuxcheng.com/post/cncf_image/</link>
        <pubDate>Tue, 03 Dec 2019 21:50:47 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_image/</guid>
        <description>&lt;h1 id=&#34;image&#34;&gt;image&lt;/h1&gt;
&lt;p&gt;容器镜像&lt;/p&gt;
&lt;p&gt;docker image driver: aufs, btrfs, devicemapper, overlay.&lt;/p&gt;
&lt;h2 id=&#34;multi-platform-images&#34;&gt;multi-platform images&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/build/building/multi-platform/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/build/building/multi-platform/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;qemu&#34;&gt;qemu&lt;/h3&gt;
&lt;p&gt;使用qume:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 安装bitfmt
docker run --privileged --rm tonistiigi/binfmt --install all

// 查看支持的平台
ls -l /proc/sys/fs/binfmt_misc/qemu-*
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;multiple-native-nodes&#34;&gt;multiple native nodes&lt;/h3&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// linux
sudo apt install docker-buildx-plugin

// mac
brew install docker-buildx
mkdir -p ~/.docker/cli-plugins
ln -sfn $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx
docker buildx install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker buildx version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理builder instance&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker buildx create
--append 添加node到builder实例。
--leave 从builder实例删除node
--driver Driver to use(&amp;quot;docker&amp;quot;, &amp;quot;docker-container&amp;quot;, &amp;quot;kubernetes&amp;quot;)
--name
--use
--node
--platform 
--bootstrap 启动实例（以容器的形式启动）

// 以本地是amd64为例，创建一个实例.
docker buildx create --use --bootstrap --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --name canux-builder

// 如果没有qumu，可以把不同平台的远程机器加到builder实例.
docker buildx create \
--name local_remote_builder \
--append --node &amp;lt;my-arm-server&amp;gt; \
--platform linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/mips64le,linux/mips64,linux/arm/v7,linux/arm/v6 \
ssh://user@&amp;lt;my-arm-server&amp;gt; 

docker buildx rm

docker buildx stop

docker buildx inspect

docker buildx use

// 查看当前可用的builders
docker buildx ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建多平台镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker buildx build --platform &amp;lt;p1,p2&amp;gt; ...

// 一次编译多个平台的镜像直接push到registry。
docker buildx build --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --push -t name/target:tag .

// 编辑成不同的image 
docker buildx build -o type=docker --platform linux/amd64 -t name:1.0.0 .
docker buildx build -o type=docker --platform linux/arm64 -t name:1.0.0-linux-arm64 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cross-compilation&#34;&gt;cross-compilation&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;overlay&#34;&gt;Overlay&lt;/h2&gt;
&lt;p&gt;最下层是一个 lower 层，也就是镜像层，它是一个只读层；&lt;/p&gt;
&lt;p&gt;右上层是一个 upper 层，upper 是容器的读写层，upper 层采用了写实复制的机制，也就是说只有对某些文件需要进行修改的时候才会从 lower 层把这个文件拷贝上来，之后所有的修改操作都会对 upper 层的副本进行修改；&lt;/p&gt;
&lt;p&gt;upper 并列的有一个 workdir，它的作用是充当一个中间层的作用。也就是说，当对 upper 层里面的副本进行修改时，会先放到 workdir，然后再从 workdir 移到 upper 里面去，这个是 overlay 的工作机制；&lt;/p&gt;
&lt;p&gt;最上面的是 mergedir，是一个统一视图层。从 mergedir 里面可以看到 upper 和 lower 中所有数据的整合，然后我们 docker exec 到容器里面，看到一个文件系统其实就是 mergedir 统一视图层。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 挂载到overlay
mount -t overlay -o lowerdir=/path/lower,upperdir=/path/upper,workdir=/path/work overlay /path/di
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;scratch&#34;&gt;scratch&lt;/h2&gt;
&lt;p&gt;scratch是空白镜像，一般用于基础镜像构建.比如制作alpine/ubuntu/debian/busybox镜像.&lt;/p&gt;
&lt;h2 id=&#34;ubuntudebian&#34;&gt;ubuntu/debian&lt;/h2&gt;
&lt;p&gt;Hash Sum mismatch:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN set -ex \
&amp;amp;&amp;amp; apt-get clean \
&amp;amp;&amp;amp; apt-get update -o Acquire::CompressionTypes::Order::=gz \
&amp;amp;&amp;amp; apt-get update \
&amp;amp;&amp;amp; apt-get install -y --allow-unauthenticated --no-install-recommends \
build-essential \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;centosfedora&#34;&gt;centos/fedora&lt;/h2&gt;
&lt;h2 id=&#34;buildpack-deps&#34;&gt;buildpack-deps&lt;/h2&gt;
&lt;p&gt;在ubuntu/debian基础上安装一些工具，比ubuntu/debian镜像更大.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker-library/buildpack-deps&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker-library/buildpack-deps&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;busybox&#34;&gt;busybox&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker-library/busybox&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker-library/busybox&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;alpine推荐&#34;&gt;alpine(推荐)&lt;/h2&gt;
&lt;p&gt;很多语言的都是基于alpine: python-version:alpine-version, golang-version:alpine-version.&lt;/p&gt;
&lt;p&gt;一个基于musl和busybox的linux发行版.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.alpinelinux.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.alpinelinux.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;alpine比distroless尺寸大，包含包管理和shell，方便调试.&lt;/p&gt;
&lt;p&gt;alpine使用musl代替glibc会导致有的程序无法运行, 解决:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mkdir /lib64
# ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意wget 部分参数不可用.&lt;/p&gt;
&lt;h2 id=&#34;distroless&#34;&gt;distroless&lt;/h2&gt;
&lt;p&gt;google提供的只包含运行时的精简镜像.&lt;/p&gt;
&lt;p&gt;缺点是没有包管理和shell，不方便调试.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/GoogleContainerTools/distroless&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/GoogleContainerTools/distroless&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;slim&#34;&gt;slim&lt;/h2&gt;
&lt;p&gt;减小image大小,适用于web程序.&lt;/p&gt;
&lt;p&gt;&amp;lt;https://github.com/docker-slim/docker-slim&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Helm</title>
        <link>https://canuxcheng.com/post/k8s_helm/</link>
        <pubDate>Thu, 05 Sep 2019 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_helm/</guid>
        <description>&lt;h1 id=&#34;helm&#34;&gt;Helm&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/helm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/helm/helm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;helm2有两个组件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;helm: 客户端&lt;/li&gt;
&lt;li&gt;tiller: 服务端(helm3被移除)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chart: helm包，包含运行一个应用所需的镜像，依赖和资源.&lt;/li&gt;
&lt;li&gt;repository: 用于发布和存储chart的仓库.&lt;/li&gt;
&lt;li&gt;release: 在k8s集群上运行的一个chart实例.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;repository有哪些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;charts: OSS, public, 已经被artifacthub取代, &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/charts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/helm/charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;artifacthub: OSS, public,  &lt;a class=&#34;link&#34; href=&#34;https://artifacthub.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://artifacthub.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;chartmuseum: OSS, private, self-host, &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/chartmuseum&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/helm/chartmuseum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;harbor: OSS, private, self-host.&lt;/li&gt;
&lt;li&gt;artifactory(jfrog): enterprise, private, self-host.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;helm和kubectl一样，访问指定配置的k8s集群。&lt;/p&gt;
&lt;p&gt;helm2需要安装tiller并且执行helm init初始化,helm不需要tiller.&lt;/p&gt;
&lt;p&gt;本地二进制安装helm3+:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -
sudo apt-get install apt-transport-https --yes
echo &amp;quot;deb https://baltocdn.com/helm/stable/debian/ all main&amp;quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
sudo apt-get update
sudo apt-get install helm
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;repo管理&#34;&gt;repo管理&lt;/h3&gt;
&lt;p&gt;查看有哪些repo,默认没有repo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm repo list 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加repo并命名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm repo add [NAME] [URL] [flags]

// 添加charts/artifactoryhub stable命名为stable
$ helm repo add stable https://charts.helm.sh/stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新repo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm repo update
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;chart管理&#34;&gt;chart管理&lt;/h3&gt;
&lt;p&gt;从repo中查找chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm search hub [KEYWORD] [flags]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从repo里面的chart里面搜索关键字:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm search repo [keyword] [flags]

//查看repo里面所有chart
$ helm search repo

// 查看repo里面所有treafik chart
$ helm search repo traefik
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看chart信息:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm show chart traefik/traefik
helm show values traefik/traefik &amp;gt; value.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm pull chart-name
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;release管理&#34;&gt;release管理&lt;/h3&gt;
&lt;p&gt;install/upgrade/uninstall/rollback&lt;/p&gt;
&lt;p&gt;status/list/get/history&lt;/p&gt;
&lt;p&gt;安装chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install [name] [chart] [flags]

// 验证签名
helm install --verify ...

helm install traefik traefik/traefik

// 需提前创建namespace, 修改value
helm install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard -f value.yaml -n kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看release(每个install都是一个release):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm list
-a, --all                  show all releases without any filter applied.
-A, --all-namespaces       list releases across all namespaces.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;卸载release:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm uninstall kubernetes-dashboard -n kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm status mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取release信息:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm get manifest [name]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;misc&#34;&gt;misc&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;helm plugin
helm env
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chart开发&#34;&gt;chart开发&lt;/h2&gt;
&lt;p&gt;创建chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm create my-chart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug chart：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 检查语法
helm lint my-chart

// 模拟安装
helm install my-chart ./my-chart --dry-run --debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模板管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm template [name] [chart]

// 在本地渲染模板
helm template my-chart ./my-chart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依赖chart管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm dependency

// 将依赖的chart下载到chart目录.
helm dep up &amp;lt;chart-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包chart:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://helm.sh/zh/docs/topics/provenance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helm.sh/zh/docs/topics/provenance/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm package my-chart

// 会另外生成一个.prov文件
helm package --sign --key &amp;quot;Canux&amp;quot; --keyring ~/.gnupg/secring.gpg my-chart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证打包的chart:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm verify my-chart.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成index文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo index my-chart-folder --url &amp;lt;repo-url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传chart到registry：&lt;/p&gt;
&lt;p&gt;有的registry支持ui上直接upload，或者CLI上传，也可以通过helm push上传.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm registry login
helm push my-chart.tgz oci://registry/helm-charts
helm registry logout 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是OCI registry目前只支持以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm registry login/logout
helm push
helm pull
helm show
helm template
helm install
helm upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chart 目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;values.yaml
Chart.yaml
charts/
templates/
templates/tests/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chart.yaml语法:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://helm.sh/zh/docs/topics/charts/#chartyaml-%E6%96%87%E4%BB%B6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helm.sh/zh/docs/topics/charts/#chartyaml-%E6%96%87%E4%BB%B6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;template的流控制:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://helm.sh/zh/docs/chart_template_guide/control_structures/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helm.sh/zh/docs/chart_template_guide/control_structures/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 用$代替. 来获取上一级的变量
{{- range .Values.worker }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include &amp;quot;app.fullname&amp;quot; $ }}-worker-{{ .name }}
labels:
    {{- include &amp;quot;worker.labels&amp;quot; $ | nindent 4 }}
spec:
  {{- if not .autoscaling.enabled }}
  replicas: {{ $.Values.replicaCount }}
  {{- end }}
  ......
---
{{- end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;template的函数:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://helm.sh/zh/docs/chart_template_guide/function_list/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helm.sh/zh/docs/chart_template_guide/function_list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hooks:&lt;/p&gt;
&lt;p&gt;helm uninstall 不会删除有hook的资源。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://helm.sh/zh/docs/topics/charts_hooks/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://helm.sh/zh/docs/topics/charts_hooks/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    &amp;quot;helm.sh/hook&amp;quot;: post-install, pre-install, ...
    &amp;quot;helm.sh/hook-weight&amp;quot;: &amp;quot;-5&amp;quot;
    &amp;quot;helm.sh/hook-delete-policy&amp;quot;: hook-succeeded, hook-failed, ...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>K8S CRI</title>
        <link>https://canuxcheng.com/post/k8s_cri/</link>
        <pubDate>Wed, 05 Jun 2019 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/k8s_cri/</guid>
        <description>&lt;h1 id=&#34;cri&#34;&gt;CRI&lt;/h1&gt;
&lt;p&gt;CRI: Container Runtime Intarface&lt;/p&gt;
&lt;p&gt;定义了k8s和container runtime进行交互的接口.&lt;/p&gt;
&lt;p&gt;是k8s与container交互的标准.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;containerd&lt;/li&gt;
&lt;li&gt;cri-o&lt;/li&gt;
&lt;li&gt;rkt&lt;/li&gt;
&lt;li&gt;kata&lt;/li&gt;
&lt;li&gt;rancher&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;docker&#34;&gt;docker&lt;/h2&gt;
&lt;p&gt;k8s_1.20 开始警告不再支持docker.&lt;/p&gt;
&lt;p&gt;k8s_1.23 开始移除dockershim.&lt;/p&gt;
&lt;p&gt;/var/run/dockerhsim.sock&lt;/p&gt;
&lt;h2 id=&#34;containerd&#34;&gt;containerd&lt;/h2&gt;
&lt;p&gt;/run/container/containerd.sock&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/containerd/containerd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/containerd/containerd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装配置:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cri-o&#34;&gt;CRI-O&lt;/h2&gt;
&lt;p&gt;redhat.&lt;/p&gt;
&lt;p&gt;/var/run/crio/crio.sock&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cri-o/cri-o&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cri-o/cri-o&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;kata&#34;&gt;kata&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kata-containers/runtime&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kata-containers/runtime&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;rkt&#34;&gt;rkt&lt;/h2&gt;
&lt;p&gt;redhat(coreos)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rkt/rkt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rkt/rkt&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Virtualbox</title>
        <link>https://canuxcheng.com/post/virtualbox/</link>
        <pubDate>Mon, 03 Jun 2019 22:53:23 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/virtualbox/</guid>
        <description>&lt;h1 id=&#34;virtualbox&#34;&gt;Virtualbox&lt;/h1&gt;
&lt;p&gt;虚拟化工具virtualbox.&lt;/p&gt;
&lt;h1 id=&#34;vboxmanage&#34;&gt;vboxmanage&lt;/h1&gt;
&lt;p&gt;vm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 导入ova
$ vboxmanage import win7.ova 

// 添加host网络
$ vboxmanage modifyvm &amp;quot;win764&amp;quot; --nic1 hostonly --hostonlyadapter1 vboxnet0
// 添加bridge网络
$ vboxmanage modifyvm &amp;quot;Win732&amp;quot; --nic2 bridged --bridgeadapter2 docker_gwbridge
// 重命名vm
$ vboxmanage modifyvm &amp;lt;vm&amp;gt; --name &amp;lt;new-name&amp;gt; 
// 修改参数
$ vboxmanage modifyvm &amp;lt;vm&amp;gt; --memory 4096 --cpus 4 --hwvirtex on --ioapic on

// 启动虚拟机
$ vboxmanage startvm &amp;quot;Win732&amp;quot;
$ vboxmanage startvm &amp;lt;vm&amp;gt; --type headless 
$ VBoxHeadless --startvm &amp;lt;uuid|name&amp;gt; --vrde on

// 控制虚拟机
$ vboxmanage controlvm &amp;lt;vm&amp;gt; pause/resume/reset/poweroff/savestate

// 查看所有/运行虚拟机
$ vboxmanage list vms/runningvms 

// 删除vm
$ vboxmanage unregistervm &amp;lt;vm&amp;gt; --delete

// linux上执行命令
$ vboxmanage guestcontrol {} --username {} --password {} run --exe /bin/bash -- -l -c &#39;pwd&#39;

// windows上执行命令
$ vboxmanage guestcontrol {} --username &#39;Administrator&#39; run --exe &#39;C:\\Program Files\\Oracle\\VirtualBox Guest Additions\\uninst.exe&#39; -- uninst.exe /S
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;media&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 列出所有hdd
$ vboxmanage list hdds

// 删除hdd
$ vboxmanage closemedium disk &amp;lt;uuid&amp;gt; --delete
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;snapshot&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//查看快照
$ vboxmanage snapshot &amp;lt;vm&amp;gt; list 

$ vboxmanage snapshot &amp;lt;vm&amp;gt; take &amp;lt;name&amp;gt; --live --pause // 创建快照

$ vboxmanage snapshot &amp;lt;vm&amp;gt; delete &amp;lt;snapshot-name/uuid&amp;gt; // 删除快照

$ vboxmanage snapshot &amp;lt;vm&amp;gt; restore &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hostonly-network&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vboxmanage hostonlyif crate // 创建hostonly bridge
$ vboxmanage hostonlyif ipconfig vboxnet0 --ip 192.168.1.1 --netmask 255.255.255.0 // 给hostonly bridge分配ip和netmask.
$ vboxmanage hostonlyif remove &amp;lt;name&amp;gt;

// 查看所有hostonly网路
$ vboxmanage list hostonlyifs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bridge-network&lt;/p&gt;
&lt;p&gt;nat-network&lt;/p&gt;
&lt;p&gt;storage&lt;/p&gt;
&lt;p&gt;extpack&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 安装扩展包
$ sudo vboxmanage extpack install Oracle_VM_VirtualBox_Extension_Pack-6.0.8.vbox-extpack
$ sudo vboxmanage extpack uninstall \
&amp;quot;Oracle VM VirtualBox Extension Pack&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/go_package/</link>
        <pubDate>Tue, 23 Apr 2019 21:42:07 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/go_package/</guid>
        <description></description>
        </item>
        <item>
        <title>Command</title>
        <link>https://canuxcheng.com/post/network_command/</link>
        <pubDate>Sun, 31 Mar 2019 21:51:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/network_command/</guid>
        <description>&lt;h1 id=&#34;network-command&#34;&gt;network command&lt;/h1&gt;
&lt;p&gt;network related command&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;net-tools&#34;&gt;net-tools&lt;/h2&gt;
&lt;p&gt;deprecated&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ecki/net-tools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ecki/net-tools&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install net-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ifconfig&#34;&gt;ifconfig&lt;/h3&gt;
&lt;p&gt;查看本地网络接口状态和流量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ifconfig # 查看up的interface
ifconfig -a  # 查看所有的interface
ifconfig &amp;lt;interface&amp;gt; # 查看指定的interface
ifconfig &amp;lt;bridge&amp;gt;/&amp;lt;interface&amp;gt; up/down
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;netstat&#34;&gt;netstat&lt;/h3&gt;
&lt;p&gt;用于查看网络连接、路由表、接口统计等信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;netstat
-a, --all, --listening # 显示所有socket, 默认只显示connected
-l, --listening  # 显示listening
-n, --numeric
-p, --programs # 显示pid或程序名称
# socket选项:
-t, --tcp
-u, --udp
-w, --raw
-x, --unix
--ax25
--ipx
--netrom

# 常用
netstat -anp    # 查看哪些端口是打开的．
sudo netstat -anp | grep port # 查看端口是否被使用
sudo netstat -tulnp # 查看tcp&amp;amp;udp端口是否被监听
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arp&#34;&gt;arp&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;arp # 用于确定IP地址的网卡物理地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;route&#34;&gt;route&lt;/h3&gt;
&lt;p&gt;Flags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;U: route is up&lt;/li&gt;
&lt;li&gt;H: target is a host&lt;/li&gt;
&lt;li&gt;G: use gateway&lt;/li&gt;
&lt;li&gt;!: reject route&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Genmask: netmask for destination net.&lt;/p&gt;
&lt;p&gt;Metric: 到target距离, hops.&lt;/p&gt;
&lt;p&gt;Ref: 该路由引用次数&lt;/p&gt;
&lt;p&gt;Use: 查找路由的次数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;route -n
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rarp&#34;&gt;rarp&lt;/h3&gt;
&lt;h3 id=&#34;hostname&#34;&gt;hostname&lt;/h3&gt;
&lt;h3 id=&#34;domainname&#34;&gt;domainname&lt;/h3&gt;
&lt;h3 id=&#34;dnsdomainname&#34;&gt;dnsdomainname&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iproute2&#34;&gt;iproute2&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/shemminger/iproute2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/shemminger/iproute2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install iproute2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ss&#34;&gt;ss&lt;/h3&gt;
&lt;p&gt;取代netstat, 用于查看socket连接状态.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ss -s # 查看socket统计信息
ss -tuln # 查看tcp和udp的监听端口
ss -tulnp # 查看tcp和udp的监听端口和对应的程序
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ip&#34;&gt;ip&lt;/h3&gt;
&lt;p&gt;取代ifconfig, route, arp等命令的集合.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip link show

# 创建vlan
ip link add link eth1 name eth1.10 type vlan id 10
# 添加ip
ip addr add 192.168.100.1/24 brd 192.168.100.255 dev eth1.10
# 启动vlan
ip link set dev eth1.10 up
# 关闭vlan
ip link set dev eth1.10 down
# 删除vlan
ip link delete eth1.10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;addr/address&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip addr show &amp;lt;interface&amp;gt; # 查看指定interface的ip地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;route&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip route show # 查看路由表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rule&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip rule showa # 查看规则
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;devlink&#34;&gt;devlink&lt;/h3&gt;
&lt;h3 id=&#34;ifstat&#34;&gt;ifstat&lt;/h3&gt;
&lt;h3 id=&#34;bridge&#34;&gt;bridge&lt;/h3&gt;
&lt;p&gt;用于管理bridge, 取代brctl.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bridge link show # 查看bridge的接口
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iputils&#34;&gt;iputils&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iputils/iputils&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/iputils/iputils&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install iputils-ping
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ping&#34;&gt;ping&lt;/h3&gt;
&lt;p&gt;round-trip time/RTT: 往返时间, 即从发送数据包到接收数据包的时间.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping # 用于确定网络的连通性
ping -c 5 &amp;lt;host&amp;gt; # 发送5个包
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arping&#34;&gt;arping&lt;/h3&gt;
&lt;h3 id=&#34;tracepath&#34;&gt;tracepath&lt;/h3&gt;
&lt;h3 id=&#34;clockdiff&#34;&gt;clockdiff&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;traceroute&#34;&gt;traceroute&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install traceroute
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;路由跟踪与跳数检查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;traceroute &amp;lt;host&amp;gt; # 跟踪到host的路由

# 通过指定端口号来跟踪
traceroute -p &amp;lt;port&amp;gt; &amp;lt;host&amp;gt;

# 使用tcp协议
traceroute -T &amp;lt;host&amp;gt;

# 使用udp协议
traceroute -U &amp;lt;host&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcpdump&#34;&gt;tcpdump&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install tcpdump

tcpdump

tcpdump tcp port &amp;lt;port&amp;gt;        # 抓tcp 在port端口的包
tcpdump udp port &amp;lt;port&amp;gt;       #抓udp 在port端口的包
tcpdump -i &amp;lt;interface&amp;gt; # 抓取指定interface的包
tcpdump host &amp;lt;ip&amp;gt; and port &amp;lt;port&amp;gt; # 抓取指定ip和端口的包
tcpdump net &amp;lt;network&amp;gt; # 抓取指定网络的包
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ncnetcat&#34;&gt;nc/netcat&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 有的系统默认安装netcat-traditional
$ sudo apt-get install netcat-traditional 
// 安装netcat-openbsd
$ sudo apt-get install netcat-openbsd
// 设置默认值
$ sudo update-alternatives --config nc
$ sudo update-alternatives --set nc /bin/nc.openbsd

nc -z IP PORT # 查看指定tcp://ip:port是否监听
nc -zu IP PORT # 查看udp://ip:port是否监听

// 通过nc监听端口
nc -l PORT

// 通过nc发送请求.
echo -e &#39;{&amp;quot;method&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;params&amp;quot;:[&amp;quot;test&amp;quot;],&amp;quot;id&amp;quot;:1}&#39; | nc IP PORT
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dnsutils&#34;&gt;dnsutils&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install dnsutils
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nslookup&#34;&gt;nslookup&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nslookup # 查询IP地址和对应的域名
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dig&#34;&gt;dig&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dig # 查询DNS记录

dig @&amp;lt;dns-server&amp;gt; &amp;lt;domain&amp;gt; # 指定dns服务器查询域名
dig &amp;lt;domain&amp;gt; A # 查询A记录
dig &amp;lt;domain&amp;gt; MX # 查询MX记录
dig &amp;lt;domain&amp;gt; NS # 查询NS记录
dig &amp;lt;domain&amp;gt; TXT # 查询TXT记录
dig &amp;lt;domain&amp;gt; ANY # 查询所有记录

# 反向解析IP地址
dig -x &amp;lt;ip-address&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nsupdate&#34;&gt;nsupdate&lt;/h3&gt;
&lt;h3 id=&#34;host&#34;&gt;host&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ethtool&#34;&gt;ethtool&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install ethtool

ethtool # 查询网络设备信息
ethtool &amp;lt;interface&amp;gt; # 查询指定网络设备信息
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iftop&#34;&gt;iftop&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ex-parrot.com/~pdw/iftop/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.ex-parrot.com/~pdw/iftop/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install iftop

sudo iftop # 查看网络流量
sudo iftop -i &amp;lt;interface&amp;gt; # 查看指定网络接口的流量
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iperf3&#34;&gt;iperf3&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;wget&#34;&gt;wget&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;wget [option] [URL]

-a, --append-output=FILE 输出重定向到日志
-o, --output-file=FILE
-q, --quiet    不输出
-b, --background
-nv, --no-verbose
--header &amp;quot;authorization:c2FuZGJveDpTMG5pY3dhbGwK&amp;quot;

-t, --tries=NUMBER    超时重连次数, 0表示不限制, 默认20
-nc, --no-clobber    不覆盖原有文件
-N, --timestamping   只下载比本地新的文件
-c, --continue    断点续传,会覆盖-N
-T, --timeout=SECONDS    超时时间, 默认900s
-w, --wait=SECONDS    重连之间的等待时间
-O, --output-document=FILE, 重命名下载文件

-nH, --no-host-directories 不创建站点的根目录
-x, --force-directories    创建和服务器一样的结构下载
-P, --directory-prefix=PREFIX  指定下载的目录

-R,  --reject=LIST 排除下载的文件
-r, --recursive  迭代下载
-np, --no-parent 不下载父目录的内容

# 同步目录
wget -Nc -r -np -nH --cut-dirs=3 -R &amp;quot;index.*, *.js, *.css, *.html, *.jpg, *.png, *.gif&amp;quot; -P /path/to/source/ http://host/path/to/dest/

# ssl + basic auth
wget --no-check-certificate --user &amp;lt;user&amp;gt; --password &amp;lt;pw&amp;gt; -nv -N -P &amp;lt;dest-folder&amp;gt; &amp;lt;src-url&amp;gt;

$ wget -q -N -P /folder url
$ wget -q -c -O /path/to/file.ext url
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;curl&#34;&gt;curl&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;curl
-X/--request post/patch/delte/get/...
-H/--header &#39;content-type: application/json&#39;
-d/--data &#39;{&amp;quot;key&amp;quot;: &amp;quot;value&amp;quot;}&#39;
--data-raw DATA  HTTP POST data, &#39;@&#39; allowed (H)
--data-ascii DATA  HTTP POST ASCII data (H)
--data-binary DATA  HTTP POST binary data (H)
--data-urlencode DATA  HTTP POST data url encoded (H)
-G, --get           Send the -d data with a HTTP GET (H)
-k/--insecure    ignore ssl check.
-u/--user &amp;lt;user:password&amp;gt;
-s/--silent        Silent mode
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Command</title>
        <link>https://canuxcheng.com/post/storage_command/</link>
        <pubDate>Sun, 31 Mar 2019 21:51:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/storage_command/</guid>
        <description>&lt;h1 id=&#34;sysstat&#34;&gt;sysstat:&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# &amp;lt;https://github.com/sysstat/sysstat&amp;gt;
$ sudo apt-get install sysstat
# 包括 iostat/mpstat/pidstat/tapestat/cifsiostat

iostat -d -x -k 1 10

pidstat -d -p pid
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;iotop&#34;&gt;iotop&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 查看进程的diskio
$ sudo apt-get install iotop
$ sudo iotop
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;df&#34;&gt;df&lt;/h1&gt;
&lt;p&gt;df计算文件系统磁盘空间使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df
$ df -h

# 查看目录信息(读写哪个设备)
$ df /path/folder
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dd&#34;&gt;dd&lt;/h1&gt;
&lt;p&gt;dd转化并拷贝文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dd
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fsck&#34;&gt;fsck&lt;/h1&gt;
&lt;p&gt;fsck检查并修复文件系统:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fsck
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fdisk&#34;&gt;fdisk&lt;/h1&gt;
&lt;p&gt;支持msdos，支持2T以下的磁盘.&lt;/p&gt;
&lt;p&gt;fdisk管理磁盘分区表:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fdisk
fdisk -l

fdisk /dev/sda # 可以创建新的磁盘分区
&amp;gt; n ...    创建新的分区
&amp;gt; t (8e表示linux LVM), 修改分区类型
&amp;gt; w 保存修改
partprobe /dev/sda # 在不重启的情况下保存分区
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;parted&#34;&gt;parted&lt;/h1&gt;
&lt;p&gt;支持gpt分区表，支持2T以上的大磁盘.&lt;/p&gt;
&lt;p&gt;大存储分区工具,比如nas,raid.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parted /dev/sda print
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mkfd&#34;&gt;mkfd&lt;/h1&gt;
&lt;p&gt;mkfs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfs [options] [-t type fs-options] device [size]
mkfs.ext4 /dev/sdb1 # 将分区格式化成ext4格式.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mountumount&#34;&gt;mount/umount&lt;/h1&gt;
&lt;p&gt;相关文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/fstab
/etc/mtab

查看磁盘的uuid, 通过uuid挂载
ls -l /dev/disk/by-uuid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mount/umount挂载文件系统:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount # 查看所有挂载信息

mount -t type -o option device dir

# 将目录挂载到指定磁盘分区
mount -t ext4 /dev/sdb1 /opt
等效修改/etc/fstab
/dev/sdb1 /opt ext4 defaults 0 0

# 将目录挂在到内存上.
mount -t tmpfs -o size=100G tmpfs /var/www

# 本机挂载, 将本机的folder2挂载到folder1, folder2中原有的内容会隐藏.
mount --bind /path/folder1 /path/folder2
/path/folder1 /path/folder2 none bind 0 0

# 挂载到overlay
mount -t overlay -o lowerdir=/path/lower,upperdir=/path/upper,workdir=/path/work overlay /path/dir

umount
umount device/dir
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 先创建linux lvm分区
pvcreate &amp;lt;pv-name&amp;gt; # 创建物理卷PV
pvdisplay
vgextend &amp;lt;vg-name&amp;gt; &amp;lt;pv-name&amp;gt;  # 给物理卷创建卷组VG
vgdisplay
lvextend -r -l +100%FREE &amp;lt;lv-path&amp;gt; # 将物理卷上的空闲空间全部放到逻辑卷LV上
lvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sync同步缓存写入固态存储:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有硬件设备:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lshw # 列出硬件
lshw -class disk # 查看磁盘设备
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设备管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lspci # 列出所有PCI设备

lsusb # 列出USB设备

lsblk # 列出块设备

setleds

loadkeys

dumpkeys

MAKEDEV
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;iops&#34;&gt;IOPS&lt;/h1&gt;
&lt;p&gt;磁盘IO.&lt;/p&gt;
&lt;p&gt;安装fio:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install fio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试随机读写的IO:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 测试本地磁盘读写
$ fio -filename=/dev/sda1 -direct=1 -iodepth 1 -thread -rw=randrw \
-rwmixread=70 -ioengine=psync -bs=16k -size=200G -numjobs=30 -runtime=100 \
-group_reporting -name=mytest
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Init</title>
        <link>https://canuxcheng.com/post/linux_init/</link>
        <pubDate>Sun, 03 Feb 2019 14:04:05 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_init/</guid>
        <description>&lt;h1 id=&#34;linux-init&#34;&gt;Linux Init&lt;/h1&gt;
&lt;p&gt;linux系统启动的第一个进程,pid=1的进程.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -l /sbin/init
$ sudo readlink /sbin/init
/sbin/init -&amp;gt; upstart
/sbin/init -&amp;gt; /lib/systemd/systemd

/etc/init.d
The directory containing System V init scripts.
通过service命令操作

/etc/init
The directory containing upstart jobs.
通过initctl命令操作
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;systemd&#34;&gt;systemd&lt;/h1&gt;
&lt;p&gt;sytemd是upstart的替代版本．通过查看/sbin/init指向systemd还是upstart.&lt;/p&gt;
&lt;p&gt;service文件位置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/systemd/system/***.service
/lib/systemd/system/*.service
/usr/lib/systemd/system/*.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;service文件编写:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.unit.html#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.freedesktop.org/software/systemd/man/systemd.unit.html#&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=details
After=containerd.service # 之前启动
Before= # 之后运行
Bindsto= #
Wants=containerd.service # 弱依赖
Requires= # 强依赖
StartLimitInterval=10s
StartLimitBurst=5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.service.html#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.freedesktop.org/software/systemd/man/systemd.service.html#&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Service]
Type=simple/notify/dbus/forking/idle/oneshot
ExecStartPre=
ExecStart=
ExecStartPost=
ExecStop=
ExecStopPost=
ExecReload=
KillMode=node/mixed/process/control-group
Restart=no/on-success/on-failure/on-abnormal/on-abort/on-watchdog/always # always总是开机启动，即使systemctl enable.
RestartSec=3s # 重启之前等待的时间.
TimeoutSec=  # TimeoutStartSec+TimeoutStopSec
LimitNOFILE=49152 # 限制单个service的fd

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;systemctl命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改后需要重新加载.service文件
$ systemctl daemon-reload

$ systemctl start/stop/status ***
$ systemctl list-unit-files
$ systemctl show docker

# 设置开机自动启动
//在/etc/systemd/system/multi-user.target.wants下创建链接
$ systemctl enable ***
$ systemctl disable ***
$ systemctl is-enabled ***
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo journalctl -fu docker.service
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;upstart&#34;&gt;upstart&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/***
/etc/init/***.conf

$ sudo service docker start/stop/status/reload/restart
$ sudo initctl start/stop/status/reload/restart docker
$ sudo initctl list

# 设置开机自动启动
$ update-rc.d *** defaults
# 取消开机启动
$ update-rc.d *** remove
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ tail -f /var/log/upstart/docker.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Stanzas功能:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://upstart.ubuntu.com/wiki/Stanzas?highlight=%28%28CategoryDoc%29%29#pid&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://upstart.ubuntu.com/wiki/Stanzas?highlight=%28%28CategoryDoc%29%29#pid&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 添加服务
$ sudo vim /etc/init/docker.conf

# docker - container daemon
description  &amp;quot;docker&amp;quot;

start on runlevel [2345]
stop on runlevel [!2345]

respawn
# give up if restart occurs 10 times in 100 seconds.
respawn limit 10 100

pre-start script
    # do something before start
end script

script
    echo &amp;quot;ERROR: `date`: docker started by init.&amp;quot;
    exec docker
end script

post-start script
    # do something after start
end script

# 检查语法错误
$ sudo init-checkconf /etc/init/docker.conf

# 注册服务
$ sudo initctl reload-configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Nginx</title>
        <link>https://canuxcheng.com/post/nginx/</link>
        <pubDate>Thu, 27 Sep 2018 03:25:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/nginx/</guid>
        <description>&lt;h1 id=&#34;nginx&#34;&gt;Nginx&lt;/h1&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nginx -s stop/quit/reload/reopen
nginx -V 详细信息
nginx -v 版本号
nginx -t 检查配置文件
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>AST</title>
        <link>https://canuxcheng.com/post/sec_ast/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_ast/</guid>
        <description>&lt;h1 id=&#34;ast&#34;&gt;AST&lt;/h1&gt;
&lt;p&gt;AST: Application Security Testing, 静态应用程序安全测试, 对应用程序源代码执行直接的白盒分析.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sast&#34;&gt;SAST&lt;/h2&gt;
&lt;p&gt;SAST: Static Application Security Testing&lt;/p&gt;
&lt;p&gt;Tools: SonarQube, Trivy, Coverity.&lt;/p&gt;
&lt;p&gt;gitlab SAST report.
gitlab secret detection report.&lt;/p&gt;
&lt;h3 id=&#34;trivy&#34;&gt;trivy&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/aquasecurity/trivy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aquasecurity/trivy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Trivy是一个开源的安全扫描工具，支持容器镜像、文件系统和Git仓库的漏洞扫描。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;trivy image &amp;lt;image&amp;gt;
trivy fs &amp;lt;path&amp;gt;
trivy repo &amp;lt;repo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;coverity&#34;&gt;Coverity&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://scan.coverity.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://scan.coverity.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Coverity是一个商业的静态代码分析工具，主要用于发现代码中的缺陷和安全漏洞。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cov-init
cov-build
cov-analyze
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dast&#34;&gt;DAST&lt;/h2&gt;
&lt;p&gt;DAST: Dynamic Application Security Testing，动态应用程序安全测试, 对应用程序进行黑盒分析.&lt;/p&gt;
&lt;p&gt;Tools:&lt;/p&gt;
&lt;p&gt;ZAP Scan(OWASP ZAP)&lt;/p&gt;
&lt;p&gt;synopsys WhiteHat Sentinel.&lt;/p&gt;
&lt;p&gt;gitlab DAST report.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;iast&#34;&gt;IAST&lt;/h2&gt;
&lt;p&gt;IAST: Interactive Application Security Testing，交互式应用程序安全测试, 结合了SAST和DAST的优点.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sca&#34;&gt;SCA&lt;/h2&gt;
&lt;p&gt;SCA: Software Composition Analysis.&lt;/p&gt;
&lt;p&gt;SBOM (software Bill of Materials),开源组件安全扫描.&lt;/p&gt;
&lt;p&gt;Tools： BlackDuck, Jfrog Xray.&lt;/p&gt;
&lt;p&gt;gitlab dependency scanning report.&lt;/p&gt;
&lt;h3 id=&#34;blackduck&#34;&gt;Blackduck&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.blackducksoftware.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.blackducksoftware.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blackduck是一个商业的开源组件安全扫描工具，主要用于发现开源组件中的漏洞和许可证问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;detect.sh ......
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>CA</title>
        <link>https://canuxcheng.com/post/sec_ca/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_ca/</guid>
        <description>&lt;h1 id=&#34;ca&#34;&gt;CA&lt;/h1&gt;
&lt;p&gt;SSL: secure sockets layer&lt;/p&gt;
&lt;p&gt;TLS: transport layer security&lt;/p&gt;
&lt;p&gt;CA: Certificate Authority.&lt;/p&gt;
&lt;p&gt;SNI: server name indication&lt;/p&gt;
&lt;p&gt;证书类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x509: 只有公钥没有私钥匙&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编码方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pem: base64编码&lt;/li&gt;
&lt;li&gt;der: 二进制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证书文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;crt: 证书文件（可以是pem或der编码）&lt;/li&gt;
&lt;li&gt;cer: 证书文件（可以是pem或der编码）&lt;/li&gt;
&lt;li&gt;csr: 申请签名的文件&lt;/li&gt;
&lt;li&gt;key: 私钥文件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;创建自签名证书&#34;&gt;创建自签名证书&lt;/h1&gt;
&lt;p&gt;创建x509证书:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl genrsa -out server.key 2048   // 创建key
$ openssl req -new -key server.key -sha256 -out server.csr // 创建csr
$ openssl x509 -req -days 365 -in server.csr -signkey server.key -sha256 -out server.crt // 创建证书
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看证书信息:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// pem编码
$ openssl x509 -in cert.pem -noout -text
// der编码
$ openssl x509 -in cert.der -inform der -noout -text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看证书有效期:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl x509 -in ca.domain.com.crt -noout -dates
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;客户端&#34;&gt;客户端&lt;/h1&gt;
&lt;p&gt;客户端需要信任证书.&lt;/p&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 添加
$ cp my-cert.crt /usr/local/share/ca-certificates/my-cert.crt
$ sudo update-ca-certificates

// 删除
$ rm /usr/local/share/ca-certificates/my-cert.crt
$ sudo update-ca-certificates --fresh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 添加
certutil -addstore -f &amp;quot;ROOT&amp;quot; my-cert.crt

// 删除
certutil -delstore &amp;quot;ROOT&amp;quot; my-cert.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;证书验证&#34;&gt;证书验证&lt;/h1&gt;
&lt;p&gt;系统默认的根证书在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/ssl/certs.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python的requests包默认使用根证书在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/lib/python3.6/site-packages/requests/cacert.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;requests也通过certifi来管理根证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/lib/python3.6/site-packages/certifi/cacert.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过设置REQUESTS_CA_BUNDLE环境变量来让requests使用系统的根证书。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Capture</title>
        <link>https://canuxcheng.com/post/sec_capture/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_capture/</guid>
        <description>&lt;h1 id=&#34;packet-capture&#34;&gt;Packet Capture&lt;/h1&gt;
&lt;p&gt;网络抓包&lt;/p&gt;
&lt;h1 id=&#34;fiddler&#34;&gt;Fiddler&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.telerik.com/fiddler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.telerik.com/fiddler&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;wireshark&#34;&gt;Wireshark&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wireshark.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wireshark.org/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Csrf</title>
        <link>https://canuxcheng.com/post/sec_csrf/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_csrf/</guid>
        <description>&lt;h1 id=&#34;csrf&#34;&gt;CSRF&lt;/h1&gt;
&lt;p&gt;Cross-site request forgery, 跨站请求伪造．&lt;/p&gt;
&lt;p&gt;发生条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登陆受信任网站A, 并在本地生成cookie&lt;/li&gt;
&lt;li&gt;在不退出A的情况下，访问危险网站B&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预防方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确使用get,post和cookie&lt;/li&gt;
&lt;li&gt;在非get请求中增加伪随机数&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>HA</title>
        <link>https://canuxcheng.com/post/ha/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ha/</guid>
        <description>&lt;h1 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.haproxy.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.haproxy.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install haproxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/haproxy/haproxy.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;global:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    log /dev/log    local0
    log /dev/log    local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

    # Default SSL material locations
    ca-base /etc/ssl/certs
    crt-base /etc/ssl/private

    # Default ciphers to use on SSL-enabled listening sockets.
    # For more information, see ciphers(1SSL). This list is from:
    #  https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
    # An alternative list with additional directives can be obtained from
    #  https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy
    ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS
    ssl-default-bind-options no-sslv3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;defaults:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect 5000
    timeout client  50000
    timeout server  50000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;frontend:&lt;/p&gt;
&lt;p&gt;backend:&lt;/p&gt;
&lt;p&gt;listen:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;keepalived&#34;&gt;Keepalived&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.keepalived.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.keepalived.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/keepalived/keepalived.conf
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Security</title>
        <link>https://canuxcheng.com/post/sec_security/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_security/</guid>
        <description>&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nvd.nist.gov/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nvd.nist.gov/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://cve.scap.org.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://cve.scap.org.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;gfw&#34;&gt;GFW&lt;/h1&gt;
&lt;h1 id=&#34;ngfw&#34;&gt;NGFW&lt;/h1&gt;
&lt;h1 id=&#34;utm&#34;&gt;UTM&lt;/h1&gt;
&lt;p&gt;Unified Threat Management, 安全网关&lt;/p&gt;
&lt;p&gt;BUV: Block Until Verdict&lt;/p&gt;
&lt;h1 id=&#34;waf&#34;&gt;WAF&lt;/h1&gt;
&lt;p&gt;Web Application Firewall, web应用防火墙&lt;/p&gt;
&lt;h1 id=&#34;ips&#34;&gt;IPS&lt;/h1&gt;
&lt;p&gt;Intrusion Prevention System, 入侵防御系统&lt;/p&gt;
&lt;h1 id=&#34;ids&#34;&gt;IDS&lt;/h1&gt;
&lt;p&gt;Intrusion Detection System, 入侵检测系统&lt;/p&gt;
&lt;h1 id=&#34;nsm&#34;&gt;NSM&lt;/h1&gt;
&lt;p&gt;Network Security Monitoring, 网络安全监控&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Sql Injection</title>
        <link>https://canuxcheng.com/post/sec_sqlinjection/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_sqlinjection/</guid>
        <description>&lt;h1 id=&#34;sql-injection&#34;&gt;SQL Injection&lt;/h1&gt;
&lt;p&gt;什么是sql injection:从数据库获取敏感信息,或者利用数据库的特性执行添加用户,导出文件等一系列恶意操作,甚至有可能获取数据库乃至系统用户最高权限。&lt;/p&gt;
&lt;p&gt;原因:造成SQL注入的原因是因为程序没有有效过滤用户的输入.&lt;/p&gt;
&lt;p&gt;预防：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;严格限制数据库的操作权限&lt;/li&gt;
&lt;li&gt;检查输入的数据格式是否符合要求&lt;/li&gt;
&lt;li&gt;对进入数据库的特殊字符进行转义&lt;/li&gt;
&lt;li&gt;数据库查询语句使用数据库提供的参数化查询接口&lt;/li&gt;
&lt;li&gt;在发布之前使用专业的sql注入检测工具进行检测&lt;/li&gt;
&lt;li&gt;避免网站打印sql错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过表单注入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;username =&amp;gt; myuser&#39; or &#39;foo&#39; = &#39;foo&#39; --
SELECT * FROM user WHERE username=&#39;myuser&#39; or &#39;foo&#39; = &#39;foo&#39; --&#39;&#39; AND password=&#39;xxx&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mssql的sql语句可以执行dos命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec xp_cmdshell &#39;net user username 2546 /add&#39; # 新建系统用户
exec xp_cmdshell &#39;net localgroup administrator username /add&#39; # 授权
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Xss</title>
        <link>https://canuxcheng.com/post/sec_xss/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_xss/</guid>
        <description>&lt;h1 id=&#34;xss&#34;&gt;XSS&lt;/h1&gt;
&lt;p&gt;XSS: Cross Site Scripting, 跨站脚本攻击&lt;/p&gt;
&lt;p&gt;XSS攻击涉及到攻击者，客户端，和web应用三者.&lt;/p&gt;
&lt;p&gt;XSS原理:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web应用未对用户提交请求的数据做充分的检查过滤,允许用户在提交的数据中掺入HTML代码(最主要的是“&amp;gt;”、“&amp;lt;”),并将未经转义的恶意代码输出到第三方用户的浏览器解释执行,是导致XSS漏洞的产生原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XSS目前主要手段和目的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盗用cookie,获取敏感信息&lt;/li&gt;
&lt;li&gt;利用植入flash，通过crossdomain权限设置获取更高权限．&lt;/li&gt;
&lt;li&gt;利用iframe, frame, XMLHttpRequests等方式以用户身份执行一些管理操作．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XSS预防:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤特殊字符&lt;/li&gt;
&lt;li&gt;使用http头指定类型&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Cfssl</title>
        <link>https://canuxcheng.com/post/sec_cfssl/</link>
        <pubDate>Sat, 28 Jul 2018 16:08:54 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_cfssl/</guid>
        <description>&lt;h1 id=&#34;cfssl&#34;&gt;cfssl&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cloudflare/cfssl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cloudflare/cfssl&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Gin</title>
        <link>https://canuxcheng.com/post/gin/</link>
        <pubDate>Fri, 20 Jul 2018 23:14:07 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/gin/</guid>
        <description>&lt;h1 id=&#34;gin&#34;&gt;Gin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gin-gonic/gin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gin-gonic/gin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get -u github.com/gin-gonic/gin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;import&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;github.com/gin-gonic/gin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Restful</title>
        <link>https://canuxcheng.com/post/rest/</link>
        <pubDate>Sat, 07 Jul 2018 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/rest/</guid>
        <description>&lt;h1 id=&#34;rest&#34;&gt;REST&lt;/h1&gt;
&lt;p&gt;REST: REpresentational State Transfer．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;restclient&#34;&gt;restclient&lt;/h1&gt;
&lt;p&gt;一个是firefox的插件．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/chao/RESTClient&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/chao/RESTClient&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另一个是java开发的application.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wiztools/rest-client&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wiztools/rest-client&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;postman&#34;&gt;postman&lt;/h1&gt;
&lt;p&gt;postman是一个application,同时也可以从chrome启动.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/postmanlabs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/postmanlabs&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;soupui&#34;&gt;soupui&lt;/h1&gt;
&lt;p&gt;一个用于SOAP和REST的application.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SmartBear/soapui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/SmartBear/soapui&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Webhook</title>
        <link>https://canuxcheng.com/post/webhook/</link>
        <pubDate>Sat, 07 Jul 2018 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/webhook/</guid>
        <description>&lt;h1 id=&#34;webhook&#34;&gt;WebHook&lt;/h1&gt;
&lt;p&gt;用于server和server之间通讯．&lt;/p&gt;
</description>
        </item>
        <item>
        <title>WebService</title>
        <link>https://canuxcheng.com/post/webservice/</link>
        <pubDate>Sat, 07 Jul 2018 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/webservice/</guid>
        <description>&lt;h1 id=&#34;webservice&#34;&gt;webservice&lt;/h1&gt;
&lt;p&gt;webservice用于server和browser之间通讯．&lt;/p&gt;
&lt;p&gt;webservice是基于http的，无状态的．&lt;/p&gt;
&lt;p&gt;webservice一般分为soap webservice和http webservice.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;soap&#34;&gt;SOAP&lt;/h1&gt;
&lt;p&gt;Simple Object Access Protocol, 简单对象访问协议，是一个基于XML的协议．&lt;/p&gt;
&lt;p&gt;简单来说SOAP的思想就是通过http + XML来在server和browser之间交换信息．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;soupui&#34;&gt;soupui&lt;/h1&gt;
&lt;p&gt;一个用于SOAP和REST的application.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SmartBear/soapui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/SmartBear/soapui&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ELK</title>
        <link>https://canuxcheng.com/post/logging_elk/</link>
        <pubDate>Fri, 08 Jun 2018 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/logging_elk/</guid>
        <description>&lt;h1 id=&#34;elk&#34;&gt;ELK&lt;/h1&gt;
&lt;p&gt;kibana: 数据可视化&lt;/p&gt;
&lt;p&gt;elasticsearch: 搜索，分析，存储数据&lt;/p&gt;
&lt;p&gt;x-pack: 具有监控和报警功能的工具包.&lt;/p&gt;
&lt;p&gt;logstash: 动态数据收集管道，支持可扩展的插件．&lt;/p&gt;
&lt;p&gt;beats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Grok</title>
        <link>https://canuxcheng.com/post/logging_grok/</link>
        <pubDate>Fri, 08 Jun 2018 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/logging_grok/</guid>
        <description>&lt;h1 id=&#34;grok&#34;&gt;grok&lt;/h1&gt;
&lt;p&gt;logstash和telegraf都是用grok来解析log&lt;/p&gt;
&lt;p&gt;在线检测&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://grokdebug.herokuapp.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://grokdebug.herokuapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;grok的正则表达式&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kkos/oniguruma/blob/master/doc/RE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kkos/oniguruma/blob/master/doc/RE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可用的pattern(logstash &amp;amp; telegraf-logparser/tail)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;elastic-stack&#34;&gt;Elastic stack&lt;/h1&gt;
&lt;p&gt;beats/filebeats: 通过filebeats agent获取log．&lt;/p&gt;
&lt;p&gt;logstash: 使用filebeats解析log并写入stash(elasticsearch).&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tick-stack&#34;&gt;TICK stack&lt;/h1&gt;
&lt;p&gt;telegraf(agent): 通过logparser/tail插件解析log并写入influxdb.&lt;/p&gt;
&lt;p&gt;pattern:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过已经定义的变量来定义filter
patterns = [&#39;&#39;&#39;${&amp;lt;capture_syntax&amp;gt;[:&amp;lt;semantic_name&amp;gt;][:&amp;lt;modifier&amp;gt;]}&#39;&#39;&#39;]
patterns = [&#39;&#39;&#39;%{TIMESTAMP_ISO8601:asctime:string} \[%{DATA:name:string}\] %{LOGLEVEL:levelname:string}: %{GREEDYDATA:message:string}&#39;&#39;&#39;]

capture_syntax是已经定义好的pattern.
semantic_name是field/tag的名字, 默认都是string类型的field
modifier 是string/int/float/tag/drop/ts-&amp;quot;CUSTOM&amp;quot;/...类型

timestamp有特殊的modifier:
timestamp 有特殊的modifier：
Timestamp modifiers:ts (This will auto-learn the timestamp format)
ts-ansic (&amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;)
ts-unix (&amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;)
ts-ruby (&amp;quot;Mon Jan 02 15:04:05 -0700 2006&amp;quot;)
ts-rfc822 (&amp;quot;02 Jan 06 15:04 MST&amp;quot;)
ts-rfc822z (&amp;quot;02 Jan 06 15:04 -0700&amp;quot;)
ts-rfc850 (&amp;quot;Monday, 02-Jan-06 15:04:05 MST&amp;quot;)
ts-rfc1123 (&amp;quot;Mon, 02 Jan 2006 15:04:05 MST&amp;quot;)
ts-rfc1123z (&amp;quot;Mon, 02 Jan 2006 15:04:05 -0700&amp;quot;)
ts-rfc3339 (&amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;)
ts-rfc3339nano (&amp;quot;2006-01-02T15:04:05.999999999Z07:00&amp;quot;)
ts-httpd (&amp;quot;02/Jan/2006:15:04:05 -0700&amp;quot;)
ts-epoch (seconds since unix epoch, may contain decimal)
ts-epochnano (nanoseconds since unix epoch)
ts-syslog (&amp;quot;Jan 02 15:04:05&amp;quot;, parsed time is set to the current year)
ts-&amp;quot;CUSTOM&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;custom_patterns:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过正则表达式或已经定义的变量来定义新的变量
# 一行一个
custom_patterns = &#39;&#39;&#39;
    LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL)
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;logparser:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[inputs.logparser]]
files = [&amp;quot;/opt/sandbox/logs/appliance.log&amp;quot;]
from_beginning = false
watch_method = &amp;quot;inotify&amp;quot;
[inputs.logparser.grok]
  patterns = [&#39;&#39;&#39;
    %{TIMESTAMP_ISO8601:timestamp:ts-&amp;quot;2006-01-02 15:04:05.000&amp;quot;}
    \[%{DATA:name:string}\]
    %{LOGLEVEL_PYTHON:levelname:tag}:
    %{GREEDYDATA:message:string}&#39;&#39;&#39;]
  measurement = &amp;quot;log_test&amp;quot;
  custom_pattern_files = []
  custom_patterns = &#39;&#39;&#39;LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL)&#39;&#39;&#39;
  timezone = &amp;quot;Local&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tail:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[inputs.tail]]
files = [&amp;quot;/opt/sandbox/logs/appliance.log&amp;quot;]
from_beginning = false
pipe = false
watch_method = &amp;quot;inotify&amp;quot;
data_format = &amp;quot;grok&amp;quot;

grok_patterns = [&#39;&#39;&#39;%{TIMESTAMP_ISO8601:timestamp:ts-&amp;quot;2006-01-02 15:04:05.000&amp;quot;}
  \[%{DATA:name:string}\] %{LOGLEVEL_PYTHON:levelname:tag}:
  %{GREEDYDATA:message:string}&#39;&#39;&#39;]
grok_custom_patterns = &#39;&#39;LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL)&#39;&#39;&#39;
grok_timezone = &amp;quot;Local&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Logging</title>
        <link>https://canuxcheng.com/post/logging/</link>
        <pubDate>Fri, 08 Jun 2018 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/logging/</guid>
        <description>&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;
&lt;p&gt;日志采集，存储，可视化.&lt;/p&gt;
&lt;p&gt;主要有Elastic stack, splunk, loki.&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Loki</title>
        <link>https://canuxcheng.com/post/logging_loki/</link>
        <pubDate>Fri, 08 Jun 2018 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/logging_loki/</guid>
        <description>&lt;h1 id=&#34;elk&#34;&gt;ELK&lt;/h1&gt;
&lt;p&gt;kibana: 数据可视化&lt;/p&gt;
&lt;p&gt;elasticsearch: 搜索，分析，存储数据&lt;/p&gt;
&lt;p&gt;x-pack: 具有监控和报警功能的工具包.&lt;/p&gt;
&lt;p&gt;logstash: 动态数据收集管道，支持可扩展的插件．&lt;/p&gt;
&lt;p&gt;beats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Dns</title>
        <link>https://canuxcheng.com/post/dns/</link>
        <pubDate>Thu, 03 May 2018 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/dns/</guid>
        <description>&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;
&lt;p&gt;Domain Name System: 域名系统&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Container</title>
        <link>https://canuxcheng.com/post/cncf_container/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_container/</guid>
        <description>&lt;h1 id=&#34;container&#34;&gt;Container&lt;/h1&gt;
&lt;p&gt;OCI: Open Container Initiative.&lt;/p&gt;
&lt;p&gt;CRI: Container Runtime Interface.&lt;/p&gt;
&lt;p&gt;CNI: Container Network Interface.&lt;/p&gt;
&lt;p&gt;CSI: Container Storage Interface.&lt;/p&gt;
&lt;h1 id=&#34;oci&#34;&gt;OCI&lt;/h1&gt;
&lt;p&gt;Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作.&lt;/p&gt;
&lt;p&gt;是container的标准.&lt;/p&gt;
&lt;p&gt;目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.opencontainers.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.opencontainers.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;runc&#34;&gt;runc&lt;/h2&gt;
&lt;p&gt;docker(libcontainer)&lt;/p&gt;
&lt;p&gt;runc支持OCI.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/opencontainers/runc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/opencontainers/runc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;rkt&#34;&gt;rkt&lt;/h2&gt;
&lt;p&gt;redhat(coreos)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rkt/rkt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rkt/rkt&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tools&#34;&gt;tools&lt;/h1&gt;
&lt;h2 id=&#34;dumb-init&#34;&gt;dumb-init&lt;/h2&gt;
&lt;p&gt;管理pid=1的进程的子进程:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Yelp/dumb-init&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Yelp/dumb-init&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;baseimage-docker&#34;&gt;baseimage-docker&lt;/h2&gt;
&lt;p&gt;处理container中运行多个进程的问题:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/phusion/baseimage-docker&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/phusion/baseimage-docker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;watchtower&#34;&gt;watchtower&lt;/h2&gt;
&lt;p&gt;根据registry中的更新自动更新 container:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/containrrr/watchtower/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/containrrr/watchtower/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;hadolint&#34;&gt;hadolint&lt;/h2&gt;
&lt;p&gt;dockerfile 语法检查:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hadolint/hadolint&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hadolint/hadolint&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gosu&#34;&gt;gosu&lt;/h2&gt;
&lt;p&gt;权限管理&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tianon/gosu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tianon/gosu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;swarm-cronjob&#34;&gt;swarm-cronjob&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-max/swarm-cronjob&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-max/swarm-cronjob&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;misc&#34;&gt;misc&lt;/h1&gt;
&lt;p&gt;get host ip(docker/docker_gwbridge) from container:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip route | awk &#39;/default/ { print $3 }&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Docker</title>
        <link>https://canuxcheng.com/post/cncf_docker/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_docker/</guid>
        <description>&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://store.docker.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://store.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/moby/moby&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/moby/moby&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker是一个容器引擎, 分为社区版CE, 和企业版EE, Docker不是虚拟机, 也不依赖虚拟化技术．&lt;/p&gt;
&lt;p&gt;docker-cli -&amp;gt; dockerd -&amp;gt; containerd -&amp;gt; shim -&amp;gt; runc&lt;/p&gt;
&lt;p&gt;containerd是容器运行时管理引擎.&lt;/p&gt;
&lt;p&gt;shim用于管理容器生命周期.&lt;/p&gt;
&lt;p&gt;Docker包括三个基本概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仓库repository,集中存放镜像文件的场所,docker hub/store是最大的公开仓库．&lt;/li&gt;
&lt;li&gt;镜像image, 镜像是一个文件系统.&lt;/li&gt;
&lt;li&gt;容器container, 容器是镜像的运行的实例．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改docker存储路径:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ service docker stop
$ mv /var/lib/docker /opt/ssd/docker
$ ln -s /opt/ssd/docker /var/lib/docker
$ service docker start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;windows:
&amp;lt;https://docs.docker.com/docker-for-windows/install/&amp;gt;

linux:
&amp;lt;https://docs.docker.com/engine/install/ubuntu/&amp;gt;

mac:
&amp;lt;https://github.com/abiosoft/colima/blob/main/docs/FAQ.md#docker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;config&#34;&gt;config&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker配置文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/docker/daemon.json
/lib/systemd/system/docker.service

{
    // debug
    &amp;quot;debug&amp;quot;: true,
    
    &amp;quot;data-root&amp;quot;： &amp;quot;/var/lib/docker&amp;quot;,
    
    &amp;quot;features&amp;quot;: {
        &amp;quot;buildkit&amp;quot;: true
    },

    //容器访问外网:
    ip-forward=true 会设置 net.ipv4.ip_forward=1, 才能访问外网
    // 容器之间访问:
    icc=true, 
    iptables=true  会修改iptables的forward策略为accept,

    // 修改默认docker0
    &amp;quot;bridge&amp;quot;:
    &amp;quot;bip&amp;quot;: &amp;quot;10.0.0.1/16&amp;quot;  // subnet + gateway
    &amp;quot;fixed-cidr&amp;quot;: &amp;quot;10.41.0.0/24&amp;quot; // iprange
    &amp;quot;fixed-cidr-v6&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;mtu&amp;quot;: 1500
    &amp;quot;default-gateway&amp;quot;:
	&amp;quot;default-gateway-v6&amp;quot;: &amp;quot;&amp;quot;,

    // 修改默认dns
    &amp;quot;dns&amp;quot; : [
        &amp;quot;114.114.114.114&amp;quot;,
        &amp;quot;8.8.8.8&amp;quot;
    ]
    &amp;quot;dns-opts&amp;quot;: [],
    &amp;quot;dns-search&amp;quot;: [],

    // ipv6
    &amp;quot;ipv6&amp;quot;: true

    // private registry
  	&amp;quot;insecure-registries&amp;quot;: [],

    // 修改registry
    &amp;quot;registry-mirrors&amp;quot;: [
        &amp;quot;https://registry.docker-cn.com&amp;quot;,
        &amp;quot;https://z4yd270h.mirror.aliyuncs.com&amp;quot;,
        &amp;quot;http://f1361db2.m.daocloud.io&amp;quot;,
        &amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;
    ]

    &amp;quot;hosts&amp;quot;: [],
    &amp;quot;log-level&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;tls&amp;quot;: true,
    &amp;quot;tlsverify&amp;quot;: true,
    &amp;quot;tlscacert&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;tlscert&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;tlskey&amp;quot;: &amp;quot;&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proxy for pull image from google(gcr):&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/config/daemon/systemd/#httphttps-proxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/config/daemon/systemd/#httphttps-proxy&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;docker命令&#34;&gt;docker命令&lt;/h2&gt;
&lt;p&gt;system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker system df	// Show docker disk usage
$ docker system events	// Get real time events from the server
$ docker system info	// Display system-wide information
$ docker system prune	// Remove unused data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;image管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker image COMMAND

&amp;gt; 查看本地镜像:
$ docker image ls
$ docker image -a

&amp;gt; 根据创建dockerfile，创建新的images
$ docker image build

&amp;gt; 创建tag
$ docker image tag

&amp;gt; 删除image
$ docker image rm &amp;lt;IMAGE ID&amp;gt;
$ docker rmi &amp;lt;IMAGE ID&amp;gt;
&amp;gt; 删除所有image
$ docker rmi $(docker images -a -q)

&amp;gt; 清理所有临时images
$ docker image prune
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;container管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$docker container COMMAND

# 列出container:
$ docker container ls
$ docker ps -a  # 默认只显示running状态的

# 运行image,产生一个container:
$ docker container run &amp;lt;IMAGE ID&amp;gt;/&amp;lt;REPOSITORY&amp;gt; [COMMAND] [ARGS]

# 在container中执行命令
$ docker container exec [OPTIONS] &amp;lt;CONTAINER&amp;gt; COMMAND [ARG...]

# 创建container但不启动
$ docker container create --name &amp;lt;name&amp;gt; &amp;lt;CONTAINER&amp;gt;

# 启动container:
$ docker container start/restart &amp;lt;CONTAINER&amp;gt;

# 停止container:
$ docker container stop &amp;lt;CONTAINER&amp;gt;

# 删除container：
$ docker container rm &amp;lt;CONTAINER&amp;gt;
$ docker rm &amp;lt;CONTAINER&amp;gt;
# 删除所有容器
$ docker rm $(docker ps -a -q) 

# 清理停止的container
$ docker container prune
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作镜像builder&lt;/p&gt;
&lt;p&gt;build: deprecated.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 根据Dockerfile 构建image
docker builder [OPTIONS] PATH | URL | -
docker builder build .  // 默认就是当前目录的Dockerfile
docker builder build -t &amp;lt;repo&amp;gt;/&amp;lt;name&amp;gt;:&amp;lt;tag&amp;gt; .  // 创建tag
docker builder build -f /path/to/mydockerfile . // 也可以指定其它路径的其它文件
docker builder build --target &amp;lt;stage&amp;gt; . // 指定阶段构建.
docker builder build ... --network=host // 使用host网络构建.
docker builder build --no-cache // 不使用缓存数据
--cache-from // 使用本地或registry上的cache
--cache-to // cache存到本地或registry
--progress = auto/plain/tty,  // plain 显示更多log。 

docker builder prune --all // 清理所有image 的缓存。

# 把image导出到tar包
# 既可以从image也可以从container导出。
# 从container导出不包含运行后的修改，只导出原始镜像。
$ docker save -o name.tgz &amp;lt;repo1&amp;gt;:&amp;lt;tag1&amp;gt; &amp;lt;repo2&amp;gt;:&amp;lt;tag2&amp;gt; ...

# 从stdin或文件加载image
docker load [OPTIONS]
docker load &amp;lt; name.tar.gz
docker load --input/-i name.tar

# 把container导出到tar包，从container导出镜像。
# 包括container启动后的修改。
docker export -o name.tar [container]

# 从container导出的包加载成镜像
docker import name.tar [repo]:[tag]

# 根据container的修改创建新的image
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
docker commit -a &amp;quot;author&amp;quot; -c &amp;quot;Dockerfile instruction&amp;quot; -m &amp;quot;commit message&amp;quot; CONTAINER [REPOSITORY[:TAG]]

# 创建新的tag
docker tag &amp;lt;old&amp;gt; &amp;lt;new&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个新的container并运行命令
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
docker run --name [NAME] IMAGE // 运行容器并命名
docker run -d IMAGE // 后台运行
docker run -it IMAGE /bin/bash // 交互模式启动容器
docker run -P IMAGE // 默认将容器的8０端口映射到主机的随机端口
docker run -p [host:port]:[containerPort] // 指定映射端口
--add-host # 相当于修改容器的/etc/hosts,但是容器重启后不会消失
-h/--hostname # 修改容器的/etc/hostname

// cpu
--cpus decimal                   Number of CPUs
-c, --cpu-shares int             CPU shares (relative weight)
--cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)
--cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)
--cpu-period
--cpu-quota

// memory
-m, --memory bytes               Memory limit
--memory-reservation bytes       Memory soft limit
--memory-swap bytes              Swap limit equal to memory plus swap: &#39;-1&#39; to enable unlimited swap
--memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)
--oom-kill-disable
--oom-score-adj
--kernel-memory

// io
--blkio-weight
--blkio-weight-device
--device-read-bps
--device-write-bps
--device-read-iops
--device-write-iops

// security
// https://docs.docker.com/engine/security/apparmor/
// https://docs.docker.com/engine/security/seccomp/
// https://docs.docker.com/engine/security/userns-remap/
// https://docs.docker.com/engine/security/rootless/
privileged
sysctl
ulimit
user
userns
security_ops
cgroup_parent
cap_add
cap_drop

# 在运行的container中执行命令
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
docker exec -d CONTAINER ... // 在后台运行
docker exec -it CONTAINER /bin/bash ... // 进入命令行

# metrics
docker stats

# resource
docker top
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;log:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看log driver
// 默认driver是 json-file, 不同的driver，option不同
// driver是json-file, journald, 通过docker logs docker-compose logs 才能看到log
$ docker inspect -f &#39;{{.HostConfig.LogConfig.Type}}&#39; &amp;lt;ID&amp;gt;

docker run -it --log-driver &amp;lt;driver&amp;gt; --log-opt mode=blocking --log-opt max-buffer-size=4m alpine ash  
// --log-driver json-file
// --log-opt mode blocking/non-blocking
// --log-opt max-buffer-size 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其它命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在container和host之前拷贝文件和目录
docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH

# 查看容器的日志
docker logs [OPTIONS] CONTAINER
docker diff CONTAINER
docker history [OPTIONS] IMAGE

# 查看healthcheck的log
docker inspect --format &amp;quot;{{json .State.Health }}&amp;quot; &amp;lt;container name&amp;gt; | jq

docker system prune
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;register使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 登陆到docker hub 或其他register
docker login
docker login -u/--username &amp;lt;user&amp;gt; -p/--password &amp;lt;password&amp;gt;

# 从docker hub/store查找images
$ docker search [OPTIONS] TERM
$ docker search

# 从registry获取repository/images到/var/lib/docker：
$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]
$ docker pull
$ docker pull ubuntu # 默认下载所有tag
$ docker pull ubuntu:14.04

# 从中国站点下载
$ docker pull registry.docker-cn.com/library/ubuntu:16.04

# 推送到docker hub
$ docker push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;secret&lt;/p&gt;
&lt;p&gt;secret以文件形式存在于/run/secrets/&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 保存敏感数据
$ docker secret

docker secret ls
docker secret inspect &amp;lt;ID/name&amp;gt;
docker secret rm &amp;lt;id/name&amp;gt;

// 根据文件创建
docker secret create &amp;lt;s-name&amp;gt; &amp;lt;s-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;config&lt;/p&gt;
&lt;p&gt;config以文件形式存在于/&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 保存非敏感数据
$ docker config

docker config ls
docker config inspect &amp;lt;id/name&amp;gt;
docker config rm &amp;lt;id/name&amp;gt;

docker config create &amp;lt;c-name&amp;gt; &amp;lt;c-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plugin&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 安装plugin
docker plugin install --grant-all-permissions name:tag key=value key=value
// 修改plugin的参数
docker plugin set name:tag key=value
// 查看plugin的参数，settable里面的是改参数能修改的变量
docker plugin inspect name:tag
// 激活plugin
docker plugin enable name:tag
// 删除
docker plugin rm name:tag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发插件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker plugin create name:tag ./plugin
docker plugin push name:tag
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;每个命令都会创建一个layer,尽可能合并相同的命令。&lt;/p&gt;
&lt;p&gt;ADD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# add可以是远程文件，不推荐使用
ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&amp;quot;&amp;lt;src&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;dest&amp;gt;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;COPY&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 只能操作本地文件, 目标路径不需要创建，不存在会自动创建.
COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&amp;quot;&amp;lt;src&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;dest&amp;gt;&amp;quot;]
COPY file /path/to/file  相当于 COPY file /path
# 不会创建目录
COPY folder /path 相当于 COPY folder/* /path/
# 需要手动指定
COPY folder  /path/to/folder 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ENV&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;env会被派生image继承。

# 指定容器中的环境变量
ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EXPOSE&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expose会被派生image继承.
# 指定容器需要映射到主机的端口
EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;/&amp;lt;protocol&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FROM&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt; [AS &amp;lt;name&amp;gt;]
FROM &amp;lt;image&amp;gt;[:&amp;lt;tag&amp;gt;] [AS &amp;lt;name&amp;gt;]
FROM &amp;lt;image&amp;gt;[@&amp;lt;digest&amp;gt;] [AS &amp;lt;name&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LABEL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label会被派生image继承.
LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;STOPSIGNAL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;STOPSIGNAL signal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;USER&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;USER &amp;lt;user&amp;gt;[:&amp;lt;group&amp;gt;]
USER &amp;lt;UID&amp;gt;[:&amp;lt;GID&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;VOLUME&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定挂载点做数据持久化
VOLUME [&amp;quot;/data&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WORKDIR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;workdir会被派生image继承.
# 指定后的操作都以该目录为当前目录，目录不存在会自动创建
WORKDIR /path/to/workdir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RUN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在容器构建过程中运行
RUN &amp;lt;command&amp;gt;  # shell 格式
RUN [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]   # exec 格式

RUN set -ex \
&amp;amp;&amp;amp; cmd1 \
&amp;amp;&amp;amp; cmd2......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ENTRYPOINT&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;entrypoint会被派生image继承，除非你在派生image重新指定.
# 和cmd类似,指定容器运行过程中的执行命令
ENTRYPOINT [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;] (exec form, preferred)
ENTRYPOINT command param1 param2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CMD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd会被派生image继承，除非你在派生image重新指定了entrypoint.
# 在容器运行过程中运行, 可以被覆盖
CMD [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]  # exec格式
CMD command param1 param2   # shell 格式,通过/bin/bash 或 /bin/sh 执行.
// 同时有cmd和entrypoint,cmd只是entrypoint的参数.
CMD [&amp;quot;param2&amp;quot;, &amp;quot;param2&amp;quot;]   # entrypoint的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ARG&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定构建环境的变量
ARG &amp;lt;name&amp;gt;[=&amp;lt;default value&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ONBUILD&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onbuild会被派生image继承.
ONBUILD ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stage:&lt;/p&gt;
&lt;p&gt;多级构建，一般0级用来编译源代码，并且组织目录结构。
下一级直接将编译好的或者组织好的目录结构copy到指定位置。
这样最终的image不会含有源代码的overlay.
也不会有临时目录结构的overlay.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 不指定stage name, 默认就是数字
COPY --from=0 /path/folder /path/folder
COPY --from=stage1 /path/folder /path/folder 
docker build --target stage1 -t docker:latest . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.dockerignore &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
/path/folder
path/folder
*/tmp*
*/*/tmp*
tmp?
*.md
!README.md  
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;docker-machine&#34;&gt;docker-machine&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/machine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker/machine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在本地安装docker和docker-machine，然后就可以从本机安装或管理远程机器上的docker.&lt;/p&gt;
&lt;p&gt;需要添加ssh的无密码登陆:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote-ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://docs.docker.com/machine/install-machine/$ base=https://github.com/docker/machine/releases/download/v0.16.0
&amp;amp;&amp;amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &amp;gt;/tmp/docker-machine
&amp;amp;&amp;amp; sudo install /tmp/docker-machine /usr/local/bin/docker-machine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-machine命令&#34;&gt;docker-machine命令&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker-machine create -d generic \
--generic-ip-address=remote-ip \
--generic-ssh-user=user \
--generic-ssh-key ~/.ssh/id_rsa \
node1
docker-machine ls
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;oom&#34;&gt;OOM&lt;/h2&gt;
&lt;p&gt;kernel OOM 会导致kernel随机kill一些container释放内存。&lt;/p&gt;
&lt;p&gt;防止kernel OOM的方法就是设置resource limit.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/config/containers/resource_constraints/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/config/containers/resource_constraints/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/compose/issues/4513&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker/compose/issues/4513&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swarm mode:&lt;/p&gt;
&lt;p&gt;swarm模式使用compose format 3来限制资源.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/compose/compose-file/#resources&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/compose/compose-file/#resources&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;non swarm mode:&lt;/p&gt;
&lt;p&gt;非swarm模式可以用compose format 2 来做资源限制.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/compose/compose-file/compose-file-v2/#cpu-and-other-resources&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/compose/compose-file/compose-file-v2/#cpu-and-other-resources&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;colima&#34;&gt;colima&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/abiosoft/colima&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/abiosoft/colima&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker for mac&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install colima docker
colima start
brew services restart colima
sudo ln -sf /Users/canche01/.colima/default/docker.sock /var/run/docker.sock
docker ps -a
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Kubernetes</title>
        <link>https://canuxcheng.com/post/kubernetes/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/kubernetes/</guid>
        <description>&lt;h1 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kubeadm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kubeadm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kops&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kops&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/kubespray&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/kubespray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kubernetes简称k8s, 是开源的容器编排工具。&lt;/p&gt;
&lt;p&gt;安装单机版k8s:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;minikube&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装k8s集群:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubeadm (k8s内置的，类似于docker swarm mode, 没有HA)&lt;/li&gt;
&lt;li&gt;kops (目前主要支持aws等云平台, 国内不友好)&lt;/li&gt;
&lt;li&gt;kubespray (通过ansible部署, 国内不友好)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k8s发行版：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openshift-okd(redhat)&lt;/li&gt;
&lt;li&gt;rancher&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;k8s集群组成&#34;&gt;k8s集群组成&lt;/h1&gt;
&lt;h2 id=&#34;master&#34;&gt;master&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;aip-server, 提供资源操作唯一入口&lt;/li&gt;
&lt;li&gt;scheduler, 负责资源调度&lt;/li&gt;
&lt;li&gt;controller-manager, 负责维护集群状态&lt;/li&gt;
&lt;li&gt;etcd(可以部署单独集群), 保存整个集群的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;node&#34;&gt;node&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;kubelet, 负责维护容器生命周期, 还包括CNI CVI&lt;/li&gt;
&lt;li&gt;kube-proxy, 为service提供cluster内部的服务发现和负载均衡&lt;/li&gt;
&lt;li&gt;CRI(containerd), 创建pod&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;addons&#34;&gt;addons&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;coredns&lt;/li&gt;
&lt;li&gt;flannel/cilium/calico&lt;/li&gt;
&lt;li&gt;dashboard, web-gui&lt;/li&gt;
&lt;li&gt;metrics-server, 取代heapster，用于cpu/memory监控&lt;/li&gt;
&lt;li&gt;ingress-nginx, 为服务提供外网入口&lt;/li&gt;
&lt;li&gt;federation, 提供跨可用区的集群&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;k8s包含的重要概念:&lt;/p&gt;
&lt;p&gt;-: nodes, 运行pod的物理机或虚拟机.
-: namespace, 对资源和对象的抽象集合．pods/deployments/services都属于某个ns.
-: pods,一组紧密关联的容器集合，共享pid,ipc,network,uts,namespace.&lt;/p&gt;
&lt;p&gt;k8s业务类型:&lt;/p&gt;
&lt;p&gt;-: long-running 长期伺服型 -&amp;gt; RC, RS, Deployment
-: batch 批处理型-&amp;gt; Job
-: node-daemon 节点后台支撑型-&amp;gt; DaemonSet
-: stateful application 有状态应用型-&amp;gt; StatefulSet&lt;/p&gt;
&lt;p&gt;api对象三大类属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;metadata 元数据(至少包含namespace, name, uid).&lt;/li&gt;
&lt;li&gt;spec 规范&lt;/li&gt;
&lt;li&gt;status 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kubernetes对外暴露服务的三种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NodePort: dev/qa. (30000-32767)&lt;/li&gt;
&lt;li&gt;Ingress: production.&lt;/li&gt;
&lt;li&gt;LoadBalance: cloud provider.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;clusterIP 是k8s内部默认服务，外部无法访问，可以通过proxy来访问。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pod&#34;&gt;pod&lt;/h1&gt;
&lt;p&gt;一个pod包含一个或多个容器，这些容器通过infra container共享同一个network namespace。&lt;/p&gt;
&lt;p&gt;infra container: k8s.gcr.io/pause, 汇编写的，永远处于暂停状态。&lt;/p&gt;
&lt;p&gt;pod共享网络:&lt;/p&gt;
&lt;p&gt;同一个pod里面看到的网络跟infra容器看到的是一样的，一个pod只有一个ip,也就是这个Pod的network namespace对应的IP; 整个pod的生命周期跟infra容易是一样的。&lt;/p&gt;
&lt;p&gt;pod共享存储:&lt;/p&gt;
&lt;p&gt;通过pod volumes, 使pod中的container共享存储。&lt;/p&gt;
&lt;p&gt;应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个pod中的某个容器异常退出，被kubelet拉起来之前保证之前的数据部丢失.&lt;/li&gt;
&lt;li&gt;同一个pod的多个容器共享数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pod volume类型:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;本地存储: emptydir/hostpath&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络存储:&lt;/p&gt;
&lt;p&gt;in-tree(ks8内置支持): awsElasticBlockStore/gcePresistentDisk/nfs&amp;hellip;&lt;/p&gt;
&lt;p&gt;out-of-tree(插件): flexvolume/csi&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;projected volume: secret/configmap/downwardAPI/serviceAccountToken&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pod服务质量配置:&lt;/p&gt;
&lt;p&gt;依据容器对cpu,memory资源的request/limit需求，pod服务质量分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guaranteed&lt;/li&gt;
&lt;li&gt;Burstable&lt;/li&gt;
&lt;li&gt;BestEffort&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;initContainer:&lt;/p&gt;
&lt;p&gt;initContainer用于普通Container启动前的初始化（如配置文件准备) 和 前置条件校验 (如网络)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;initContainer会先于普通container启动执行，直到所有initcontainer执行成功后，普通container 才会执行。&lt;/li&gt;
&lt;li&gt;pod中多个initcontainer之间是按次序依次启动执行，而pod中多个普通container是并行启动。&lt;/li&gt;
&lt;li&gt;initcontainer 执行成功后就结束退出，而普通container会一直执行或重启。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;resources&#34;&gt;resources&lt;/h1&gt;
&lt;p&gt;查看所有对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl api-resources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#statefulsetcondition-v1beta2-apps&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#statefulsetcondition-v1beta2-apps&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;workloads&#34;&gt;Workloads&lt;/h2&gt;
&lt;h3 id=&#34;replicasetsrs&#34;&gt;replicasets/rs&lt;/h3&gt;
&lt;p&gt;控制无状态的pod数量,增删Pods.&lt;/p&gt;
&lt;h3 id=&#34;deploymentsdeploy&#34;&gt;deployments/deploy&lt;/h3&gt;
&lt;p&gt;定义pod的数目和版本，通过Controller自动恢复失败的pod，滚动升级，重新生成，回滚等。&lt;/p&gt;
&lt;p&gt;DeploymentStatus: complete, processing, failed&lt;/p&gt;
&lt;p&gt;Deployment只负责管理不同版本的ReplicaSet, 由ReplicaSet管理Pod副本个数; 每个版本的ReplicaSet对应了Deployment template的一个版本; 一个ReplicaSet下的Pod都是相同的版本.&lt;/p&gt;
&lt;h3 id=&#34;daemonsetsds&#34;&gt;daemonsets/ds&lt;/h3&gt;
&lt;p&gt;ds作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证集群内每个节点运行一组相同的pod&lt;/li&gt;
&lt;li&gt;跟踪集群节点状态，保证新加入的节点自动创建对应的pod&lt;/li&gt;
&lt;li&gt;跟踪集群节点状态，保证移除的节点删除对应的pod&lt;/li&gt;
&lt;li&gt;跟踪pod状态，保证每个节点pod处于运行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jobs&#34;&gt;jobs&lt;/h3&gt;
&lt;p&gt;job的作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个或多个pod确保指定数量的Pod可以成功运行和终止.&lt;/li&gt;
&lt;li&gt;跟踪pod状态，根据配置及时重试失败的pod.&lt;/li&gt;
&lt;li&gt;确定依赖关系，保证上一个任务运行完毕后再运行下一个任务.&lt;/li&gt;
&lt;li&gt;控制任务并行度，并根据配置确保pod队列大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cronjobscj&#34;&gt;cronJobs/cj&lt;/h3&gt;
&lt;h3 id=&#34;statefulsetssts&#34;&gt;statefulsets/sts&lt;/h3&gt;
&lt;p&gt;控制有状态的pod数量.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;service-discovery--load-balancing&#34;&gt;service discovery &amp;amp; load balancing&lt;/h2&gt;
&lt;h3 id=&#34;servicessvc&#34;&gt;services/svc&lt;/h3&gt;
&lt;p&gt;提供访问一个或多个pod的稳定的访问地址.支持ClusterIP, NodePort, LoadBalancer等访问方式.&lt;/p&gt;
&lt;h3 id=&#34;ingresses&#34;&gt;ingresses&lt;/h3&gt;
&lt;h3 id=&#34;endpointslices&#34;&gt;endpointslices&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;config--storage&#34;&gt;Config &amp;amp; Storage&lt;/h2&gt;
&lt;h3 id=&#34;secrets&#34;&gt;secrets&lt;/h3&gt;
&lt;p&gt;secret用于在集群中存储密码，token等敏感信息用的资源对象.&lt;/p&gt;
&lt;p&gt;其中敏感数据采用base-64编码保存.&lt;/p&gt;
&lt;p&gt;四种类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Opaque&lt;/li&gt;
&lt;li&gt;kubernetes.io/service-account-token&lt;/li&gt;
&lt;li&gt;kubernetes.io/dockerconfigjson&lt;/li&gt;
&lt;li&gt;bootstrap.kubernetes.io/token&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;secret主要被pod使用，一般通过volume挂载到指定容器目录，供容器中业务使用.&lt;/p&gt;
&lt;p&gt;访问私有镜像仓库也可以通过secret实现.&lt;/p&gt;
&lt;p&gt;secret大小限制1M; secret不适合机密信息，推荐用vault.&lt;/p&gt;
&lt;h3 id=&#34;configmapscm&#34;&gt;configmaps/cm&lt;/h3&gt;
&lt;p&gt;主要管理容器运行所需的配置文件，环境变量，命令行参数等可变配置。&lt;/p&gt;
&lt;p&gt;可用于解耦容器镜像和可变配置，从而保障工作负载的可移植性.&lt;/p&gt;
&lt;p&gt;主要被pod使用，一般用于挂载pod用的配置文件，环境变量，命令行参数.&lt;/p&gt;
&lt;p&gt;ConigMap 大小不超过1M; pod只能引用相同namespace中的configmap, pod引用的configmap不存在时，pod无法创建;使用envFrom从ConfigMap配置环境变量时，如果ConfigMap中的某些key被认为无效，该环境变量不会注入容器，但是pod可以创建; 只有通过k8s api创建的pod才能使用ConfigMap, 其它方式创建的pod不能使用ConfigMap.&lt;/p&gt;
&lt;h3 id=&#34;persistentvolumepv&#34;&gt;persistentvolume/pv&lt;/h3&gt;
&lt;p&gt;static volume provisioning:&lt;/p&gt;
&lt;p&gt;dynamic volume provisioning:&lt;/p&gt;
&lt;h3 id=&#34;persistentvolumeclaimspvc&#34;&gt;persistentvolumeclaims/pvc&lt;/h3&gt;
&lt;p&gt;pvc中只需要申明需要的存储size, access mode等业务需求.&lt;/p&gt;
&lt;p&gt;pvc简化了用户对存储的需求，pv才是存储的实际信息载体，通过kube-controller-manager中的PersistentVolumeController将PVC与合适的PV 绑定.&lt;/p&gt;
&lt;h3 id=&#34;csidrivers&#34;&gt;csidrivers&lt;/h3&gt;
&lt;h3 id=&#34;csinodes&#34;&gt;csinodes&lt;/h3&gt;
&lt;h3 id=&#34;storageclassessc&#34;&gt;storageclasses/sc&lt;/h3&gt;
&lt;h3 id=&#34;volumeattachments&#34;&gt;volumeattachments&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;metadata&#34;&gt;metadata&lt;/h2&gt;
&lt;h3 id=&#34;events&#34;&gt;events&lt;/h3&gt;
&lt;h3 id=&#34;horizontalpodautoscaler&#34;&gt;horizontalpodautoscaler&lt;/h3&gt;
&lt;h3 id=&#34;podtemplate&#34;&gt;podtemplate&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cluster&#34;&gt;cluster&lt;/h2&gt;
&lt;h3 id=&#34;componentstatusescs&#34;&gt;componentstatuses/cs&lt;/h3&gt;
&lt;h3 id=&#34;namespacesns&#34;&gt;namespaces/ns&lt;/h3&gt;
&lt;p&gt;一个集群内部的逻辑隔离机制，每个资源都属于一个namespace，同一个namespace中的资源命名唯一，不同namespace中的资源可重名.&lt;/p&gt;
&lt;h3 id=&#34;nodesno&#34;&gt;nodes/no&lt;/h3&gt;
&lt;h3 id=&#34;serviceaccountsa&#34;&gt;serviceaccount/sa&lt;/h3&gt;
&lt;p&gt;解决pod在集群中的身份认证问题.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tools&#34;&gt;Tools&lt;/h1&gt;
&lt;p&gt;sonobuoy&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vmware-tanzu/sonobuoy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vmware-tanzu/sonobuoy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kuard&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-up-and-running/kuard&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-up-and-running/kuard&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Namespace</title>
        <link>https://canuxcheng.com/post/cncf_ns/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_ns/</guid>
        <description>&lt;h1 id=&#34;ns&#34;&gt;NS&lt;/h1&gt;
&lt;p&gt;namespace 是 Linux 内核用来隔离内核资源的方式&lt;/p&gt;
&lt;p&gt;Linux namespace资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mount: 挂载点&lt;/li&gt;
&lt;li&gt;Network: 网络设备/协议栈/端口&lt;/li&gt;
&lt;li&gt;IPC: 进程间通信&lt;/li&gt;
&lt;li&gt;USR: 用户和用户组&lt;/li&gt;
&lt;li&gt;PID: 进程&lt;/li&gt;
&lt;li&gt;UTS: 主机名和域名&lt;/li&gt;
&lt;li&gt;Cgroup: 控制组&lt;/li&gt;
&lt;li&gt;Time&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cgroup&#34;&gt;Cgroup&lt;/h1&gt;
&lt;p&gt;Cgroup: Control Groups.是linux下用于对一个或一组进程资源控制和监控的机制.可以管理cpu, memory,diskIO 等资源.不同资源的具体管理工作由相应的cgrouup子系统来实现.&lt;/p&gt;
&lt;p&gt;cgroup在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理, 每个cgroup可以包含其它子cgroup.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls -l /sys/fs/cgroup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cgroup子系统:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;cpuacct&lt;/li&gt;
&lt;li&gt;cpuset&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;blkio&lt;/li&gt;
&lt;li&gt;devices&lt;/li&gt;
&lt;li&gt;freezer&lt;/li&gt;
&lt;li&gt;ns&lt;/li&gt;
&lt;li&gt;pid&lt;/li&gt;
&lt;li&gt;net_cls&lt;/li&gt;
&lt;li&gt;net_prio&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;lsns&#34;&gt;lsns&lt;/h1&gt;
&lt;p&gt;查看系统的namespace&lt;/p&gt;
&lt;p&gt;ns类型: mnt, net, ipc, user, pid, uts, cgroup&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$lsns -l
$lsns -t net
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;unshare&#34;&gt;unshare&lt;/h1&gt;
&lt;p&gt;使用非共享的NS运行程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建unshare 的 ns类型.
$unshare -f -m/-n/-i/-U/-p/-u/-C ... 

// 在net类型的namespace执行sleep命令
$unshare -fn sleep 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nsenter&#34;&gt;nsenter&lt;/h1&gt;
&lt;p&gt;ns enter: Namespace enter.&lt;/p&gt;
&lt;p&gt;nsenter - run program with namespaces of other processes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nsenter [options] [program [arguments]]

// 指定ns的目标进程，可以通过nsls查看.
$ nsenter -t/--target  

// 进入所有类型的ns.
$ nsenter -a --all ...
// 进入指定类型的ns
$ nsenter -m/-u/-i/-n/-p/-C/-U ...

// 进入指定ns的指定进程
$ nsenter -t &amp;lt;pid&amp;gt; -n ip a

$ nsenter -S/-G/-r/-w ...

$ nsenter -F/--no-fork ...

$ nsenter -Z/--follow-context ...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Registry</title>
        <link>https://canuxcheng.com/post/cncf_registry/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cncf_registry/</guid>
        <description>&lt;h1 id=&#34;container-registry&#34;&gt;Container Registry&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Docker Hub Registry&lt;/li&gt;
&lt;li&gt;Google Container Registry (gcr.io)&lt;/li&gt;
&lt;li&gt;RedHat Quay Registry (quay.io)&lt;/li&gt;
&lt;li&gt;GitHub Docker Packages (docker.pkg.github.com)(Deprecated)&lt;/li&gt;
&lt;li&gt;GitHub Container Registry (ghcr.io)&lt;/li&gt;
&lt;li&gt;Kubernetes Registry(registry.k8s.io =&amp;gt; k8s.gcr.io)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;harbor&#34;&gt;Harbor&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/goharbor/harbor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Habor是由VMWare中国团队开源的容器镜像仓库, 用于存储和分发docker镜像的registry服务器.&lt;/p&gt;
&lt;p&gt;安装步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载并解压安装包, &lt;a class=&#34;link&#34; href=&#34;https://github.com/goharbor/harbor/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goharbor/harbor/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;配置harbor.cfg;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim harbor.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行安装程序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./install.sh --with-notary --with-clair --with-chartmuseum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改web的port:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /data/harbor/docker-compose.yml
proxy:
  ports:
    - 8080:80 # 默认http是80
    - 4433:443 # 默认https是443
$ vim /data/harbor/harbor.yml
hostname = ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理harbor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /data/harbor
# docker-compose down -v 　停止并删除container

&amp;gt; 更新配置
# ./prepare --with-notary --with-clair --with-chartmuseum

&amp;gt; 启动
# docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;docker使用harbor&#34;&gt;docker使用harbor&lt;/h2&gt;
&lt;p&gt;Deploy a plain HTTP registry:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim /etc/docker/daemon.json
{  &amp;quot;insecure-registries&amp;quot; : [&amp;quot;myregistrydomain.com:5000&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use self-signed certificates:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cp your-ca /etc/docker/certs.d/harbor.domain.com/ca.crt
# vim /lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd --insecure-registry harbor.domain.com:port
# systemctl daemon-reload
# systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update hosts on docker client:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim /etc/hosts ip harbor.domain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create user account:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://&amp;lt;ip:port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;push images to harbor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker login harbor.domain.com:port
$ docker tag SOURCE_IMAGE[:TAG] harbor.domain.com:port/&amp;lt;project&amp;gt;/IMAGE[:TAG]
$ docker push harbor.domain.com:port/&amp;lt;project&amp;gt;/IMAGE[:TAG]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pull images from harbor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker login harbor.domain.com:port
$ docker pull harbor.domain.com:port/&amp;lt;project&amp;gt;/IMAGE[:TAG]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;k8s使用harbor:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改存储路径&#34;&gt;修改存储路径&lt;/h2&gt;
&lt;p&gt;默认路径是/data/registry&lt;/p&gt;
&lt;p&gt;停服务:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker-compose down -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改路径:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mv /data/* /new/path
$ vim /new/path/harbor/harbor.yml
data_volume: /new/path

$ vim /new/path/harbor/docker-compose.yml
/data =&amp;gt; /new/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动服务:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /new/path
$ docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;artifactory&#34;&gt;Artifactory&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Swarm</title>
        <link>https://canuxcheng.com/post/swarm/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/swarm/</guid>
        <description>&lt;h1 id=&#34;swarm&#34;&gt;Swarm&lt;/h1&gt;
&lt;p&gt;docker swarm 是 docker内置的容器编排工具。&lt;/p&gt;
&lt;p&gt;从docker1.12开始swarm内置于docker engine.&lt;/p&gt;
&lt;p&gt;swarm mode具有内置kv存储，服务发现，负载均衡，路由网格，动态伸缩，滚动更新，安全传输等功能。&lt;/p&gt;
&lt;p&gt;swarm: 老版本的swarm, 需要kv store, 可以作为独立的container运行, 已废弃, 已经被docker swarm mode 代替.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/swarm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker/swarm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swarmkit:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/docker/swarmkit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/docker/swarmkit&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;swarm命令&#34;&gt;swarm命令&lt;/h1&gt;
&lt;p&gt;创建集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker swarm init
--advertise-addr &amp;lt;ip&amp;gt; 多网卡情况下指定manager的ip

docker swarm join --token &amp;lt;token&amp;gt; &amp;lt;host:port&amp;gt;

# 查看token
docker swarm join-token manager   获取添加manager命令
docker swarm join-token worker   获取添加worker命令
docker swarm join-token -q worker

docker swarm leave -f/--force

docker swarm update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker node ls
docker node ls --format &amp;quot;{{.Hostname}}&amp;quot;
​
docker node rm
​
docker node inspect
​
# 查看node上运行的tasks/container
docker node ps -f/--filter NODE
​
# 添加label, node.labels.role=api
docker node update --label-add role=api node1
# 删除label
docker node update --label-rm role node1
​
# 活跃节点
docker node update --availability active node1
# 指定该节点满载,不再分派任务,关闭已有任务并重新分派.
docker node update --availability drain node1
# 已有任务继续运行,不分配新任务.
docker node update --availability pause node1

# 查看所有node和label
docker node ls -q | xargs docker node inspect -f &#39;{{ .ID }} [{{ .Description.Hostname }}]: {{ .Spec.Labels }}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 相当于docker-compose.yml里面的service.
docker service ls # 列出所有service
​
docker service rm SERVICE
​
docker service inspect SERVICE
​
# 查看service的log
docker service logs -f SERVICE
​
# 查看service的状态,在哪些node上运行,运行状态等
docker service ps SERVICE
​
docker service update
docker service update --image &amp;lt;url:tag&amp;gt; # 根据镜像更新服务
​
docker service scale
​
docker service rollback
​
docker service create
--constraint node.id/node.hostname/node.role/node.labels/engine.labels
--env/-e
--label
--limit-cpu
--limit-memory
--replicas
--restart-condition
--user/--group
--mode global/replicated
--endpoint-mode vip/dnsrr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stack&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# stack = n*service
# service = n*task(container)
docker stack ls # 列出所有stack

# 查看stack的service
docker stack services &amp;lt;stack&amp;gt;

# 查看stack的task/container
docker stack ps &amp;lt;stack&amp;gt;

docker stack rm STACK

# 根据docker-compose.yml部署应用
docker stack deploy -c/--compose-file &amp;lt;docker-compose.yml&amp;gt; STACK
docker stack deploy --bundle-file &amp;lt;DAB&amp;gt; STACK

# 默认所有node从docker hub pull, 如果是私有镜像，需要加参数
# 需要在manager上docker login private-registry
docker stack deploy --with-registry-auth -c test.yml test

docker stack deploy --resolve-image (always|changed|never) ...

docker stack deploy --orchestrator (swarm|kubernetes|all) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;swarm-compose&#34;&gt;swarm compose&lt;/h1&gt;
&lt;p&gt;其它字段参考Compose， 这里只分析deploy下的字段.&lt;/p&gt;
&lt;p&gt;通过compose文件部署服务.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  endpoint_mode:

  // 给service打标签(不作用于container) 
  labels:
    com.examples.key: value

  // 默认mode=replicated, replicas=1.
  mode: replicated
  max_replicas_per_node:
  replicas: 1

  // 部署到匹配的全部node.
  mode: global 
​
  # global和replicated都可以用placement.
  placement:
    preferences: // 只支持spreed.
      - spreed: node.labels.datacenter
    constraints:
      # 多个约束是and关系
      - node.id==...
      - node.hostname==...
      - node.role==...
      - node.role==manager/worker
      - node.platform.os!=windows
      - node.platform.arch==x86
      - engine.labels.&amp;lt;key&amp;gt;==&amp;lt;value&amp;gt;
      # 用户自定义标签
      - node.labels.&amp;lt;key&amp;gt;==&amp;lt;value&amp;gt;
​
  resources:
    limits:
      cpus: &#39;0.5&#39;
      memory: 1G
    reservations:
      cpus: &#39;0.25&#39;
      memory: 20M
​
  restart_policy:
    condition: any(default)/on-failure/none
    delay: 0(default)/5s
    max_attempts: never give up(default)/3
    window: decide immediately(default)/10s
​
  update_config/rollback_config:
    parallelism: 0 (default 0 means all)
    delay: 10s (容器升级间隔时间)
    failure_action: pause(default)/continue/rollback
    monitor: 0s (更新完成后确认成功的时间)
    max_failure_ratio: 更新期间允许的失败率
    order: stop-first(default)/start-first

// 默认endpoint_mode=vip, 支持route mesh, 自动负载均衡和服务发现.
deploy:
  endpoint_mode: vip
ports:
- target: 80
  published: 8080
  // 默认mode=ingress, 也可以改为host.
  mode: ingress
  protocol: tcp/udp
- 8080:80/tcp

// dnsrr 模式
deploy:
  endpoint_mode: dnsrr
  update_config:
    // 如果expose端口，不能start-first, 否则报错no suitable node (host-mode port already in use on 1 node
    order: stop-first 
// 设置iptables规则，外部访问8080通过prerouting做dnat指定目的ip，通过forward转发给container的80.
// iptables-&amp;gt;nat-&amp;gt;prerouting: 
// DNAT tcp -- !docker_gwbridge * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 to:172.18.0.16:80
// iptables-&amp;gt;filter-&amp;gt;forward:
// ACCEPT tcp -- enp5s0 * 0.0.0.0/0 0.0.0.0/0 multiport dports 80
ports:
- target: 80
  published: 8080
  // dnsrr只能用port-&amp;gt;mode=host.
  mode: host
  protocol: tcp/udp
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;swarm-network&#34;&gt;swarm network&lt;/h1&gt;
&lt;p&gt;global模式container:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eth0: overlay(user define overlay)
eth1: ingress(swarm define ingress)
eth2: docker_gwbridge(swarm define bridge)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;replicate模式container:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eth0: overlay(user define overlay)
eth1: docker_gwbridge(swarm define bridge)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;overlay: 通过4789/udp跨主机访问其他container, host不能访问overlay的ip，只有container之间通过container-servicename或者container-overlay的ip相互访问.&lt;/p&gt;
&lt;p&gt;overlay 问题: 通过overlay连接，默认15分钟timeout, 所以数据库建议用dnsrr模式; 如果用vip模式，需要修改内核网络参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo sysctl -w net.ipv4.tcp_keepalive_time=600 net.ipv4.tcp_keepalive_intvl=60 net.ipv4.tcp_keepalive_probes=3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vip模式就是访问的虚拟ip,replicated的service如果有多个container,通过servicename访问的就是同一个vip,通过vip解析到背后container的真实overlay-ip(自动负载均衡).&lt;/p&gt;
&lt;p&gt;dnsrr模式就是直接解析container的overlay-ip来访问,如果是replicated的service有多个container,每次访问的就是从dns列表中根据负载均衡算法拿到其中一个overlay-ip.&lt;/p&gt;
&lt;p&gt;ingress network: 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。&lt;/p&gt;
&lt;p&gt;docker_gwbridge: host和container之间通过ip访问, container能访问host的物理网卡的ip和docker_gwbridge的ip, host也能访问container的docker_gwbridge的ip, 但是container之间不能访问bridge的ip.&lt;/p&gt;
&lt;p&gt;修改默认的docker_gwbridge:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对于已存在的，要先删除
$ service docker stop
$ sudo ip link set docker_gwbridge down
$ sudo ip link del dev docker_gwbridge
// 创建swarm之前创建好网络
$ docker network create --subnet &amp;quot;172.18.0.0/16&amp;quot;  --ip-range “172.18.1.0/16” \
--opt com.docker.network.bridge.name=docker_gwbridge \
--opt com.docker.network.bridge.enable_icc=false \
--opt com.docker.network.bridge.enable_ip_masquerade=true \
docker_gwbridge
// 创建swarm
$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;endpoint_mode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vip: 通过vip这个虚拟ip对外访问，提供负载均衡，不暴露具体的container的ip.&lt;/li&gt;
&lt;li&gt;dnssr: DNS round-robin, 为每个服务设置dns,连接到其中一个具体的contaier的ip.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;swarm-scheduler&#34;&gt;swarm scheduler&lt;/h1&gt;
&lt;p&gt;filter过滤器可以实现特定的容器运行在特定的node上, swarm支持３种策略和6个过滤器.&lt;/p&gt;
&lt;p&gt;swarm strategy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spread： 默认策略,配置相同的情况下选择容器数量最少的node&lt;/li&gt;
&lt;li&gt;binpack： 尽可能将容器放到一台node上运行。&lt;/li&gt;
&lt;li&gt;random： 直接随机分配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;swarm node filters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;constraint&lt;/li&gt;
&lt;li&gt;health&lt;/li&gt;
&lt;li&gt;containerslots&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;swarm container-configuration filters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;affinity&lt;/li&gt;
&lt;li&gt;dependency&lt;/li&gt;
&lt;li&gt;port&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Swarm CNI</title>
        <link>https://canuxcheng.com/post/swarm_cni/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/swarm_cni/</guid>
        <description>&lt;h1 id=&#34;cni&#34;&gt;CNI&lt;/h1&gt;
&lt;p&gt;CNI: Container Network Intarface&lt;/p&gt;
&lt;h2 id=&#34;单台host上的container通信&#34;&gt;单台host上的container通信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;none&lt;/li&gt;
&lt;li&gt;host&lt;/li&gt;
&lt;li&gt;bridge&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多台host之间的container通信&#34;&gt;多台host之间的container通信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;overlay&lt;/li&gt;
&lt;li&gt;macvlan&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;提供overlaymacvlan的网络服务&#34;&gt;提供overlay/macvlan的网络服务&lt;/h3&gt;
&lt;p&gt;vxlan encapsulated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;canal&lt;/li&gt;
&lt;li&gt;flannel&lt;/li&gt;
&lt;li&gt;weave&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bgp unencapsulated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;calico&lt;/li&gt;
&lt;li&gt;romana&lt;/li&gt;
&lt;li&gt;cilium&lt;/li&gt;
&lt;li&gt;kube-router&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;docker网络管理&#34;&gt;Docker网络管理&lt;/h1&gt;
&lt;p&gt;查看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker network ls # 查看所有网络
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认支持的三种模式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认启动的容器都是桥接(docker0)，重启后容器的ip就变了。
docker run --network bridge  ...
docker run --network host ... # 容器和主机使用相同的ip
docker run --network none ... # 容器不会分配局域网的ip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker network create -d &amp;lt;driver&amp;gt; ... [name]
-d/--driver # 默认是bridge, 可选overlay/macvlan
--subnet  # CIDR格式
--gateway
--ip-range
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker network connect [OPTIONS] NETWORK CONTAINER
$ docker network disconnect [OPTIONS] NETWORK CONTAINER
$ docker run --network [name] --name [container-name] [image:tag]

# 使用自定义bridge网络并指定IP:
docker run --network [name] --ip [ip] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;opt可用的参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;com.docker.network.bridge.name # bridge名字
com.docker.network.bridge.enable_ip_masquerade # iptables:nat, 容器访问外网.
com.docker.network.bridge.enable_icc # iptables:filter, 同一网段容器相互访问.
com.docker.network.bridge.host_binding_ipv4
com.docker.network.driver.mtu
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bridge网络&#34;&gt;bridge网络&lt;/h1&gt;
&lt;p&gt;bridge网络不能跨主机通信(单网卡情况下), node1上的container不能通过container-hostname/ip访问node2上的container.&lt;/p&gt;
&lt;p&gt;主要用于container访问host并通过host访问外部网络，container能通过ip访问host和局域网中的其他node,或者通过node访问外网。&lt;/p&gt;
&lt;p&gt;host或局域网中的其它机器能通过container-ip(bridge网络)访问container.&lt;/p&gt;
&lt;p&gt;创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker network create -d bridge ... [name]

$ docker network create --driver=bridge --gateway=192.168.1.1 --subnet=192.168.1.0/24 --opt com.docker.network.bridge.name=br0 br0

// 定制docker_gwbridge网络
$ docker network create --subnet 172.26.0.0/16 --ip-range 172.26.0.0/16 --gateway 172.26.0.1 \ 
--opt com.docker.network.bridge.name=docker_gwbridge \
--opt com.docker.network.bridge.enable_icc=true \ 
--opt com.docker.network.bridge.enable_ip_masquerade=true \ 
docker_gwbridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker0:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// dockerd 自动的默认bridge网络，不推荐用于production.

1. 删除docker0:

// 停止
$ ip link set dev docker0 down
$ ifconfig docker0 down

// 删除
$ ip link delete docker0
$ brctl delbr docker0

2. 修改默认网络:
$ vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;: &amp;quot;192.168.1.5/24&amp;quot;,
    &amp;quot;fixed-cidr&amp;quot;: &amp;quot;192.168.1.5/25&amp;quot;,
    &amp;quot;fixed-cidr-v6&amp;quot;: &amp;quot;2001:db8::/64&amp;quot;,
    &amp;quot;mtu&amp;quot;: 1500,
    &amp;quot;default-gateway&amp;quot;: &amp;quot;10.20.1.1&amp;quot;,
    &amp;quot;default-gateway-v6&amp;quot;: &amp;quot;2001:db8:abcd::89&amp;quot;,
    &amp;quot;dns&amp;quot;: [&amp;quot;10.20.1.2&amp;quot;,&amp;quot;10.20.1.3&amp;quot;]
}
$ service docker restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;overlay网络&#34;&gt;overlay网络&lt;/h1&gt;
&lt;p&gt;overlay网络可以实现容器之间的跨主机通信.&lt;/p&gt;
&lt;p&gt;container通过overlay网络实现通信.container能通过service-name/container-ip访问其它container。&lt;/p&gt;
&lt;p&gt;局域网中的node 既不能通过container-servicename也不能通过container-ip(overlay的ip)访问container, 也就是说外部服务只能通过expose port来访问container.&lt;/p&gt;
&lt;p&gt;创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker network create -d overlay ... [name]

$ docker network create --attachable --driver=overlay --gateway=172.27.0.1 --subnet=172.27.0.0/24 --ip-range=172.27.0.0/24 --opt com.docker.network.bridge.name=ol0 ol0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;macvlan&#34;&gt;macvlan&lt;/h1&gt;
&lt;p&gt;macvlan不仅支持在interface上创建，还支持sub-interface(vlan).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip link set eth1 promisc on  |  
ifconfig eth1 promisc 

docker network create -d macvlan --subnet=192.168.100.0/24 --gateway=192.168.100.1 -o parent=eth1 lan0
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Swarm CSI</title>
        <link>https://canuxcheng.com/post/swarm_csi/</link>
        <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/swarm_csi/</guid>
        <description>&lt;h1 id=&#34;csi&#34;&gt;CSI&lt;/h1&gt;
&lt;p&gt;CSI: Container Storage Interface&lt;/p&gt;
&lt;p&gt;CSI提供容器的数据持久化服务.&lt;/p&gt;
&lt;p&gt;容器管理数据的两种方式：&lt;/p&gt;
&lt;p&gt;数据卷(Volumes)&lt;/p&gt;
&lt;p&gt;挂载主机目录(bind mounts)&lt;/p&gt;
&lt;p&gt;临时文件系统(tmpfs)&lt;/p&gt;
&lt;h2 id=&#34;数据存储原理&#34;&gt;数据存储原理&lt;/h2&gt;
&lt;p&gt;如果container上目录不存在，docker会自动创建&lt;/p&gt;
&lt;p&gt;如果container目录存在且有内容，会被host上的目录覆盖掉，但不会被删除.&lt;/p&gt;
&lt;h2 id=&#34;volumes&#34;&gt;Volumes&lt;/h2&gt;
&lt;p&gt;如果host上目录不存在，docker会自动创建&lt;/p&gt;
&lt;p&gt;volumes是被设计用来持久化数据的，它的生命周期独立于容器.数据卷通过docker volume命令管理的，位于/var/lib/docker/volumes/下面.&lt;/p&gt;
&lt;p&gt;Docker不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。&lt;/p&gt;
&lt;p&gt;创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker volume create &amp;lt;volume-name&amp;gt;
$ docker volume rm &amp;lt;volume-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -v/--volume myvolume:/var/lib/app ...
$ docker run --mount source=myvolume,target=/var/lib/app ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bind-mount&#34;&gt;Bind mount&lt;/h2&gt;
&lt;p&gt;如果host上目录不存在会报错，需要提前创建.&lt;/p&gt;
&lt;p&gt;bind mount就是直接将host路径挂在到docker．&lt;/p&gt;
&lt;p&gt;source和target都是文件，即可挂载单个文件.&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -v/--volume /opt/app:/var/lib/app:ro ...
$ docker run --mount type=bind,source=/opt/app,target=/var/lib/app,readonly ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tmpfs&#34;&gt;tmpfs&lt;/h2&gt;
&lt;p&gt;tmpfs是临时文件系统，也叫内存文件系统，就是将数据存在内存上。&lt;/p&gt;
&lt;p&gt;tmpfs只能用于linux, 多个容器也不能共享，容器停止数据就销毁。&lt;/p&gt;
&lt;p&gt;使用&amp;ndash;mount可以指定参数，使用&amp;ndash;tmpfs不能指定参数。&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run --mount type=tmpfs,destination=/tmp/app,tmpfs_size=10G tmpfs_mode=1777 ...
$ docker run --tmpfs  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;docker管理volume&#34;&gt;Docker管理volume&lt;/h1&gt;
&lt;p&gt;查看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker volume ls # 查看所有卷
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建volume:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker volume create my-volume 
# mountpoint: /var/lib/docker/volumes/my-volume/_data.
docker run -v/--volume my-volume:/container/path 
# src=https://canuxcheng.com/var/lib/docker/volumes/my-volume/_data, dest=/container/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定路径作为volume：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -v /host/path:/container/path ...
# src=https://canuxcheng.com/host/path, dest=/container/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认随机路径，数据不能持久化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# src=https://canuxcheng.com/var/lib/docker/volumes/... /_data (on host)
docker run -v /path ....
docker run --mount ...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>https://canuxcheng.com/post/storage_monitoring/</link>
        <pubDate>Thu, 05 Apr 2018 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/storage_monitoring/</guid>
        <description>&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;h2 id=&#34;diskio&#34;&gt;diskio&lt;/h2&gt;
&lt;p&gt;IOPS: Input/Output Per Second. 每秒输入输出量，也叫TPS.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(mean(reads),1s) as &amp;quot;read&amp;quot; FROM &amp;quot;diskio&amp;quot;
SELECT non_negative_derivative(mean(writes),1s) as &amp;quot;write&amp;quot; FROM &amp;quot;diskio&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;throughput:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(mean(read_bytes),1s) as &amp;quot;read&amp;quot; FROM &amp;quot;diskio&amp;quot;
SELECT non_negative_derivative(mean(write_bytes),1s) as &amp;quot;write&amp;quot; FROM &amp;quot;diskio&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilization:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(last(&amp;quot;io_time&amp;quot;),1ms)
FROM &amp;quot;diskio&amp;quot;
WHERE &amp;quot;name&amp;quot; =~ /^(v|s|)d(a|b|c|d)$/
GROUP BY &amp;quot;host&amp;quot;,&amp;quot;name&amp;quot;,time(_interval)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Queue length:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(last(&amp;quot;weighted_io_time&amp;quot;,1ms))
FROM &amp;quot;diskio&amp;quot;
WHERE &amp;quot;name&amp;quot; =~ /^(v|s|)d(a|b|c|d)$/
GROUP BY &amp;quot;host&amp;quot;,&amp;quot;name&amp;quot;,time(_interval)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Storage</title>
        <link>https://canuxcheng.com/post/storage/</link>
        <pubDate>Thu, 05 Apr 2018 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/storage/</guid>
        <description>&lt;h1 id=&#34;storage&#34;&gt;Storage&lt;/h1&gt;
&lt;h1 id=&#34;raid&#34;&gt;RAID&lt;/h1&gt;
&lt;p&gt;RAID: redundant array of independent disks, 独立磁盘冗余数组．&lt;/p&gt;
&lt;h1 id=&#34;存储方式&#34;&gt;存储方式&lt;/h1&gt;
&lt;p&gt;DAS: direct attached storage, 直连式存储，通过SCSI或FC连接服务器．&lt;/p&gt;
&lt;p&gt;NAS: network attached storage，网络接入存储，通过IP(NFS/CIFS/..).&lt;/p&gt;
&lt;p&gt;SAN: storage area network, 存储区域网络，有IP或FC两种方式．&lt;/p&gt;
&lt;h1 id=&#34;存储接口&#34;&gt;存储接口&lt;/h1&gt;
&lt;p&gt;SCSI&lt;/p&gt;
&lt;p&gt;iSCSI&lt;/p&gt;
&lt;p&gt;SAS&lt;/p&gt;
&lt;p&gt;SATA&lt;/p&gt;
&lt;p&gt;FC&lt;/p&gt;
&lt;p&gt;FCoE&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Websocket</title>
        <link>https://canuxcheng.com/post/websocket/</link>
        <pubDate>Tue, 03 Apr 2018 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/websocket/</guid>
        <description>&lt;h1 id=&#34;websocket&#34;&gt;WebSocket&lt;/h1&gt;
&lt;p&gt;websocket用于server和browser之间通讯．&lt;/p&gt;
&lt;p&gt;websocket采用特殊报头，使得浏览器和服务器只需要做一个握手的动作．&lt;/p&gt;
&lt;p&gt;通讯数据以\x00开头，以\xFF结尾．&lt;/p&gt;
&lt;p&gt;url:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ws://
wss://
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个客户端只建立一个tcp连接&lt;/p&gt;
&lt;p&gt;服务端可以推送/push数据到web客户端&lt;/p&gt;
&lt;p&gt;有更加亲量级的头，减少数据传送．&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JS BOM</title>
        <link>https://canuxcheng.com/post/js_bom/</link>
        <pubDate>Thu, 15 Mar 2018 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_bom/</guid>
        <description>&lt;h1 id=&#34;bom&#34;&gt;BOM&lt;/h1&gt;
&lt;p&gt;Browser Object Model&lt;/p&gt;
&lt;p&gt;介绍浏览器对象，不过缺乏规范.&lt;/p&gt;
&lt;h1 id=&#34;window&#34;&gt;window&lt;/h1&gt;
&lt;p&gt;window对象是最顶层对象，有6大属性,属性本身也是对象.&lt;/p&gt;
&lt;p&gt;window对象的document属性也是对象，document对象有5大属性.&lt;/p&gt;
&lt;p&gt;引用当前窗口时，可以省略window对象.&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.document
document

window.alert()
alert()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象集合:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;frames[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document # DOM的Document对象
history # History对象
location # Location对象
Navigator # Navigator对象
Screen # Screen对象
window # 等价于self

closed
defaultStatus
status
innerheight
innerwidth
outerheight
outerwidth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert() // 弹出警告框
confirm() // 和alert差不多，带确定和取消按钮，确定返回true
prompt() // 输入提示框,返回输入内容
find() // 查找

// 子窗口的opener属性反过来引用打开她的那个窗口(父窗口)
subwin = open() // 打开一个新窗口, _parent在当前窗口打开, 返回子窗口的window对象.
subwin.opener // 表示window

moveTo()
moveBy()
resizeTo()
resizeBy()

setTimeout()
clearTimeout()

setInterval()
clearInterval()

close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;location&#34;&gt;location&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hash
host
hostname
href
pathname
port
protocol
search
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assign()
reload()
replace()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;history&#34;&gt;history&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lehgth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;back()
forward()
go()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;navigator&#34;&gt;navigator&lt;/h1&gt;
&lt;p&gt;对象集合:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins[] # Plugin对象的数组
navigator.plugins.length # 插件个数
navigator.plugins[i].name # 第i个插件名字
navigator.plugins[i].filename # 第i个插件文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appName # 浏览器名称
appVersion # 浏览器版本
userAgent # user-agent 头部信息
platform # win32/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javaEnabled()
taintEnabled()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;screen&#34;&gt;screen&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;width
height
availHeight
availWidth
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Brazil</title>
        <link>https://canuxcheng.com/post/travel_brazil/</link>
        <pubDate>Thu, 08 Mar 2018 16:41:50 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/travel_brazil/</guid>
        <description>&lt;h1 id=&#34;巴西之旅&#34;&gt;巴西之旅&lt;/h1&gt;
&lt;p&gt;看照片：&lt;/p&gt;
&lt;h1 id=&#34;库里提巴&#34;&gt;库里提巴&lt;/h1&gt;
&lt;p&gt;库里提巴（Curitiba）&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AlertManager</title>
        <link>https://canuxcheng.com/post/metrics_alertmanager/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_alertmanager/</guid>
        <description>&lt;h1 id=&#34;alert-manager&#34;&gt;alert-manager&lt;/h1&gt;
&lt;p&gt;在Prometheus中支持基于PromQL创建告警规则, prometheus通过push触发alertmanager.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/alertmanager&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/alertmanager&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Exporter</title>
        <link>https://canuxcheng.com/post/metrics_exporter/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_exporter/</guid>
        <description>&lt;h1 id=&#34;exporter&#34;&gt;exporter&lt;/h1&gt;
&lt;p&gt;广义上讲所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:&lt;/p&gt;
&lt;p&gt;prometheus通过pull从exporter拉取数据.&lt;/p&gt;
&lt;p&gt;直接采集:cAdvisor, kubernetes, etcd, gokit等直接内置了用于向prometheus暴露监控数据的端点.&lt;/p&gt;
&lt;p&gt;间接采集: 通过promethesu的client api编写exporter，例如mysql-exporter, consul-exporter.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;host&#34;&gt;host&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/node_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/node_exporter&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;k8s&#34;&gt;k8s&lt;/h1&gt;
&lt;p&gt;k8s metrics api包括 resource metrics api 和 customer metrics api.&lt;/p&gt;
&lt;p&gt;cadvisor, metrics-server, kube-state-metrics 等实现了 核心api.&lt;/p&gt;
&lt;p&gt;一些adapter实现了自定义api.&lt;/p&gt;
&lt;p&gt;k8s-prometheus-adapter实现了metrics-server的核心api，同时实现了自定义api.&lt;/p&gt;
&lt;h2 id=&#34;metrics-server&#34;&gt;metrics-server &lt;/h2&gt;
&lt;p&gt;提供了整个集群的资源监控数据&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/metrics-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/metrics-server&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cadvisor&#34;&gt;cAdvisor&lt;/h2&gt;
&lt;p&gt;负责单节点内部的容器和节点资源使用统计，会自动收集本机容器 CPU、内存、网络和文件系统的资源占用情况&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/google/cadvisor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/google/cadvisor&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;kube-state-metrics&#34;&gt;kube-state-metrics &lt;/h2&gt;
&lt;p&gt;提供了 Kubernetes 资源对象（如 DaemonSet、Deployments 等）的度量。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes/kube-state-metrics&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes/kube-state-metrics&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;adapter&#34;&gt;adapter&lt;/h2&gt;
&lt;p&gt;同时支持核心api和自定义api.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/DirectXMan12/k8s-prometheus-adapter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/DirectXMan12/k8s-prometheus-adapter&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;blackbox&#34;&gt;blackbox&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/blackbox_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/blackbox_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;wmi&#34;&gt;wmi&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/martinlindhe/wmi_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/martinlindhe/wmi_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;snmp&#34;&gt;snmp&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/snmp_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/snmp_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;mysql&#34;&gt;mysql&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/mysqld_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/mysqld_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;rabbitmq&#34;&gt;rabbitmq&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/deadtrickster/prometheus_rabbitmq_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/deadtrickster/prometheus_rabbitmq_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;mongo&#34;&gt;mongo&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/percona/mongodb_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/percona/mongodb_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;redis&#34;&gt;redis&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/oliver006/redis_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/oliver006/redis_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;haproxy&#34;&gt;haproxy&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/haproxy_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/haproxy_exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;consul&#34;&gt;consul&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/consul_exporter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/consul_exporter&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pushgateway&#34;&gt;pushgateway&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prometheus/pushgateway&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prometheus/pushgateway&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于Prometheus数据采集基于Pull模型进行设计，因此在网络环境的配置上必须要让Prometheus Server能够直接与Exporter进行通信。 当这种网络需求无法直接满足时，就可以利用PushGateway来进行中转。可以通过PushGateway将内部网络的监控数据主动Push到Gateway当中。而Prometheus Server则可以采用同样Pull的方式从PushGateway中获取到监控数据.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Influxdb</title>
        <link>https://canuxcheng.com/post/metrics_influxdb/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_influxdb/</guid>
        <description>&lt;h1 id=&#34;influxdb&#34;&gt;Influxdb&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/influxdata/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/influxdata/influxdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scalable datastore for metrics, events, and real-time analytics.&lt;/p&gt;
&lt;p&gt;支持从opentsdb, graphite, collectd等获取数据&lt;/p&gt;
&lt;p&gt;默认数据库_internal 用于存储内部运行数据&lt;/p&gt;
&lt;p&gt;安装配置参考官方文档&lt;/p&gt;
&lt;p&gt;log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo journalctl -u influxdb.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 开通kapacitor的subscription功能
[[subscriber]]
enable = true
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;p&gt;influxdb每条记录是一个point.&lt;/p&gt;
&lt;p&gt;points包括下面部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;measurement: a measurement, like cpu_load, 相当于表名
tags: zero or more tag, key=value, eg: host=ip
fields: zero or more field, key=value, eg: value=0.18
time: a timestamp

&amp;lt;measurement&amp;gt;[,&amp;lt;tag-key&amp;gt;=&amp;lt;tag-value&amp;gt;...] &amp;lt;field-key&amp;gt;=&amp;lt;field-value&amp;gt;[,&amp;lt;field2-key&amp;gt;=&amp;lt;field2-value&amp;gt;...] [unix-nano-timestamp]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;series: 在一个database中,相同的retention policy, measurement, tag set的数据集，叫一个序列．&lt;/p&gt;
&lt;p&gt;RP: retention policy, autogen是默认的存储策略, 用于设置数据保留时间.&lt;/p&gt;
&lt;p&gt;CQ: continuous query, 连续查询，自动定时启动一组语句，将结果放在指定数据表中．&lt;/p&gt;
&lt;p&gt;IFQL: influx query language.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ influx --help
$ influx -username &amp;lt;username&amp;gt; -p &amp;lt;password&amp;gt; -h &amp;lt;hostname&amp;gt;
$ influx -precision rfc3339 # 显示可读的时间戳

$ influx -database &#39;test&#39; -host &#39;127.0.0.1&#39;
-execute &#39;select * from &amp;quot;test&amp;quot;.&amp;quot;test&amp;quot;.&amp;quot;test&amp;quot; where time &amp;gt; now() - 30d&#39;
-format &#39;csv&#39; &amp;gt; test.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;database&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ CREATE DATABASE test
$ DROP DATABASE test
$ SHOW DATABASES
$ USE test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;measurement(table)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ DROP MEASUREMENT &amp;lt;measurement&amp;gt;
$ SHOW MEASUREMENTS
$ SHOW MEASUREMENTS WHERE &amp;lt;tagkey&amp;gt;=&amp;lt;tagvalue&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tags&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ SHOW TAG KEYS
$ SHOW TAG KEYS FROM &amp;lt;measurement&amp;gt;
$ SHOW TAG VALUES FROM &amp;lt;measurement&amp;gt; WITH KEY=&amp;lt;tagkey&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fileds&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ SHOW FIELD KEYS
$ SHOW FIELD KEYS FROM &amp;lt;measurement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subscription&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ SHOW SUBSCRIPTIONS
$ CREATE SUBSCIPTION &amp;lt;subs_name&amp;gt; ON &amp;lt;db&amp;gt;.&amp;lt;rp&amp;gt; DESTINATIONS (&amp;quot;ANY&amp;quot;|&amp;quot;ALL&amp;quot;) host{&amp;quot;,&amp;quot;, host}
$ DROP SUBSCRIPTION &amp;lt;subs_name&amp;gt; ON &amp;lt;db&amp;gt;.&amp;lt;rp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;series&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ SHOW SERIES
$ DROP SERIES FROM &amp;lt;measurement&amp;gt; WHERE &amp;lt;tagkey&amp;gt;=&#39;&amp;lt;tagvalue&amp;gt;&#39;
$ DROP SERIES WHERE &amp;lt;tagkey&amp;gt;=&#39;&amp;lt;tagvalue&amp;gt;&#39; # 从所有measurement删除指定节点的所有数据
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;shared&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ drop shard &amp;lt;shard_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;http-api&#34;&gt;HTTP API&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;port = 8086
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;write&#34;&gt;write&lt;/h2&gt;
&lt;p&gt;create:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -i -XPOST http://localhost:8086/query --data-urlencode &amp;quot;q=CREATE DATABASE mydb&amp;quot;
post /query
data = {
    &amp;quot;q&amp;quot;: &amp;quot;create database &amp;lt;database&amp;gt;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;query&#34;&gt;query&lt;/h2&gt;
&lt;p&gt;show:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -G &#39;http://localhost:8086/query&#39; --data-urlencode &amp;quot;q=show databases&amp;quot;
get /query
params = {
    &amp;quot;pretty&amp;quot; : True,
    &amp;quot;q&amp;quot;: &amp;quot;show databases&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;influxql&#34;&gt;influxQL&lt;/h1&gt;
&lt;p&gt;influxql语句按下列关键字顺序排列&lt;/p&gt;
&lt;p&gt;tag_key, field_key, measurement都需要用双引号.&lt;/p&gt;
&lt;p&gt;The SELECT clause specifies an InfluxQL function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;quot;&amp;lt;field_key/tag_key&amp;gt;&amp;quot; from &amp;quot;&amp;lt;measurement&amp;gt;&amp;quot;
select &amp;quot;&amp;lt;field_key/tag_key&amp;gt;&amp;quot; as &amp;quot;alias&amp;quot; from &amp;quot;&amp;lt;measurement&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The INTO clause writes query results to a user-specified measurement.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; INTO &amp;quot;&amp;lt;measurement&amp;gt;&amp;quot; from &amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The FROM clause specifies a single measurement.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;quot;&amp;lt;measurement&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The WHERE clause specifies the time range for the query.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;condition1&amp;gt; OR/AND &amp;lt;condition2&amp;gt;

# string类型的 value必须用单引号．
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;quot;&amp;lt;tag_key/field_key&amp;gt;&amp;quot; &amp;lt;operation&amp;gt; &#39;&amp;lt;tag_value/field_value&amp;gt;&#39;

now() : time &amp;gt; now(() - 10m

= != &amp;lt; &amp;gt;

RE:
=~ !~
=~  : /.*ERROR.*|.*CRITICAL.*/  /ERROR|CRITICAL/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The GROUP BY clause groups results by all tags (*) and into 12-minute intervals.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;quot;&amp;lt;tag_key&amp;gt;&amp;quot;

fill()
time()/time(1ns/u/ms/s/m/h/d/w)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ORDER BY time DESC clause returns results in descending timestamp order.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;time/field_key&amp;gt;
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;time/field_key&amp;gt; desc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The LIMIT 2 clause limits the number of points returned to two.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; limit &amp;lt;number&amp;gt;
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; desc limit &amp;lt;number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The OFFSET 2 clause excludes the first two averages from the query results.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; limit &amp;lt;number&amp;gt; offset &amp;lt;&amp;gt;
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; desc limit &amp;lt;number&amp;gt; offset &amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SLIMIT 1 clause limits the number of series returned to one.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt;
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; desc limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SOFFSET 1 clause paginates the series returned.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt; soffzet &amp;lt;&amp;gt;
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; desc limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt; soffset&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The tz() clause returns the UTC offset for the specified timezone.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt; soffzet &amp;lt;&amp;gt; tz(&amp;lt;time_zone&amp;gt;)
select &amp;lt;&amp;gt; from &amp;lt;&amp;gt; where &amp;lt;&amp;gt; group by &amp;lt;&amp;gt; order by &amp;lt;&amp;gt; desc limit &amp;lt;&amp;gt; offset &amp;lt;&amp;gt; slimit &amp;lt;&amp;gt; soffset&amp;lt;&amp;gt; tz(&amp;lt;time_zone&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;flux&#34;&gt;flux&lt;/h1&gt;
&lt;p&gt;influxql的升级版，支持多表查询.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;function&#34;&gt;function&lt;/h1&gt;
&lt;h2 id=&#34;aggregations&#34;&gt;aggregations&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;count(&amp;lt;fieldkey&amp;gt;) # 统计fieldvalues行数
distinct(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues不重复的值的列表
integral(&amp;lt;fieldkey&amp;gt;) # 积分
mean(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues的算数平均值
median(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues的排序后的中间值
mode(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues出现频率最高的值
spread(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues最值之间的差异
stddev(&amp;lt;fiekdkey&amp;gt;) # 返回fieldvalues的标准偏差
sum(&amp;lt;fieldkey&amp;gt;) # 返回fieldvalues的和
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;selectors&#34;&gt;selectors&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bottom(&amp;lt;fieldkey&amp;gt;, N) # 返回最小的N个fieldvalues
first(&amp;lt;fieldkey&amp;gt;) # 返回timestamp最小的fieldvalue
last(&amp;lt;fieldkey&amp;gt;) # 返回timestamp最大的fieldvalue
max(&amp;lt;fieldkey&amp;gt;) # 返回最大的fieldvalue
min(&amp;lt;fieldkey&amp;gt;) # 返回最小的fieldvalue
percentile(&amp;lt;fieldkey&amp;gt;, N) # 百分数
sample(&amp;lt;fieldkey&amp;gt;, N) # 返回N个fieldvalue的随即样本
top(&amp;lt;fieldkey&amp;gt;, N) # 返回最大的N个fieldvalue
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;transformations&#34;&gt;transformations&lt;/h2&gt;
&lt;p&gt;transformations函数的field_key可以是aggregations和selectors函数的返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cumulative_sum(&amp;lt;field_key&amp;gt;)
derivative(&amp;lt;field_key&amp;gt;, [&amp;lt;unit&amp;gt;]) # 求单位时间的变化率, (cur-last)/(interval/unit)
difference(&amp;lt;field_key&amp;gt;) # 返回连续时间值之间的差异 -&amp;gt; 值的差异
elapsed(&amp;lt;field_key&amp;gt;) # 返回连续时间间隔的差异 -&amp;gt; 时间间隔差异
moving_average()
non_negative_derivative()
non_negative_difference()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;predictors&#34;&gt;predictors&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;holt_winters(function(&amp;lt;field_key&amp;gt;), N, S)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;rp&#34;&gt;RP&lt;/h1&gt;
&lt;p&gt;数据保存策略.&lt;/p&gt;
&lt;p&gt;autogen是默认RP，duration=infinite&lt;/p&gt;
&lt;p&gt;duration: 存储的数据时间间隔&lt;/p&gt;
&lt;p&gt;replication: 存储的数据副本数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show retention policies on &amp;quot;&amp;lt;database&amp;gt;&amp;quot;

create retention policy &amp;quot;&amp;lt;rp_name&amp;gt;&amp;quot; on &amp;quot;&amp;lt;database&amp;gt;&amp;quot; duration 30d replication 1 default

drop retention policy &amp;quot;&amp;lt;rp_name&amp;gt;&amp;quot; on &amp;quot;&amp;lt;database&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cq&#34;&gt;CQ&lt;/h1&gt;
&lt;p&gt;对超过保存策略指定时间的数据，可以做统计采样.(类似于store procedure).&lt;/p&gt;
&lt;p&gt;CQ不能更新，只能删除重建．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show continuous queries

create continuous query &amp;lt;CQ_name&amp;gt; on &amp;lt;database&amp;gt;
begin
    SELECT &amp;lt;function[s]&amp;gt; INTO &amp;lt;destination_measurement&amp;gt; FROM &amp;lt;measurement&amp;gt; [WHERE &amp;lt;stuff&amp;gt;] GROUP BY time(&amp;lt;interval&amp;gt;)[,&amp;lt;tag_key[s]&amp;gt;]
end

DROP CONTINUOUS QUERY &amp;lt;cq_name&amp;gt; ON &amp;lt;database_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;best-practice&#34;&gt;Best Practice&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;select 1-(mean(&amp;quot;part&amp;quot;) / mean(&amp;quot;all&amp;quot;)) as &amp;quot;rate&amp;quot;
from (
    select sum(&amp;quot;value&amp;quot;) as &amp;quot;smart&amp;quot; from &amp;quot;jobs_type&amp;quot; where &amp;quot;type&amp;quot;=&#39;smart&#39; and $timeFilter
),(
    select sum(&amp;quot;value&amp;quot;) as &amp;quot;all&amp;quot; from &amp;quot;jobs_type&amp;quot; where &amp;quot;type&amp;quot;=&#39;reversinglab&#39; and $timeFilter
)
group by time($__interval) fill(none)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Kapacitor</title>
        <link>https://canuxcheng.com/post/metrics_kapacitor/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_kapacitor/</guid>
        <description>&lt;h1 id=&#34;kapacitor&#34;&gt;Kapacitor&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/influxdata/Kapacitor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/influxdata/Kapacitor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Open source framework for processing, monitoring, and alerting on time series data&lt;/p&gt;
&lt;p&gt;可以通过chrongraf创建tickscript/task, 然后通过api/cli导入到kapacitor.&lt;/p&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hostname = &amp;quot;kapcitor-service&amp;quot;

# 如果从influxdb读取数据需要配置该选项．
[[influxdb]]
enabled = true

# 如果从该路径加载tickscript
[[load]]
enabled = true
dir=&amp;quot;/etc/kapacitor/load&amp;quot;
# tasks, 放到/etc/kapacitor/load/tasks/*.tick,重启kapacitor会自动加载task,并默认enable.
## 要求，ID和tick文件同名，tickscript开头需要指定dbrp, tickscript里面需要指定batch/stream.
# templates...
# handlers...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ kapacitor help

# 创建template(也就是变量可以单独赋值的tickscript)
$ kapacitor define-template &amp;lt;name&amp;gt; -tick /path/template.tick
$ kapacitor show-template &amp;lt;name&amp;gt;

# 创建/更新 task, 创建的默认是disable状态.
# 从tickscript创建task
$ kapacitor define &amp;lt;name&amp;gt; -tick task.tick -type [stream|batch] -dbrp [database.retentionPolicy]
# 从template创建task(如果yaml/json中没有指定template需要用-template指定)
$ kapacitor define &amp;lt;name&amp;gt; -file task.yaml
$ kapacitor define &amp;lt;name&amp;gt; -file task.json

# 删除task
$ kapacitor delete [task id/name]

$ kapacitor list tasks/templates
$ kapacitor reload [task id/name] # 相当于disable &amp;amp; enable.
$ kapacitor enable [task id/name]
$ kapaciror disable [task id/name]
$ kapacitor show [id/name]
$ kapacitor watch [task id/name]

$ kapacitor list topics
$ kapacitor delete topics [topic id]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;http-api&#34;&gt;Http API&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;port = 9092
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;configuration&#34;&gt;configuration&lt;/h2&gt;
&lt;p&gt;获取所有可以overwrite的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /kapacitor/v1/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取section/option参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /kapacitor/v1/config/smtp
GET /kapacitor/v1/config/smtp/
GET /kapacitor/v1/config/influxdb
GET /kapacitor/v1/config/influxdb/localhost

POST /kapacitor/v1/config/smtp/
{
    &amp;quot;set&amp;quot;:{
        &amp;quot;enabled&amp;quot;: true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作task:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改已存在的task的参数:
$ curl -H &#39;content-type: application/json&#39; -X PATCH -d &#39;{&amp;quot;vars&amp;quot;: {&amp;quot;warn&amp;quot;:{&amp;quot;value&amp;quot;:90, &amp;quot;type&amp;quot;:&amp;quot;int&amp;quot;}}}&#39; http://kapacitor-service:9092/kapacitor/v1/tasks/cpu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作alert:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 列出所有topic:
$ curl -H &#39;content-type: application/json&#39; -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics
// 列出指定topic的所有events:
$ curl -H &#39;content-type: application/json&#39; -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics/&amp;lt;topic&amp;gt;/events
// 列出指定events
$ curl -H &#39;content-type: application/json&#39; -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics/&amp;lt;topic&amp;gt;/events/&amp;lt;event&amp;gt;?min-level=CRITICAL
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tickscript&#34;&gt;TICKscript&lt;/h1&gt;
&lt;p&gt;注释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tickscript字符串用单引号和三单引号表示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = &#39;test&#39;
var b = &#39;&#39;&#39;test1
test2&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Keywords:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TRUE
FALSE
AND
OR
lambda
var
dbrp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;operator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ - * /    算数运算
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=    比较运算
=~ !~    正则表达式匹配和不匹配
! AND OR    逻辑运算
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chaining operators:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|    chaining method (constructor)
.    property method (property methods &amp;amp; event handlers)
@    User Define Function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;status:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 -&amp;gt; OK
1 -&amp;gt; INFO
2 -&amp;gt; WARN
3 -&amp;gt; CRIT
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;node&#34;&gt;node&lt;/h1&gt;
&lt;p&gt;node是tickscript中的复杂数据结构．&lt;/p&gt;
&lt;p&gt;两个顶级node类型是stream和batch&lt;/p&gt;
&lt;p&gt;batch是定时查询influxdb.&lt;/p&gt;
&lt;p&gt;stream是通过订阅influxdb,写入到influxdb的数据也会写入kapacitor.&lt;/p&gt;
&lt;p&gt;constructor调用相应的property methods.&lt;/p&gt;
&lt;h2 id=&#34;stream&#34;&gt;stream&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var data = stream
    |from()...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chaining methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Deadman
From
Stats
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;batch&#34;&gt;batch&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var data = batch
    |query()...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chaining methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Deadman
Query
Stats
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;alert&#34;&gt;alert&lt;/h2&gt;
&lt;p&gt;alert有三种类型: threshold, relative, deadman.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var alert = data
    |eval()...
    |alert()
      .id(&#39;{{ index .Tags &amp;quot;&amp;lt;tag-key&amp;gt;&amp;quot; }}&#39;)
      .message(&#39;{{ .ID }} {{ .Level }} {{ index .Fields &amp;quot;&amp;lt;field-key&amp;gt;&amp;quot; }} {{ .Time }}&#39;)
      .details(...)
      ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id()    # 定义alert的ID
message()    # 相当于email的subject.
details()    # html格式的警告信息，相当于email的body.
info()
infoReset()
warn()
warnReset()
crit()
critReset()
email()
log()    # 将json格式的alert存放到文件．
idTag
idField
levelTag()
levelField()
durationField()
messageField()
post()
tcp()
all()    # period里面所有值都满足条件才alert
topic()
flapping()
history()
inhibit(&amp;lt;category&amp;gt;, &amp;lt;tags&amp;gt;) // 忽略一类告警
quiet()
noRecoveries() # 不要发恢复(OK)的警告
stateChangesOnly() # 状态改变才发警告,OK/INFO/WARNING/CRITICAL
category()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;message/details event data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过property methods定义一些变量
ID -&amp;gt; {{ .ID }}
Name -&amp;gt; measurement
TaskName -&amp;gt; task name
Group -&amp;gt; groupBy
Tags -&amp;gt; {{.Tags}} {{index .Tags &amp;quot;&amp;lt;tag_key&amp;gt;&amp;quot;}}
Fields -&amp;gt; {{.Fields}} {{index .Fields &amp;quot;&amp;lt;field_key&amp;gt;&amp;quot;}}
Message
Details
Time -&amp;gt; {{ .Time }}
Duration -&amp;gt; {{ .Duration }}
Level -&amp;gt; {{ .Level }}
Data
Recoverable
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;query&#34;&gt;query&lt;/h2&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query(q string)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fill()
align()
alignGroup()
groupBy()
cron()
every()
period()
quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;from&#34;&gt;from&lt;/h2&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;database()
retentionPolicy()
measurement()
where()
groupBy()
round()
truncate()
quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;window&#34;&gt;window&lt;/h2&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()
period()
align()
quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;log&#34;&gt;Log&lt;/h2&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;level()
prefix()
quiet()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdbout&#34;&gt;influxDBOut&lt;/h2&gt;
&lt;p&gt;constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;influxDBOut()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;property methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;handler&#34;&gt;handler&lt;/h1&gt;
&lt;p&gt;handler是用来处理alert的工具, 最常用的是email&lt;/p&gt;
&lt;p&gt;handler可以调用相应的options.&lt;/p&gt;
&lt;h2 id=&#34;email&#34;&gt;email&lt;/h2&gt;
&lt;p&gt;options:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;to(&amp;quot;&amp;lt;email_address&amp;gt;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要配置smtp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[smtp]
    enabled = true
    host = &amp;quot;localhost&amp;quot;  # 一般postfix/mailutils和kapacitor安装到同一台server
    port = 25

    from = &amp;quot;canuxcheng@gmail.com&amp;quot;  # 必须配置
    to = [&amp;quot;&amp;quot;]  # 可以在tickscript中指定, tickscript不指定，就用该配置.

    global = true # 开启后,tickscript中不用指定handler,默认都是发邮件.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;log-1&#34;&gt;log&lt;/h2&gt;
&lt;p&gt;options:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;path
mode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写入到log.&lt;/p&gt;
&lt;h2 id=&#34;slack&#34;&gt;slack&lt;/h2&gt;
&lt;h2 id=&#34;post&#34;&gt;post&lt;/h2&gt;
&lt;h2 id=&#34;tcp&#34;&gt;tcp&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Prometheus</title>
        <link>https://canuxcheng.com/post/metrics_prometheus/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_prometheus/</guid>
        <description>&lt;h1 id=&#34;prometheus&#34;&gt;Prometheus&lt;/h1&gt;
&lt;p&gt;Prometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询&lt;/p&gt;
&lt;p&gt;swarm部署:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vegasbrianc/prometheus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vegasbrianc/prometheus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;k8s部署:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/coreos/kube-prometheus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/coreos/kube-prometheus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/coreos/prometheus-operator&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/coreos/prometheus-operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/charts/tree/master/stable/prometheus-operator&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/helm/charts/tree/master/stable/prometheus-operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高可用:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/thanos-io/thanos&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/thanos-io/thanos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;prometheus grafana dashboard:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-monitoring/kubernetes-mixin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-monitoring/kubernetes-mixin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grafana/kubernetes-app&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grafana/kubernetes-app&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;promql&#34;&gt;PromQL&lt;/h1&gt;
&lt;p&gt;metrics类型:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;counter计数器&lt;/li&gt;
&lt;li&gt;gauge仪表盘&lt;/li&gt;
&lt;li&gt;histogram直方图&lt;/li&gt;
&lt;li&gt;summary摘要&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Telegraf</title>
        <link>https://canuxcheng.com/post/metrics_telegraf/</link>
        <pubDate>Thu, 18 Jan 2018 19:23:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_telegraf/</guid>
        <description>&lt;h1 id=&#34;telegraf&#34;&gt;Telegraf&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/influxdata/telegraf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/influxdata/telegraf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The plugin-driven server agent for collecting &amp;amp; reporting metrics.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;configuartion&#34;&gt;Configuartion&lt;/h1&gt;
&lt;p&gt;agent configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interval    所有inputs的默认运行间隔
round_interval
collection_jitter
precision    ns/us/ms/s
flush_interval
flush_jitter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;input configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interval
name_override # 默认measurements是插件名,修改默认measurements.
name_prefix
name_suffix
tags
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go-api&#34;&gt;Go API&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://godoc.org/github.com/influxdata/telegraf#Input&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godoc.org/github.com/influxdata/telegraf#Input&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试插件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 需要配置文件
$ telegraf --input-filter &amp;lt;plugin-name&amp;gt; --test
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;
&lt;p&gt;安装依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install ruby-dev
sudo gem install fpm
sudo apt-get install rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译telegraf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make telegraf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./telegraf config &amp;gt; ./etc/telegraf.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构建deb:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make package
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;
&lt;p&gt;修改默认enable的plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# plugin中相应的sampleConfig中的字段不要用#注释．
internal/config/config.go -&amp;gt; 可以修改默认enable的plugin.
inputDefaults
outputDefaults
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./telegraf --config ./etc/telegraf.conf --input-filter process --test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加debugxinxi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;log&amp;quot;
log.Printf(&amp;quot;D! key: %v&amp;quot;, value)
# &amp;quot;D!&amp;quot; 开头的信息当debug=true才会打印.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Contribution</title>
        <link>https://canuxcheng.com/post/go_oss/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_oss/</guid>
        <description>&lt;h1 id=&#34;golang-contribution&#34;&gt;Golang Contribution&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.dev/doc/contribute&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.dev/doc/contribute&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建google账号&#34;&gt;创建google账号&lt;/h2&gt;
&lt;p&gt;推荐申请一个google邮箱。&lt;/p&gt;
&lt;p&gt;在开发机配置git&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.email name@example.com   
$ git config user.email name@example.com            
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;签cla&#34;&gt;签CLA&lt;/h2&gt;
&lt;p&gt;个人开发者需要签署CLA。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cla.developers.google.com/about/google-individual&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cla.developers.google.com/about/google-individual&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置git认证&#34;&gt;配置git认证&lt;/h2&gt;
&lt;p&gt;点击“Generate Password”， 用google邮箱登陆，根据提示配置git。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.googlesource.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建gerrit账号&#34;&gt;创建gerrit账号&lt;/h2&gt;
&lt;p&gt;用google邮箱登陆即可。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go-review.googlesource.com/dashboard/self&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装git-codereview&#34;&gt;安装git-codereview&lt;/h2&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/review/git-codereview@latest
$ git --exec-path

&amp;gt; copy git-codereview.exe from GOBIN to Git\mingw64\libexec\git-core

$ git codereview help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux/mac:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/review/git-codereview@latest
$ git codereview help
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选取修改的cl&#34;&gt;选取修改的CL&lt;/h2&gt;
&lt;p&gt;从github选取一个还没有人提交CL(change log/list)的Issue进行修改。&lt;/p&gt;
&lt;p&gt;issue三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NeedsInvestigation&lt;/li&gt;
&lt;li&gt;NeedsDecision&lt;/li&gt;
&lt;li&gt;NeedsFix    选这个里面还没有CL的做&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues?q=is%3Aissue&amp;#43;is%3Aopen&amp;#43;label%3ANeedsFix&amp;#43;NOT&amp;#43;%22golang.org%2Fcl%22&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;提交patch&#34;&gt;提交patch&lt;/h2&gt;
&lt;p&gt;支持github或者gerrit提交patch。&lt;/p&gt;
&lt;p&gt;github用户直接fork到自己账号，clone下来即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/golang/go.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gerrit用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://go.googlesource.com/go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建开发分支并修改代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b canux_dev
...
git add -A
git codereview change
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地测试修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./all.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交修改，github用户直接去github页面提交PR。&lt;/p&gt;
&lt;p&gt;gerrit用户通过命令行提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git codereview mail     # send changes to Gerrit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;commit message格式有严格要求。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/doc/contribute#commit_messages&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://golang.org/doc/contribute#commit_messages&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;code-review&#34;&gt;code review&lt;/h2&gt;
&lt;p&gt;提交之后trybots会自动构建，可以通过build dashboard查看各个平台build结果:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://build.golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://build.golang.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看自己的patch的review情况：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go-review.googlesource.com/dashboard/self&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Debug</title>
        <link>https://canuxcheng.com/post/go_debug/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_debug/</guid>
        <description>&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;go vet
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;gdb&#34;&gt;gdb&lt;/h1&gt;
&lt;h1 id=&#34;delve&#34;&gt;delve&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/derekparker/delve&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/derekparker/delve&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Devops</title>
        <link>https://canuxcheng.com/post/go_devops/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_devops/</guid>
        <description>&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;
&lt;p&gt;go有三种安装方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码安装&lt;/li&gt;
&lt;li&gt;标准包安装&lt;/li&gt;
&lt;li&gt;第三方工具安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GOROOT:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOROOT 就是go的安装目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows标准包安装go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msi指定安装路径，自动添加%GOROOT%/bin到环境变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux标准包安装go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;下载.tar.gz包解压到/usr/local/go
GOROOT=/usr/local/go
export PATH=$PATH:/usr/local/go/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go --help
$ go version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三方工具gvm安装go:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://github.com/moovweb/gvm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gvm install go1.9.2
$ gvm use go1.9.2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gopath&#34;&gt;GOPATH&lt;/h1&gt;
&lt;p&gt;gopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．&lt;/p&gt;
&lt;p&gt;GOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOPATH=$USERPROFILE%go
GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gopath结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src    存放源码
pkg    编译后的库文件
bin    编译后生成的可执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gopath有多个值时用冒号分开即可.&lt;/p&gt;
&lt;h1 id=&#34;gobin&#34;&gt;GOBIN&lt;/h1&gt;
&lt;p&gt;默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOBIN=$HOME/go/bin
export PATH=$PATH:$HOME/go/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go get 和 go install 安装的二进制到GOBIN。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go命令&#34;&gt;go命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ go help [command]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get&lt;/p&gt;
&lt;p&gt;下载并安装包和依赖, 也就是安装第三方的库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get [...] [packages]

&amp;gt; go get安装第三方包如果出现依赖无法安装，可以通过github下载．
$ cd golang.org/x
$ git clone https://github.com/golang/crypto.git crypto
$ go install golang.org/x/crypto/ssh

go get -u (without any arguments) now only upgrades the direct and indirect dependencies of your current package, and no longer examines your entire module.

go get -u ./... from your module root upgrades all the direct and indirect dependencies of your module, and now excludes test dependencies.

go get -u -t ./... is similar, but also upgrades test dependencies.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;build&lt;/p&gt;
&lt;p&gt;编译包和依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go build [-o output] [-i] [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;install&lt;/p&gt;
&lt;p&gt;编译并安装包和依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go install [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run&lt;/p&gt;
&lt;p&gt;编译并运行程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run [...] gofiles... [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fmt&lt;/p&gt;
&lt;p&gt;格式化代码和文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go fmt [...] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vet&lt;/p&gt;
&lt;p&gt;检测代码常见错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go vet [-n] [-x] [build flags] [vet flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test&lt;/p&gt;
&lt;p&gt;测试包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test [...] [packages] [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doc&lt;/p&gt;
&lt;p&gt;查看文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go doc [package/symbol]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tool&lt;/p&gt;
&lt;p&gt;运行工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go tool [-n] command [args...]

addr2line

asm

buildid

cgo

// 查看汇编代码
compile
go tool compile -S pkg.go

cover
dist
doc
fix
link
nm
objdump
pack
pprof
test2json
trace
vet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go mod init &amp;lt;name&amp;gt;
go mod tidy // 添加缺少的，删除多余的.
go mod download // 下载包
go mod verify 
go mod edit
go mod graph
go mod why
go mod vendor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过env 设置golang的变量，取代系统环境变量
go env
go env -w GOROOT=&amp;quot;/usr/local/go&amp;quot;
go env -w GOPATH=&amp;quot;$HOME/go&amp;quot;
go env -w GOBIN=&amp;quot;$HOME/go/bin&amp;quot;
go env -w GO111MODULE=on
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;clean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go clean -cache
go clean -modcache
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;安装第三方包&#34;&gt;安装第三方包&lt;/h1&gt;
&lt;p&gt;go get的功能很有限．&lt;/p&gt;
&lt;p&gt;godep和golide都会被官方的dep取代．&lt;/p&gt;
&lt;h2 id=&#34;depdeprecated&#34;&gt;dep(deprecated)&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/dep&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/dep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无法解决GFW的问题.&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get -u github.com/golang/dep/cmd/dep
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go官方包管理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 初始化一个使用dep管理包的项目，
# 创建Gopkg.toml, Gopkg.lock, vendor/
$ dep init

$ dep status

$ dep prune

$ dep ensure
$ dep ensure -update
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;module&#34;&gt;module&lt;/h2&gt;
&lt;p&gt;vgo已经集成到go1.11&lt;/p&gt;
&lt;p&gt;通过go mod init初始化两个文件.&lt;/p&gt;
&lt;p&gt;go.mod:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module
go
require
exclude
replace

// 使用本地module,或使用指定repo里面的module
replace github.com/crazy-canux/go-devops =&amp;gt; /path/to/local/github.com/crazy-canux/go-devops
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go.sum:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go env -w GOSUMDB=off
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置相关环境变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GO111MODULE:
// auto/on/off
go env -w GO111MODULE=on

GOPROXY:
go env -w GOPROXY=https://goproxy.cn,direct
https://proxy.golang.org //默认值
https://goproxy.cn
https://goproxy.io
https://mirrors.aliyun.com/goproxy/

GOSUMDB:

GOPRIVATE

GONOPROXY

GONOSUMDB
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;项目结构&#34;&gt;项目结构&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cmd: 可执行文件入口
pkg: 核心代码库
api: api的spec, openapi/swagger/json/protocol/grpc
hack: 构建/测试相关脚本
plugin: 插件
staging: wip
third_party: 第三方工具/代码
vendor: 项目依赖
build
test
docs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有子目录包结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go-devops
    |- README.md
    |- doc.go
    |- grafana.go
    |- grafana_test.go
    ...

import &amp;quot;go-devops&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有子目录的包结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go-devops
    |- README.md
    |- doc.go // package go_devops
    |- grafana
       |- doc.go // package grafana
       |- grafana.go
       |- grafana_test.go

import &amp;quot;go-devops/grafana&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;proxy&#34;&gt;proxy&lt;/h1&gt;
&lt;p&gt;goproxy.io&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/goproxyio/goproxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goproxyio/goproxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;goproxy.cn&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/goproxy/goproxy.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goproxy/goproxy.cn&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Document</title>
        <link>https://canuxcheng.com/post/go_document/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_document/</guid>
        <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;p&gt;go文档相关&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://godoc.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godoc.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go文档的两种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go doc&lt;/li&gt;
&lt;li&gt;godoc&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;go-doc&#34;&gt;go doc&lt;/h1&gt;
&lt;p&gt;直接在命令行查看文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go doc [package/symbol]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;godoc&#34;&gt;godoc&lt;/h1&gt;
&lt;p&gt;go自带的文档命令行接口,在浏览器查看文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;godoc package [name ...]
godoc -http=:6060
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过github的项目文档在:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://godoc.org
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;godev&#34;&gt;go.dev&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pkg.go.dev&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go</title>
        <link>https://canuxcheng.com/post/go/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go/</guid>
        <description>&lt;h1 id=&#34;go概述&#34;&gt;Go概述&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://golang.org/ref/spec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go语言表达能力强，简洁，清晰，高效．&lt;/p&gt;
&lt;p&gt;go是一个快速的，静态的，强类型的，编译型语言．&lt;/p&gt;
&lt;p&gt;go具有高并发和垃圾回收功能.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go基本语法&#34;&gt;Go基本语法&lt;/h1&gt;
&lt;p&gt;go源程序叫*.go&lt;/p&gt;
&lt;p&gt;go大小写敏感&lt;/p&gt;
&lt;p&gt;go程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．&lt;/p&gt;
&lt;p&gt;go中只有首字母大写的名称才能从包中导出．&lt;/p&gt;
&lt;p&gt;go的类型在变量名后面．&lt;/p&gt;
&lt;p&gt;go函数外的每个语句都必须以关键字开始.&lt;/p&gt;
&lt;p&gt;go标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.&lt;/p&gt;
&lt;p&gt;go使用大括号{}表示一个代码块.&lt;/p&gt;
&lt;p&gt;go使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．&lt;/p&gt;
&lt;p&gt;go的包名一般是小写的单个单词(文件所在的最后一层目录名).&lt;/p&gt;
&lt;p&gt;go一般使用驼峰命名法.&lt;/p&gt;
&lt;p&gt;go没有逗号操作符.&lt;/p&gt;
&lt;p&gt;go中++/&amp;ndash;是语句不是表达式．&lt;/p&gt;
&lt;p&gt;go中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go注释&#34;&gt;Go注释&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* comment */
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go关键字&#34;&gt;Go关键字&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var const 
break continue for if else switch case default goto fallthrough
func return defer
package import
range type struct map
interface
select go chan
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go运算符和优先级&#34;&gt;Go运算符和优先级&lt;/h1&gt;
&lt;p&gt;go中的运算都是从左到右结合．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^    #
!    # 逻辑非

*
/    # 结果取整数
%
&amp;lt;&amp;lt;   # 位运算，左移
&amp;gt;&amp;gt;   # 位运算，右移
&amp;amp;    # 位运算，　按位与
&amp;amp;^   #

+
-
|    # 位运算,按位或
^    # 位运算,按位异或

==
!=
&amp;lt;
&amp;lt;=
&amp;gt;
&amp;gt;=

&amp;lt;- # chan运算符

&amp;amp;&amp;amp;   # 逻辑与
||   # 逻辑或
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go数据类型&#34;&gt;Go数据类型&lt;/h1&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;p&gt;定义/申明变量:&lt;/p&gt;
&lt;p&gt;通过关键字var在包或函数中申明/定义变量&lt;/p&gt;
&lt;p&gt;在函数或块中定义的变量作用域就是当前函数或当前块。&lt;/p&gt;
&lt;p&gt;在函数外部定义的全局变量作用域是整个包.&lt;/p&gt;
&lt;p&gt;大写字母开头的全局变量能被其它包引用。&lt;/p&gt;
&lt;p&gt;全局变量必须使用var关键字．&lt;/p&gt;
&lt;p&gt;没有初始化的变量在申明的时候赋予零值.&lt;/p&gt;
&lt;p&gt;已经申明但没有使用的变量在编译时会报错．&lt;/p&gt;
&lt;p&gt;通过等号给变量赋值就是定义变量.&lt;/p&gt;
&lt;p&gt;大写字母开头的变量是public, 小写字母开头的是private变量.&lt;/p&gt;
&lt;p&gt;申明变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一个变量一种类型
var varname Type

# 多个变量一种类型
var varname varname1 ... Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义(初始化)变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 定义的时候初始化
var i, j int = 1, 2
# 初始化使用表达式可以省略类型，从值中获取类型
var i, j = true, &amp;quot;str&amp;quot;

# 多个变量多种类型
var (
    var1 Type1 = val1
    var2 Type2 = val2
    # 给类型取别名
    variable alias Type = value
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_  # 下划线是个特殊变量名，用于忽略一个值.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;
&lt;p&gt;定义常量：&lt;/p&gt;
&lt;p&gt;通过关键字const在包或函数中定义常量．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 常量可以是bool, string, 数值
const Pi float = 3.14
const World = &amp;quot;China&amp;quot;
const Truth = true
# 定义多个常量
const (
    Pi = 3.14
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;枚举:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iota内置常量用来统计枚举中的行数
const (
    con = val
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量不能用:=语法来申明。&lt;/p&gt;
&lt;h2 id=&#34;bool&#34;&gt;bool&lt;/h2&gt;
&lt;p&gt;bool类型变量的零值是false.&lt;/p&gt;
&lt;p&gt;bool类型是值传递．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;true
false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数值类型&#34;&gt;数值类型&lt;/h2&gt;
&lt;p&gt;数值类型变量的零值是0.&lt;/p&gt;
&lt;p&gt;数值类型是值传递.&lt;/p&gt;
&lt;p&gt;有符号类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int int8 int16 int32(rune) int64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无符号类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uint uint8(byte) uint16 uint32 uint64 uintptr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;int, uint, uintptr 在32位系统是32bit, 在64位系统是64bit&lt;/p&gt;
&lt;p&gt;浮点类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float32
float64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;complex64
complex128
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;p&gt;string类型变量的零值是&amp;quot;&amp;quot;.&lt;/p&gt;
&lt;p&gt;string类型是值传递.&lt;/p&gt;
&lt;p&gt;go中的字符串都采用utf-8编码.&lt;/p&gt;
&lt;p&gt;go中的字符串用双引号  或者　反引号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 单行字符串
var str string = &amp;quot;hello&amp;quot;
# 多行字符串(原样输出)
var str string = `hello
                 world`

var str = &amp;quot;hello&amp;quot; // 类型可以通过值确定
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go中的字符串是不可变的, 修改字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用类型转换
var str string = &amp;quot;hello&amp;quot;
c := []byte(str) # str转换成 []byte 类型
c[index] = value # 重新赋值
newString := string(c) # []byte 转换成 string

# 使用索引运算
s := &amp;quot;hello&amp;quot;
s = &amp;quot;str&amp;quot; + s[1:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s1 := &amp;quot;hello&amp;quot;
s2 := &amp;quot;world&amp;quot;
s3 := s1 + s2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for index, value := range s {...}
for index := range s {...}
for _, value := range s {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结构体struct&#34;&gt;结构体/struct&lt;/h2&gt;
&lt;p&gt;结构体就是字段的集合．结构体字段通过点操作符来访问．&lt;/p&gt;
&lt;p&gt;结构体是值传递.&lt;/p&gt;
&lt;p&gt;申明一个结构体类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type StructName struct {
    var Type
    var1 Type1
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明多个结构体类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type (
    StructB struct {
        ...
    }

    StructB struct {
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明一个结构体类型的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s StructName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义结构体变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 列出全部字段
var s = StructName{val, ...}
s := StructName{val, ...}

# 使用val: 可以仅列出部分字段, 未列出的字段使用默认值
var s = StructName{
    var: val,
    ...
}
s := StructName{
    var: val,
    ...
}

# 给字段赋值
s.var1 = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构体指针:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type StructName struct {
    var Type
    var1 Type1
}

var s = &amp;amp;StructName{}
s := &amp;amp;StructName{}

(*s).Var1 = val1
s.Var1 = val1 // go允许隐士间接引用

s := StructName{val, val1}
p := &amp;amp;s
# 原本应该通过(*p).var来访问，go允许隐式间接引用．
p.var = p.var1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;指针pointer&#34;&gt;指针/pointer&lt;/h2&gt;
&lt;p&gt;指针的零值为nil.&lt;/p&gt;
&lt;p&gt;go的指针保存了值的内存地址, go没有指针运算．&lt;/p&gt;
&lt;p&gt;通过指针实现引用传递.&lt;/p&gt;
&lt;p&gt;申明一个指针变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var point *int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;amp;操作符会生成一个指向其操作数的指针(保存变量的地址)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;point = &amp;amp;variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*操作符表示指针指向的数值(读写该地址保存的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*point = value
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数组array&#34;&gt;数组/array&lt;/h2&gt;
&lt;p&gt;数组通过下标来访问．数组不能改变大小（长度）&lt;/p&gt;
&lt;p&gt;数组是值传递．&lt;/p&gt;
&lt;p&gt;数组的属性有类型和长度,只有长度和类型都相同的才是同类型数组,才能相互赋值.&lt;/p&gt;
&lt;p&gt;数组长度和容量相同．&lt;/p&gt;
&lt;p&gt;申明数组:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ArrayName [number]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ArrayName = [number]Type{}

ArrayName := [number]Type{val, val1, ...}
ArrayName := [number]Type{index: value, ...} // 给指定索引赋值,其余为零值
ArrayName := []Type{val, ...} // 容量也可以由初始化的元素个数决定.

ArrayName := [number]*Type{0: new(int), 1: new(string), ...} // 指针数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组元素赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayName[0] = val

*ArrayName[0] = val // 指针数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组赋值（值传递）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 只有类型和长度相同的数组才能赋值
# 非指针数组赋值，会另外开辟地址空间.
 # 修改newArray的值，不会改变ArrayName的值
 newArray = ArrayName

# 指针类型的数组赋值，指向的是相同的地址.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多维数组(嵌套数组):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6 7, 8}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for index, value := range a {
    fmt.Println(&#39;%d, %d\n&#39;, index, value)
}

# 只要索引, 去掉,value即可
for index := range a {...}
# 只要值，用_忽略索引
for _, value := range a {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切片slice&#34;&gt;切片/slice&lt;/h2&gt;
&lt;p&gt;切片的零值是nil, nil切片的长度和容量都是０，且没有底层数组．&lt;/p&gt;
&lt;p&gt;切片传递的是地址(引用传递),修改切片的元素值其实就是修改底层数组的对应的元素的值,共享该元素的其它切片的值也相应改变．&lt;/p&gt;
&lt;p&gt;切片的属性包括指向底层数组的指针，切片的长度，切片的容量.&lt;/p&gt;
&lt;p&gt;切片不存储数据，只是描述数组的一段,因此切片不指定大小（长度）.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 表示切片类型
[]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明切片:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var SliceName []Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过字面量定义
var SliceName = []Type{}
SliceName := []Type{val, val1, ...}

SliceName := []Type{index: value}   // 索引就表示长度和容量

// 通过make函数创建切片
var SliceName = make([]type, len, cap)
SliceName := make([]Type, len, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过切片定义新切片:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;切片的操作返回新的切片。
NewS := SName[i:j]
cap(SName) = k
NewS 长度和容量：
len = j-i
cap = k-i
NewS 无法访问指向的底层数组第一个元素之前的元素。
也不能访问超出长度之后的索引,但是可以通过append增加切片长度之后访问.
NewS[index] //当index &amp;gt;= j编译器报错 ，超出了NewS 的长度，无法访问。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三索引操作:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NewS := SName[i:j:k]
三索引表示容量， i:j 表示长度， i:k 表示容量.
容量不能超过可用容量(也就是SName的容量).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切片操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 半开区间，不包括最后一个下标
s[low:high]
s[:high] // low=0, default
s[low:] // high=max, default
s[:] // s[0:max], default

s[:0] // 把切片的长度变为０（清空切片)
s[:4] // 扩展为４
s[2:] // 扩展为 arrayname[2:4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二维切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[][]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 切片遍历和数组相同
for index, value := range s {
    ...
}
for index := range s {...}
for _, value := range s {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;slice作为函数参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;切片作为函数参数，传递的其实是值,函数会使用和切片相同的底层数组创建一个新的切片来操作.
所以函数内部修改了切片的值,作为参数的切片的值也被修改了.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;映射map&#34;&gt;映射/map&lt;/h2&gt;
&lt;p&gt;映射的零值是nil, 既没有键，也不能添加键．&lt;/p&gt;
&lt;p&gt;map是引用传递．是存储键值对的无序集合.&lt;/p&gt;
&lt;p&gt;map是无序的，只能通过key索引，没有下标操作.&lt;/p&gt;
&lt;p&gt;map的key需要支持==或!= 运算，不能是函数，映射，切片&lt;/p&gt;
&lt;p&gt;申明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 申明值为nil的空映射，不能用于存储键值对.
var MapName map[keyType]ValueType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var MapName = map[keyType]ValueType{}
var MapName = map[keyType]ValueType{
    key: value,
    ...
}

MapName := map[keyType]valueType{}
MapName := map[KeyType]ValueType{
    &amp;quot;key&amp;quot;: value,
    ...
}

# 通过make定义map
var MapName = make(map[keyType]ValueType, cap)
MapName := make(map[keyType]ValueType, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m[key] = value

value = m[key]
# 若key在m中ok为true, 否则为false, 且value是对应类型的零值
value, ok := m[key]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for key, value := range m {...}
for key := range m {...}
for _, value := range m {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map作为函数参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不会创建该映射的副本，该函数对映射的修改就是对原始参数指向的映射的修改.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;go中兼容的类型才能转换，而且必须显示转换．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ValueA [:]= TypeA(ValueB)

floatA := float64(uint64Var)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;值传递pass by value：bool, number, string, struct, array, interface&lt;/p&gt;
&lt;p&gt;引用传递pass by reference： slice, map, function, channel&lt;/p&gt;
&lt;p&gt;zero value:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struct, array 取决于元素类型&lt;/li&gt;
&lt;li&gt;pointer, slice, map, channel, function, interface: nil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;amp;:  address of operator,  used to get memory address. 地址操作。
*:  dereference or pointer type. 解引用 或 指针类型。&lt;/p&gt;
&lt;p&gt;explicit(显式) is better than implicit（隐式）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go控制流&#34;&gt;Go控制流&lt;/h1&gt;
&lt;p&gt;go控制流的左大括号不能另起一行．&lt;/p&gt;
&lt;p&gt;golang没有内置的while循环。&lt;/p&gt;
&lt;h2 id=&#34;for循环&#34;&gt;for循环&lt;/h2&gt;
&lt;p&gt;go只有for可以循环．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; 10; i++ {
    sum += i
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环有三种模式：&lt;/p&gt;
&lt;p&gt;for循环后面没有小括号，代码块必须要大括号．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for init; condition; statement {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环的初始化语句init和后置语句statement可以省略,相当于while．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for condition {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无限循环, 相当于for(;;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;if条件语句&#34;&gt;if条件语句&lt;/h2&gt;
&lt;p&gt;if后面的小括号不要，但是代码块需要大括号．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition {
    ...
} else if condition {
    ...
} else {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;switch条件语句&#34;&gt;switch条件语句&lt;/h2&gt;
&lt;p&gt;go中的switch-case的variable无需为常量，且取值可以不是整数．&lt;/p&gt;
&lt;p&gt;go中的只执行匹配的case，相当于默认在每个case后面加了break语句．&lt;/p&gt;
&lt;p&gt;case匹配到的语句如果只有一行可以和case语句写在同一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
case value1:
    ...
case value2: expression
default:
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个条件可以放到一个case:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
    case value1, value2, ...: expression
    case valuen: fallthrough
    defalut:
        ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有条件的switch-case&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch {
case condition:
    ...
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不需要默认的break,需要添加fallthrough:&lt;/p&gt;
&lt;p&gt;fallthrough不会判断后面的case的condition,而是直接执行后面所有的case.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
case val1:
    ...
    fallthrough
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;label&#34;&gt;label&lt;/h2&gt;
&lt;p&gt;golang的label不需要缩进:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LabelName:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;break&#34;&gt;break&lt;/h2&gt;
&lt;p&gt;break用于跳出for/switch/select循环.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break也支持label:&lt;/p&gt;
&lt;p&gt;break的label可以跳出外层循环.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break [tag]

label:
for i := 0; i &amp;lt; 1000; i++ {
    for j :=0; j &amp;lt; 1000; j++ {
        if j &amp;lt; i {
            break label // 跳出最外层循环.
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;continue&#34;&gt;continue&lt;/h2&gt;
&lt;p&gt;continue语句只能在for循环中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;continue也支持label:&lt;/p&gt;
&lt;p&gt;continue的label可以从外层循环继续执行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;continue [tag]

next:
for outer := 2; outer &amp;lt; 3000; outer++ {
    for inner :=2; inner &amp;lt; outer; inner++ {
        if outer%inner == 0 {
            continue next // 并非继续内存循环，而是从外层循环继续执行.
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;goto&#34;&gt;goto&lt;/h2&gt;
&lt;p&gt;goto跳转语句，跳转到指定标签运行．&lt;/p&gt;
&lt;p&gt;标签区分大小写.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Label:
    expression

...
goto Label
continue LABEL
break LABEL
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go函数&#34;&gt;Go函数&lt;/h1&gt;
&lt;p&gt;函数的零值是nil.&lt;/p&gt;
&lt;p&gt;函数是引用类型.&lt;/p&gt;
&lt;p&gt;大写字母开头的函数是public, 小写字母开头的是private.&lt;/p&gt;
&lt;p&gt;创建函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var Type, var1 Type1) rType {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多值返回：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var Type) (rType, rType1, ...) {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命名返回值(必须用括号)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 一般return后面不带返回值，否则需要返回定义的所有变量
func FuncName(var Type) (rvar rType, rvar1 rType) {
    ...
    rvar = ...
    rvar1 = ...
    return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个变量类型相同时保留最后一个的类型即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var, var1 Type) (rvar, rvar1 rType) {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量作用域：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数内部定义的变量是局部变量
函数外定义的变量是全局变量．
局部变量优先使用．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;形式参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;形式参数的作用域范围和函数体中的局部变量一致．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数返回值的作用域范围和函数体中的局部变量一致．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实际参数可以是值传递，也可以是引用传递．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 实参必须是指针才能调用该函数
func FuncName(v *Type) rType {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数中短变量申明(局部变量):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在函数内部，明确值的类型的情况下可以用 := 代替var关键字定义变量
func FuncName() {
    variable := value
    var1, var2, ... := val1, val2, ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重复申明短变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本次申明与已申明的变量在同一作用域．
在初始化中与已申明的变量类型相同才能赋值．
本次申明中至少另有一个变量是新申明的．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;defer关键字：&lt;/p&gt;
&lt;p&gt;defer会将函数推迟到外层函数返回之后执行.&lt;/p&gt;
&lt;p&gt;推迟调用的函数其参数会立即求值，然后压入defer栈中,外层函数返回后按照后进先出的顺序调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncOut() {
    ...
    defer FuncName()
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数也是值，也可以传递，可以用作函数的参数或返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(variable func(Type, ...) rType) rType {
    ...
}

FuncName := func(variable Type, ...) rType {
    ..
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匿名函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func(&amp;lt;arguments&amp;gt;) (returns) {}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(vars ...Type) rType {}
FuncName(vars..)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;closures/闭包:&lt;/p&gt;
&lt;p&gt;init函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 每个包中可以有任意个init函数.
# 这些init函数会在main函数执行之前调用.
# init函数不能有参数和返回值
# main中的init最后调用.
func init() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go文件和输入输出&#34;&gt;Go文件和输入输出&lt;/h1&gt;
&lt;p&gt;go的标准库fmt实现了类似于C语言的printf和scanf格式化I/O函数.&lt;/p&gt;
&lt;p&gt;还有io和bufio标准库可用&lt;/p&gt;
&lt;h2 id=&#34;输入&#34;&gt;输入&lt;/h2&gt;
&lt;p&gt;输入的本质就是从Stdin读取&lt;/p&gt;
&lt;p&gt;fmt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var input string
fmt.Scan*(&amp;amp;input)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Reader:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inputReader := bufio.NewReader(os.Stdin)
inputReader.Read*()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输出&#34;&gt;输出&lt;/h2&gt;
&lt;p&gt;输出的本质就是往os.Stdout写&lt;/p&gt;
&lt;p&gt;fmt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Print*()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;os.File:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os.Stdout.Write*(&amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Writer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;outputWriter := bufio.NewWriter(os.Stdout)
outputWriter.Writer*()
outputWriter.Flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;p&gt;标准库os.File结构的指针用来表示文件句柄&lt;/p&gt;
&lt;p&gt;标准库bufio提供了带缓冲的操作&lt;/p&gt;
&lt;p&gt;读文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;readFile, err := os.Open(&amp;quot;filename&amp;quot;)
readFile.Read*()

inputReader := bufio.NewReader(readFile)
inputReader.Read*(&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeFile, err := os.Create(&amp;quot;filename&amp;quot;)
writeFile.Write*()

outputWriter := bufio.NewWriter(outputFile)
outputWriter.Write*(&amp;quot;string&amp;quot;)
outputWriter.Flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go包&#34;&gt;Go包&lt;/h1&gt;
&lt;p&gt;创建包：&lt;/p&gt;
&lt;p&gt;包名一般和所在路径的最后一层目录一致．一般是小写的单个单词.&lt;/p&gt;
&lt;p&gt;同一个目录中的代码文件使用同一个包名．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package pkg1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单个导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;pkg1&amp;quot;
import &amp;quot;pkg2&amp;quot;
# 导入时创建别名
import alias &amp;quot;pkg&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组合导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    &amp;quot;pkg1&amp;quot;
    &amp;quot;pkg2&amp;quot;
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包内的函数名首字母大些才能被其它包导入，否则就是私有的．&lt;/p&gt;
&lt;p&gt;命名导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    alias &amp;quot;pkg&amp;quot; # 给包取别名
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入副作用：&lt;/p&gt;
&lt;p&gt;只执行导入包中的init函数并初始化全局变量，不导入其它内容．&lt;/p&gt;
&lt;p&gt;编译时不检查该导入是否使用.也不能通过包名调用其中的导出函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import _ &amp;quot;path/pkg&amp;quot;

import (
    _ &amp;quot;path/pkg&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go包查找顺序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$GOROOT/src/... # 安装golang的路径里面的标准库
$GOPATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发时候推荐的书写顺序:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;第三方包&lt;/li&gt;
&lt;li&gt;本地包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go包的编译器导入顺序：按照依赖关系拓扑排序topological sort.&lt;/p&gt;
&lt;p&gt;编译器导入规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先加载被依赖的包&lt;/li&gt;
&lt;li&gt;避免重复加载&lt;/li&gt;
&lt;li&gt;包之间有依赖关系的，根据依赖图顺序加载&lt;/li&gt;
&lt;li&gt;所有包在init()调用前完成初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go文档&#34;&gt;Go文档&lt;/h1&gt;
&lt;p&gt;通过注释编写文档，godoc会自动识别．对包，函数，类型，全局变量都可以.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// this is documents
func Fucntion() {}

/*
    This is documents
*/
type St struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以给包写一段文字较多的文档，通过在包内创建doc.go.&lt;/p&gt;
&lt;p&gt;这段文档会显示在所有其它文档之前．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim doc.go
/*
    This docs for package
    ...
*/
package pkg # 使用和包一样的名字.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go-runtime&#34;&gt;Go runtime&lt;/h1&gt;
&lt;h2 id=&#34;调度器&#34;&gt;调度器&lt;/h2&gt;
&lt;p&gt;GMP模型&lt;/p&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;p&gt;mcache: 每个p的本地缓存
mcentral：全局中心缓存
mheap：操作系内存管理&lt;/p&gt;
&lt;h2 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;GOGC
GOMEMLIMIT&lt;/p&gt;
&lt;p&gt;三色标记清除算法进行垃圾收集Tricolor Mark-and-Sweep&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色: 未访问，可能是垃圾&lt;/li&gt;
&lt;li&gt;灰色：已被访问，但子对象没有扫描&lt;/li&gt;
&lt;li&gt;黑色：已被访问，子对象处理完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GC四个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;STW（stop the world）起始阶段：暂停所有goroutine，做初始标记。&lt;/li&gt;
&lt;li&gt;concurrent mark并发标记：并发追踪所有可达对象。&lt;/li&gt;
&lt;li&gt;concurrent sweep并发清除：并发释放不可达对象的内存。&lt;/li&gt;
&lt;li&gt;STW终止阶段：做最后同步和收尾工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;网络轮询器netpoller&#34;&gt;网络轮询器netpoller&lt;/h2&gt;
&lt;h2 id=&#34;系统监控sysmon&#34;&gt;系统监控Sysmon&lt;/h2&gt;
&lt;h2 id=&#34;栈管理&#34;&gt;栈管理&lt;/h2&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;go的标准库errors实现了用于错误处理的函数.&lt;/p&gt;
&lt;p&gt;内置函数panic是断言函数，会触发一个异常，用于终止当前的线程(会在defer执行完之后终止线程)&lt;/p&gt;
&lt;p&gt;内置接口定义了error接口类型, error类型都有一个Error方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var errName error = errors.New(&amp;quot;error message.&amp;quot;)

err := errors.New(&amp;quot;error message.&amp;quot;)

err := fmt.Errorf(format string, a ...interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;panic:&lt;/p&gt;
&lt;p&gt;相当于抛出一个异常，在运行完defer之后,返回到调用者继续运行defer，直到最外层的defer执行完毕，终止程序.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;panic(v interface{})
panic(&amp;quot;ERROR: command not found&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;recover:&lt;/p&gt;
&lt;p&gt;只能用于defer修饰的函数，用于接收panic调用中传递过来的错误值,没有panic返回nil.&lt;/p&gt;
&lt;p&gt;当前函数的后面不会被执行，recover捕获异常之后会返回到调用者继续执行.&lt;/p&gt;
&lt;p&gt;相当于catch一个异常.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;recover() interface{}
defer func() {
    if err := recover(); err != nil {
        fmt.Println(e)
        // &amp;quot;ERROR: command not found&amp;quot;
    }
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在包内部，总是应该从panic中recover．&lt;/li&gt;
&lt;li&gt;总是向包的调用者返回错误值，而不是panic.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反射与接口&#34;&gt;反射与接口&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Go_Concurrency</title>
        <link>https://canuxcheng.com/post/go_concurrency/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_concurrency/</guid>
        <description>&lt;h1 id=&#34;并发concurrency&#34;&gt;并发/concurrency&lt;/h1&gt;
&lt;p&gt;传统并发基于线程，golang基于CSP&lt;/p&gt;
&lt;p&gt;CSP: communicating sequential processes, 通信顺序进程。&lt;/p&gt;
&lt;p&gt;go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.&lt;/p&gt;
&lt;p&gt;concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。&lt;/p&gt;
&lt;p&gt;所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.&lt;/p&gt;
&lt;p&gt;parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。&lt;/p&gt;
&lt;p&gt;process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。&lt;/p&gt;
&lt;p&gt;thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。&lt;/p&gt;
&lt;p&gt;co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。&lt;/p&gt;
&lt;p&gt;goroutine: go语言的协程，是并行的，通过channel来通信.&lt;/p&gt;
&lt;p&gt;GMP: goroutine的实现模型。&lt;/p&gt;
&lt;p&gt;G: goroutine, 初始栈2kb，够过go关键字创建，包含grunable, grunning, gwaiting三种状态。&lt;/p&gt;
&lt;p&gt;M: machine，对应OS线程，与cpu绑定，golang默认10000个，SetMaxThreads可以设置，需要绑定P才能执行G，否则休眠。&lt;/p&gt;
&lt;p&gt;P: processor, 逻辑处理器，管理G的本地队列和调度上下文。由GOMAXPROCS确定个数(默认cpu核个数)。用来 解决GM的锁竞争问题。&lt;/p&gt;
&lt;p&gt;不要通过共享内存通信，通过通信来共享内存。&lt;/p&gt;
&lt;h2 id=&#34;goroutines&#34;&gt;goroutines&lt;/h2&gt;
&lt;p&gt;go关键字会启动一个新的goroutine并执行.&lt;/p&gt;
&lt;p&gt;每个goroutine会绑定到一个逻辑处理器P上运行，每个逻辑处理器会绑定到单个操作系统线程。&lt;/p&gt;
&lt;p&gt;当goroutine阻塞，就会把goroutine和machine从逻辑处理器P上分离，然后创建一个新的machine绑定到该逻辑处理器P，并继续运行队列中的其它goroutine.&lt;/p&gt;
&lt;p&gt;当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的machine也会保存下来.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go FuncName(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主进程main结束了，goroutine也结束．&lt;/p&gt;
&lt;h2 id=&#34;竟态&#34;&gt;竟态&lt;/h2&gt;
&lt;p&gt;race condition: 竞争状态，多个goroutine同时操作同一资源.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 检测竞争状态
$ go build -race
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以要解决goroutine间的通信和同步的问题.&lt;/p&gt;
&lt;p&gt;通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。&lt;/p&gt;
&lt;p&gt;channel还是mutex,选择的依据是他们的能力/特性.&lt;/p&gt;
&lt;p&gt;channel的能力是让数据流动起来，擅长的是数据流动的场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递数据的所有权，即把某个数据发送给其他协程&lt;/li&gt;
&lt;li&gt;分发任务，每个任务都是一个数据&lt;/li&gt;
&lt;li&gt;交流异步结果，结果是一个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;状态&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;p&gt;goroutine通过channel来通信和同步。&lt;/p&gt;
&lt;p&gt;channels是引用类型,chan是线程安全的，并且不会有数据冲突。&lt;/p&gt;
&lt;p&gt;chan通过make来创建，通过close来关闭．chan是先进先出的FIFO.&lt;/p&gt;
&lt;p&gt;chan 支持的类型Type： 基本类型（number, string, bool），复合类型（pointer, struct, array, slice, map, function, interface），自定义类型.&lt;/p&gt;
&lt;p&gt;chan的Type不能是channel本身。&lt;/p&gt;
&lt;p&gt;申明一个变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ChanName chan Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个chan, 默认chan都是双向的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ch = make(chan Type, cap)
ch := make(chan Type, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chan的方向：&lt;/p&gt;
&lt;p&gt;将make创建的双向转换为单向,也可以直接在函数参数申明单向。&lt;/p&gt;
&lt;p&gt;只接收的chan无法关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var recvOnly chan&amp;lt;- Type = ch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只发送的chan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var sendOnly &amp;lt;-chan Type = ch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作chan:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch &amp;lt;- v    # 发送值到ch
v := &amp;lt;-ch    # 从ch接收值, 并赋予Type类型变量v
v, ok = &amp;lt;-ch # 从ch接收值带状态, 如果ch关闭或没有数据，ok就为false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无缓冲的chan(同步):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无缓冲的chan发送者会阻塞unbuffered，直到接收者接收数据, 也就是说是同步的synchronous.&lt;/p&gt;
&lt;p&gt;只有发送者或只有接受者的chan会导致死锁，产生panic.&lt;/p&gt;
&lt;p&gt;带缓冲的chan（异步）:&lt;/p&gt;
&lt;p&gt;带缓冲的chan，在缓冲区满之前，都不会阻塞buffered，是异步的asynchronous.&lt;/p&gt;
&lt;p&gt;只有通道中没有要接收的值，接收动作才会阻塞.&lt;/p&gt;
&lt;p&gt;只有在通道没有可用缓冲区容纳被发送的值，发送动作才会阻塞．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan Type, cap)

// 带缓冲的chan可以通过range遍历
for val := range ch {
    fmt.Println(val)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示关闭chan:&lt;/p&gt;
&lt;p&gt;通道关闭后，不能再向通道发送值，但是已经发送的值可以被接收.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 一般在生产者(发送动作)关闭chan
close(ch)

// 如果chan关闭ok=false, v为零值.
v, ok := &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;监听chan的数据流，类似于switch-case, 可用于处理多个chan的情况&lt;/p&gt;
&lt;p&gt;运行规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每次执行select都只会执行一个case或者执行default；当有case可以执行，default不会执行；没有case执行时才执行default。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当没有case或default可以执行，select阻塞等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有多个case可以执行，select随机选择一个执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;case后面必须是读或写chan的操作，否则编译出错。&lt;/p&gt;
&lt;p&gt;ctx, cancel := context.WithCancel(context.Background())
select {
case var := &amp;lt;-ch1:
do something
case ch2 &amp;lt;-value:
do something
case &amp;lt;-time.After(2 * time.Second):
fmt.Println(&amp;ldquo;timeout!&amp;rdquo;)
case &amp;lt;-ctx.Done():
fmt.Println(&amp;ldquo;cancelled:&amp;rdquo;, ctx.Err())
&amp;hellip;
default:    // default可以省略
do default thing.
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;退出goroutine&#34;&gt;退出goroutine&lt;/h2&gt;
&lt;h3 id=&#34;for-range&#34;&gt;for-range&lt;/h3&gt;
&lt;p&gt;range能感知channel关闭，当channel被发送数据的goroutine关闭时，range就会结束，然后退出for循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func(send &amp;lt;-chan int) {
    for val := range send {
        ...
    }
}(sendOnly)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;for-select&#34;&gt;for-select&lt;/h3&gt;
&lt;p&gt;select有多路复用能力，for-select 可以持续处理多路多个channel的能力。但select不能感知channel的关闭.&lt;/p&gt;
&lt;p&gt;context.Context退出goroutine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case &amp;lt;-ctx.Done():
            fmt.Println(&amp;quot;goroutine exiting:&amp;quot;, ctx.Err())
            return
        default:
            fmt.Println(&amp;quot;working...&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;某个通道关闭，不再处理该通道，但是继续处理其它channel,select不会在nil的通道上进行等待:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case x, ok := in1:
            if !ok {
                in1 = nil   把只读channel设置为nil,select不会在这里阻塞。
            }
        case y, ok :=&amp;lt;-in2:
            if !ok {
                in2 = nil
            }
        if in1 == nil &amp;amp;&amp;amp; in2 == nil {
            return
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用专门channel发送退出信号,只需要在main中关闭channel，所有goroutine都会接收到信号退出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case &amp;lt;- stopCh:
            ...
            return
        case &amp;lt;- t.C:
            ...
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_builtin</title>
        <link>https://canuxcheng.com/post/gsl_builtin/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_builtin/</guid>
        <description>&lt;h1 id=&#34;builtin&#34;&gt;builtin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/builtin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pkg.go.dev/builtin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go的builtin package.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;true
false
iota // Untyped int.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;p&gt;pointer, channel, func, interface, map, or slice type的zero value：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nil
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 分配并初始化各种类型的对象, 返回一个指针．
new(Type) *Type

# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.
make(t Type, size ...IntegerType) Type

# 返回容量，　Array/ArrayPointer/Slice/Channel
cap(v Type) int

# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel
len(v Type) int

print(args ...Type)

println(args ...Type)

func max[T cmp.Ordered](x T, y ...T) T
func min[T cmp.Ordered](x T, y ...T) T
func clear[T ~[]Type | ~map[Type]Type1](t T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;complex:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 把两个浮点数构造成一个复数
complex(r, i FloatType) ComplexType

# 返回复数c的实部
real(c ComplexType) FloatType

# 返回复数c的虚部
imag(c ComplexType) FloatType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;slice:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 向切片末尾追加元素，返回新的切片．切片长度增加.
# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．
# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.
append(slice []Type, elems ...Type) []Type

# 复制一个切片, 返回复制的元素的个数
copy(dst, src []Type) int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从映射删除一个键值对
delete(m map[Type]1, key Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chan:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 由发送者关闭一个双向或只发送的信道
close(c chan&amp;lt;- Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 停止当前go程的正常执行(断言函数)
panic(v interface{})

# 管理panic过程中的go程
recover() interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;types&#34;&gt;types&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bool

uint
uintptr
uint8/byte (0 - 255)
uint16
uint32
uint64

int
int8 (-128 - 127)
int16
int32/rune
int64

float32
float64

complex64
complex128

string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Type
Type1
IntegerType
FloatType
ComplexType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误处理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error

// go使用error值来表示错误状态，nil表示成功，非nil表示失败．
type error interface {
    ERROR() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;any:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type any = interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comparable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type comparable interface{ comparable }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_concurrency</title>
        <link>https://canuxcheng.com/post/gsl_concurrency/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_concurrency/</guid>
        <description>&lt;h1 id=&#34;sync&#34;&gt;sync&lt;/h1&gt;
&lt;p&gt;sync用于goroutine同步.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;locker&#34;&gt;Locker&lt;/h2&gt;
&lt;p&gt;一个可以加锁和解锁的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Locker interface {
    Lock()
    Unlock()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pool&#34;&gt;Pool&lt;/h2&gt;
&lt;p&gt;Pool是一个可以分别存取的临时对象的集合。&lt;/p&gt;
&lt;h2 id=&#34;once&#34;&gt;Once&lt;/h2&gt;
&lt;p&gt;只执行一次动作的对象(单例模式)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Once struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只有第一次调用才执行
func (o *Once) Do(f func())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;
&lt;p&gt;互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.&lt;/p&gt;
&lt;p&gt;Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。&lt;/p&gt;
&lt;p&gt;同一时刻只能有一个线程进入临界区.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Mutex struct {}

Mutex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 加锁，如果已经加锁，阻塞至m解锁．
func (m *Mutex) Lock()

// 解锁，如果没有加锁，导致panic
func (m *Mutex) Unlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rwmutex&#34;&gt;RWMutex&lt;/h2&gt;
&lt;p&gt;读写互斥锁,可以由不同的线程加锁和解锁.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type RWMutex struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。
func (rw *RWMutex) Lock()

// 解除写入锁定，如果没有加锁，导致panic
func (rw *RWMutex) Unlock()

// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。
func (rw *RWMutex) RLock()

// 解除读取锁，如果没有加锁，导致panic.
func (rw *RWMutex) RUnlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cond&#34;&gt;Cond&lt;/h2&gt;
&lt;p&gt;条件变量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cond struct {
    L Locker
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewCond(l Locker) *Cond
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (c *Cond) Broadcase()

func (c *Cond) Signal()

func (c *Cond) Wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;
&lt;p&gt;用于等待一组线程结束，父线程用Add方法来设定应等待的线程数量;
每个被等待的线程在结束时应调用Done方法;
同时，主线程应调用Wait方法阻塞至所有线程结束．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type WaitGroup sttruct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 增加计数
func (*WaitGroup) Add(delta int)

# 减少计数
func (*WaitGroup) Done()

# 阻塞直到计数器为0
func (*WaitGroup) Wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;syncatomic&#34;&gt;sync/atomic&lt;/h1&gt;
&lt;p&gt;提供底层的原子级内存操作，主要用于goroutine同步.&lt;/p&gt;
&lt;p&gt;int32, int64, uint32, uint64, uintptr, pointer.&lt;/p&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func AddInt64(addr *int64, delta int64) (new int64)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func LoadInt64(addr *int64) (val int64)
func LoadUint64(addr *uint64) (val uint64)
func StoreInt64(addr *int64, val int64)
func StoreUint64(addr *uint64, val uint64)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_cryptographic</title>
        <link>https://canuxcheng.com/post/gsl_cryptographic/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_cryptographic/</guid>
        <description>&lt;h1 id=&#34;crypto&#34;&gt;crypto&lt;/h1&gt;
&lt;p&gt;收集了常用的密码常量&lt;/p&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;RegisterHash(h Hash, f func() hash.Hash)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;publickey&#34;&gt;PublicKey&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PublicKey interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;privatekey&#34;&gt;PrivateKey&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PrivateKey interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Hash uint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (h Hash) Avaliable() bool
func (h Hash) Size() int
func (h Hash) New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptocipher&#34;&gt;crypto/cipher&lt;/h1&gt;
&lt;p&gt;用于包装底层块加密算法的实现.&lt;/p&gt;
&lt;h2 id=&#34;block&#34;&gt;Block&lt;/h2&gt;
&lt;p&gt;代表一个使用特定密钥的底层　加／解密器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;blockmode&#34;&gt;BlockMode&lt;/h2&gt;
&lt;p&gt;代表一个工作在块模式(CBC, ECB等)的加／解密器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type BlockMode interface {
    BlockSize() int
    CryptBlocks(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个BlockMode接口，底层用b加密，初始向量长度等于b的块尺寸.
func NewCBCEncrypter(b Block, iv []byte) BlockMode

// 返回一个BlockMode接口，底层用b解密，初始向量长度等于b的块尺寸.
func NewCBCDecrypter(b Block, iv []byte) BlockMode
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;
&lt;p&gt;stream接口表示一个流模式的加／解密器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stream interface {
    XORKeyStream(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewCFBEncrypter(block Block, iv []byte) Stream

func NewCFBDecrypter(block Block, iv []byte) Stream

func NewOFB(b Block, iv []byte) Stream

func NewCTR(b Block, iv []byte) Stream
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptorand&#34;&gt;crypto/rand&lt;/h1&gt;
&lt;p&gt;用于加解密的更安全的随机数生成器.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptoaes&#34;&gt;crypto/aes&lt;/h1&gt;
&lt;p&gt;对称加密算法,aes加密算法用于取代des算法.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const BlockSize = 16
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个cipher.Block接口, key为密钥，长度只能是16(aes-128),24(aes-192),32(aes-256)字节.
func NewCipher(key []byte) (cipher.Block, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptodsa&#34;&gt;crypto/dsa&lt;/h1&gt;
&lt;p&gt;非对称，数字签名算法dsa.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptorsa&#34;&gt;crypto/rsa&lt;/h1&gt;
&lt;p&gt;非对称加密算法rsa.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptomd5&#34;&gt;crypto/md5&lt;/h1&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const BlockSize = 64
const Size = 16
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回data的ms5检验和
func Sum(data []byte) [Size]byte

func New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha1&#34;&gt;crypto/sha1&lt;/h1&gt;
&lt;h2 id=&#34;constants-2&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// SHA1块大小
const BlockSize = 64

// SHA1校验和的字节数
const Size = 20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回数据data的SHA1校验和
func Sum(data []byte) [Size]byte

// 返回一个使用新的SHA1校验的hash.Hash接口
func New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha256&#34;&gt;crypto/sha256&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha512&#34;&gt;crypto/sha512&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hash-1&#34;&gt;hash&lt;/h1&gt;
&lt;h2 id=&#34;hash-2&#34;&gt;Hash&lt;/h2&gt;
&lt;p&gt;被所有hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash interface {
    io.Writer
    Sum(b []byte) []byte
    Reset()
    Size() int
    BlockSize() int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash32&#34;&gt;Hash32&lt;/h2&gt;
&lt;p&gt;被所有32位hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash32 interface {
    Hash
    Sum32() uint32
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash64&#34;&gt;Hash64&lt;/h2&gt;
&lt;p&gt;被所有64位hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash64 interface {
    Hash
    Sum64() uint64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashadler32&#34;&gt;hash/adler32&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashcrc32&#34;&gt;hash/crc32&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashcrc64&#34;&gt;hash/crc64&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashfnv&#34;&gt;hash/fnv&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_data</title>
        <link>https://canuxcheng.com/post/gsl_data/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_data/</guid>
        <description>&lt;h1 id=&#34;time&#34;&gt;time&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;p&gt;const:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    ANSIC       = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;
    Unixdate    = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;
    RFC3339     = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 阻塞go程d代表的时间段
func Sleep(d Duration)

func After(d Duration) &amp;lt;- chan Time

func Tick(d Duration) &amp;lt;- chan Time
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;time-1&#34;&gt;Time&lt;/h2&gt;
&lt;p&gt;代表一个纳秒精度的时间点.&lt;/p&gt;
&lt;p&gt;零值是January 1, year 1, 00:00:00.000000000 UTC.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type  Time struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST
func date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time

// 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301
func Now() Time

func Parse(layout, value s tring) (Time, error)

func ParseInLocation(layout, value string, loc *Location) (Time, error)

func Unix(sec int64, nsec int64) Time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回T的地点和时区信息
func (t Time) Location() *Location

// 返回t的时区规范名和相对于UTC的偏移量
func (t Time) Zone() (name string, offset int)

func (t Time) IsZero() bool

func (t Time) Local() Time

func (t Time) UTC() Time

func (t Time) In(loc *Location) Time

func (t Time) Unix() int64

func (t Time) UnixNano() int64

// 比较两个时间
func (t Time) Equal(u Time) bool

// t &amp;gt; u 返回true
func (t Time) Before(u Time) bool

// t &amp;lt; u 返回true
func (t Time) After(u Time) bool

// 返回t的年月日.
func (t Time) date() (year int, month Month, day int)

// 返回t对应的时分秒
func (t Time) Clock() (hour, min, sec int)

// 返回t对应的年
func (t Time) Year() int

// 返回t对应的月
func (t Time) Month() Month

func (t Time) ISOWeek() (year, week int)

// 返回t对应的当年的第几天
func (t Time) YearDay() int

// 返回t对应的当月的第几天
func (t Time) Day() int

// 返回t对应的星期几
func (t Time) Weekday() Weekday

// 返回t对应的第几小时
func (t Time) Hour() int

// 返回t对应的分钟
func (t Time) Minute() int

// 返回t对应的秒
func (t Time) Second() int

// 返回t对应的纳秒偏移量
func (t Time) Nanosecond() int

func (t Time) Add(d Duration) Time

func (t Time) Adddate(years int, months int, days int) Time

func (t Time) Sub(u Time) Duration

func (t Time) Round(d duration) Time

func (t Time) Truncate(d Duration) Time

func (t Time) Format(layout string) string

func (t Time) String(layout string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;weekday&#34;&gt;Weekday&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回d对应的英文名
func (d Weekday) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;month&#34;&gt;Month&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Month int

const (
    January Month = 1 + iota
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回m对应的英文名
func (m Month) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;location&#34;&gt;Location&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Location struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回使用给定名字创建的Location
// name == &amp;quot;&amp;quot; 或　name == &amp;quot;UTC&amp;quot;, 返回UTC
// name == &amp;quot;Local&amp;quot;, fanhui1Local
// 其它时间数据库的值
func LoadLocation(name string) (*Location, error)

// 使用给定的名称和偏移量创建一个Location
func FixedZone(name string, offset int) *Location
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回对时区信息的描述
func (l *Location) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;duration&#34;&gt;Duration&lt;/h2&gt;
&lt;h2 id=&#34;timer&#34;&gt;Timer&lt;/h2&gt;
&lt;h2 id=&#34;ticker&#34;&gt;Ticker&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerheap&#34;&gt;container/heap&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerlist&#34;&gt;container/list&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerring&#34;&gt;container/ring&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressbzip2&#34;&gt;compress/bzip2&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressflate&#34;&gt;compress/flate&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressgzip&#34;&gt;compress/gzip&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compresslzw&#34;&gt;compress/lzw&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compresszlib&#34;&gt;compress/zlib&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;archive&#34;&gt;archive&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_database</title>
        <link>https://canuxcheng.com/post/gsl_database/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_database/</guid>
        <description>&lt;h1 id=&#34;databasesql&#34;&gt;database/sql&lt;/h1&gt;
&lt;p&gt;使用该包，必须提供一个数据库驱动&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/wiki/SQLDrivers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/wiki/SQLDrivers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mssql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/denisenkom/go-mssqldb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/denisenkom/go-mssqldb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mysql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/go-sql-driver/mysql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/go-sql-driver/mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;postgresql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/lib/pq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lib/pq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jackc/pgx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jackc/pgx&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量
var ErrNoRows = errors.New(&amp;quot;sql: no rows in result set&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 注册并命名一个数据库，在Open中使用该命名启用该驱动
// 如果注册同一名称两次或者driver参数为nil, 会导致panic.
Register(name string, driver driver.Driver)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;db&#34;&gt;DB&lt;/h2&gt;
&lt;p&gt;DB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．&lt;/p&gt;
&lt;p&gt;可以安全的被多个go程同时使用．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type DB struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 验证数据库驱动和参数,并不创建和数据库的连接．
// driverName: mssql, mysql, postgres
// mssql dataSourceName: &amp;quot;server=%s;port=%d;database=%s;user id=%s;password=%s&amp;quot;
// mysql dataSourceName: &amp;quot;user:password@tcp(server:port)/database&amp;quot;
Open(driverName, dataSourceName string) (*DB, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回数据库下层驱动
func (db *DB) Driver() driver.Driver

// 创建和数据库的连接,检查连接是否有效
func (db *DB) Ping() error

// 关闭数据库，释放资源
func (db *DB) Close() error

// 设置与数据库建立连接的最大数目, 默认０表示无限制.
func (db *DB) SetMaxOpenConns(n int)

// 设置连接池中的最大闲置连接数
func (db *DB) SetMaxIdleConns(n int)

// 执行命令但是不返回执行结果,一般用于(insert/update/delete)
func (db *DB) Exec(query string, args ...interface{}) (Result, error)

// 执行命令返回多行结果（一般用于select)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)

// 执行命令最多返回一行结果
// 总是返回非nil值，直到返回值的Scan方法被调用，才会返回被延迟的错误.
func (db *DB) QueryRow(query string, args ...interface{}) *Row

// 创建一个准备好的状态用于之后的命令
func (db *DB) Prepare(query string) (*Stmt, error)

// 开始一个事务
func (db *DB) Begin() (*Tx, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stmt&#34;&gt;Stmt&lt;/h2&gt;
&lt;p&gt;stmt是准备好的状态，可以安全的被多个go程同时使用．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stmt struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *Stmt) Exec(args ...interface{}) (Result, error)

func (s *Stmt) Query(args ...interface{}) (*Rows, error)

func (s *Stmt) QueryRow(args ...interface{}) *Row

func (s *Stmt) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tx&#34;&gt;Tx&lt;/h2&gt;
&lt;p&gt;Tx表示一个进行中的数据库事务．&lt;/p&gt;
&lt;p&gt;一次事务必须以对Commit或Rollback的调用结束．&lt;/p&gt;
&lt;p&gt;事务结束后，所有的操作都会失败并返回ErrTxDone.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Tx struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)

func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)

func (tx *Tx) QueryRow(query string, args ...interface{}) *Row

func (tx *Tx) Prepare(query string) (*Stmt, error)

// 使用已存在的状态生成一个特定的状态．
func (tx *Tx) Stmt(stmt *Stmt) *Stmt

// 提交事务
func (tx *Tx) Commit() error

// 回滚事务
func (tx *Tx) Rollback() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner interface {
    Scan(src interface{}) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;result&#34;&gt;Result&lt;/h2&gt;
&lt;p&gt;Exec方法返回Result.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Result interface {
    LastInsertId() (int64, error)
    RowsAffected() (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;row&#34;&gt;Row&lt;/h2&gt;
&lt;p&gt;QueryRow方法返回Row, 表示单行查询结果．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Row struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将该行查询结果各列分别保存进dest参数指定的值中．
// 如果匹配多行，只取第一行，如果没有匹配行，返回ErrNoRows.
func (r *Row) Scan(dest ...interface{}) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rows&#34;&gt;Rows&lt;/h2&gt;
&lt;p&gt;Query方法返回Rows, 表示查询的结果集，它的游标指向第０行，使用Next方法遍历该结果集．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Rows struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回列名
func (rs *Rows) Columns() ([]string, error)

// 将当前行的各列结果填充进dest
func (rs *Rows) Scan(dest ...interface{}) error

// 准备用于Scan的下一行结果，每次调用Scan都要先调用Next
func (rs *Rows) Next() bool

func (rs *Rows) Close() error

func (rs *Rows) Err() error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;databasesqldriver&#34;&gt;database/sql/driver&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_file</title>
        <link>https://canuxcheng.com/post/gsl_file/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_file/</guid>
        <description>&lt;h1 id=&#34;path&#34;&gt;path&lt;/h1&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool
func Join(elem ...string) string
func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pathfilepath&#34;&gt;path/filepath&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;Constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    Separator = os.PathSeparator
    ListSeparator = os.PathListSeparator
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variable&#34;&gt;Variable&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrBadPattern = errors.New(&amp;quot;Syntax error in pattern&amp;quot;)

var SkipDir = errors.New(&amp;quot;skip this diractory&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool
func Abs(path string) (string, error)

// 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名.
func Rel(basepath, targpath string) (string, error)

func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string) // 包括小数点
func Walk(root string, walkFn WalkFunc) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;walkfunc&#34;&gt;WalkFunc&lt;/h2&gt;
&lt;p&gt;调用Walk时会对每个目录和文件调用该函数.&lt;/p&gt;
&lt;p&gt;如果该函数返回错误，Walk函数会中止.&lt;/p&gt;
&lt;p&gt;如果该函数返回SkipDir, Walk会掉过处理该目录，继续处理其它内容.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type WalkFunc func(path string, info os.FileInfo, err error) error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encoding&#34;&gt;encoding&lt;/h1&gt;
&lt;p&gt;定义了供其它包使用的在字节和文本之间转换数据的接口.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;encoding&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodingjson&#34;&gt;encoding/json&lt;/h1&gt;
&lt;p&gt;go和json数据类型对应关系，参考WEB/JSON.&lt;/p&gt;
&lt;p&gt;在线获取json的go数据结构:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mholt/json-to-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mholt/json-to-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mholt.github.io/json-to-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mholt.github.io/json-to-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;chan/complex/func类型不能编码为json.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;encoding/json&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 返回golang对象v的json编码(将go的对象转换为json对象), 可以打tag.
&amp;gt; &amp;quot;-&amp;quot; 该字段不会输出到json
&amp;gt; myName 在json中的名字
&amp;gt; omitempty 允许json中没有该字段
&amp;gt; Type 如果指定类型，会转换成指定的类型出现在json
json.Marshal(v interface{}) ([]byte, error)

# 具有缩进功能
json.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)

# 将json对象data转换成go对象，存入v
# 只有可导出字段才会在json中找到.
&amp;gt; Bool                   对应JSON布尔类型
&amp;gt; float64                对应JSON数字类型
&amp;gt; string                 对应JSON字符串类型
&amp;gt; []interface{}          对应JSON数组
&amp;gt; map[string]interface{} 对应JSON对象
&amp;gt; nil                    对应JSON的null
json.Unmarshal(data []byte, v interface{}) error

// 将json格式的src中的无用的空白字符剔除后写入dst.
func Compact(dst *bytes.Buffer, src []byte) error

// 格式化json，以便json编码能安全的嵌入html的&amp;lt;script&amp;gt;标签
func HTMLEscape(dst *bytes.Buffer, src []byte)

//
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;marshaler&#34;&gt;Marshaler&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Marshaler interface {
    MarshalJSON() ([]byte, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unmarshaler&#34;&gt;Unmarshaler&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Unmarshaler interface {
    UnmarshalJSON([] byte) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decoder&#34;&gt;Decoder&lt;/h2&gt;
&lt;p&gt;从输入流解码json对象&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Decoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewDecoder(r io.Reader) *Decoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 从dec读取下一个对象存入v.
func (dec *Decoder) Decode(v interface{}) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;encoder&#34;&gt;Encoder&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodingcsv&#34;&gt;encoding/csv&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodinggob&#34;&gt;encoding/gob&lt;/h1&gt;
&lt;p&gt;go binary, go的数据持久化包，用于编码器和解码器之间交换二进制数据.&lt;/p&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Register(value interface{})

func RegisterName(name string, value interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gobdecoder&#34;&gt;GobDecoder&lt;/h2&gt;
&lt;h2 id=&#34;gobencoder&#34;&gt;GobEncoder&lt;/h2&gt;
&lt;h2 id=&#34;decoder-1&#34;&gt;Decoder&lt;/h2&gt;
&lt;p&gt;管理从远端读取数据的类型和信息的解码操作.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Decoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个从r读取数据的Decoder
func NewDecoder(r io.Reader) *Decoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从dec读取下一个值并存入e
func (dec *Decoder) Decode(e interface{}) error

func (dec *Decoder) DecodeValue(v reflect.Value) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;encoder-1&#34;&gt;Encoder&lt;/h2&gt;
&lt;p&gt;管理数据类型和信息编码后发送到远端的操作.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Encoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个将编码后数据写入w的Encoder
func NewEncoder(w io.Writer) *Encoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将e编码后发送到enc
func (enc *Encoder) Encode(e interface{}) error

func (enc *Encoder) EncodeValue(value reflect.Value) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;commontype&#34;&gt;CommonType&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type CommonType struct {
    Name string
    Id typeId
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttemplate&#34;&gt;text/template&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttemplateparse&#34;&gt;text/template/parse&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;textscanner&#34;&gt;text/scanner&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttabwriter&#34;&gt;text/tabwriter&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;html&#34;&gt;html&lt;/h1&gt;
&lt;p&gt;提供了用于转义和解转义html文本的函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将　&amp;lt;, &amp;gt;, &amp;amp;, &#39;, &amp;quot; 转义为字符实体 &amp;amp;lt, &amp;amp;gt, &amp;amp;#39,
 func EscapeString(s string) string

 func UnescapeString(s string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;htmltemplate&#34;&gt;html/template&lt;/h1&gt;
&lt;p&gt;实现了数据驱动模板，用于生成可对抗代码注入的安全html输出．&lt;/p&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将b转义后写入w．
func HTMLEscape(w io.Writer, b []byte)

// 转义s之后,返回结果字符串.
func HTMLEscapeString(s string) string

// 转义多个字符串，返回结果字符串.
func HTMLEscaper(args ...interface{}) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;funcmap&#34;&gt;FuncMap&lt;/h2&gt;
&lt;p&gt;定义函数名字符串到函数的映射，每个函数必须要1到2个返回值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FuncMap map[string]interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template&#34;&gt;Template&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Template struct {
    Tree *parse.Tree
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建名为name的模板
func New(name string) *Template

// 在err非nil时panic, 检测模板是否正确．
// 通过template.New().Parse() 返回值作为参数.
func Must(t *Template, err error) *Template

// 创建一个模板，并解析filenames作为模板内容
// 第一个文件名为模板名字(不包括扩展名)
func ParseFiles(filenames ...string) (*Template, error)

// 创建一个模板，并解析匹配pattern的文件．
// 匹配的第一个文件名为模板名字(不包括扩展名)
func ParseGlob(pattern string) (*Template, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将字符串str解析为模板
func (t *Template) Parse(str string) (*Template, error)

// 将文件解析为模板
func (t *Template) ParseFiles(filenames ...string) (*Template, error)

//
func (t *Template) ParseGlob(pattern string) (*Template, error)

// 将解析好的模板应用到data上，并将输出写入wr.
func (t *Template) Execute(wr io.Writer, data interface{}) (err error)

// 使用和t关联的名为name的模板
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error

// 注册函数到模板t, funcMap的key是模板中调用的函数名，value是实际的函数
func (t *Template) Funcs(funcMap FuncMap) *Template
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;yaml&#34;&gt;yaml&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/go-yaml/yaml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/go-yaml/yaml&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;toml&#34;&gt;toml&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/toml-lang/toml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/toml-lang/toml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/BurntSushi/toml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/BurntSushi/toml&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GSL_golang</title>
        <link>https://canuxcheng.com/post/gsl_golang/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_golang/</guid>
        <description>&lt;h1 id=&#34;runtime&#34;&gt;runtime&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 指定编译器
const Compiler = &amp;quot;gc&amp;quot;/&amp;quot;gccgo&amp;quot;

// 处理器架构: 386/amd64/arm
const GOARCH string = theGoarch

// 操作系统: linux/freebsd/darwin/win
const GOOS string = theGoos
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var MemProfileRate int = 512 * 1024
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func GOROOT() string
func Version() string

// 返回本地机器的逻辑cpu个数
func NumCPU() int

//更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu.
func GOMAXPROCS(n int) int

// 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行.
// 当前goroutine放回队列等待继续执行.
func Gosched()

// 终止当前goroutine,终止前执行所有defer.
func Goexit()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimedebug&#34;&gt;runtime/debug&lt;/h1&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 设置最大线程数，默认1000.
func SetMaxThreads(threads int) int
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimecgo&#34;&gt;runtime/cgo&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimepprof&#34;&gt;runtime/pprof&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimerace&#34;&gt;runtime/race&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimetrace&#34;&gt;runtime/trace&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;expvar&#34;&gt;expvar&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;context&#34;&gt;context&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unsafe&#34;&gt;unsafe&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;errors&#34;&gt;errors&lt;/h1&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 使用字符串创建一个错误, 返回一个error
func New(text string) error
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_math</title>
        <link>https://canuxcheng.com/post/gsl_math/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_math/</guid>
        <description>&lt;h1 id=&#34;math&#34;&gt;math&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathbig&#34;&gt;math/big&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathcmplx&#34;&gt;math/cmplx&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathrand&#34;&gt;math/rand&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sort&#34;&gt;sort&lt;/h1&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Ints(a []int)
func IntAreSorted(a []int) bool
func SearchInts(a []int, x int) int

func Float64s(a []float64)
func Float64sArerSorted(a []float64) bool
func SearchFloat64s(a []float64, x float64) int

func Strings(a []string)
func StringsAreSorted(a []string) bool
func SearchStrings(a []string, x string) int

func Sort(data Interface)
func Stable(data Interface)
func IsSorted(data Interface) bool
func Reverse(data Interface) Interface
// 二分查找
func Search(n int, f func(int) bool) int
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;interface&#34;&gt;Interface&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;initslice&#34;&gt;InitSlice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type InitSlice []int
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;float64slice&#34;&gt;Float64Slice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Float64Slice []float64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringslice&#34;&gt;StringSlice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type StringSlice []string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_multimedia</title>
        <link>https://canuxcheng.com/post/gsl_multimedia/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_multimedia/</guid>
        <description>&lt;h1 id=&#34;image&#34;&gt;image&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mime&#34;&gt;mime&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_network</title>
        <link>https://canuxcheng.com/post/gsl_network/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_network/</guid>
        <description>&lt;h1 id=&#34;net&#34;&gt;net&lt;/h1&gt;
&lt;p&gt;网络IO接口，包括TCP/IP, UDP, SOCKET, DNS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    IPv4len = 4
    IPv6len = 16
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;addr&#34;&gt;Addr&lt;/h2&gt;
&lt;p&gt;代表一个网络终端地址．&lt;/p&gt;
&lt;p&gt;TCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Addr interface {
    Network() string
    String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tcpaddr&#34;&gt;TCPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveTCPAddr(net, addr string) (*TCPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;udpaddr&#34;&gt;UDPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveUDPAddr(net, addr string) (*UDPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipaddr&#34;&gt;IPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveIPAddr(net, addr string) (*IPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unixaddr&#34;&gt;UnixAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveUnixAddr(net, addr string) (*UnixAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conn&#34;&gt;Conn&lt;/h2&gt;
&lt;p&gt;该接口代表通用的面向流的网络连接．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Conn interface {
    Read()
    Write()
    Close()
    LocalAddr()
    RemoteAddr()
    SetDeadline()
    SetReadDeadline()
    setWriteDeadline()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// tcp: &amp;quot;tcp&amp;quot;、&amp;quot;tcp4&amp;quot;、&amp;quot;tcp6&amp;quot;、
// unix: &amp;quot;unix&amp;quot;, &amp;quot;unixpacket&amp;quot;
// unix: &amp;quot;unixgramh&amp;quot;
// udp: &amp;quot;udp&amp;quot;、&amp;quot;udp4&amp;quot;、&amp;quot;udp6&amp;quot;、
// ip: &amp;quot;ip&amp;quot;、&amp;quot;ip4&amp;quot;、&amp;quot;ip6&amp;quot;、
func Dail(network, address string) (Conn, error)

func DialTimeout(network, address string, timeout time.Duration) (Conn, error)

func Pipe() (Conn, Conn)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;packetconn&#34;&gt;PacketConn&lt;/h2&gt;
&lt;p&gt;该接口代表通用的面向数据包的网络连接．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PacketConn interface {
    ReadDrom()
    WriteTo()
    Close()
    LocalAddr()
    SetDeadline()
    SetReadDeadline()
    SetWriteDeadline()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ip: &amp;quot;ip&amp;quot;、&amp;quot;ip4&amp;quot;、&amp;quot;ip6&amp;quot;、
// udp: &amp;quot;udp&amp;quot;、&amp;quot;udp4&amp;quot;、&amp;quot;udp6&amp;quot;、
// unix: &amp;quot;unixgram&amp;quot;
func ListenPacket(net, laddr string) (PacketConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;listener&#34;&gt;Listener&lt;/h2&gt;
&lt;p&gt;通用的面向流的网络协议的公用的网络监听接口．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Listener interface {
    Addr() addr
    Accept() (c Conn, err error)
    Close() error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// tcp: &amp;quot;tcp&amp;quot;、&amp;quot;tcp4&amp;quot;、&amp;quot;tcp6&amp;quot;、
// unix: &amp;quot;unix&amp;quot;, &amp;quot;unixpacket&amp;quot;
func Listen(net, laddr string) (Listener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipconn&#34;&gt;IPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口．&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DilIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;udpconn&#34;&gt;UDPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)
func ListenDUP(net string, laddr *UDPAddr) (*UDPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;tcpconn&#34;&gt;TCPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;tcplistener&#34;&gt;TCPListener&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *TCPListener) Accept() (Conn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unixconn&#34;&gt;UnixConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)
func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;unixlistener&#34;&gt;UnixListener&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *UnixListener) Accept() (c Conn, err error)
func (l *UnixListener) AcceptUnix() (*UnixConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nethttp&#34;&gt;net/http&lt;/h1&gt;
&lt;p&gt;http协议客户端和服务器的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net/http&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    MethodGet = &amp;quot;GET&amp;quot;
    MethodHead = &amp;quot;HEAD&amp;quot;
    MethodPost = &amp;quot;POST&amp;quot;
    MethodPut = &amp;quot;PUT&amp;quot;
    MethodPatch = &amp;quot;PATCH&amp;quot;
    MethodDelete = &amp;quot;DELETE&amp;quot;
    MethodConnect = &amp;quot;CONNECT&amp;quot;
    MethodOptions = &amp;quot;OPTIONS&amp;quot;
    MethodTrace = &amp;quot;TRACE&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 在w的header中添加Set-Cookie头．
func SetCookie(w ResponseWriter, cookie *Cookie)

func Handle(pattern string, handler Handler)

// 注册一个handler和对应的pattern 到DefaultServeMux.
func HandlerFunc(pattern string, handler func(ResponseWriter, *Request))

// 为监听器收到的每个连接创建一个新的goroutine．
// goroutine 会读取请求并调用handler回复该请求．
func Serve(l net.Listener, handler Handler) error

// 监听tcp地址addr, 使用handler参数调用Serve函数处理连接．
// handler = nil 相当于DefaultServeMux
func ListenAndServe(addr string, handler Handler) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type File interface {
    io.Closer
    io.Reader
    Readdir(count int) ([]os.FileInfo, error)
    Seek(offset int64, whence int) (int64, error)
    Stat() (os.FileInfo, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;filesystem&#34;&gt;FileSystem&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type FileSystem interface {
    Open(name string) (File, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dir&#34;&gt;Dir&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Dir string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (d Dir) Open(name string) (File, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;
&lt;p&gt;实现Handler接口的对象可以被注册为http的服务函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对每个请求回复&amp;quot;404 page not found&amp;quot;
func NotFoundHandler() Handler

// 对每个请求使用状态码code重定向到url.
func RedirectHandler(url string, code int) Handler

func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler

// 将请求的URL.Path中的前缀prefix去除后再给h.
func StripPrefix(prefix string, h Handler) Handler

func FileServer(root FileSystem) Handler
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;handlerfunc&#34;&gt;HandlerFunc&lt;/h2&gt;
&lt;p&gt;将普通函数转换成http的服务函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ServeHTTP会调用f(w, r)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;servemux&#34;&gt;ServeMux&lt;/h2&gt;
&lt;p&gt;ServeMux是http请求的多路转接器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ServeMux struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建并返回一个新的*ServeMux
func NewServeMux() *ServeMux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//
func (mux *ServeMux) Handle(pattern string, handler Handler)

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))

func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)

func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;server&#34;&gt;Server&lt;/h2&gt;
&lt;p&gt;定义了运行http服务端的参数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Server struct {
    Addr string
    Handler Handler
    ReadTimeout time.Duration
    WriteTimeout time.Duration
    MaxHeaderBytes int
    TLSConfig *tls.Config
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
    ConnState func(net.Conn, ConnState)
    ErrorLog *log.Logger
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *Server) SetKeepAlivesEnabled(v bool)

func (s *Server) Serve(l net.Listener) error

func (s *Server) ListenAndServe() error

func (s *Server) ListenAndServeTLS(certFile, keyFile string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;client&#34;&gt;Client&lt;/h2&gt;
&lt;p&gt;代表一个http客户端.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Client struct {
    Transport RoundTripper
    CheckRedirect func(req *Request, via []*Request) error
    Jar CookieJar
    Timeout time.Duration
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;
&lt;p&gt;代表http的头部.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Header map[string][]string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (h Header) Get(key string) string
func (h Header) Set(key, value string)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;代表一个http回复的头部中SetCookie头的值，或http请求的头部里面的cookie值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cookie struct {
    Name string
    Value string
    Path string
    Domain string
    Expires time.Time
    RawExpires string
    MaxAge int
    Secure bool
    HttpOnly bool
    Raw string
    Unparsed []string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回cookie序列化的结果
func (c *Cookie) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;request&#34;&gt;Request&lt;/h2&gt;
&lt;p&gt;代表一个服务端接收的或客户端发送的http请求.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Request struct {
    Method string
    URL *url.URL
    Proto string // &amp;quot;HTTP/1.0&amp;quot;
    ProtoMajor int // 1
    ProtoMinor int // 0
    Header Header
    Body io.ReadCloser
    ContentLength int64
    TransferEncoding []string
    Close bool
    Host string
    Form url.Values
    PostForm url.Values
    MultipartForm *multipart.Form
    Trailer Header
    RemoteAddr string
    RequestURI string
    TSL *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewRequest(method, urlStr string, body io.Reader) (*Request, error)

func ReadRequest(b *bufio.Reader) (req *Request, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 解析并返回该请求r的header设置的cookie
func (r *Request) Cookies() []*Cookie

// 返回请求r中命名为name的cookie,如果未找到返回nil, ErrNoCookie.
func (r *Request) Cookie(name string) (*cookie, error)

//解析r.URL中的查询字符串，并将解析结果更新到r.Form字段.
// post和put的body会同时更新到r.PostForm和r.Form.
func (r *Request) ParseForm() error

// 将请求的主体作为multipart/form-data解析.
func (r *Request) ParseMultipartForm(maxMemory int64) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;response&#34;&gt;Response&lt;/h2&gt;
&lt;p&gt;代表一个http请求的回复r&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Response struct {
    Status string
    StatusCode int
    Proto string
    ProtoMajor int
    ProtoMinor int
    Header Header
    Body io.ReadCloser
    ContentLength int64
    TransferEncoding []string
    Close bool
    Trailer Header
    Request *Request
    TLS *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)

func Head(url string) (resp *Response, err error)
func Get(url string) (resp *Response, err error)
func Post(url string, bodyType string, boyd io.Reader) (resp *Response, err error)
func PostForm(url string, data url.Values) (resp *Response, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (r *Response) ProtoAtLeast(major, minor int) bool

// 获取相应中的Set-Cookie设置的cookie
func (r *Response) Cookies() []*Cookie
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;responsewriter&#34;&gt;ResponseWriter&lt;/h2&gt;
&lt;p&gt;用于构造http回复.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ResponseWriter interface {
    Header() Header
    WriteHeader(int)
    Write([]byte) (int, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netmail&#34;&gt;net/mail&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netsmtp&#34;&gt;net/smtp&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netrpc&#34;&gt;net/rpc&lt;/h1&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在DefaultServer注册并公布rcvr方法.
func Register(rcvr interface{}) error

// 接收连接，将每个连接交给DefaultServer服务.会阻塞.
func Accept(lis net.Listener)

// 在单个连接执行DefaultServer,会阻塞.
func ServceConn(conn io.ReadWriteCloser)

func HandleHTTP()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;call&#34;&gt;Call&lt;/h2&gt;
&lt;p&gt;代表一个执行中或执行完毕的会话．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Call struct {
    ServiceMethod string
    Args interface{}
    Reply interface{}
    Error error
    Done chan *Call
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;client-1&#34;&gt;Client&lt;/h2&gt;
&lt;p&gt;rpc客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type client struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewClient(conn io.ReadWriteCloser) *Client

func Dial(network, address string) (*Client, error)

func DialHTTP(network, address string) (*Client, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 调用指定的方法，等待返回，将结果写入reply.
func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error

func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call

func (client *Client) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nettextproto&#34;&gt;net/textproto&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;neturl&#34;&gt;net/url&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;scheme://[userinfo@]host/path[?query][#fragment]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type URL struct {
    Scheme string
    Opaque string
    User *Userinfo
    Host string // host or host:port
    Path string
    RawQuery string
    Fragment string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Parse(rawurl string) (url *URL, err error)
func ParseRequestURI(rawurl string) (url *URL, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;h2 id=&#34;userinfo&#34;&gt;Userinfo&lt;/h2&gt;
&lt;h2 id=&#34;values&#34;&gt;VAlues&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_oop</title>
        <link>https://canuxcheng.com/post/gsl_oop/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_oop/</guid>
        <description>&lt;h1 id=&#34;reflect&#34;&gt;reflect&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;p&gt;const:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    SelectSend
    SelectRecv
    SelectDefault
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将src拷贝到dst, 直到src被耗尽或dst被装满.
func Copy(dst, src Value) int

// 判断两个值是否深度一致
func DeepEqual(a1, a2 interface{}) bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kind&#34;&gt;Kind&lt;/h2&gt;
&lt;p&gt;表示Type类型值表示的具体分类.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Kind uint

const (
    Invalid Kind = iota
    Bool
    Int
    ...
    Uint
    ...
    Float...
    Complex...
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (k Kind) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringheader&#34;&gt;StringHeader&lt;/h2&gt;
&lt;h2 id=&#34;sliceheader&#34;&gt;SliceHeader&lt;/h2&gt;
&lt;h2 id=&#34;structfield&#34;&gt;StructField&lt;/h2&gt;
&lt;h2 id=&#34;structtag&#34;&gt;StructTag&lt;/h2&gt;
&lt;h2 id=&#34;chandir&#34;&gt;ChanDir&lt;/h2&gt;
&lt;h2 id=&#34;selectdir&#34;&gt;SelectDir&lt;/h2&gt;
&lt;h2 id=&#34;selectcase&#34;&gt;SelectCase&lt;/h2&gt;
&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;
&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;
&lt;p&gt;用来表示一个go类型.&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Type interface {
    Kind() Kind
    Name() string
    PkgPath() string
    String() string
    Size() uintptr
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回接口中保存的值的类型
func TypeOf(i interface{}) Type

// 返回类型t的指针的类型
func PtrTo(t Type) Type

// 返回类型t的slice的类型
func SliceOf(t Type) Type

// 返回一个键类型为key, 值类型为elem的map类型
func MapOf(key, elem Type) Type

// 返回元素类型为t, 方向为dir的chan类型
func ChanOf(dir ChanDir, t Type) Type
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;
&lt;p&gt;为go值提供反射接口.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Value struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个接口i保存的具体值的Value
func ValueOf(i interface{}) Value

// 返回一个类型typ的零值的Value
func Zero(typ Type) Value

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 如果v是否持有值，如果v是Value零值，返回false.
func (v Value) IsValid() bool

func (v Value) IsNil() bool

// 返回v持有值的分类，如果v是Value零值，返回Invalid
func (v Value) Kind() Kind

// 返回v持有的值的类型Type.
func (v Value) Type() Type

...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_string</title>
        <link>https://canuxcheng.com/post/gsl_string/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_string/</guid>
        <description>&lt;h1 id=&#34;strings&#34;&gt;strings&lt;/h1&gt;
&lt;p&gt;实现了用于操作字符的函数.&lt;/p&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func EqualFold(s, t string) bool

func HasPrefix(s, prefix string) bool
func HasSuffix(s, suffix string) bool

func Count(s, sep string) int

func Contains(s, substr string) bool
...

func Index(s, sep string) int
...

func LastIndex(s, sep string) int
...

func title(s string) string

func ToLower(s string) string
...

// 返回count个string
func Repeat(s string, count int) string

func Replace(s, old, new string, n int) string

func Map(mapping func(rune) rune, s string) string

func Trim(s string, cutset string) string
...

// 返回将字符串按照空白分割的多个字符串
func Fields(s string) []string
// 按照f作为分隔符来分割字符串，返回切片
func FieldsFunc(s string, f func(rune) bool) []string

func Split(s, sep string) []string
...

// 将一系列字符串连接为一个字符串，之间用sep来分割.
func Join(a []string, sep string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;
&lt;h2 id=&#34;replacer&#34;&gt;Replacer&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bytes&#34;&gt;bytes&lt;/h1&gt;
&lt;p&gt;实现了操作[]bytes的常用函数.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;reader-1&#34;&gt;Reader&lt;/h2&gt;
&lt;h2 id=&#34;buffer&#34;&gt;Buffer&lt;/h2&gt;
&lt;p&gt;Buffer是一个实现了读写方法的可变大小的字节缓冲.&lt;/p&gt;
&lt;p&gt;零值是一个空的可用于读写的缓冲.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Buffer struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewBuffer(buf []byte) *Buffer
func NewBufferString(s string) *Buffer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Buffer) String() string

func (b *Buffer) Read(p []byte) (n int, err error)
func (b *Buffer) Write(p []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;strconv&#34;&gt;strconv&lt;/h1&gt;
&lt;p&gt;实现了基本数据类型和字符串的相互转换.&lt;/p&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const InitSize = intSize
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;Variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrRange = errors.New(&amp;quot;value out of range&amp;quot;)
var ErrSyntax = errors.New(&amp;quot;invalid syntax&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个字符是否是可打印的
func IsPrint(r rune) bool

// 返回字符串s是否可以不被修改的表示为一个反引号字符串
func CanBackquote(s string) bool

func Quote(s string) string
...

func Unquote(s string) (t string, err error)
...

func AppendInt(dst []byte, i int64, base int) []byte
...

// 字符串转换成其他类型
func ParseInt(s string, base int, bitSize int) (i int64, err error)
...

// 其他类型转换为字符串
func FormatInt(i int64, base int) string
...

// ParseInt(s, 10, 0)的简写, string -&amp;gt; int
func Atoi(s string) (i int, err error)
// FormatInt(i, 10)的简写, int -&amp;gt; string
func Itoa(i int) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;numerror&#34;&gt;NumError&lt;/h2&gt;
&lt;p&gt;表示一次失败的转换&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type NumError struct {
    Func string
    Num string
    Err error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (e *NumError) Error() string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unicode&#34;&gt;unicode&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;regexp&#34;&gt;regexp&lt;/h1&gt;
&lt;p&gt;实现了正则表达式搜索&lt;/p&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;regexp-1&#34;&gt;Regexp&lt;/h2&gt;
&lt;p&gt;Regexp代表一个编译好的正则表达式．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Regexp struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Compile(expr string) (*Regexp, error)

func CompilePOSIX(expr string) (*Regexp, error)

func MustCompile(str string) *Regexp

func MustCompilePOSIX(str string) *Regexp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;regexpsyntax&#34;&gt;regexp/syntax&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;indexsuffixarray&#34;&gt;index/suffixarray&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_system</title>
        <link>https://canuxcheng.com/post/gsl_system/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_system/</guid>
        <description>&lt;h1 id=&#34;os&#34;&gt;os&lt;/h1&gt;
&lt;p&gt;提供了操作系统的不依赖平台的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;os&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# flag 参数
const (
    O_RDONLY int = syscall.O_RDONLY
    O_WRONLY int = syscall.O_WRONLY
    O_RDWR int = syscall.O_RDWR
    O_CREATE int = syscall.O_CREATE # 不存在就创建
    O_APPEND int = syscall.O_APPEND # 追加写入
    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件
    O_EXCL int = syscall.O_EXCL
    O_SYNC int = syscall.O_SYNC
)

const (
    SEEK_SET int = 0
    SEEK_CUR int = 1
    SEEK_END int = 2
)

const (
    // 操作系统指定的路径分隔符
    PathSeperator = &#39;/&#39;
    // 操作系统指定的表分隔符
    PathListSeparator = &#39;:&#39;
)

// 操作系统空设备的名字
const DevNull = &amp;quot;/dev/null&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var (
    ErrInvalid = errors.New(&amp;quot;invalid argument&amp;quot;)
    ...
)

// 指向标准输入／输出／错误的文件描述符
var (
    Stdin = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)
    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)
    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)
)

// 保存了命令行参数，第一个是程序名
var Args []string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回内核提供的主机名
func Hostname() (name string, err error)

// 当前程序以给出的状态码马上退出，defer不会执行
func Exit(code int)

// 返回key=value格式的环境变量的字符串的切片拷贝
func Environ() []string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件相关的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func IsExist(err error) bool // 文件存在返回true
func IsNotExist(err error) bool // 文件不存在返回true

func IsPathSeparator(c uint8) bool
...
func SameFile(fi1, fi2 FileInfo) bool
func Getwd() (dir string, err error)
func Chdir(dir string) error
func Chmod(name string, mode FileMode) error
func Chown(name string, uid, gid int) error
...
func Mkdir(name string, perm FileMode) error // 创建单个目录
func MkdirAll(path string, perm FileMode) error // 创建多级目录
func Rename(oldpath, newpath string) error
func Truncate(name string, size int64) error
func Remove(name string) error
func RemoveAll(path string) error
func Readlink(name string) (string, error)
func Symlink(oldname, newname string) error // 创建符号连接
func Link(oldname, newname string) error // 创建硬连接
func TempDir() string // 返回一个用于保管临时文件的默认目录

// 从filename指定的文件读取数据并返回, 成功返回文件内容和nil
func ReadFile(filename string) ([]byte, error)

// 向filename指定文件写入数据，如果文件存在先清空文件，如果不存在创建文件.
func WriteFile(filename string, data []byte, perm os.FileMode) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;signal&#34;&gt;Signal&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Signal interface {
    String() string
    Signal()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;variable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var (
    Interrupt Signal = syscall.SIGINT
    Kill Signal = syscall.SIGKILL
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;filemode&#34;&gt;FileMode&lt;/h2&gt;
&lt;p&gt;代表文件模式和权限位．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FileMode uint32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;constant:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    ModeDir    FileMode = 1 &amp;lt;&amp;lt; (32 - 1 - iota) // d: 目录
    ...
    ModeType = ModeDir | ModeSymlink | ModeNamePipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (m FileMode) IsDir() bool
func (m FileMode) IsRegular() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fileinfo&#34;&gt;FileInfo&lt;/h2&gt;
&lt;p&gt;用来描述一个文件对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FileInfo interface {
    Name() string
    Size() int64
    Mode() FileMode
    ModeTime() time.Time
    IsDir() bool
    Sys() interface{}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取一个文件对象
func Stat(name string) (fi FileInfo, err error)

func Lstat(name string) (fi FileInfo, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;
&lt;p&gt;表示一个打开的文件对象&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type File struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 采用flag=os.O_RDWR和perm=0666模式创建一个名为name的文件, 返回读写文件句柄
// 文件已存在就截断
func Create(name string) (file *File, err error)

// 打开指定文件，返回只读文件句柄, flag=os.O_RDONLY
func Open(name string) (file *File, err error)

// 指定flag和perm创建／打开文件
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)

// 使用给定的文件描述服和名称创建一个文件.
func NewFile(fd uintptr, name string) *File

// 返回一对关联的文件对象
func Pipe() (r *File, w *File, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 从文件f中最多读取len(b)字节数据写入b, 返回读取的字节数
// 返回0, io.EOF, 表示读取0个字节,文件终止．
func (f *File) Read(b []byte) (n int, err error)

func (f *File) ReadAt(b []byte, off int64) (n int, err error)

// 向文件f写入len(b)字节数据b，返回写入字节数
func (f *File) Write(b []byte) (n int, err error)

func (f *File) WriteAt(b []byte, off int64) (ret int, err error)

func (f *File) WriteString(s string) (ret int, err error)

func (f *File) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;process&#34;&gt;Process&lt;/h2&gt;
&lt;p&gt;保存一个被StarProcess创建的进程的信息&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Process struct {
    Pid int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 启动一个新进程
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)

// 查找一个运行中的进程
func FindProcess(pid int) (p *Process, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 向进程发送信号
func (p *Process) Signal(sig Signal) error

// 阻塞直到进程退出
func (p *Process) Wait() (*ProcessState, error)

// 让进程立刻退出
func (p *Process) Kill() error

// 释放进程绑定的资源
func (p *Process) Release() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;processstate&#34;&gt;ProcessState&lt;/h2&gt;
&lt;p&gt;保管Wait函数报告的某个已退出进程的信息．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ProcessState struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个已退出的进程的id
func (p *ProcessState) Pid() int

// 报告进程是否已退出
func (p *ProcessState) Exited() bool

// 报告进程是否成功退出
func (p *ProcessState) Success() bool

// 返回已退出进程及其子进程耗费的系统cpu时间
func (p *ProcessState) SystemTime() time.Duration

// 返回已退出进程及其子进程耗费的用户cpu时间
func (p *ProcessState) UserTime() time.Duration

func (p *ProcessState) Sys() interface{}

func (p *ProcessState) SysUsage() interface{}

func (p *ProcessState) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;procattr&#34;&gt;ProcAttr&lt;/h2&gt;
&lt;p&gt;保存被StratProcess启动的新进程的属性&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ProcAttr struct {
    Dir string
    Env []string
    Files []*File
    Sys *syscall.SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;osexec&#34;&gt;os/exec&lt;/h1&gt;
&lt;p&gt;执行外部命令，包装了os.StartProcess函数，提供更高级的接口.&lt;/p&gt;
&lt;h2 id=&#34;variable&#34;&gt;variable&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrNotFound = errors.New(&amp;quot;executable file not found in $PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 在环境变量指定的目录中搜索可执行文件file
func LookPath(file string) (string, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmd&#34;&gt;Cmd&lt;/h2&gt;
&lt;p&gt;表示一个准备执行或执行中的外部命令&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cmd struct {
    Path string
    Args []string
    Env []string
    Dir string
    stdin io.Reader
    Stdout io.Writer
    Stderr io.Writer
    ExtraFiles []*os.File
    SysProcAttr *syscall.SysProcAttr
    Process *os.Process
    ProcessState *os.ProcessState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回*Cmd
func Command(name string, arg ***string) *Cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 同步：执行命令，并阻塞直到完成
func (c *Cmd) Run() error

// 异步：开始执行命令，不阻塞直接返回，
func (c *Cmd) Start() error
// 阻塞通过Start执行的命令直到完成，设置状态码并释放资源．
func (c *Cmd) Wait() error

func (c *Cmd) StdinPipe() (io.WriteCloser, error)
func (c *Cmd) StdoutPipe() (io.ReadCloser, error)
func (c *Cmd) StderrPipe() (io.ReadCloser, error)

// 执行命令并返回stdout的切片
func (c *Cmd) Output() ([]byte, error)
// 执行命令并返回stdout和stderr合并后的切片
func (c *Cmd) CombinedOutput() ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ossignal&#34;&gt;os/signal&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;osuser&#34;&gt;os/user&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;syscall&#34;&gt;syscall&lt;/h1&gt;
&lt;p&gt;提供了操作系统级别的调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;syscall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    AF_ALG    = 0x26
    ...
)

// 定义异常
const (
    E2BIG    = Errno(0x70)
    ...
)

// 定义信号
const (
    SIGABRT    = Signal(0x6)
    ...
)

const (
    SYS_READ    = 0
    ...
)

const (
    SizeofSockaddrInet4    = 0x10
    ...
)

const (
    IFA_UNSPEC    = 0x0
    ...
)

const (
    SizeofSockFilter    = 0x8
    ...
)

const (
    VINTR    = 0x0
    ...
)

const ImplementsGetwd = true

const PathMax = 0x1000

const SizeofInotifyEvent = 0x10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var (
    Stdin = 0
    Stdout = 1
    Stderr = 2
)

var ForkLock sync.RWMutex

var SocketDisableIPv6 bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;others&#34;&gt;others&lt;/h2&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;io&#34;&gt;io&lt;/h1&gt;
&lt;p&gt;提供了对IO原语的基本接口&lt;/p&gt;
&lt;p&gt;go1.16 删除了io/ioutil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-2&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 放无法获取更多输入时Read方法返回os.EOF
var EOF = errors.New(&amp;quot;EOF&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func ReadAll(r io.Reader) ([]byte, error)
func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
func ReadFull(r Reader, buf []byte) (n int, err error)

// 将src数据拷贝到dst, 直到EOF或出错，返回拷贝的字节数
func Copy(dst Writer, src Reader) (written int64, err error)

// 类似Copy，不过只拷贝n个字节.
func CopyN(dst Writer, src Reader, n int64) (written int64, err error)

func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)

// 将字符串s写入w
func WriteString(w Writer, s string) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;
&lt;p&gt;用于包装基本的读取方法&lt;/p&gt;
&lt;p&gt;os.File(os.Stdout, os.Stdin. os.Stderr), bytes.Buffer 和 bufio.Reader 都是io.Reader接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;writer&#34;&gt;Writer&lt;/h2&gt;
&lt;p&gt;用于包装基本的写入方法&lt;/p&gt;
&lt;p&gt;os.File(os.Stdin, os.Stderr, os.Stdin), bytes.Buffer 和 bufio.Writer, net/http.ResponseWriter 都是io.Writer接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Writer interface {
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;closer&#34;&gt;Closer&lt;/h2&gt;
&lt;p&gt;用于包装基本的关闭方法&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Closer interface {
    Close() error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;seeker&#34;&gt;Seeker&lt;/h2&gt;
&lt;p&gt;用于包装基本的移位方法&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;readwriter&#34;&gt;ReadWriter&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bufio&#34;&gt;bufio&lt;/h1&gt;
&lt;p&gt;bufio实现了有缓冲的IO&lt;/p&gt;
&lt;h2 id=&#34;constants-2&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    // 用于缓冲一个token
    MaxScanTokenSize = 64 * 1024
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-3&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 会被Scanner返回的错误
var (
    ErrInvalidUnreadByte = errors.New(&amp;quot;bufio: invalid use of UnreadByte&amp;quot;)
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)

// 将每一行文本去掉末尾的换行标记，然后作为一个token返回
func ScanLines (data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader-1&#34;&gt;Reader&lt;/h2&gt;
&lt;p&gt;给io.Reader接口对象附加缓冲&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewReader(rd io.Reader) *Reader

func NewReaderSize(rd io.Reader, size int) *Reader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Reader) Read(p []byte) (n int, err error)
// 读取直到第一次遇到delim字节，返回一个包含已读取数据和delim字节的字符串
// 当且仅当返回的切片不以delim结尾时，返回非nil错误
func (b *Reader) ReadString(delim byte) (line string, err error)
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)

func (b *Reader) ReadByte() (c byte, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;writer-1&#34;&gt;Writer&lt;/h2&gt;
&lt;p&gt;给io.Writer接口对象提供缓冲&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Writer struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewWriter(w io.Writer) *Writer

func NewWriterSize(w io.Writer, size int) *Writer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Writer) Write(p []byte) (nn int, err error)
func (b *Writer) WriteString(s string) (int, error)
func (b *Writer) WriteByte(c byte) error
func (b *Writer) WriteRune(r rune) (size int, err error)

func (b *Writer) Flush() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;readwriter-1&#34;&gt;ReadWriter&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ReadWriter struct {
    *Reader
    *Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewReadWriter(r *Reader, w *Writer) *ReadWriter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;提供了方便的读取数据接口&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建并返回一个从r读取数据的Scanner，默认分割函数是ScanLines
func NewScanner(r io.Reader) *Scanner
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置s的分割函数
func (s *Scanner) Split(split SplitFunc)

// 获取当前位置的token, 并让Scanner的扫描位置移动到下一个token.
func (s *Scanner) Scan() bool

// 返回最近一次Scan调用生成的token.
func (s *Scanner) Bytes() []byte

// 创建一个字符串保存Bytes返回的token,并返回
func (s *Scanner) Text() string

// 返回Scanner遇到的第一个非EOF错误
func (s *Scanner) Err() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;splitfunc&#34;&gt;SplitFunc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;fmt&#34;&gt;fmt&lt;/h1&gt;
&lt;p&gt;实现了类似于C的printf/scanf的格式化IO.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;fmt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通用占位符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%v    相应值的默认格式
%#v   相应值的go语法表示
%T    相应值的类型的go语法表示
%%    字面上的百分号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%t    true/false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%b    二进制表示
%c    相应的unicode码点所表示的字符
%d    十进制表示
%o    八进制表示
%q    单引号包围的字符字面值
%x    十六进制(字母小写)
%X    十六进制(字母大写)
%U    unicode格式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浮点数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%b    无小数部分的，指数为二的幂的科学计数法．
%e    科学计数法
%E    科学计数法
%f    有小数点，而无指数
%g    根据情况选择%e 或 %f
%G    根据情况选择E% 或 %f

%[宽度]Type
%.[精度]Type
%[宽度].[精度]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串与字节切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%s    字符串或切片的字节
%q    双引号包围的字符串
%x    十六进制(小写字母)
%X    十六进制(大写字母)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%p    十六进制表示(0x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-4&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个包含该格式化字符串的错误
func Errorf(format string, a ...interface{}) error

// 写入到STDOUT, 返回写入字节数
// 默认格式化
func Print(a ...interface{}) (n int, err error)
// 默认格式化，自动结尾添加换行符
func Println(a ...interface{}) (n int, err error)
// 指定格式化
func Printf(format string, a ...interface{}) (n int, err error)

// 写入到w, 返回写入字节数
// w: os.File bufio.Writer
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

// 返回该字符串
func Sprint(a ...interface{}) string
func Sprintln(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string

// 从STDIN扫描文本存入a,返回成功扫描的个数
// 换行视为空白，获取len(a)个条目才停止扫描
func Scan(a ...interface{}) (n int, err error)
// 换行才停止扫描
func Scanln(a ...interface{}) (n int, err error)
// 根据空格分割的条目格式化写入指定参数a
func Scanf(format string, a ...interface{}) (n int, err error)

// 从r扫描文本存入a, 返回成功扫描的条目
// r: os.File bufio.Reader
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)

// 从字符串str扫描文本存入a,  返回扫描成功的条目
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringer&#34;&gt;Stringer&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stringer initerface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gostringer&#34;&gt;GoStringer&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type GoStringer interface {
    GoString() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;state&#34;&gt;State&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type State interface {
    Write(b []byte) (ret int, err error)
    Width() (wid int, ok bool)
    Precision() (prec int, ok bool)
    Flag(c int) bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;formatter&#34;&gt;Formatter&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Formatter interface {
    Format(f State, c rune)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanstate&#34;&gt;ScanState&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ScanState interface {
    ReadRune() (r rune, size int, err error)
    UnreadRune() error
    SkipSpace()
    Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
    Width() (wid int, ok bool)
    Read(buf []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner-1&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner interface {
    Scan(state ScanState, verb rune) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;log&#34;&gt;log&lt;/h1&gt;
&lt;p&gt;实现了简单的日志服务.&lt;/p&gt;
&lt;h2 id=&#34;constants-3&#34;&gt;Constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    Ldate        = 1 &amp;lt;&amp;lt; iota     // 日期
    Ltime              // 时间
    Lmicroseconds      // 微秒
    Llongfile          // 绝对文件名和行好 /path/to/file.go:13
    Lshortfile         // 文件名和行好, 覆盖上面字段 file.go:13
    LstdFlags    = Ldate | Ltime      // 标准logger的初始值
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-5&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Printf(format string, v ...interface{})
func Print(v ...interface{})
func Println(v ...interface{})

// 下列函数在Print...函数基础上再调用os.Exit(1)
func Fatalf(format string, v ...interface{})
func Fatal(v ...interface{})
func Fatalln(v ...interface{})

// 下列函数在Print...函数基础上再调用panic(...)
// panic会执行当前函数的defer, 然后退出当前函数，返回到调用者，
// 调用函数会执行defer, 直到应用程序退出.最后panic.
func Panicf(format string, v ...interface{})
func Panic(v ...interface{})
func Panicln(v ...interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;logger&#34;&gt;Logger&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Logger struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个Logger.
func New(out io.Writer, prefix string, flag int) *Logger
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *Logger) Flags() int
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;flag&#34;&gt;flag&lt;/h1&gt;
&lt;p&gt;实现了命令行参数解析&lt;/p&gt;
&lt;p&gt;第三方包:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/alecthomas/kingpin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/alecthomas/kingpin&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;variables-4&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

//
var ErrHelp = errors.New(&amp;quot;flag: help requested&amp;quot;)

//
var Usage = func() {
    fmt.Fprintf(os.Stderr, &amp;quot;Usage of %s:\n&amp;quot;, os.Args[0])
    PrintDefaults()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-6&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回已被设置的flag数量
func NFlag() int
// 返回已注册flag的结构体指针
func Lookup(name string) *Flag

// 非flag参数不能在flag参数前面指定，否则flag参数不会被解析．
// 返回非flag参数个数
func NArg() int
// 返回所有非flag参数
func Args() []string
// 返回第i个非flag参数, i=0 就是第一个参数，而不是程序名称
func Arg(i int) string

// 向Stderr写入所有注册好的flag的默认值
func PrintDefaults()

// 从os.Args[1:] 中解析注册的flag.
func Parse()
// 返回是否Parse是否被调用过
func Parsed() bool

// 按照字典顺序遍历flag，并对每个flag调用fn, 只针对解析时设置了的flag
func Visit(fn func(*Flag))
// 按照字典顺序遍历flag,　并对每个flag调用fn, 针对所有flag.
func VisitAll(fn func(*Flag))

// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 返回一个保存了该flag的值的指针
func Bool(name string, value bool, usage string) *bool
// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 将flag值保存到指针p指向的变量
func BoolVar(p *bool, name string, value bool, usage string)

func Int
func IntVar
func Int64
func Int64Var

func Uint
func UintVar
func Uint64
func Uint64Var

func Float64
func Float64Var

func String
func StringVar

// time.Duration类型
func Duration
func DurationVar

// 用指定的名字，帮助信息，注册一个flag，类型由value决定
func Var(value Value, name string, usage string)
// 设置已注册的flag的值
func Set(name, value string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;errorhandling&#34;&gt;ErrorHandling&lt;/h2&gt;
&lt;p&gt;定义如何处理flag解析错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ErrorHandling int

const (
    ContinueOnError ErrorHandling = iota
    ExitOnError
    PanicOnError
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flag-1&#34;&gt;Flag&lt;/h2&gt;
&lt;p&gt;定义一个flag&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Flag struct {
    Name     string
    Usage    string
    Value    Value
    DefValue string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flagset&#34;&gt;FlagSet&lt;/h2&gt;
&lt;p&gt;代表一个已注册flag集合.&lt;/p&gt;
&lt;p&gt;FlagSet零值没有名字，默认采用ContinueOnError.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FlagSet struct {
    Usage func()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个新的FlagSet叫name，采用errorHandling为错误处理策略
func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置f的名字和错误处理策略.
func (f *FlagSet) Init(name string, errorHandling ErrorHandling)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;
&lt;p&gt;用于将动态值保存在flag里.&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Value interface {
    String() string
    Set(string) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getter&#34;&gt;Getter&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;logrus&#34;&gt;logrus&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sirupsen/logrus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sirupsen/logrus&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cobra&#34;&gt;cobra&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/spf13/cobra&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GSL_test</title>
        <link>https://canuxcheng.com/post/gsl_test/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_test/</guid>
        <description>&lt;h1 id=&#34;testing&#34;&gt;testing&lt;/h1&gt;
&lt;p&gt;go的测试由go test命令和testing包组成．&lt;/p&gt;
&lt;p&gt;测试程序命名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XXX.go # 测试文件和源码放在一个包中
XXX_test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;testing&amp;quot;

# 单元测试
# go test 会自动执行
func TestXXX(t *testing.T) {}

# 性能测试
# go test XXX_test.go -test.bench=&amp;quot;.*&amp;quot;  压力测试需要指定才能执行
func BenchmarkXXX(b *testing.B) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;t&#34;&gt;T&lt;/h2&gt;
&lt;p&gt;管理测试状态并支持格式化测试的日志．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type T struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将当前测试标识为失败，但继续执行该文件剩下的测试
func (c *T) Fail()

// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.
func (c *T) FailNow()

// 用于报告测试函数是否失败
func (c *T) Failed() bool

func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})

# 相当于Log/Logf之后调用Fail.(当前case失败)
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})

# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})

func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;b&#34;&gt;B&lt;/h2&gt;
&lt;p&gt;管理基准测试的计时行为，并指示应该迭代的运行测试多少次.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type B struct {
    N int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool

func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})

func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})

func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})

func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;testingiotest&#34;&gt;testing/iotest&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;testingquick&#34;&gt;testing/quick&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gotests&#34;&gt;gotests&lt;/h1&gt;
&lt;p&gt;通过源代码自动生成测试代码，可以用命令行，也可以用goland等的插件．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cweill/gotests&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cweill/gotests&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/cweill/gotests/...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>OOP</title>
        <link>https://canuxcheng.com/post/go_oop/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_oop/</guid>
        <description>&lt;h1 id=&#34;go面向对象&#34;&gt;Go面向对象&lt;/h1&gt;
&lt;p&gt;golang不是传统的面向对象编程，而是通过struct, method, interface, embedding实现面向对象的核心功能.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;方法method&#34;&gt;方法/method&lt;/h2&gt;
&lt;p&gt;go中没有类，但是可以为结构体定义方法．&lt;/p&gt;
&lt;p&gt;方法就是一类带有特殊的　接收者参数　的函数．&lt;/p&gt;
&lt;p&gt;只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．&lt;/p&gt;
&lt;p&gt;除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．&lt;/p&gt;
&lt;p&gt;方法有两种接收者,值接收者和指针接收者.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Vertex struct {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值接收者:&lt;/p&gt;
&lt;p&gt;值接收者操作的是值的副本.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (v Vertex) MethodName() rType {
    ...
}

var v Vertex
v.MethodName() // 操作值的副本

# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换
vp := new(Vertex)
vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针接收者：&lt;/p&gt;
&lt;p&gt;指针接收者，调用方法的时候操作的是该指针指向的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指针接收者的方法可以修改接收者指向的值
func (v *Vertex) MethodName() rType {
    ...
}

vp := new(Vertex)
vp.MethodName() // 操作实际的值

# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.
var v Vertex
v.MethodName() // (&amp;amp;v).MethodName() , 操作的是实际的值
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口/Interface&lt;/h2&gt;
&lt;p&gt;接口是引用类型. zero value is nil.&lt;/p&gt;
&lt;p&gt;接口类型是由一组方法签名定义的集合, 任何实现了这些方法的类型，自动被认为实现了这个接口。．&lt;/p&gt;
&lt;p&gt;某个类型实现了该接口的所有方法签名，就算实现了该接口,无需显示申明实现了哪个接口.&lt;/p&gt;
&lt;p&gt;接口可以匿名嵌入其它接口，或嵌入到结构中．&lt;/p&gt;
&lt;p&gt;一般只有一个方法的接口命名为MethodName + &amp;rsquo;er&#39;.&lt;/p&gt;
&lt;p&gt;接口存储两个数据接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iTable, 包含存储值的类型信息以及和该值关联的方法.&lt;/li&gt;
&lt;li&gt;指向存储的值的指针.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Speaker interface {
    Speak()
}

type Animal struct {
    Name string
}

func (a Animal) Speak() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值接收者方法:&lt;/p&gt;
&lt;p&gt;接口类型的值为值或指针都可以调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s SName) MethodName() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针接收者方法:&lt;/p&gt;
&lt;p&gt;接口类型的值必须为指针才能调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *SName) MethodName() {
    ...
}

s := &amp;amp;SName{...}
// i = &amp;amp;SName{...} //接口变量能保存实现了该接口的任意类型的对象
i = s
i.MethodName()

# 接口类型为值时，调用失败
var s SName
i = s
i.MethodName() // 调用失败
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;空接口：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有类型都实现了空接口.&lt;/p&gt;
&lt;p&gt;指定了零个方法的接口值被称为空接口,一般用来处理未知类型的值.&lt;/p&gt;
&lt;p&gt;当接口储存的类型和对象都为nil，接口才为nil&lt;/p&gt;
&lt;p&gt;以空接口为参数的函数可以接收任意类型的值作为参数.&lt;/p&gt;
&lt;p&gt;如果一个函数返回空接口就可以返回任意类型的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x interface{}
x = 43
x = &amp;quot;hello&amp;quot;

# 空接口可以保存任何类型的值
var i interface{}
# 空接口作为形参
func FuncName(i interface{}) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;指针的类型断言/comma-ok断言：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;断言接口值i保存了具体类型Type, 并将底层类型为Type的值赋予变量t.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只返回一个值，断言失败会触发panic.
t := i.(Type)

返回两个值，断言成功返回true, 失败返回false.
var x interface{} = &amp;quot;hello&amp;quot;
str, ok := x.(string) // ok=true
num, ok := x.(int) // ok=false 断言失败

// i.(type) 是固定写法
switch v := i.(type) {
case string:
    fmt.Println(&amp;quot;string&amp;quot;)
case int:
    fmt.Println(&amp;quot;int&amp;quot;)
default:
    fmt.Println(&amp;quot;unknown type&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;嵌入接口:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口中可以嵌入其它接口，这样实现了该接口的对象就隐式包含嵌入接口的所有方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader interface {
    Read()
}

type Writer interface {
    Write()
}

type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;封装encapsulation&#34;&gt;封装Encapsulation&lt;/h2&gt;
&lt;p&gt;小写字母开头的标识符（类型/属性/方法&amp;hellip;)是未公开的，只能在当前包引用，不能在其它包引用。&lt;/p&gt;
&lt;p&gt;可以通过创建工厂函数对外暴露未公开的标识符:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标识符才有公开或未公开属性，值没有&lt;/li&gt;
&lt;li&gt;短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量；显示声明的变量不能引用未公开类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过工厂函数返回未公开类型的值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type privateType  Type
func New(args) privateType {
    return privateType(args)
}
# packageB
import packageA
func main() {
    b := packageA.New(args) // 返回一个值，而不是标识符
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公开类型的未公开属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type Public struct {
    private Type
}

# packageB
import packageA
func main() {
    b := packageA.Public{
        private: value, // panic, 公开类型的未公开属性不能通过字面量直接赋值
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型嵌套中的未公开类型的公开属性会提升到外部类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type inner struct { // inner private
    In Type  // In public
}
type Outer struct {
    inner
    Out Type
}

# packageB
import packageA
func main() {
    b := packageA.Outer{
        Out: value, // 外部类型中的未公开内部类型不能通过字面量直接赋值
    }
    b.In = value // 内部类型的公开属性提升到外部类型。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多态polymorphism&#34;&gt;多态Polymorphism&lt;/h2&gt;
&lt;p&gt;golang多态通过interface实现。&lt;/p&gt;
&lt;p&gt;形式参数是接口的函数，叫做多态函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(iVar IName) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有实现了接口的方法的实体类型，就可以作为参数传给多态函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Speaker interface {
    Speak()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Dog struct{}
func (d Dog) Speak() {
    fmt.Println(&amp;quot;dog&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cat struct{}
func (c Cat) Speak() {
    fmt.Println(&amp;quot;cat&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多态函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func makeSound(s Speaker) {
    s.Speak()
}

func main() {
    var d Dog
    var c Cat
    makeSound(d) // dog
    makeSound(c) // cat
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;继承inheritance&#34;&gt;继承Inheritance&lt;/h2&gt;
&lt;p&gt;golang没有继承，但是可以通过结构体嵌套实现继承行为。&lt;/p&gt;
&lt;p&gt;如果外部类型实现同名的属性或方法，就会覆盖内部类型的属性或方法（不过内部类型的属性和方法还在，可以通过内部类型访问）&lt;/p&gt;
&lt;p&gt;内部类型实现的接口，也会自动提升到外部类型。只要内部类型实现了某接口，外部类型相当于也实现了该接口。&lt;/p&gt;
&lt;p&gt;如果匿名字段实现了一个方法，那么包含这个匿名字段的结构也可以调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Inner struct {
    in Type
}

func (i *Inner) InnerMethod() {}

type Outer struct {
    Inner    // 只需要类型名称，不需要声明变量
    out Type
    ...
}

outer := Outer{}

outer.Inner.InnerMethod() //始终可以访问内部类型的方法，即使外部类型实现同名方法
outer.Inner.in // 同上

outer.InnerMethod() //如果外部类型没有实现同名方法，就是内部类型方法，否则是外部类型方法
outer.in // 同上
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;反射reflection&#34;&gt;反射Reflection&lt;/h2&gt;
&lt;p&gt;反射就是检查程序在运行时的状态.&lt;/p&gt;
&lt;p&gt;使用反射一般使用标准库reflect.&lt;/p&gt;
&lt;p&gt;Go 的反射通过 reflect.TypeOf() 和 reflect.ValueOf() 在运行时检查或操作对象，是实现泛型、序列化、ORM、接口断言等动态功能的基础。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;reflect&amp;quot;
x := 123
t := reflect.TypeOf(x)   // int
v := reflect.ValueOf(x)  // 123
k := t.Kind()            // reflect.Int
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Rabbitmq</title>
        <link>https://canuxcheng.com/post/rabbitmq/</link>
        <pubDate>Mon, 25 Sep 2017 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/rabbitmq/</guid>
        <description>&lt;h1 id=&#34;amqp&#34;&gt;AMQP&lt;/h1&gt;
&lt;p&gt;AMQP: Advanced Message Queuing Protocol,高级消息队列协议&lt;/p&gt;
&lt;p&gt;常用的开源AMQP框架：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rabbitmq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rabbitmq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/kafka&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/kafka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/activemq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/activemq&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;mqtt&#34;&gt;MQTT&lt;/h1&gt;
&lt;p&gt;MQTT: Message Queuing Telemetry Transport,消息队列遥测传输协议&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;rabbitmq&#34;&gt;Rabbitmq&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rabbitmq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rabbitmq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个erlang开发的符合AMQP和MQTT的开源项目．&lt;/p&gt;
&lt;p&gt;rabbitmq-server也叫broker server&lt;/p&gt;
&lt;p&gt;rabbitmq的三个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exchange,　交换器，发送消息的实体&lt;/li&gt;
&lt;li&gt;binding, 绑定器，连接交换器和队列，并且封装消息的路由信息&lt;/li&gt;
&lt;li&gt;queue,　队列，接受消息的实体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;workflow:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;producer(publish-message) =&amp;gt;

rabbitmq-server =&amp;gt; exchange -&amp;gt; binding -&amp;gt; queue =&amp;gt;

=&amp;gt; comsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;producer: 生产message并且publish到rabbitmq-server.&lt;/p&gt;
&lt;p&gt;consumer: 连接到rabbitmq-server并且subscribe一些queue.&lt;/p&gt;
&lt;p&gt;connection: producer和consumer都是通过tcp连接到rabbitmq-server.&lt;/p&gt;
&lt;p&gt;channels: 建立在tcp连接中的虚拟连接，用于处理数据流动.&lt;/p&gt;
&lt;p&gt;queue:　生产者和消费者都应该创建queue.(只能通过exchange接收message)&lt;/p&gt;
&lt;p&gt;exchanges类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fanout: 所有绑定到此exchange的queue都可以接收消息&lt;/li&gt;
&lt;li&gt;direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息&lt;/li&gt;
&lt;li&gt;topic：所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;message类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;messages: 生产者产生的总消息数．&lt;/li&gt;
&lt;li&gt;messages_ready: 等待deliver给消费者的消息．&lt;/li&gt;
&lt;li&gt;messages_unack: 已经被consumer处理，但是没有被ack的消息．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;virtual hosts: 本质就是一个rabbitmq server,拥有独立的exchange,queue.默认是/(%2F).&lt;/p&gt;
&lt;p&gt;round-robin dispatch: 循环分发，按顺序分发message到consumer,如果message被consumer正确接收，就会从queue中移除．&lt;/p&gt;
&lt;p&gt;no-ack: 每次consumer接收数据后，不管是否处理完成，就标记为ack,然后从queue中删除．但是如果处理过程异常，数据就会丢失．&lt;/p&gt;
&lt;p&gt;ack: ack方式就是数据处理完成后发送ack,保证数据被处理再从queue删除，如果异常，会dispatch到别的consumer.&lt;/p&gt;
&lt;p&gt;durable: 消息持久化，如果rabbitmq-server异常退出或服务器重启，为了保证数据还在，需要做数据持久化.&lt;/p&gt;
&lt;p&gt;消息的状态信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deliver: 消息投递给消费着．
redeliver:　消息重新投递给消费者．&lt;/li&gt;
&lt;li&gt;publish/subscribe: 将同一个消息deliver到多个consumer叫publish或subscribe.&lt;/li&gt;
&lt;li&gt;ack: 已经处理完成的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;p&gt;rabbitmq-3.7 开始配置文件格式为sysctl，同时也兼容旧的erlang格式。&lt;/p&gt;
&lt;p&gt;erlang格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
    {rabbit,
        [
            {heartbeat, 8000}
        ]
    }
].
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sysctl格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key = value
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rabbitmqctl-命令&#34;&gt;rabbitmqctl 命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo rabbitmqctl [-n node] [-t timeout] [-q] &amp;lt;commands&amp;gt; [command options]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加用户并授权：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认的guest/guest只能用于localhost.
$ add_user [username] [password]
$ delete_user &amp;lt;username&amp;gt;
$ change_password &amp;lt;username&amp;gt; &amp;lt;newpassword&amp;gt;
$ clear_password &amp;lt;username&amp;gt;
$ set_user_tags [username] administrator
$ list_users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;权限管理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add_vhost &amp;lt;vhostpath&amp;gt;
delete_vhost &amp;lt;vhostpath&amp;gt;
list_vhosts [&amp;lt;vhostinfoitem&amp;gt; ...]
set_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;user&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;write&amp;gt; &amp;lt;read&amp;gt;
clear_permissions [-p &amp;lt;vhostpath&amp;gt;] &amp;lt;username&amp;gt;
list_permissions [-p &amp;lt;vhostpath&amp;gt;]
list_user_permissions &amp;lt;username&amp;gt;

list_queues [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;queueinfoitem&amp;gt; ...]
list_exchanges [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;exchangeinfoitem&amp;gt; ...]
list_bindings [-p &amp;lt;vhostpath&amp;gt;] [&amp;lt;bindinginfoitem&amp;gt; ...]
list_connections [&amp;lt;connectioninfoitem&amp;gt; ...]
list_channels [&amp;lt;channelinfoitem&amp;gt; ...]
list_consumers [-p &amp;lt;vhostpath&amp;gt;]
status
environment
report
eval &amp;lt;expr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rabbitmq-plugins-插件管理&#34;&gt;rabbitmq-plugins 插件管理&lt;/h2&gt;
&lt;p&gt;启动web-gui:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rabbitmq-plugins enable rabbitmq_management
# http://localhost:15672 guest/guest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h1&gt;
&lt;p&gt;rabbitmq-cluster部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在所有node上安装rabbitmq-server.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改所有node的/etc/hosts，配置ip和hostname.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步所有node的cookie(/var/lib/rabbitmq/.erlang.cookie).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动所有node上的rabbitmq-server.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # rabbitmq-server -detached
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将所有slave node添加manager组成cluster.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # rabbitmqctl stop_app
 # rabbitmqctl reset
 # rabbitmqctl join_cluster rabbit@manager
 # rabbitmqctl start_app
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查cluster状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # rabbitmqctl cluster_status
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置policy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # rabbitmqctl set_policy ha-all &amp;quot;&amp;quot; &#39;{&amp;quot;ha-mode&amp;quot;:&amp;quot;all&amp;quot;,&amp;quot;ha-sync-mode&amp;quot;:&amp;quot;automatic&amp;quot;}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;haproxy-server部署:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在haproxy server安装haproxy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置haproxy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # sudo vim /etc/haproxy/haproxy.cfg
 global
     log /dev/log    local0
     log /dev/log    local1 notice
     chroot /var/lib/haproxy
     user haproxy
     group haproxy
     daemon
 defaults
     log     global
     mode    tcp
     maxconn 10000
     timeout connect 3000
     timeout client 1000s
     timeout server 1000s
 frontend rabbitmq_front
     bind &amp;lt;haproxy-ip&amp;gt;:5672
     reqadd X-Forwarded-Proto:\ amqp
     default_backend rabbitmq_backend
 backend rabbitmq_backend
     balance roundrobin
     server rabbitmq-master &amp;lt;master-ip&amp;gt;:5672 check
     server rabbitmq-slave &amp;lt;slave-ip&amp;gt;:5672 check
 bind 0.0.0.0:15672
     server &amp;lt;master-hostname&amp;gt; &amp;lt;master-ip&amp;gt;:15672 check
     server &amp;lt;slave-hostname&amp;gt; &amp;lt;slave-ip&amp;gt;:15672 check
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启haproxy service.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;celery&#34;&gt;Celery&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/celery&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/celery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可用配置，django需要加namespace作为前缀。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.celeryproject.org/en/stable/userguide/configuration.html#new-lowercase-settings&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.celeryproject.org/en/stable/userguide/configuration.html#new-lowercase-settings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;django中的celery配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CELERY_BROKER_URL = &amp;quot;amqp://user:pw@amqp:5672&amp;quot;
CELERY_ACCEPT_CONTENT = [&#39;json&#39;]
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_EVENT_SERIALIZER = &#39;json&#39;
CELERY_TIMEZONE = &#39;UTC&#39;
CELERY_ENABLE_UTC = True
CELERY_WORKER_PREFETCH_MULTIPLIER = 4
CELERY_TASK_ACKS_LATE = False

CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_TASK_QUEUES = (
    Queue(&#39;queue1&#39;, Exchange(&#39;exchange1&#39;, type=&#39;direct&#39;), routing_key=&#39;default&#39;, queue_arguments={&#39;x-max-priority&#39;: 100}),
    Queue(&#39;queue2&#39;, Exchange(&#39;exchange2&#39;, type=&#39;direct&#39;), routing_key=&#39;default&#39;, queue_arguments={&#39;x-max-priority&#39;: 100}),
)
CELERY_TASK_DEFAULT_QUEUE = &#39;default&#39;
CELERY_TASK_DEFAULT_EXCHANGE = &#39;default&#39;
CELERY_TASK_DEFAULT_EXCHANGE_TYPE = &#39;direct&#39;
CELERY_TASK_DEFAULT_DELIVERY_MODE = &#39;persistent&#39;
CELERY_TASK_DEFAULT_ROUTING_KEY = &#39;default&#39;
CELERY_TASK_ROUTES = (
    {
        &amp;quot;proj.app1.tasks.task1&amp;quot;: {
            &amp;quot;queue&amp;quot;: &amp;quot;queue1&amp;quot;,
            &amp;quot;routing_key&amp;quot;: &amp;quot;default&amp;quot;
        }
    },
    {
        &amp;quot;proj.app2.tasks.task2&amp;quot;: {
            &amp;quot;queue&amp;quot;: &amp;quot;queue2&amp;quot;,
            &amp;quot;routing_key&amp;quot;: &amp;quot;default&amp;quot;
        }
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在project中创建celery的app:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
from celery import Celery

# set the default Django settings module for the &#39;celery&#39; program.
os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;site_main.settings&#39;)

app = Celery(&#39;proj&#39;)

// namespace就会去django的配置找前缀为celery的参数.
app.config_from_object(&#39;django.conf:settings&#39;, namespace=&#39;CELERY&#39;)

app.autodiscover_tasks()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;celery选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;celery [options] command [args]

-A, --app &amp;lt;app&amp;gt;¶
-b, --broker &amp;lt;broker&amp;gt;
--result-backend &amp;lt;result_backend&amp;gt;
--loader &amp;lt;loader&amp;gt;
--config &amp;lt;config&amp;gt;
--workdir &amp;lt;workdir&amp;gt;
-C, --no-color
-q, --quiet
--version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;worker选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n, --hostname
-D, --detach
-l, --loglevel
-O default|fair
// 默认的concurrency是cpu的个数，如果是container运行就是host的cpu个数，不是resourcelimit的cpu个数.
-c, --concurrency
// cpu密集型任务最好用prefork, IO密集最好用eventlet/gevent. 
-P, --poo prefork(default)|eventlet|gevent|solo
-E, --task-events, --events
-Q, --queues
-B, --beat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beat选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--detach
-s, --schedule
-S, --scheduler
-l, --loglevel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;inspect选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-t, --timeout
-d, --destination
-j, --json
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Rpc</title>
        <link>https://canuxcheng.com/post/rpc/</link>
        <pubDate>Sun, 03 Sep 2017 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/rpc/</guid>
        <description>&lt;h1 id=&#34;rpc&#34;&gt;RPC&lt;/h1&gt;
&lt;p&gt;Remote Procedure Call Protocol: 远程过程调用.&lt;/p&gt;
&lt;p&gt;google的rpc框架，支持多语言:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc/grpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grpc/grpc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;facebook的rpc框架，贡献给了apache, 支持多语言:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/thrift&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/thrift&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Germany</title>
        <link>https://canuxcheng.com/post/travel_germany/</link>
        <pubDate>Mon, 08 May 2017 16:41:50 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/travel_germany/</guid>
        <description>&lt;h1 id=&#34;德国之旅&#34;&gt;德国之旅&lt;/h1&gt;
&lt;p&gt;看照片：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://user.qzone.qq.com/1085694641/4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://user.qzone.qq.com/1085694641/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;德国是汽车之都。&lt;/p&gt;
&lt;p&gt;德国有16个州。&lt;/p&gt;
&lt;h1 id=&#34;城市州&#34;&gt;城市州&lt;/h1&gt;
&lt;p&gt;德国16个州中的三个城市州&lt;/p&gt;
&lt;h2 id=&#34;柏林&#34;&gt;柏林&lt;/h2&gt;
&lt;p&gt;德国首都。&lt;/p&gt;
&lt;p&gt;德国第一大城市。&lt;/p&gt;
&lt;h2 id=&#34;汉堡&#34;&gt;汉堡&lt;/h2&gt;
&lt;p&gt;德国第二大城市。&lt;/p&gt;
&lt;h2 id=&#34;不来梅&#34;&gt;不来梅&lt;/h2&gt;
&lt;h1 id=&#34;巴伐利亚州拜仁洲&#34;&gt;巴伐利亚州(拜仁洲)&lt;/h1&gt;
&lt;p&gt;慕尼黑是首府。&lt;/p&gt;
&lt;h2 id=&#34;慕尼黑&#34;&gt;慕尼黑&lt;/h2&gt;
&lt;p&gt;慕尼黑的奥特莱斯位于Ingolstadt Village。&lt;/p&gt;
&lt;p&gt;奥迪的总部位于慕尼黑的Ingolstadt。&lt;/p&gt;
&lt;p&gt;宝马总部位于慕尼黑。&lt;/p&gt;
&lt;p&gt;德国第三大城市。&lt;/p&gt;
&lt;h2 id=&#34;纽伦堡&#34;&gt;纽伦堡&lt;/h2&gt;
&lt;h2 id=&#34;奥格斯堡&#34;&gt;奥格斯堡&lt;/h2&gt;
&lt;h2 id=&#34;非森&#34;&gt;非森&lt;/h2&gt;
&lt;p&gt;天鹅堡的所在地Fussen。&lt;/p&gt;
&lt;h1 id=&#34;巴登符腾堡州&#34;&gt;巴登符腾堡州&lt;/h1&gt;
&lt;p&gt;斯图加特是首府。&lt;/p&gt;
&lt;h2 id=&#34;斯图加特&#34;&gt;斯图加特&lt;/h2&gt;
&lt;p&gt;斯图加特的奥特莱斯位于Metzingen Village。&lt;/p&gt;
&lt;p&gt;保时捷的总部。&lt;/p&gt;
&lt;p&gt;奔驰的总部。&lt;/p&gt;
&lt;h1 id=&#34;黑森州&#34;&gt;黑森州&lt;/h1&gt;
&lt;p&gt;威斯巴登是首府。&lt;/p&gt;
&lt;h2 id=&#34;威斯巴登&#34;&gt;威斯巴登&lt;/h2&gt;
&lt;h2 id=&#34;法兰克福&#34;&gt;法兰克福&lt;/h2&gt;
&lt;p&gt;该州最大城市,法国第五大城市。&lt;/p&gt;
&lt;p&gt;法兰克福的奥特莱斯位于Wertheim Village。&lt;/p&gt;
&lt;h1 id=&#34;北莱茵-威斯特法伦州&#34;&gt;北莱茵-威斯特法伦州&lt;/h1&gt;
&lt;p&gt;杜塞尔多夫是首府。&lt;/p&gt;
&lt;h2 id=&#34;杜塞尔多夫&#34;&gt;杜塞尔多夫&lt;/h2&gt;
&lt;h2 id=&#34;科隆&#34;&gt;科隆&lt;/h2&gt;
&lt;p&gt;该州最大城市，德国第四大城市。&lt;/p&gt;
&lt;h1 id=&#34;下萨克森州&#34;&gt;下萨克森州&lt;/h1&gt;
&lt;p&gt;汉诺威是首府。&lt;/p&gt;
&lt;h2 id=&#34;汉诺威&#34;&gt;汉诺威&lt;/h2&gt;
&lt;h2 id=&#34;沃尔夫斯堡&#34;&gt;沃尔夫斯堡&lt;/h2&gt;
&lt;p&gt;大众总部。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hadoop MapReduce</title>
        <link>https://canuxcheng.com/post/hadoop_mapreduce/</link>
        <pubDate>Wed, 03 May 2017 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hadoop_mapreduce/</guid>
        <description>&lt;h1 id=&#34;map-reduce&#34;&gt;Map-Reduce&lt;/h1&gt;
&lt;p&gt;一种基于YARN的大型数据并行处理系统．主要处理离线数据．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mapreduce-commands&#34;&gt;mapreduce commands&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;mapred [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mapred archive
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;admin commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mapred historyserver

$ mapred hsadmin
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Redis</title>
        <link>https://canuxcheng.com/post/redis/</link>
        <pubDate>Wed, 03 May 2017 14:46:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/redis/</guid>
        <description>&lt;h1 id=&#34;redis&#34;&gt;Redis&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://redisdoc.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://redisdoc.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;redis在key-value存储上性能比memcached更好．&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# redis-cli, redis-sentinel, redis-server
$ sudo apt-get install redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只安装redis-cli:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install redis-tools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;redis-server监听端口6379.&lt;/p&gt;
&lt;p&gt;redis-sentinel端口26379.&lt;/p&gt;
&lt;p&gt;redis gui:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/qishibo/AnotherRedisDesktopManager&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/qishibo/AnotherRedisDesktopManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/luin/medis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/luin/medis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;redis HA:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/CodisLabs/codis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/CodisLabs/codis&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;redis的命令&#34;&gt;redis的命令&lt;/h1&gt;
&lt;p&gt;server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;client:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sentinel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-sentinel
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;redis-cli 进入命令行模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; command    # 查看所有可用命令

&amp;gt; info    # 查看redis服务器信息

&amp;gt; monitor

&amp;gt; select 1 # 选中数据库1
&amp;gt; keys *  # 显示所有key
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;string&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; set &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
&amp;gt; get &amp;lt;key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;list&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; lset &amp;lt;key&amp;gt; &amp;lt;index&amp;gt; &amp;lt;value&amp;gt;
&amp;gt; lindex &amp;lt;key&amp;gt; &amp;lt;index&amp;gt;
&amp;gt; rpop
&amp;gt; lpop &amp;lt;key&amp;gt;
&amp;gt; rpush
&amp;gt; lpush
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hash&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; hset &amp;lt;key&amp;gt; &amp;lt;field&amp;gt; &amp;lt;value&amp;gt;
&amp;gt; hget &amp;lt;key&amp;gt; &amp;lt;field&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sadd &amp;lt;key&amp;gt; &amp;lt;member&amp;gt;
&amp;gt; spop &amp;lt;key&amp;gt;
&amp;gt; srem &amp;lt;key&amp;gt; &amp;lt;memeber&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sorted set&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; zadd &amp;lt;key&amp;gt; &amp;lt;score&amp;gt; &amp;lt;member&amp;gt;
&amp;gt; zrem &amp;lt;key&amp;gt; &amp;lt;member&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;通过redis-cli&amp;gt; info查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;其它指标参考grafana dashboard.

Redis_mode: cluster/standalone

&amp;gt;&amp;gt;&amp;gt; replication (master/slave)
Connected_slaves:    连接的slave实例个数

&amp;gt;&amp;gt;&amp;gt; persistence  （rdb和aof的持久化信息）
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Smtp</title>
        <link>https://canuxcheng.com/post/smtp/</link>
        <pubDate>Wed, 26 Apr 2017 09:56:04 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/smtp/</guid>
        <description>&lt;h1 id=&#34;email&#34;&gt;Email&lt;/h1&gt;
&lt;p&gt;MTA: Mail Transfer Agent&lt;/p&gt;
&lt;p&gt;MUA: Mail User Agent&lt;/p&gt;
&lt;p&gt;python邮件服务器MTA：smtp协议&lt;/p&gt;
&lt;p&gt;python客户端MUA：本地协议pop3, 远程协议imap&lt;/p&gt;
&lt;h2 id=&#34;mailutils&#34;&gt;mailutils:&lt;/h2&gt;
&lt;p&gt;mailutils默认安装postfix,如果已经安装其它MTA就使用已经安装的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install mailutils
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非交互安装mailutils:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 这里不用配置任何参数．
$ sudo debconf-set-selections &amp;lt;&amp;lt;&amp;lt; &amp;quot;postfix postfix/mailname string &amp;quot;
$ sudo debconf-set-selections &amp;lt;&amp;lt;&amp;lt; &amp;quot;postfix postfix/main_mailer_type string &#39;Internet Site&#39;&amp;quot;
$ sudo apt-get install -y mailutils
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;test mail body&amp;quot; | mail -s &amp;quot;test mail title&amp;quot; canuxcheng@gmail.com
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sendmail&#34;&gt;sendmail&lt;/h1&gt;
&lt;p&gt;开源的smtp服务器．&lt;/p&gt;
&lt;p&gt;安装sendmail:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install sendmail
$ sudo apt-get install sendmail-cf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/hosts
  127.0.0.1 localhost.localdomain    localhost    hostname

$ sudo vim /etc/mail/sendmail.mc
  modify 127.0.0.1 to 0.0.0.0, 才能发送给其它机器，否则只能发给本机．
  DAEMON_OPTIONS(&#39;..., Port=smtp, Addr=127.0.0.1&#39;)dnl
# mv sendmail.cf sendmail.cf.old
# m4 sendmail.mc &amp;gt; sendmail.cf
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;postfix&#34;&gt;postfix&lt;/h1&gt;
&lt;p&gt;比sendmail更友好的smtp服务器．&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install postfix
# general type of mail configuration -&amp;gt; Internet site
# system mail name -&amp;gt; 空着
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用默认值即可.
$ sudo vim /etc/postfix/main.cf
inet_interfaces = all
mydestination = localhost, $hostname, localhost.localdomain, localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的email标准库&#34;&gt;Python的email标准库&lt;/h1&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;smtpd&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;smtplib&lt;/li&gt;
&lt;li&gt;poplib&lt;/li&gt;
&lt;li&gt;imaplib&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>HAWQ</title>
        <link>https://canuxcheng.com/post/hawq/</link>
        <pubDate>Mon, 24 Apr 2017 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hawq/</guid>
        <description>&lt;h1 id=&#34;hawq&#34;&gt;HAWQ&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://hawq.incubator.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://hawq.incubator.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/incubator-hawq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/incubator-hawq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HAWQ是在Pivotal Greenplum和PostgreSQL基础上开发而来．&lt;/p&gt;
&lt;p&gt;HAWQ也就是Pivotal HDB.&lt;/p&gt;
&lt;p&gt;HAWQ和Pivotal　HDB是一个项目．&lt;/p&gt;
&lt;p&gt;Hortonworks公司的HDP集成了HAWQ.&lt;/p&gt;
&lt;p&gt;HAWQ可以通过HDFS在本机快速，交互查询hadoop数据．&lt;/p&gt;
&lt;p&gt;hawq的交互式命令行接口, 类似于postgresql, 参考postgresql.&lt;/p&gt;
&lt;p&gt;hawq的client: psql (参考postgresql)&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;psql&#34;&gt;psql&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ psql
$ PGPASSWORD=&#39;password&#39;;psql -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; -U &amp;lt;username&amp;gt; -d [database] -c &amp;quot;[psql command]&amp;quot;
$ psql -l # 查看所有database

# jdbc
$ jdbc:pivotal:greenplum://hdm1:5432;DatabaseName=getstartdb;User=hdbuser;Password=hdbpass
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql&#34;&gt;sql&lt;/h1&gt;
&lt;p&gt;AO(append only) table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type2) WITH (appendonly=true, orientation=parquet);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AO table distributed by specified column and partitioned by range:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) distributed by range(var) partition by range(var1) (start val end val1 every val2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AO table distributed by randomly and partitioned by range:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) distributed randomly partition by range (var) (start(val) end (val1) every(val2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet table distributed by specified column and partitoned by list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) WITH (appendonly=true, orientation=parquet) distributed by (var) partition by list (var1) (partition name values (val), partition name1 values (val1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet table distributed by randomly and partitioned by list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) WITH (appendonly=true, orientation=parquet) distributed randomly partiton by list (var1) (partition name values (val), partition name1 values (val));
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Hive</title>
        <link>https://canuxcheng.com/post/hive/</link>
        <pubDate>Mon, 24 Apr 2017 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hive/</guid>
        <description>&lt;h1 id=&#34;hive&#34;&gt;Hive&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/hive&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/hive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://hive.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://hive.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hive2数据仓库用于读取，写入和管理使用SQL的大型分布式数据集．&lt;/p&gt;
&lt;p&gt;hive2的client: beeline(hive命令的升级版)&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hivebeeline&#34;&gt;hive/beeline&lt;/h1&gt;
&lt;p&gt;hive&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hive --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beeline&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ beeline --silent=true
beeline&amp;gt; !connect jdbc:hive2://[ip]:[port]/[database] [username] [password]

$ beeline -u &amp;quot;jdbc:hive2://[ip]:10000[/database]&amp;quot; -n [username] -p [password] -e &amp;quot;USE [database]; ...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql&#34;&gt;sql&lt;/h1&gt;
&lt;p&gt;normal table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table tablename (var type, var1 type1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) STORED AS PARQUET;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;partition table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2);
&amp;gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet partition table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2) STORED AS PARQUET;
&amp;gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values};
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Impala</title>
        <link>https://canuxcheng.com/post/impala/</link>
        <pubDate>Mon, 24 Apr 2017 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/impala/</guid>
        <description>&lt;h1 id=&#34;impala&#34;&gt;Impala&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/incubator-impala&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/incubator-impala&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://impala.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://impala.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;impala的client: impala-shell&lt;/p&gt;
&lt;p&gt;Cloudera公司的CDH集成了Impala.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;impala-shellbeeline&#34;&gt;impala-shell/beeline&lt;/h1&gt;
&lt;p&gt;impala-shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ impala-shell
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;beeline&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ beeline --silent=true
beeline&amp;gt; !connect jdbc:hive2://[ip]:21050[/database];auth=noSasl [username] [password]

$ beeline -u &amp;quot;jdbc:hive2://[ip]:21050[/database];auth=noSasl&amp;quot; -n [username] -p [password] -e &amp;quot;USE [database]; ...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql&#34;&gt;sql&lt;/h1&gt;
&lt;p&gt;normal table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crate table {table_name} (var type, var1 type1) STORED AS PARQUET;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;partition table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2);
&amp;gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parquet partition table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2) STORED AS PARQUET;
&amp;gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Presto</title>
        <link>https://canuxcheng.com/post/presto/</link>
        <pubDate>Mon, 24 Apr 2017 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/presto/</guid>
        <description>&lt;h1 id=&#34;presto&#34;&gt;Presto&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/prestodb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/prestodb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://prestodb.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://prestodb.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;presto的client: presto-cli(rename to presto)&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;presto-cli&#34;&gt;presto-cli&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ presto --server localhost:8080 --catalog hive --schema default

# jdbc for presto
$ jdbc:presto://host:port/catalog/schema
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>MongoDB</title>
        <link>https://canuxcheng.com/post/mongodb/</link>
        <pubDate>Sun, 16 Apr 2017 14:46:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/mongodb/</guid>
        <description>&lt;h1 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mongodb/mongo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mongodb/mongo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mongodb是一种开源的文档数据库，高性能，高可用性，自动裁剪．&lt;/p&gt;
&lt;p&gt;mongodb的database和关系数据库中的database一样．&lt;/p&gt;
&lt;p&gt;mongodb将BSON(mongo的JSON)文档存储在集合(collections)中，集合相当于关系数据库中的表table．&lt;/p&gt;
&lt;p&gt;mongodb的collections中的域(field)，相当于关系数据库中的字段column.&lt;/p&gt;
&lt;p&gt;mongodb的collections中的文档(document)，相当于关系数据库中的记录行row.&lt;/p&gt;
&lt;p&gt;mongodb也支持index索引和primary key主键，但是不支持table joins表连接．&lt;/p&gt;
&lt;p&gt;ubuntu安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv0C49F3730359A14518585931BC711F9BA15703C6
$ echo &amp;quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list
$ sudo apt-get update
$ sudo apt-get install -y mongodb-org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ubuntu启动:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo service mongod start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成默认的数据库是test.另外db, admin, local是保留的数据库名称．&lt;/p&gt;
&lt;p&gt;mongod的默认端口是27017.&lt;/p&gt;
&lt;p&gt;mongo web-gui:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Studio3T/robomongo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Studio3T/robomongo&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mongo的命令&#34;&gt;mongo的命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;mongo [options] [db address] [file names (ending in .js)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mongo shell进入到指定数据库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongo [db_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地命令行执行sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongo [database] -e/--eval [javascript]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;远程执行sql语句:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mongo -u [username] -p [password] [ip]:[port]/[datbase] -e/--eval [javascript]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;先用mongo命令进入mongo命令行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help    # 查看所有命令
exit    # 退出mongo shell

db    # 显示当前数据库
use &amp;lt;db_name&amp;gt;    # 切换到指定数据库, 不存在则创建．
show dbs    # 查看所有数据库
show collections # 查看当前database的collections
show users
show profile
show logs
show log [name]

sh.help()

rs.help()

db.help() # 查看所有database的方法
db.hostInfo()
db.serverStatus()

db.mycoll.help() # 查看所有collections的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;curd&#34;&gt;CURD&lt;/h1&gt;
&lt;p&gt;mongo的CURD操作就相当于关系数据库中的sql操作．&lt;/p&gt;
&lt;p&gt;CURD: create update read delete.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; use &amp;lt;database_name&amp;gt; # 切换/创建数据库
&amp;gt; db.createCollection(collection_name) # 在当前数据库创建集合
&amp;gt; db.dropDatabase() # 删除当前数据库
&amp;gt; db.getCollectionNames() # 获取当前数据库的所有集合

&amp;gt; db.mycoll.insert(obj) #　往集合mycollection中插入JSON对象obj.
&amp;gt; db.mycoll.find([query],[fields]) # 查询文档
&amp;gt; db.mycoll.remove(query) # 删除文档
&amp;gt; db.mycoll.save(obj) # 替换已有的文档
&amp;gt; db.mycoll.update( query, object[, upsert_bool, multi_bool] ) # 更新已有的文档
&amp;gt; db.mycoll.drop() # 删除当前集合

# 释放内存
&amp;gt; use admin
&amp;gt; db.runCommand({closeAllDatabases:1})
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;通过mongo&amp;gt; serverStatus()查看&lt;/p&gt;
&lt;p&gt;其它指标参考grafana dashboard.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Xml</title>
        <link>https://canuxcheng.com/post/xml/</link>
        <pubDate>Fri, 07 Apr 2017 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/xml/</guid>
        <description>&lt;h1 id=&#34;xml&#34;&gt;XML&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Xpath</title>
        <link>https://canuxcheng.com/post/xpath/</link>
        <pubDate>Fri, 07 Apr 2017 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/xpath/</guid>
        <description>&lt;h1 id=&#34;xpath&#34;&gt;XPath&lt;/h1&gt;
&lt;p&gt;XPath是一门在XML文档中查找信息的语言．&lt;/p&gt;
&lt;p&gt;xpath定位有绝对定位和相对定位，推荐使用相对定位．&lt;/p&gt;
&lt;p&gt;绝对的XPath定位包含了从HTML根节点起的所有元素，并且一些轻微的改变就会失效。&lt;/p&gt;
&lt;p&gt;相对的XPath用id或者name属性来找到一个靠近的元素(比较理想的是父元素)，这样你就可以依靠他们的相对关系来确定目标元素的位置。&lt;/p&gt;
&lt;h1 id=&#34;firefox&#34;&gt;firefox&lt;/h1&gt;
&lt;p&gt;firebug + firepath&lt;/p&gt;
&lt;p&gt;firefox通过两者结合来获取xpath&lt;/p&gt;
&lt;h1 id=&#34;chrome&#34;&gt;chrome&lt;/h1&gt;
&lt;p&gt;chrome的开发者工具(F12)可以直接copy xpath.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Kvm</title>
        <link>https://canuxcheng.com/post/kvm/</link>
        <pubDate>Wed, 05 Apr 2017 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/kvm/</guid>
        <description>&lt;h1 id=&#34;kvm&#34;&gt;KVM&lt;/h1&gt;
&lt;p&gt;Kernel-based Virtual Machine.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;qemu&#34;&gt;Qemu&lt;/h1&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install qemu-system qemu-kvm
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Libvirt</title>
        <link>https://canuxcheng.com/post/libvirt/</link>
        <pubDate>Wed, 05 Apr 2017 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/libvirt/</guid>
        <description>&lt;h1 id=&#34;libvirt&#34;&gt;Libvirt&lt;/h1&gt;
&lt;p&gt;支持多种虚拟化平台的库&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://libvirt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://libvirt.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install libvirt-bin (包含virsh命令和libvirtd daemon)
// libvirtd在container中无法运行；在container中安装libvirt-bin可以获取virsh命令远程访问libvirt-bin server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;libvirt-bin拆分成了两个包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libvirt-daemon-system
libvirt-clients

$ sudo apt-get install libvirt-dev # 库, python/go client依赖该库

$ sudo apt-get install virt-manager # windows管理工具

$ sudo apt-get install virt-view # ...

$ sudo service libvirt-bin restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;virsh&#34;&gt;virsh&lt;/h1&gt;
&lt;p&gt;libvirt的命令行工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ virsh list --all    # 查看所有虚拟机
$ virsh list --all --name # 只看domain name.

$ virsh define /path/to/X.xml    # 从xml配置文件定义一个domain
$ virsh start     # 启动虚拟机
$ virsh reboot    # 重启虚拟机
$ virsh shutdown   # 关闭虚拟机
$ virsh destroy    # 强制关闭虚拟机
$ virsh undefine   # 移除虚拟机
$ virsh vncdisplay # 查看虚拟机的vnc信息，可以通过vnc访问.

$ virsh net-list --all # 查看所有网络
$ virsh net-define default.xml
$ virsh net-autostart default
$ virsh net-start default
$ virsh net-undefine default
$ virsh net-destroy default

# 批量操作vm
$ for vm in `virsh list --all --name`; do virsh undefine/destroy ${vm}; done
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;qemu-img&#34;&gt;qemu-img&lt;/h1&gt;
&lt;p&gt;创建虚拟机的镜像文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ qemu-img create -f qcow2 /path/to/name.qcow2 100G
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;libvirt-qemu&#34;&gt;libvirt-qemu&lt;/h1&gt;
&lt;p&gt;libvirt操作qemu/kvm.&lt;/p&gt;
&lt;p&gt;本地:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qemu:///system
qemu:///session
qemu+unix:///system
qemu+unix:///session
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh远程:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# libvirt-bin server上需要安装nc和libvirt-bin
$ sudo apt-get install netcat-openbsd
$ sudo update-alternatives --config nc // netcat-traditional避免使用默认安装

# ssh用户需要在libvirt和kvm组里
$ adduser username libvirtd
$ adduser username kvm

$ sudo apt-get install sshpass // 免密码访问

# client上需要安装openssh-clients
$ sshpass -p password virsh -c qemu+ssh://user@127.0.0.1/system list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tcp远程:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/libvirt/libvirtd.conf:
listen_tls = 0　　　　　　　　　 #禁用tls登录
listen_tcp = 1　　　　　　　　　 #启用tcp方式登录
tcp_port = &amp;quot;16509&amp;quot;　　　　　　　 #tcp端口16509
listen_addr = &amp;quot;0.0.0.0&amp;quot;         # 允许任意ip访问
auth_tcp = &amp;quot;none&amp;quot;　　　　　　    #TCP不使用认证

$ vim /etc/default/libvirt-bin
start_libvirtd=&amp;quot;yes&amp;quot;
libvirtd_opts=&amp;quot;-l --config /etc/libvirt/libvirtd.conf&amp;quot;

$ sudo service libvirt-bin restart

$ virsh -c qemu+tcp://127.0.0.1:16509/system list
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;libvirtd配置&#34;&gt;libvirtd配置&lt;/h1&gt;
&lt;p&gt;配置libvirtd：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/libvirt/libvirtd.conf

max_clients = 1024　　　　　　   #最大总的连接客户数1024
min_workers = 50　　　　　　    #libvirtd启动时，初始的工作线程数目
max_workers = 200　　　　　　 #同上，最大数目
max_requests = 1000　　　　　
#最大同时支持的RPC调用，必须大于等于max_workers
max_client_requests = 200　　 #每个客户端支持的最大连接数
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>IDE</title>
        <link>https://canuxcheng.com/post/devops_ide/</link>
        <pubDate>Sun, 02 Apr 2017 21:11:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_ide/</guid>
        <description>&lt;h1 id=&#34;jetbrains&#34;&gt;JetBrains&lt;/h1&gt;
&lt;p&gt;IntelliJ: Java的IDE, 安装Python的插件也支持python.&lt;/p&gt;
&lt;h2 id=&#34;pycharm&#34;&gt;PyCharm&lt;/h2&gt;
&lt;p&gt;PyCharm: Python的IDE.&lt;/p&gt;
&lt;h2 id=&#34;goland&#34;&gt;Goland&lt;/h2&gt;
&lt;p&gt;Goland: golang的IDE.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vscode&#34;&gt;VSCode&lt;/h1&gt;
&lt;h2 id=&#34;intellisense--code-navigation&#34;&gt;IntelliSense &amp;amp; Code Navigation&lt;/h2&gt;
&lt;p&gt;Go to Definition: F12, 跳转到定义.&lt;/p&gt;
&lt;p&gt;Peek Definition: Alt + F12， 速览定义，不跳转.&lt;/p&gt;
&lt;p&gt;Go to references: Shift + F12, 转到引用.&lt;/p&gt;
&lt;h2 id=&#34;frontend&#34;&gt;frontend&lt;/h2&gt;
&lt;h3 id=&#34;vs-js-debug&#34;&gt;vs-js-debug&lt;/h3&gt;
&lt;p&gt;vscode内置了js/ts/node的debugger.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/vscode-js-debug&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/microsoft/vscode-js-debug&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;live-server&#34;&gt;live server&lt;/h3&gt;
&lt;p&gt;live preview(html, svg&amp;hellip;)&lt;/p&gt;
&lt;p&gt;如果用remote-ssh开启live server就是在远程机器上开启5500端口，webroot就是vscode打开的目录.&lt;/p&gt;
&lt;p&gt;如果是remote-ssh开发html，用这个preview很方便.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ritwickdey/vscode-live-server&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ritwickdey/vscode-live-server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;vscode-chrome-debug&#34;&gt;vscode-chrome-debug&lt;/h3&gt;
&lt;p&gt;打开的是安装vscode的机器上的chrome。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/vscode-chrome-debug&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/microsoft/vscode-chrome-debug&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过live server监听remote-ssh机器上的5500，可以通过chrome远程调试静态站点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
    &amp;quot;configurations&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;angularjs&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;chrome&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;url&amp;quot;: &amp;quot;http://remote-ssh-server:5500/path/to/index.html&amp;quot;,
            &amp;quot;webRoot&amp;quot;: &amp;quot;${workspaceFolder}/path/to/&amp;quot;,
        },
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;python&#34;&gt;python&lt;/h2&gt;
&lt;p&gt;debuging:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://code.visualstudio.com/docs/python/debugging&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://code.visualstudio.com/docs/python/debugging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;debug current file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;current file&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
    &amp;quot;program&amp;quot;: &amp;quot;${file}&amp;quot;,
    &amp;quot;console&amp;quot;: &amp;quot;integratedTerminal&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug with module:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;module&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;module-name&amp;quot;,
    &amp;quot;console&amp;quot;: &amp;quot;integratedTerminal&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug with attach:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// create ssh tunnel
ssh -2 -L sourceport:localhost:5678 -i identifyfile user@remoteaddress
{
    &amp;quot;name&amp;quot;: &amp;quot;Python: Attach&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;request&amp;quot;: &amp;quot;attach&amp;quot;,
    &amp;quot;port&amp;quot;: 5678,
    &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
    &amp;quot;pathMappings&amp;quot;: [
        {
            &amp;quot;localRoot&amp;quot;: &amp;quot;${workspaceFolder}&amp;quot;,
            &amp;quot;remoteRoot&amp;quot;: &amp;quot;.&amp;quot;,
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;testing:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://code.visualstudio.com/docs/python/testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://code.visualstudio.com/docs/python/testing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;unittest:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;python.testing.autoTestDiscoverOnSaveEnabled&amp;quot;: true,
    &amp;quot;python.testing.unittestArgs&amp;quot;: [
        &amp;quot;-v&amp;quot;,
        &amp;quot;-s&amp;quot;,
        &amp;quot;./tests&amp;quot;,
        &amp;quot;-p&amp;quot;,
        &amp;quot;test_*.py&amp;quot;
    ],
    &amp;quot;python.testing.pytestEnabled&amp;quot;: false,
    &amp;quot;python.testing.nosetestsEnabled&amp;quot;: false,
    &amp;quot;python.testing.unittestEnabled&amp;quot;: true,
    &amp;quot;restructuredtext.confPath&amp;quot;: &amp;quot;${workspaceFolder}/docs&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;django&#34;&gt;django&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://code.visualstudio.com/docs/python/tutorial-django&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://code.visualstudio.com/docs/python/tutorial-django&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;debugging:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    // 使用 IntelliSense 了解相关属性。
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
    &amp;quot;configurations&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Python: Django&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;python&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;${workspaceFolder}/path/to/manage.py&amp;quot;,
            &amp;quot;console&amp;quot;: &amp;quot;integratedTerminal&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;runserver&amp;quot;,
                &amp;quot;0:8888&amp;quot;
            ],
            &amp;quot;django&amp;quot;: true,
            &amp;quot;env&amp;quot;: {
            }
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;golang&#34;&gt;golang&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/vscode-go/blob/master/docs/debugging.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/vscode-go/blob/master/docs/debugging.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;debugging:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
    &amp;quot;configurations&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;golang file&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;go&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;mode&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;${file}&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;gin debug&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;go&amp;quot;,
            &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
            &amp;quot;mode&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;program&amp;quot;: &amp;quot;${workspaceFolder}/backend/main.go&amp;quot;
        },
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rest-client&#34;&gt;rest client&lt;/h2&gt;
&lt;p&gt;调试rest API&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Huachao/vscode-restclient&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Huachao/vscode-restclient&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;example.api:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@api = http://hostname:port/api/v0
@Authorization = Basic a2FpemVuOkFybUFkbWluMSE=
@Content-Type = application/json

###
GET {{api}}/users HTTP/1.1
Authorization: {{Authorization}}
Content-Type: {{Content-Type}}

### 
POST {{api}}/groupus HTTP/1.1
Authorization: {{Authorization}}
Content-Type: {{Content-Type}}
{
    key: value
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;record&#34;&gt;record&lt;/h2&gt;
&lt;p&gt;vscode录制.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/codetour&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/microsoft/codetour&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/arciisine/vscode-chronicler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/arciisine/vscode-chronicler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持远程debug的时候在本地录制，也就是本地是windows，只需要本地安装ffmpeg和chroicler。&lt;/p&gt;
&lt;h2 id=&#34;mcp&#34;&gt;MCP&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;&amp;hellip;/Code/User/settings.json&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/GLips/Figma-Context-MCP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/GLips/Figma-Context-MCP&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/modelcontextprotocol/servers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/modelcontextprotocol/servers&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;servers&amp;quot;: {
        &amp;quot;postgres&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@modelcontextprotocol/server-postgres&amp;quot;,
                &amp;quot;postgresql://server?ssl=true&amp;amp;sslmode=require&amp;amp;rejectUnauthorized=false&amp;quot;
            ]
        },
        &amp;quot;redis&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@modelcontextprotocol/server-redis&amp;quot;,
                &amp;quot;redis://localhost:6379&amp;quot;
            ]
        },
        &amp;quot;playwright&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;@playwright/mcp@latest&amp;quot;
            ]
        },
        &amp;quot;Azure MCP Server&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@azure/mcp@latest&amp;quot;,
                &amp;quot;server&amp;quot;,
                &amp;quot;start&amp;quot;
            ]
        },
        &amp;quot;memory&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@modelcontextprotocol/server-memory&amp;quot;
            ]
        },
        &amp;quot;sequential-thinking&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@modelcontextprotocol/server-sequential-thinking&amp;quot;
            ]
        },
        &amp;quot;git&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;docker&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;run&amp;quot;,
                &amp;quot;--rm&amp;quot;,
                &amp;quot;-i&amp;quot;,
                &amp;quot;--mount&amp;quot;,
                &amp;quot;type=bind,src=${workspaceFolder},dst=/workspace&amp;quot;,
                &amp;quot;mcp/git&amp;quot;
            ]
        },
        &amp;quot;filesystem&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;@modelcontextprotocol/server-filesystem&amp;quot;,
                &amp;quot;${workspaceFolder}&amp;quot;
            ]
        },
        &amp;quot;fetch&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;docker&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;run&amp;quot;,
                &amp;quot;-i&amp;quot;,
                &amp;quot;--rm&amp;quot;,
                &amp;quot;mcp/fetch&amp;quot;
            ]
        },
        &amp;quot;kubernetes&amp;quot;: {
            &amp;quot;command&amp;quot;: &amp;quot;npx&amp;quot;,
            &amp;quot;args&amp;quot;: [
                &amp;quot;-y&amp;quot;,
                &amp;quot;mcp-server-kubernetes&amp;quot;
            ]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Cryptographic</title>
        <link>https://canuxcheng.com/post/sec_cryptographic/</link>
        <pubDate>Mon, 27 Mar 2017 17:11:58 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sec_cryptographic/</guid>
        <description>&lt;h1 id=&#34;pgp&#34;&gt;PGP&lt;/h1&gt;
&lt;p&gt;PGP: Pretty Good Privacy。&lt;/p&gt;
&lt;p&gt;用于签名和加密解密。&lt;/p&gt;
&lt;h2 id=&#34;pgp-1&#34;&gt;PGP&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Pretty_Good_Privacy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Pretty_Good_Privacy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;openpgp&#34;&gt;OpenPGP&lt;/h2&gt;
&lt;p&gt;OpenPGP是PGP的标准,也有很多实现。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://openpgp.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://openpgp.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gnupg&#34;&gt;GnuPG&lt;/h2&gt;
&lt;p&gt;GunPG: Gun Privacy Guard, 是基于openPGP的实现。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gnupg.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gnupg.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gpg --help

$ 快速生成签名密钥对
gpg --quick-generate-key &amp;quot;Canux&amp;quot;
// 查看公钥
gpg --list-keys
// 查看私钥
gpg --list-secret-keys
// 删除私钥
gpg --delete-secret-keys &amp;quot;Canux&amp;quot;
// 删除公钥
gpg --delete-keys &amp;quot;Canux&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GPGME: GPG Made Easy, 是一个让应用程序使用GPG更容易的库．&lt;/p&gt;
&lt;h1 id=&#34;openssl&#34;&gt;OpenSSL&lt;/h1&gt;
&lt;p&gt;网络安全和密码工具。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.openssl.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.openssl.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl --help
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;单向哈希加密&#34;&gt;单向哈希加密&lt;/h1&gt;
&lt;p&gt;md5和shaX都是常用的存储密码的加密方法.&lt;/p&gt;
&lt;p&gt;rainbow table可以破解单向加密.&lt;/p&gt;
&lt;p&gt;salt方法可以防止rainbow table破解.&lt;/p&gt;
&lt;p&gt;scrypt是最难破解的加密方案.&lt;/p&gt;
&lt;h2 id=&#34;md5&#34;&gt;md5&lt;/h2&gt;
&lt;h2 id=&#34;sha1&#34;&gt;sha1&lt;/h2&gt;
&lt;h2 id=&#34;sha256&#34;&gt;sha256&lt;/h2&gt;
&lt;h2 id=&#34;sha512&#34;&gt;sha512&lt;/h2&gt;
&lt;h2 id=&#34;hmac&#34;&gt;hmac&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;symmetric-cryptography&#34;&gt;Symmetric Cryptography&lt;/h1&gt;
&lt;p&gt;对称加密就是加密和解密使用的密钥是相同的．&lt;/p&gt;
&lt;h2 id=&#34;base32&#34;&gt;base32&lt;/h2&gt;
&lt;h2 id=&#34;base64&#34;&gt;base64&lt;/h2&gt;
&lt;h2 id=&#34;des&#34;&gt;des&lt;/h2&gt;
&lt;h2 id=&#34;aes&#34;&gt;aes&lt;/h2&gt;
&lt;h2 id=&#34;rc4&#34;&gt;rc4&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;asymmetric-cryptography&#34;&gt;Asymmetric Cryptography&lt;/h1&gt;
&lt;p&gt;非对称加密就是存在两个密钥.&lt;/p&gt;
&lt;h2 id=&#34;rsa&#34;&gt;rsa&lt;/h2&gt;
&lt;h2 id=&#34;dsa&#34;&gt;dsa&lt;/h2&gt;
&lt;h2 id=&#34;ecdsa&#34;&gt;ecdsa&lt;/h2&gt;
&lt;h2 id=&#34;ecc&#34;&gt;ecc&lt;/h2&gt;
&lt;p&gt;elliptic curves cryptography&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JS DOM</title>
        <link>https://canuxcheng.com/post/js_dom/</link>
        <pubDate>Wed, 15 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_dom/</guid>
        <description>&lt;h1 id=&#34;dom&#34;&gt;DOM&lt;/h1&gt;
&lt;p&gt;DOM: document object model.&lt;/p&gt;
&lt;p&gt;当网页被加载时，浏览器会创建页面的文档对象模型(DOM).&lt;/p&gt;
&lt;p&gt;DOM操作需要在html加载完成后进程.&lt;/p&gt;
&lt;p&gt;js可以通过DOM访问html文档的所有元素.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 能够改变页面中的所有 HTML 元素&lt;/li&gt;
&lt;li&gt;JavaScript 能够改变页面中的所有 HTML 属性&lt;/li&gt;
&lt;li&gt;JavaScript 能够改变页面中的所有 CSS 样式&lt;/li&gt;
&lt;li&gt;JavaScript 能够对页面中的所有事件做出反应&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查找html元素&#34;&gt;查找html元素&lt;/h2&gt;
&lt;p&gt;找到返回该元素的对象，没找到返回null.&lt;/p&gt;
&lt;p&gt;通过id:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById(&amp;quot;id&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过标签名:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementsByTagName(&amp;quot;tag&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过类名:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementsByName(&amp;quot;name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;操作html元素或文本&#34;&gt;操作html元素或文本&lt;/h2&gt;
&lt;p&gt;操作标签或标签内的文本.&lt;/p&gt;
&lt;p&gt;直接改变html内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 绝不要使用在文档加载之后使用 document.write()。这会覆盖该文档
document.write(...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改变元素的内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById(id).innerHTML = &amp;quot;new text&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;操作html属性&#34;&gt;操作html属性&lt;/h2&gt;
&lt;p&gt;改变元素属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById(id).attribute = &amp;quot;new value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;操作css&#34;&gt;操作css&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById(id).style.property = &amp;quot;new style&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;增删html元素&#34;&gt;增删html元素&lt;/h2&gt;
&lt;p&gt;增加元素:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var para = document.createElement(&amp;quot;p&amp;quot;);
var node = document.createTextNode(&amp;quot;new para&amp;quot;);
para.appendChild(node);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除元素:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var parent = document.getElementById(&amp;quot;id&amp;quot;);
var child = document.getElementById(&amp;quot;cid&amp;quot;);
parent.removeChild(child);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对事件做出反应&#34;&gt;对事件做出反应&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function changetext(id) {
    id.innerHTML = &amp;quot;new text&amp;quot;
}
&amp;lt;h1 onclick=&amp;quot;changetext(this)&amp;quot;&amp;gt;&amp;lt;/h1&amp;gt;

document.getElementById(id).onclick=function(){...};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;p&gt;集合:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;all[]
anchors[]
applets
forms[]
images[]
links[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;body
cookie
domain
lastModified
referrer
title
URL
readyState // loading/interfactive/complete
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open()
close()
getElementById() # 返回id对应的第一个对象
getElementsByName() # 返回对应的所有对象的集合
getElementsByTagName() # 同上
write()
writeln()
createElement()
createTextNode()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;element&#34;&gt;Element&lt;/h1&gt;
&lt;p&gt;element表示html元素,拥有元素，文本和注释的子节点.&lt;/p&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tagName // tag名字
innerHTML // 元素里面的文本内容
id
title
style
className
length
nodeName // 和tagName相同
nodeType // 节点类型: 1= 元素节点，2= 属性节点, 3= 文本节点, 8= 注释
nodeValue // 文本节点的值
parentNode // 父节点
childNodes // 子节点
firstChild
lastChild
nextSibling
previousSibling
ownerDocument // 返回当前根节点文档对象
accesKey
attributes
contentEditable
dir
lang
namespaceURI
tabIndex
textContent
clientHeight
clientWidth
offsetHeight
offsetWidth
offsetLeft
offsetParent
offsetTop
scrollHeight
scrollLeft
scrollTop
scrollWidth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appendChild(node) // 在元素后追加node
InsertBefore() // 在元素前插入node
removeChild()
replaceChild()
cloneNode()

compareDocumentPosition()
getAttribute()
getAttributeNode()
getElementsByTagName()
getFeature()
getUserData()
hasAttribute()
hasAttributes()
hasChildNodes()
isDefaultNamespace()
isEqualNode()
isSameNode()
isSupported()
normalize()
removeAttribute()
removeAttributeNode()
setArrbitute()
setArrtibuteNode()
setIdAttribute()
setIdArrtibuteNode()
setUserData()
toString()
item() #
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;attribute&#34;&gt;Attribute&lt;/h1&gt;
&lt;p&gt;Attribute表示html属性&lt;/p&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isId
name
value
specified
length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gtNamedItem()
item()
removeNameItem()
setNamedItem()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;event&#34;&gt;Event&lt;/h1&gt;
&lt;p&gt;window事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 等待html加载完成
onload
window.onload = function(){};

onunload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;鼠标事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onclick
ondblclick
onmousedown
onmousemove
onmouseout
onmouseover
onmouseup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;键盘事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onkeypress
onkeydown
onkeyup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表单事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onsubmit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;媒体事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onabort
onerror
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>JS OOP</title>
        <link>https://canuxcheng.com/post/js_oop/</link>
        <pubDate>Wed, 15 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_oop/</guid>
        <description>&lt;h1 id=&#34;oop&#34;&gt;OOP&lt;/h1&gt;
&lt;p&gt;javascript中一切都是对象.&lt;/p&gt;
&lt;p&gt;javacript内置了Bull/Number/String/Object/Function/Array/Date/RegExp类型.&lt;/p&gt;
&lt;h1 id=&#34;object&#34;&gt;Object&lt;/h1&gt;
&lt;p&gt;创建Object实例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new Object();

var obj = Object(); // new 可以省略

var obj = ｛
    name: &amp;quot;value&amp;quot;
};

var obj = {
    &amp;quot;name&amp;quot;: &amp;quot;value&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.attr = &amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.method =  methodName;
function methodName() {};

obj.method = function() {};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete obj.attr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问对象属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.property
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问对象方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.method()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;boolean&#34;&gt;Boolean&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor
prototype
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toSource()
valueOf()
toString()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;number&#34;&gt;Number&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor
prototype

MAX_VALUE
MIN_VALUE
NaN
NEGATIVE_INFINITY
POSITIVE_INFINITY
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;valueOf()
toString()

toLocaleString()
toFixed()
toExponential()
toPrecision()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;string&#34;&gt;String&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor
prototype

length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toSource()
toString()
valueOf()

anchor()
big()
indexOf()
replace()
match()
search()
toLowerCase()
toUpperCase()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;function&#34;&gt;Function&lt;/h1&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Infinity
java
NaN
Packages
undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape()
eval()
getClass()
isFinite()
isNaN()
parseFloat()
parseInt()
String()
unescape()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;array&#34;&gt;Array&lt;/h1&gt;
&lt;p&gt;创建对象:&lt;/p&gt;
&lt;p&gt;new都可以省略.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var arr = new Array();

var arr = new Array(size);

var arr = new Array(element0, element1, ...);

var arr = [];
var arr = [1,2, &amp;quot;test&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr[index] = &amp;quot;value&amp;quot;;

// 字符串下标，不能直接通过数组对象访问，只能通过对象方法访问.
arr[&amp;quot;key&amp;quot;] = &amp;quot;value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor
prototype

length // set或get数组中元素个数.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toSource()
toString()
valueOf()

toLocaleString()

join(separator) // 返回按照分隔符分隔的字符串
concat() // 拼接

push() // 往数组末尾添加元素,返回最新长度.
pop() // 移除数组末尾元素,并返回

unshift() // 在数组开头添加元素，返回最新长度.
shift() //　移除数组开头元素并返回

reverse() // 对数组逆序排序操作．
sort(sortby) // 对数组顺序排序操作

slice(start, end) // 取下标为start和end之间的元素，不包括start和end.

splice(index, howmany, item1, ...) // 删除，插入，替换功能.
splice(index, howmany) // 从index开始，获取howmany个元素
splice(index, 0, item) // 从index插入item
splice(index, 1, item) // 用item替换index的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;date&#34;&gt;Date&lt;/h1&gt;
&lt;p&gt;创建对象:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var date = new Date();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor
prototype
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toString()
toSource()
valueOf()

Date()
UTC()
parse(datestring) // 返回datestring的epoch毫秒数

toLocalString()
toLocalTimeString()
toLocalDateString(0)
toUTCString()
toGMTString()
toDateString()
toTimeString()

get...

set...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;regexp&#34;&gt;RegExp&lt;/h1&gt;
&lt;h1 id=&#34;math&#34;&gt;Math&lt;/h1&gt;
&lt;h1 id=&#34;events&#34;&gt;Events&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Angular</title>
        <link>https://canuxcheng.com/post/js_angular/</link>
        <pubDate>Mon, 13 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_angular/</guid>
        <description>&lt;h1 id=&#34;angularjs&#34;&gt;angularjs&lt;/h1&gt;
&lt;p&gt;angularjs 1.*&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/angular/angular.js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/angular/angular.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://angularjs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://angularjs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rev087/ng-inspector&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rev087/ng-inspector&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;angular&#34;&gt;Angular&lt;/h1&gt;
&lt;p&gt;Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。&lt;/p&gt;
&lt;p&gt;angular.js 的升级版&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/angular/angular&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/angular/angular&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/angular/angular-cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/angular/angular-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://angular.io&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://angular.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://angular.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://angular.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装 angular-cli:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g @angular/cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ng v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建项目:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd &amp;lt;project&amp;gt;
$ ng new &amp;lt;application&amp;gt;

# 严格模式
$ ng new &amp;lt;application&amp;gt; --strict

$ ng generate &amp;lt;schematic&amp;gt; [options]
appShell
application
class
component
directive
enum
guard
interceptor
interface
library
module
pipe
resolver
service
serviceWorker
webWorker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试项目:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd &amp;lt;my-app&amp;gt;
$ ng serve
// --open会自动打开浏览器
$ ng serve --open
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ng build --prod
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;项目结构&#34;&gt;项目结构&lt;/h1&gt;
&lt;p&gt;工作区配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.editorconfig: 代码编辑器配置&lt;/li&gt;
&lt;li&gt;angular.json:  为工作区所有项目指定CLI的默认配置，包括CLI要用到的构建，启动开发服务器和测试工具的配置项。&lt;/li&gt;
&lt;li&gt;tsconfig.json: 工作空间所有项目的基本typescript配置。&lt;/li&gt;
&lt;li&gt;tslint.json: 工作空间中所有项目的默认的TSlint配置。&lt;/li&gt;
&lt;li&gt;src/: 根项目的源文件。&lt;/li&gt;
&lt;li&gt;e2e/: 端到端测试文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用配置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.browserslistrc 配置前端工具之间共享的目标浏览器和node.js版本&lt;/li&gt;
&lt;li&gt;karma.conf.js 应用的karma配置&lt;/li&gt;
&lt;li&gt;tsconfig.app.json 应用的typescript配置.&lt;/li&gt;
&lt;li&gt;tsconfig.spec.json 应用测试的typescript配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用源文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;app/ 包含定义应用逻辑和数据的组件文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assets/ 包含要在构建应用时应该按原样复制的图像和静态文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;environments/ 包含特定目标环境的构建配置选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;favicon.ico 应用在标签栏中的图标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;index.html 主页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;main.ts 应用的入口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;polyfills.ts 为浏览器支持提供polyfill脚本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;styles.css 列出为项目提供样式的css文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app/app.component.ts  根组件AppComponent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app/app.component.html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app/app.component.css&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app/app.component.spec.ts 根组件的单元测试.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app/app.module.ts 定义名为AppModule根模块.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;module&#34;&gt;Module&lt;/h1&gt;
&lt;p&gt;angular的模块化系统NgModule, 也就是根模块，习惯命名为AppModule,位于app.module.ts文件。&lt;/p&gt;
&lt;p&gt;NgModule是一个带有@NgModule()装饰器的类，该装饰器是一个函数.&lt;/p&gt;
&lt;p&gt;重要的属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;declarations: 可申明对象表，数据本NgModule的组件，指令和管道。&lt;/li&gt;
&lt;li&gt;exports：导出表，能在其它模块的组件模板中使用的可申明对象的子集。&lt;/li&gt;
&lt;li&gt;imports：导入表，导出了本模块中的组件模板所需的类的其它模块。&lt;/li&gt;
&lt;li&gt;providers：本模块向全局服务中贡献的那些服务的创建器。&lt;/li&gt;
&lt;li&gt;bootstrap：应用的主视图，称为根组件，是应用中所有其它视图的宿主。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;components&#34;&gt;components&lt;/h1&gt;
&lt;p&gt;组件控制屏幕上被称为视图的一小片区域, 每个angular应用最少有一个根组件。&lt;/p&gt;
&lt;p&gt;通过@Component装饰器定义组件.&lt;/p&gt;
&lt;p&gt;组件配置选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;selector: 选择器&lt;/li&gt;
&lt;li&gt;templateUrl: 该组件的HTML模板文件相对于组件文件的地址。&lt;/li&gt;
&lt;li&gt;template: html&lt;/li&gt;
&lt;li&gt;styleUrls: 该组件的CSS文件相对路径.&lt;/li&gt;
&lt;li&gt;style: css&lt;/li&gt;
&lt;li&gt;providers: 当前组件所需的服务提供者的一个数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pipes&#34;&gt;pipes&lt;/h1&gt;
&lt;p&gt;管道&lt;/p&gt;
&lt;h1 id=&#34;directives&#34;&gt;directives&lt;/h1&gt;
&lt;p&gt;指令就是带有@Directive()装饰器的类。&lt;/p&gt;
&lt;p&gt;组件是特殊指令，angular还内置了结构型指令和属性型指令，也可以自定义指令。&lt;/p&gt;
&lt;p&gt;结构型指(structural)令通过添加，移除或替换DOM元素来修改布局。&lt;/p&gt;
&lt;p&gt;属性型指令(attribute)会修改现有元素的外观和行为。&lt;/p&gt;
&lt;h1 id=&#34;services&#34;&gt;services&lt;/h1&gt;
&lt;p&gt;服务类： 对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建服务类。&lt;/p&gt;
&lt;h1 id=&#34;dependency-injection&#34;&gt;dependency injection&lt;/h1&gt;
&lt;p&gt;依赖注入可以保持组件的精简和高效。&lt;/p&gt;
&lt;p&gt;通过@Injectable装饰器来定义DI。&lt;/p&gt;
&lt;h1 id=&#34;routing&#34;&gt;routing&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>DevOps</title>
        <link>https://canuxcheng.com/post/js_devops/</link>
        <pubDate>Mon, 13 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_devops/</guid>
        <description>&lt;h1 id=&#34;js--ts&#34;&gt;JS &amp;amp; TS&lt;/h1&gt;
&lt;p&gt;vscode&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Next.js: debug server-side&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;node-terminal&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;npm run dev&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Next.js: debug client-side&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chrome&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Next.js: debug client-side (Firefox)&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;firefox&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:3000&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;reAttach&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;pathMappings&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;webpack://_N_E&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${workspaceFolder}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Next.js: debug full stack&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;node&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;program&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${workspaceFolder}/node_modules/next/dist/bin/next&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;runtimeArgs&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;--inspect&amp;#34;&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;skipFiles&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;node_internals&amp;gt;/**&amp;#34;&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;serverReadyAction&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;action&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;debugWithEdge&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;killOnServerStop&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;pattern&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;- Local:.+(https?://.+)&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;uriFormat&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;webRoot&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${workspaceFolder}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SPA: Single page application, 单页应用，like react, vue and angular.
SSR: server side rendering. 服务端渲染, like next.js, nuxt.js&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;yalc&#34;&gt;yalc&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wclr/yalc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wclr/yalc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i yalc -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;usage:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yalc publish
yalc add ...
yalc remove ...
yalc publish 
yalc push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yalc publish需要exports dist，而不是src。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: &amp;quot;./dist/index.cjs.js&amp;quot;,
    &amp;quot;./alpha&amp;quot;: &amp;quot;./dist/alpha.cjs.js&amp;quot;,
    &amp;quot;./package.json&amp;quot;: &amp;quot;./package.json&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;eslint&#34;&gt;ESLint&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/typescript-eslint/typescript-eslint&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/typescript-eslint/typescript-eslint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;linting.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vite&#34;&gt;vite&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vitejs/vite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vitejs/vite&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;webpack&#34;&gt;Webpack&lt;/h2&gt;
&lt;p&gt;bundler&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/webpack/webpack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/webpack/webpack&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;rollup&#34;&gt;Rollup&lt;/h2&gt;
&lt;p&gt;bundler&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rollup/rollup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rollup/rollup&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gulp&#34;&gt;gulp&lt;/h2&gt;
&lt;p&gt;Automation - gulp is a toolkit that helps you automate painful or time-consuming tasks in your development workflow.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gulpjs/gulp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gulpjs/gulp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gulp command line&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install --global gulp-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gulp for devDependencies&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install --save-dev gulp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create gulpfile.js and test it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim gulpfile.js
$ gulp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;karma&#34;&gt;karma&lt;/h2&gt;
&lt;p&gt;A simple tool that allows you to execute JavaScript code in multiple real browsers.&lt;/p&gt;
&lt;p&gt;angularjs 的 test runner.&lt;/p&gt;
&lt;p&gt;The main purpose of Karma is to make your test-driven development easy, fast, and fun.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/karma-runner/karma&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/karma-runner/karma&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;karma command line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g karma-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;karma for devDependencies&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install --save-dev karma
$ npm install karma-jasmine karma-chrome-launcher jasmine-core --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run karma&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ karma start
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>JavaScript</title>
        <link>https://canuxcheng.com/post/js/</link>
        <pubDate>Mon, 13 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js/</guid>
        <description>&lt;h1 id=&#34;javascript概述&#34;&gt;JavaScript概述&lt;/h1&gt;
&lt;p&gt;Javascript包括三部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ECMAScript核心,提供核心语言功能．&lt;/li&gt;
&lt;li&gt;DOM文档对象模型, 提供访问和操作网页内容的方法和接口．&lt;/li&gt;
&lt;li&gt;BOM浏览器对象模型, 提供与浏览器交互的方法和接口．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ES5.0 (2009)
ES5.1 (2011, ISO/IEC)
ES6.0 (2015)&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;javascript基本语法&#34;&gt;javascript基本语法&lt;/h1&gt;
&lt;p&gt;javascript源程序叫xxx.js.&lt;/p&gt;
&lt;p&gt;javascript大小写敏感．&lt;/p&gt;
&lt;p&gt;javascript使用驼峰命名法．&lt;/p&gt;
&lt;p&gt;javascript的标识符以字母，下划线或美元符号开头，还可以包含数字．不能是关键字．&lt;/p&gt;
&lt;p&gt;JvaScript代码块以大括号{}包围,开括号写在第一行结尾处，前面空格，闭括号单独一行。&lt;/p&gt;
&lt;p&gt;javascript中所有事物都是对象，都有属性和方法.&lt;/p&gt;
&lt;p&gt;JavaScript使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．&lt;/p&gt;
&lt;p&gt;javascript中运算符周围要有空格。&lt;/p&gt;
&lt;p&gt;javascript中使用四个空格来缩进。&lt;/p&gt;
&lt;p&gt;javascript不支持goto。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;注释&#34;&gt;注释&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * comment1
 * comment2
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;关键字&#34;&gt;关键字&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 数据类型
var function return typeof new delete

# 流程控制
if else for in do while switch case default with break continue

# 修饰符
void

# 动作相关
instanceof this

# 异常处理
try catch throw

# 调试
debugger

# ECMAScript2015
let const
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;运算符和优先级&#34;&gt;运算符和优先级&lt;/h1&gt;
&lt;h2 id=&#34;算数运算符&#34;&gt;算数运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;+
-
* 
**
/
%
++
--
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;赋值运算符&#34;&gt;赋值运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;=
+=
-=
*=
/=
%=
&amp;lt;&amp;lt;=
&amp;gt;&amp;gt;=
&amp;gt;&amp;gt;&amp;gt;=
&amp;amp;=
^=
|=
**=
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;比较运算符&#34;&gt;比较运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 在比较值钱进行类型转换.
==

// 强制对值和类型进行比较.
===

!=

!==

&amp;gt;
&amp;lt;
&amp;gt;=
&amp;lt;=

// 三元运算符
?
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;逻辑运算符&#34;&gt;逻辑运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 逻辑与
&amp;amp;&amp;amp;

// 逻辑或
||

// 逻辑非
!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型运算符&#34;&gt;类型运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;typeof

instanceof
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;位运算符&#34;&gt;位运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp;
|
~
^
&amp;lt;&amp;lt;
&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h2 id=&#34;var申明变量&#34;&gt;var申明变量&lt;/h2&gt;
&lt;p&gt;通过var申明的变量没有块作用域，在块之外也能访问.&lt;/p&gt;
&lt;p&gt;申明变量:&lt;/p&gt;
&lt;p&gt;重复申明同名变量不会改变变量的值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var varName;
// 一次申明多个变量
var varName1, varName2, ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;varName = varValue;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明并赋值:&lt;/p&gt;
&lt;p&gt;动态类型语言，变量可以赋予不同类型值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var varName = varValue;
// 一次定义多个变量
var varName1 = varValue1, varName2=varValue2, ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明变量类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var varName = new Boolean/Number/String/Array/Object;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;let申明变量&#34;&gt;let申明变量&lt;/h2&gt;
&lt;p&gt;通过let申明有块作用域的变量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    let varName = varValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let不能多次申明同一个变量。&lt;/p&gt;
&lt;h2 id=&#34;const申明常量&#34;&gt;const申明常量&lt;/h2&gt;
&lt;p&gt;const定义的变量与let相似， 但不能重新赋值.&lt;/p&gt;
&lt;p&gt;它没有定义常量值。它定义了对值的常量引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    const varName = varValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量对象的属性可以修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const car = {type:&amp;quot;porsche&amp;quot;, model:&amp;quot;911&amp;quot;, color:&amp;quot;black&amp;quot;};
car.color = &amp;quot;white&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量数组元素可以修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const cars = [&amp;quot;audi&amp;quot;, &amp;quot;bmw&amp;quot;];
cars[0] = &amp;quot;honda&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;布尔boolean&#34;&gt;布尔/Boolean&lt;/h2&gt;
&lt;p&gt;布尔类型只有true和false两个值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x = true
var y = false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数字number&#34;&gt;数字/Number&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var name = 1.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字符串string&#34;&gt;字符串/String&lt;/h2&gt;
&lt;p&gt;字符串可以用单引号或双引号表示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var name = &amp;quot;string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;null&#34;&gt;Null&lt;/h2&gt;
&lt;p&gt;Null类型只有一个特殊值null.表示一个空对象指针.&lt;/p&gt;
&lt;p&gt;通过null清空变量的值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;varName = null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;undefined&#34;&gt;Undefined&lt;/h2&gt;
&lt;p&gt;没有赋值的变量值为undefined.&lt;/p&gt;
&lt;p&gt;Undefined类型只有一个特殊值undefined.&lt;/p&gt;
&lt;h2 id=&#34;对象object&#34;&gt;对象/Object&lt;/h2&gt;
&lt;p&gt;对象由大括号包围的键值对表示，中间用逗号隔开.&lt;/p&gt;
&lt;p&gt;定义对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new Object;

var obj = {key: &amp;quot;val&amp;quot;, key1: &amp;quot;val1&amp;quot;};

var obj = {
    firstName: &amp;quot;bill&amp;quot;, // 冒号后空格.
    lastName: &amp;quot;gates&amp;quot; // 最后一个不要都好.
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问对象属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val = obj.key
val = obj[&amp;quot;key&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问对象方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.method()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;typeof&#34;&gt;typeof&lt;/h2&gt;
&lt;p&gt;该操作符可以返回数据类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;undefined
boolean
number
string
object
function
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;控制流&#34;&gt;控制流&lt;/h1&gt;
&lt;h2 id=&#34;if&#34;&gt;if&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if (condition) {
    expression;
}

if (condition) {
    expression;
} else {
    expression;
}

if (condition) {
    expression;
} else if (condition) {
    expression;
} else {
    expression;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;switch&#34;&gt;switch&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;switch(expression) {
    case value:
        statement;
        break;
    case value:
        statement;
        break;
    ...
    default:
        statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;for&#34;&gt;for&lt;/h2&gt;
&lt;p&gt;for:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (initialization; expression; post-loop-expression) {
    statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for-in:&lt;/p&gt;
&lt;p&gt;循环遍历对象的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (property in object) {
    statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;while&#34;&gt;while&lt;/h2&gt;
&lt;p&gt;do-while:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;do {
    statement;
} while (condition);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (condition) {
    statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;with&#34;&gt;with&lt;/h2&gt;
&lt;p&gt;将代码作用于设定到一个特定对象.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with (expression) {
    statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;break和continue&#34;&gt;break和continue&lt;/h2&gt;
&lt;p&gt;label:&lt;/p&gt;
&lt;p&gt;break和continue都可以和label配合使用.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;labelName: statement
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break:&lt;/p&gt;
&lt;p&gt;跳出循环(for, while).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;labelName:
for () {
    for () {
        if () {
            break labelName; # 跳出最外层循环
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;continue:&lt;/p&gt;
&lt;p&gt;继续下一次循环.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;labelName:
for () {
    for () {
        if () {
            continue labelName; # 从外层循环继续循环
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;文件和输入输出&#34;&gt;文件和输入输出&lt;/h1&gt;
&lt;h2 id=&#34;输出&#34;&gt;输出&lt;/h2&gt;
&lt;p&gt;alert写入警告框：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.alert(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;write写入html：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.write(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;innerHTML写入html:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById(&amp;quot;demo&amp;quot;).innerHTML = 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;console.log写入浏览器控制台:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 可以在js代码或调试窗口打印变量值：
console.log(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输入&#34;&gt;输入&lt;/h2&gt;
&lt;p&gt;prompt&lt;/p&gt;
&lt;p&gt;alert和prompt会跳过渲染先被执行。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;p&gt;定义函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 没参数
function funcName() {
}

// 带参数
function funcName(args) {
}

// 使用变量
var name = function(args) {};

// 使用构造方法
var name = new Function(args, return value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数返回值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function funcName() {
    return ...
}

// 函数返回值赋值给变量
var value = funcName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;js的函数形式参数和实际参数可以是任意个数和任意类型．&lt;/p&gt;
&lt;p&gt;函数内部定义的变量是局部变量,局部变量在函数运行后被删除．&lt;/p&gt;
&lt;p&gt;如果把值赋给未申明的变量，该变量被自动作为全局变量．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name = &amp;quot;value&amp;quot; 相当于全局变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数内部属性:&lt;/p&gt;
&lt;p&gt;函数内部两个特殊对象arguments和this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arguments // 用来存储该函数的所有参数
arguments.callee // 指针，指向该函数本身.

this // 表示函数调用语句所处的作用域
window // 当在全局调用this，引用的就是window对象.

// 调用函数
apply()
call()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;错误和异常&#34;&gt;错误和异常&lt;/h1&gt;
&lt;p&gt;try-catch:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
    statement;
} catch(err) {
    statement;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;throw:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;throw exception
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;严格模式&#34;&gt;严格模式&lt;/h2&gt;
&lt;p&gt;通过在脚本或函数开头添加严格模式：&lt;/p&gt;
&lt;p&gt;严格模式在不声明变量的情况下使用变量，是不允许的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;;
......
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;debugger调试&#34;&gt;debugger调试&lt;/h2&gt;
&lt;p&gt;debugger关键字会停止js的执行，如果有调试函数就调用。&lt;/p&gt;
&lt;p&gt;如果调试器打开，会在debugger停止执行，如果没有打开调试器，会继续运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x = 10;
debugger;
document.getElementbyId(&amp;quot;demo&amp;quot;).innerHTML = x;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模块和包&#34;&gt;模块和包&lt;/h1&gt;
&lt;h3 id=&#34;commonjs&#34;&gt;commonjs&lt;/h3&gt;
&lt;p&gt;for old nodejs projects.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// import
require()
// export
module.exports
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持单个对象，可以是默认对象&lt;/p&gt;
&lt;p&gt;extention: &amp;ldquo;*.js&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;es&#34;&gt;ES&lt;/h3&gt;
&lt;p&gt;for new nodejs projects.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// import
import * from *
// export
export &amp;lt;function&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认导出和命名导出都可以。&lt;/p&gt;
&lt;p&gt;extention: *.mjs&amp;quot;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;文档&#34;&gt;文档&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;jsx&#34;&gt;JSX&lt;/h1&gt;
&lt;p&gt;JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。虽然还有其它方式可以编写组件，但大部分 React 开发者更喜欢 JSX 的简洁性，并且在大部分代码库中使用它。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JS Test</title>
        <link>https://canuxcheng.com/post/js_test/</link>
        <pubDate>Mon, 13 Mar 2017 09:36:32 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_test/</guid>
        <description>&lt;h1&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jest&#34;&gt;Jest&lt;/h2&gt;
&lt;p&gt;for javascript.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jestjs/jest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jestjs/jest&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ts-jest&#34;&gt;TS Jest&lt;/h2&gt;
&lt;p&gt;for typescript.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kulshekhar/ts-jest&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kulshekhar/ts-jest&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jasmine&#34;&gt;jasmine&lt;/h2&gt;
&lt;p&gt;A JavaScript Testing Framework&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jasmine/jasmine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jasmine/jasmine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install jasmine to devDependencies&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install --save-dev jasmineinit 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jasmine in project&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npx jasmine init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set jasmine as test script in package.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; &amp;quot;scripts&amp;quot;: { &amp;quot;test&amp;quot;: &amp;quot;jasmine&amp;quot; } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run test&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm test
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Testing</title>
        <link>https://canuxcheng.com/post/testing/</link>
        <pubDate>Wed, 01 Mar 2017 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/testing/</guid>
        <description>&lt;h1 id=&#34;qa&#34;&gt;QA&lt;/h1&gt;
&lt;p&gt;Quality Assurance&lt;/p&gt;
&lt;p&gt;QA主要就是进行软件测试相关的工作.&lt;/p&gt;
&lt;p&gt;软件测试就是使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异．&lt;/p&gt;
&lt;p&gt;软件测试五个要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;质量&lt;/li&gt;
&lt;li&gt;人员&lt;/li&gt;
&lt;li&gt;技术&lt;/li&gt;
&lt;li&gt;流程&lt;/li&gt;
&lt;li&gt;资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试两个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试覆盖率&lt;/li&gt;
&lt;li&gt;测试效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试(Unit Testing)&lt;/li&gt;
&lt;li&gt;集成测试(Integration Testing)： 验证多个模块之间接口交互。&lt;/li&gt;
&lt;li&gt;系统测试(System Testing)：整个系统的测试，验证系统是否满足需求（功能，性能，兼容性，稳定性）。&lt;/li&gt;
&lt;li&gt;验收测试(Acceptance Testing)·&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试的手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手动测试/自动化测试&lt;/li&gt;
&lt;li&gt;静态测试&lt;/li&gt;
&lt;li&gt;动态测试&lt;/li&gt;
&lt;li&gt;黑盒测试&lt;/li&gt;
&lt;li&gt;白盒测试&lt;/li&gt;
&lt;li&gt;灰度测试：部分了解内部结构，常用于测试接口，集成层，复杂业务逻辑等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;li&gt;稳定性测试&lt;/li&gt;
&lt;li&gt;安全测试&lt;/li&gt;
&lt;li&gt;可用性测试&lt;/li&gt;
&lt;li&gt;兼容性测试&lt;/li&gt;
&lt;li&gt;文档测试&lt;/li&gt;
&lt;li&gt;本地化测试&lt;/li&gt;
&lt;li&gt;冒烟测试&lt;/li&gt;
&lt;li&gt;功能测试Functional Testing&lt;/li&gt;
&lt;li&gt;回归测试Regression Testing&lt;/li&gt;
&lt;li&gt;用户界面测试UI Testing&lt;/li&gt;
&lt;li&gt;端到端测试End-To-End Testing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试的模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统的瀑布模型&lt;/li&gt;
&lt;li&gt;V模型&lt;/li&gt;
&lt;li&gt;W模型&lt;/li&gt;
&lt;li&gt;X模型&lt;/li&gt;
&lt;li&gt;H模型&lt;/li&gt;
&lt;li&gt;敏捷测试模型(金字塔模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件测试的模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金字塔模式Ideal Test Automation Pyramid&lt;/li&gt;
&lt;li&gt;蛋筒冰激凌模式Ice Cream Cone&lt;/li&gt;
&lt;li&gt;双金字塔模式Dual Test Pyramid&lt;/li&gt;
&lt;li&gt;纸杯蛋糕模式Cupcake&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;test-automation-pyramid&#34;&gt;Test Automation Pyramid&lt;/h1&gt;
&lt;p&gt;Mike Cohn的测试金字塔&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://martinfowler.com/bliki/TestPyramid.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://martinfowler.com/bliki/TestPyramid.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automated GUI Tests(10%)&lt;/li&gt;
&lt;li&gt;Automated Service Tests(Component/Integration/API)(20%)&lt;/li&gt;
&lt;li&gt;Automated Unit Tests(70%)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unit-test单元测试&#34;&gt;Unit Test/单元测试&lt;/h1&gt;
&lt;p&gt;单元测试是开发者编写的测试一个单元（函数／类）的功能是否符合预期．&lt;/p&gt;
&lt;p&gt;单元测试的覆盖率是指测试的单元调用了多少代码．&lt;/p&gt;
&lt;p&gt;Unit Test的工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java: Junit&lt;/li&gt;
&lt;li&gt;Python: unittest(pyunit), nose2, pytest&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;test-automation&#34;&gt;Test Automation&lt;/h1&gt;
&lt;p&gt;敏捷测试的核心就是自动化测试．&lt;/p&gt;
&lt;p&gt;自动化测试框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Robot Framework&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ATDD: Acceptance test-driven development&lt;/p&gt;
&lt;p&gt;BDD: Behavior-driven development&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;big-list-of-naughty-strings&#34;&gt;big-list-of-naughty-strings&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/minimaxir/big-list-of-naughty-strings&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/minimaxir/big-list-of-naughty-strings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试中谨慎使用的字符串．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;allure&#34;&gt;Allure&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/allure-framework&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/allure-framework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Allure是一个灵活的轻量级多语言测试报告框架．&lt;/p&gt;
&lt;h1 id=&#34;reportportal&#34;&gt;reportportal&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/reportportal&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/reportportal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReportPortal是一个开源的测试报告平台，支持多种测试框架和语言，提供实时的测试结果和分析。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>RobotFramework</title>
        <link>https://canuxcheng.com/post/testing_robotframework/</link>
        <pubDate>Sat, 25 Feb 2017 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/testing_robotframework/</guid>
        <description>&lt;h1 id=&#34;robot-framework&#34;&gt;Robot Framework&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robotframework/robotframework&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robotframework/robotframework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robotframework/QuickStartGuide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robotframework/QuickStartGuide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持python和java的API.&lt;/p&gt;
&lt;p&gt;Robot Framework is a generic test automation framework for acceptance testing and acceptance test-driven development (ATDD).&lt;/p&gt;
&lt;p&gt;Install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install robotframework
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Modular:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Test Data&lt;/li&gt;
&lt;li&gt;Robot Framework(test data syntax)&lt;/li&gt;
&lt;li&gt;Test Libraries(test library API) + Test Tools&lt;/li&gt;
&lt;li&gt;System under Test(system interface)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ robot --version
$ robot [options] data_sources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会生成三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;output.xml&lt;/li&gt;
&lt;li&gt;log.html&lt;/li&gt;
&lt;li&gt;report.html&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;setting-table&#34;&gt;setting table&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;*** Settings ***
# 前三个是加载外部文件
Library    Selenium2Library # 需要在sys.path路径里面
Resource    ${RESOURCES}/common.tsv
Variables    ${RESOURCES}/common.py
Documentation    Docs
Metadata    Version    2.0
Suite Setup
Suite Teardown
Force Tags
Default Tags
Test Setup
Test Teardown
Test Template
Test Timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;test-case-table&#34;&gt;Test Case table&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robotframework/HowToWriteGoodTestCases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robotframework/HowToWriteGoodTestCases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test case:data_sources就是test cases files.robotframework测试用例可以使用带参数的简单表格语法，也可以是不带参数的关键字表格,也可以是数据驱动测试用例.&lt;/p&gt;
&lt;p&gt;Test Cases由keywords和可能的arguments组成．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Test Cases ***
Test Case Name
    [Documentation]    Docs
    [Tags]
    [Setup]
    [Teardown]
    [Template]
    [Timeout]
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test Case分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Workflow tests&lt;/li&gt;
&lt;li&gt;higher-level tests&lt;/li&gt;
&lt;li&gt;Data-driven tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;keywords-table&#34;&gt;Keywords table&lt;/h1&gt;
&lt;p&gt;key word:测试用例使用关键词创建,关键词的2个来源是库关键字和用户关键字．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Keywords ***
Keyword name
    [Documentation]    docs
    [Tags]
    [Arguments]
    [Return]
    [Teardown]
    [Timeout]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Keywords分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Library keywords&lt;/li&gt;
&lt;li&gt;User keywords&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;variables&#34;&gt;Variables&lt;/h1&gt;
&lt;p&gt;variables:测试用例中可能变化的数据定义成变量．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Variables ***
${ScalarVar}    first one    second one
@{ListVar}     one    two
&amp;amp;{DictVar}     key=value    key1=value1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scalar variables标量&lt;/li&gt;
&lt;li&gt;list variables列表&lt;/li&gt;
&lt;li&gt;dictionary variables字典&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;organizing-test-cases&#34;&gt;Organizing test cases&lt;/h1&gt;
&lt;p&gt;test suites:测试用例的集合叫测试套件．每个包含测试用例的输入文件组成一个测试套件．&lt;/p&gt;
&lt;p&gt;test setup/suit setup: 在测试之前执行某些关键词．&lt;/p&gt;
&lt;p&gt;test teardown/suit teardown: 在测试之后执行某些关键词．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Settings ***
Suite Setup    Action/Keyword
Test Setup
Suite Teardown    Action/Keyword
Test Teardown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tags:给测试用例设置标签，以便给他们自由的元数据．&lt;/p&gt;
&lt;p&gt;给测试套件加标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Settings ***
Force Tags    quickstart # 这个是case的强制的tag.
Default Tags    example smoke # 这个是case的默认的tag.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义标签注意多个标签之间用四个空格区分．&lt;/p&gt;
&lt;p&gt;给单个case加标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 自定义的tag名字多个单词最好用-连接，不要用空格．
[Tags]    Your-tags1    tag2 # 这个是自定义的tag.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;libraries&#34;&gt;Libraries&lt;/h1&gt;
&lt;p&gt;内置标准库和第三方库，自定义库都可以作为keywords.&lt;/p&gt;
&lt;p&gt;robotframework的强大之处在于可以根据自己的需要开发自己的库．&lt;/p&gt;
&lt;h2 id=&#34;standardbuild-in-libraries&#34;&gt;standard(build-in libraries)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BuiltIn&lt;/p&gt;
&lt;p&gt;内置标准库，默认唯一自动加载的库．其它的库都需要手动加载．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # Comment关键字用来注释．
  Comment    this is comment
  # Evaluate关键字用来调用python程序．
  ${var}    Evaluate    random.randint(1000, 999)    random
  # Import Library关键字用来导入python模块．
  Import Library    mytest.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Collections&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DateTime&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dialogs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Easter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OperatingSystem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remote&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Screenshot&lt;/p&gt;
&lt;p&gt;用于测试过程中的截屏．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # Take Screenshot关键字用来截屏
  Take Screenshot
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Telnet&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XML&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;external&#34;&gt;External&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;selenium2library&lt;/p&gt;
&lt;p&gt;用于web自动化测试．提供了丰富的定位器，包括id,name, xpath, css.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robotframework/Selenium2Library&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robotframework/Selenium2Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $ pip install robotframework-selenium2library
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;other&#34;&gt;other&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tools&#34;&gt;Tools&lt;/h1&gt;
&lt;p&gt;robot framework相关的工具．&lt;/p&gt;
&lt;h2 id=&#34;build-in-tools&#34;&gt;build-in tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rebot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Testdoc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Libdoc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tidy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;editors&#34;&gt;editors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RIDE&lt;/p&gt;
&lt;p&gt;robot framework的IDE.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robotframework/RIDE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robotframework/RIDE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # Only wxPython 2.8.12.1 with Unicode support is officially supported
  $ pip install robotframework-ride
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usage:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  # 添加windows的桌面：
  # C:\Python27\python.exe -c &amp;quot;from robotide import main; main()&amp;quot;
  # C:\Python27\Lib\site-packages\robotide\widgets\robot.ico
  &amp;gt; ride.py
  $ ride.py
  # F5搜索关键字
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;build&#34;&gt;build&lt;/h2&gt;
&lt;h2 id=&#34;other-1&#34;&gt;other&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;robot-command&#34;&gt;robot command&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ robot tests.robot
$ robot -t/--test [test cases] tests.robot
$ robot -t My*test*case* tests.robot # 例如case叫My test case just for test.
$ robot -s/--suite [test suites] tests.robot
$ robot -i/--include [tags] tests.robot
$ robot -i My-test-tag tests.robot # 例如tag叫My-test-tag.
$ robot -e/--exclude [tags] tests.robot
-d --outputdir dir # 存放output, log, report文件的路径.
-o --output file
-l --log file
-r --report file
-W --consolewidth chars
-C --consolecolors auto|on|ansi|off
-K --consolemarkers auto|on|off
-L --loglevel level    # 格式LOGLEVEL:DEFAULT, 可选TRACE, DEBUG, INFO (default), WARN, NONE
# DEFAULT是log file中默认显示的日志级别
-b --debugfile # 存放debug log的文件．
-T --timestampoutputs # 表示所有在outputdir里面的文件都自动加时间戳．
-P --pythonpath path * # 指定PYTHONPATH, 可以指定正在开发的库用来测试，而不需要安装到site-packages.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;library&#34;&gt;Library&lt;/h1&gt;
&lt;p&gt;robotframework的灵活就在于可以自己开发第三方库，实现和自己业务相关的关键字．&lt;/p&gt;
&lt;p&gt;在robot中导入的这个库必须在sys.path路径里面．&lt;/p&gt;
&lt;p&gt;库API的三种类型： 静态库, 动态库, 混合库.&lt;/p&gt;
&lt;p&gt;以Selenium2Library为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Selenium2Library
|-- docs
|-- tests
|-- Selenium2Library
    |-- __init__.py
    |-- keywords/*.py
    |-- ...
|-- setup.py
|-- ...

$ pip install robotframework-selenium2library
# C:\Python27\Lib\site-packages\Selenium2Library
# /usr/local/lib/python2.7/dist-packages/Selenium2Library
# 通过ride导入该库后，可以用F5查看关键字的帮助.

# __init__.py
# 一个类继承所有关键字所在的类．rf通过导入这个类导入所有关键字．
from .keywords import *
from .utils import LibraryListener
...

__version__ =  1.0.0

class Selenium2Library(keywords):
    &amp;quot;&amp;quot;&amp;quot;docs.&amp;quot;&amp;quot;&amp;quot;

    ROBOT_LIBRARY_SCOPE = &#39;GLOBAL&#39;
    ROBOT_LIBRARY_VERSION = __version__

    def __init__(self, ...):
       &amp;quot;&amp;quot;&amp;quot;docs&amp;quot;&amp;quot;&amp;quot;
       self.ROBOT_LIBRARY_LISTENER = LibraryListener()
       ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;static-librarty-api&#34;&gt;Static librarty API&lt;/h1&gt;
&lt;p&gt;使用一个模块或一个类，方法直接映射到关键字名称．静态API是最基本最常用的．&lt;/p&gt;
&lt;p&gt;robotframework在类和模块中寻找关键字对应的方法，会忽略单下划线或双下划线开头的方法．&lt;/p&gt;
&lt;p&gt;robotframework在类中寻找关键字对应的方法，不区分大小写，会自动忽略空格和下划线．&lt;/p&gt;
&lt;p&gt;robotframework测试库实现为类时，基类中的方法也被识别为关键字．&lt;/p&gt;
&lt;p&gt;robotframework测试库实现为模块时，导入的模块的命名空间的可能函数也被识别为关键字．此时要防止导入的库中的方法成为关键字．&lt;/p&gt;
&lt;p&gt;关键字跑出异常，该关键字状态就是failed,否则就是pass.&lt;/p&gt;
&lt;h1 id=&#34;dylamic-library-api&#34;&gt;dylamic library API&lt;/h1&gt;
&lt;p&gt;可以在运行时动态确定要实现的关键字的名称以及执行方法．&lt;/p&gt;
&lt;h1 id=&#34;hybird-library-api&#34;&gt;hybird library API&lt;/h1&gt;
&lt;p&gt;静态和动态都有的方式．&lt;/p&gt;
&lt;h1 id=&#34;测试库范围&#34;&gt;测试库范围&lt;/h1&gt;
&lt;p&gt;要确保一个测试用例对状态的更改不会影响其它用例．&lt;/p&gt;
&lt;p&gt;测试库可以控制何时使用类属性创建新库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ROBOT_LIBRARY_SCOPE
# Global: 只有一个instance创建，并且所有test cases共享．
# TEST CASE: 为每个test case创建一个instance.
# TEST SUITE: 为每个test suite创建一个instance.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;测试库版本&#34;&gt;测试库版本&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;ROBOT_LIBRARY_VERSION
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;指定文档格式&#34;&gt;指定文档格式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;ROBOT_LIBRARY_DOC_FORMAT
# reST: 需要安装docutils模块
# ROBOT: 默认的html格式
# TEXT:　纯文本格式
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;listener&#34;&gt;Listener&lt;/h1&gt;
&lt;p&gt;Listener监听器接口允许外部监听器获取关于测试执行的通知．&lt;/p&gt;
&lt;p&gt;同名的默认方法会先调用，然后调用自定义的方法．&lt;/p&gt;
&lt;p&gt;可以实现的方法有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start_suite(name, attribute)/end_suite(name, attribute) # test suite开始/结束的时候调用
start_test(name, attribute)/end_test(name, attribute) # test case开始/结束的时候调用
start_keyword(name, attributes)/end_keyword(name, attribute) # keyword开始/结束的时候调用
close() # 相当于teardown.
log_message(message) # 当执行的keyword写log的时候调用
message(message) # 当framework写system log的时候调用
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface-methods&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface-methods&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# librarylistener.py
# rf的外部监听程序

from robot.api import logger
...

class LibraryListener(object):
    &amp;quot;&amp;quot;&amp;quot;docs&amp;quot;&amp;quot;&amp;quot;
    # version 2 for rf&amp;gt;=2.1
    # version 3 for rf&amp;gt;=3.0
    ROBOT_LISTENER_API_VERSION = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;allure&#34;&gt;allure&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/allure-framework/allure-python/tree/master/allure-robotframework&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/allure-framework/allure-python/tree/master/allure-robotframework&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install allure-robotframework
$ robot --listener allure_robotframework ./my_robot_test
$ robot --listener allure_robotframework:/set/your/path/here ./my_robot_test

allure generate output/allure
allure serve output/allure
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;reportportal&#34;&gt;reportportal&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/reportportal/plugin-import-robot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/reportportal/plugin-import-robot&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Selenium</title>
        <link>https://canuxcheng.com/post/testing_selenium/</link>
        <pubDate>Sat, 25 Feb 2017 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/testing_selenium/</guid>
        <description>&lt;h1 id=&#34;selenium&#34;&gt;Selenium&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SeleniumHQ/selenium&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/SeleniumHQ/selenium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用于基于浏览器的web应用的自动化测试工具集．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;selenium1: deprecated.
selenium2: 默认支持firefox&amp;lt;=46. 支持python2.6+, python3.2+
selenium3: 支持firefox47+, 所有浏览器都需要安装webdriver.支持python2.6+, python3.3+, 必须重启OS.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持python, java, javascript等API.&lt;/p&gt;
&lt;p&gt;默认安装selenium3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install selenium
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;selenium3需要安装相应浏览器的driver, 然后重启OS:&lt;/p&gt;
&lt;p&gt;selenium, driver, browser三个版本都需要兼容才能工作．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;winfows放在C:\Python\Scripts\
linux放在/usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://sites.google.com/a/chromium.org/chromedriver/downloads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sites.google.com/a/chromium.org/chromedriver/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mozilla/geckodriver/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mozilla/geckodriver/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[Deprecated] Remote Control: 也就是selenium1.selenium2依然保留了selenium1的API.但是selenium3会彻底删除RC的API.&lt;/p&gt;
&lt;p&gt;[Deprecated] IDE: selenium IDE是一个firefox的插件，用于记录浏览器上的测试步骤，能用于生成测试代码，并且转换成编程语言．但是已经被WebDriver取代．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;webdriver&#34;&gt;WebDriver&lt;/h1&gt;
&lt;p&gt;也就是selenium2.已经取代了selenium RC和selenium IDE.&lt;/p&gt;
&lt;p&gt;python的API参考python博客．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;grid&#34;&gt;Grid&lt;/h1&gt;
&lt;p&gt;Selenium Grid用于分布式测试&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;定位元素&#34;&gt;定位元素&lt;/h1&gt;
&lt;p&gt;对应的python的API参考python博文．&lt;/p&gt;
&lt;p&gt;selenium提供８种定位web页面中元素的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;tag&lt;/li&gt;
&lt;li&gt;link&lt;/li&gt;
&lt;li&gt;partial_link&lt;/li&gt;
&lt;li&gt;通过xpath&lt;/li&gt;
&lt;li&gt;通过css&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在浏览器通过F12快捷键进入调试模式获取．&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OpenStack</title>
        <link>https://canuxcheng.com/post/cloud_openstack/</link>
        <pubDate>Thu, 23 Feb 2017 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cloud_openstack/</guid>
        <description>&lt;h1 id=&#34;openstack&#34;&gt;OpenStack&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack-dev&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack-dev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;openstack是一个云操作系统，通过数据中心可控制大型的计算，存储，网络等资源池．&lt;/p&gt;
&lt;p&gt;所有的管理通过前端的界面管理员就可以完成，同样也可以通过web接口让最终的用户部署资源．&lt;/p&gt;
&lt;p&gt;openstack的设计原则：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.openstack.org/wiki/BasicDesignTenets&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.openstack.org/wiki/BasicDesignTenets&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;horizon---openstack-dashboard&#34;&gt;horizon - OpenStack Dashboard&lt;/h1&gt;
&lt;p&gt;控制面板&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/horizon&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/horizon&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;keystone---openstack-identity&#34;&gt;keystone - OpenStack Identity&lt;/h1&gt;
&lt;p&gt;认证服务&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/keystone&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/keystone&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nova---openstack-compute&#34;&gt;nova - OpenStack Compute&lt;/h1&gt;
&lt;p&gt;计算服务&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/nova&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/nova&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;swift---openstack-storage&#34;&gt;swift - OpenStack Storage&lt;/h1&gt;
&lt;p&gt;存储服务&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/swift&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/swift&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;neutron---openstack-networking&#34;&gt;neutron - OpenStack Networking&lt;/h1&gt;
&lt;p&gt;网络服务(原名quantum)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/neutron&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/neutron&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;glance---openstack-image-management&#34;&gt;glance - OpenStack Image Management&lt;/h1&gt;
&lt;p&gt;镜像管理&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/glance&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/glance&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cinder---openstack-block-storage&#34;&gt;cinder - OpenStack Block Storage&lt;/h1&gt;
&lt;p&gt;块存储服务&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack/cinder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack/cinder&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Makefile</title>
        <link>https://canuxcheng.com/post/linux_makefile/</link>
        <pubDate>Thu, 12 Jan 2017 21:18:33 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_makefile/</guid>
        <description>&lt;h1 id=&#34;make&#34;&gt;Make&lt;/h1&gt;
&lt;p&gt;make的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制源代码的编译&lt;/li&gt;
&lt;li&gt;手册页的编写&lt;/li&gt;
&lt;li&gt;将应用程序安装到目标目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;make的使用规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果工程没有编译过，需要编译所有源文件和链接所有目标文件．&lt;/li&gt;
&lt;li&gt;如果工程里某几个目标文件被修改，只需要编译修改的源文件，并链接所有目标文件．&lt;/li&gt;
&lt;li&gt;如果头文件被修改，只需要编译引用了被修改的头文件的源文件，并链接所有目标文件．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;makefile文件查找顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前目录找makefile&lt;/li&gt;
&lt;li&gt;当前目录找Makefile&lt;/li&gt;
&lt;li&gt;当前目录找GNUmakefile&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;make命令&#34;&gt;make命令&lt;/h1&gt;
&lt;p&gt;make命令会执行当前目录的makefile/Makefile/GNUmakefile文件．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make [options] [target] ...
-f FILE, --file=FILE, --makefile=FILE    # 指定makefile文件
-n, --just-print, --dry-run, --recon # 只打印，不执行
-k, --keep-going　# 忽略错误继续执行

make
make all
make install
make clean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;make的工作顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入所有makefile文件&lt;/li&gt;
&lt;li&gt;读入include的其它makefile文件&lt;/li&gt;
&lt;li&gt;初始化变量&lt;/li&gt;
&lt;li&gt;推导隐晦规则，分析所有规则&lt;/li&gt;
&lt;li&gt;为所有目标文件创建依赖关系链&lt;/li&gt;
&lt;li&gt;根据依赖关系决定哪些目标需要重新生成&lt;/li&gt;
&lt;li&gt;执行生成的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;makefile语法&#34;&gt;makefile语法&lt;/h1&gt;
&lt;p&gt;make命令执行makefile文件时，会比较target和prerequisites的时间戳，如果后者比前者新，或者前者不存在，就会执行command,否则会跳过command.&lt;/p&gt;
&lt;p&gt;其中#表示注释，\表示续行．@表示该命令的执行不会打印到stdout,-表示忽略错误继续执行．&lt;/p&gt;
&lt;p&gt;makefile中的command必须以tab开头，target和prerequisites有多个时用空格分开．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
target...: prerequisites...
    command
    command1 too \
    long
    @command2
    -command3
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;makefile变量赋值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var=val
var := val  覆盖之前的值
var ?= val  如果没有被赋值过，就赋值
var += val  添加一个值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过命令定义变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var := $(shell &amp;lt;command&amp;gt;)
为了区分makefile变量和shell命令里面的变量，用$$var表示shell变量
var := $(shell cat file | awk &#39;/.*/{print $$0}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;makefile的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义变量：
obj=a.o b.o c.o
使用变量：
$(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动化变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$&amp;lt;    # 第一个依赖文件
$^    # 所有的依赖文件
$@    # 目标文件
$*    # 不包含扩展名的目标文件名称
$+    # 所有的依赖文件，用空格分开
$?    # 所有时间戳比目标文件晚的依赖文件，以空格分开
$%    # 如果目标是归档成员，则表示目标的归档成员
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;清空目标文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clean:
    -rm elf $(obj)
# 或者用.PHONY表示clean是一个伪目标
.PHONY: clean
clean:
    -rm elf $(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在makefile中引用外部makefile:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 优先在当前目录查找，-l可以指定额外的查找路径
-include a.makefile b.makefile ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;makefile支持的通配符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~    # 用来表示$HOME环境变量
*    # 用来表示任意长度字符串
[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自动推导和隐晦规则：&lt;/p&gt;
&lt;p&gt;伪目标：&lt;/p&gt;
&lt;p&gt;查找路径：&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Grafana</title>
        <link>https://canuxcheng.com/post/metrics_grafana/</link>
        <pubDate>Thu, 12 Jan 2017 21:05:48 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_grafana/</guid>
        <description>&lt;h1 id=&#34;grafana&#34;&gt;Grafana&lt;/h1&gt;
&lt;p&gt;The tool for beautiful monitoring and metric analytics &amp;amp; dashboards for Graphite, InfluxDB &amp;amp; Prometheus &amp;amp; More.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grafana/grafana&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持多种data source:&lt;/p&gt;
&lt;p&gt;graphite/influxdb/opentsdb/premetheus/elasticsearch/mysql/postgresql&lt;/p&gt;
&lt;p&gt;安装配置参考官方文档&lt;/p&gt;
&lt;p&gt;grafana配置文件是grafana.ini.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;http-api&#34;&gt;HTTP API&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;port = 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dashboard&#34;&gt;dashboard&lt;/h2&gt;
&lt;p&gt;create/update dashboard:&lt;/p&gt;
&lt;p&gt;将datasource设置成变量，然后导出的json文件就可以直接导入了．&lt;/p&gt;
&lt;p&gt;dashboard.id=null才能创建新dashboard.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post /api/dashboards/db
data = json.dumps({
    &amp;quot;dashboard&amp;quot;: {
        &amp;quot;id&amp;quot;: null,
        ...
    },
    &amp;quot;folderId&amp;quot;: 0,
    &amp;quot;overwrite&amp;quot;: True, # True for python, true for go.
    &amp;quot;message&amp;quot;: &amp;quot;commit message&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;datasource&#34;&gt;datasource&lt;/h2&gt;
&lt;p&gt;create datasource:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post /api/datasources
data = json.dumps({
    &amp;quot;name&amp;quot;:
    &amp;quot;type&amp;quot;:
    &amp;quot;url&amp;quot;:
    &amp;quot;database&amp;quot;:
    &amp;quot;access&amp;quot;: &amp;quot;proxy&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;alert&#34;&gt;alert&lt;/h2&gt;
&lt;p&gt;create alert notification/channel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post /api/alert-notifications
data = json.dumps({
    &amp;quot;name&amp;quot;:
    &amp;quot;type&amp;quot;: &amp;quot;email&amp;quot;,
    &amp;quot;isDefault&amp;quot;: true,
    &amp;quot;settings&amp;quot;: {
        &amp;quot;addresses&amp;quot;: &amp;quot;a.com; b.com&amp;quot;,
        &amp;quot;uploadImage&amp;quot;: true
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;dashboard-1&#34;&gt;Dashboard&lt;/h1&gt;
&lt;p&gt;graph&lt;/p&gt;
&lt;p&gt;singlestat&lt;/p&gt;
&lt;p&gt;table&lt;/p&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;heatmap&lt;/p&gt;
&lt;p&gt;alertlist&lt;/p&gt;
&lt;h2 id=&#34;templating&#34;&gt;templating&lt;/h2&gt;
&lt;p&gt;定义变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show tag values with key=&#39;host&#39;
# 设置在dashboard加载时更新
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在templating中定义变量, query中使用的两种方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$varname
select * from cpu where &#39;host&#39; =~ /^$host$/
[[varname]]
select * from cpu where &#39;host&#39; =~ /^[[host]]&amp;amp;/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$_interval  # 相当于influxdb里面的$interval，表示group by的时间间隔
$timeFilter/$_timeFilter    # time &amp;gt; now() - &amp;lt;time range&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;panel里的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$col         给select出来的field取别名
$tag_host
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;annotations&#34;&gt;Annotations&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;alerting&#34;&gt;Alerting&lt;/h1&gt;
&lt;p&gt;email需要安装配置SMTP,推荐使用sendmail.&lt;/p&gt;
&lt;p&gt;alert发出去的图片或连接打不开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/grafana/grafana.ini
  [server]
  domain=
  root_url=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;grafana4.6.2只有graph panel支持alert, singlestat 和 table暂不支持．&lt;/p&gt;
&lt;p&gt;conditions暂不支持template variables.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;plugins&#34;&gt;plugins&lt;/h1&gt;
&lt;p&gt;默认安装路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/var/lib/grafana/plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看已经安装的plugin
$ sudo grafana-cli plugins list-remote
$ sudo grafana-cli plugins install &amp;lt;plugin-id&amp;gt; &amp;lt;version&amp;gt;

# 查看安装的plugin
$ sudo grafana-cli plugins ls

# 删除plugin
$ sudo grafana-cli plugins remove &amp;lt;plugin-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;enable-https&#34;&gt;enable https&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/grafana/grafana.ini
protocol=https
cert-file=file.crt
key-file=file.key
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;provisioning&#34;&gt;Provisioning&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://grafana.com/docs/administration/provisioning/#provisioning-grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://grafana.com/docs/administration/provisioning/#provisioning-grafana&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;datasource&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/grafana/provisioning/datasources/datasource.yaml
- name: MAF
    type: influxdb
    access: proxy
    url: http://influxdb-service:8086
    database: sandbox
    isDefault: true
    editable: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dashboard&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/grafana/provisioning/dashboards/dashboard.yaml
apiVersion: 1
providers:
- name: &#39;default&#39;
orgId: 1
folder: &#39;&#39;
type: file
disableDeletion: false
editable: true
updateIntervalSeconds: 600
options:
    path: /etc/grafana/dashboards
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Vagrant</title>
        <link>https://canuxcheng.com/post/vagrant/</link>
        <pubDate>Thu, 12 Jan 2017 21:00:01 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/vagrant/</guid>
        <description>&lt;h1 id=&#34;vagrant&#34;&gt;Vagrant&lt;/h1&gt;
&lt;p&gt;构建在虚拟化技术之上的虚拟机运行环境管理工具．&lt;/p&gt;
&lt;p&gt;适合用来构建和分发开发环境．通过命令行可以批量自动化，不用一个一个安装配置图形界面的虚拟机．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mitchellh/vagrant&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mitchellh/vagrant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要安装virtualbox或vmware等虚拟机.&lt;/p&gt;
&lt;p&gt;vagrant还支持其它的providers(docker, vmware, hyper-v, aws)&lt;/p&gt;
&lt;p&gt;可以在这里找到很多vagrant可用的box:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://atlas.hashicorp.com/boxes/search&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://atlas.hashicorp.com/boxes/search&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;初始化&#34;&gt;初始化&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p /home/user/vagrant
$ cd /vagrant

# 在当前目录生成一个Vagrantfile文件, 需手动添加vm.box
$ vagrant init 

# 相当于直接添加了vm.box到Vagrantfile.
$ vagrant init [box-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;添加box&#34;&gt;添加box&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 默认从https://atlas.hashicorp.com/boxes/search下载该box.
$ vagrant box add [[--name ]box-name] hashicorp/precise64

# 也可以使用下载到本地的box
$ vagrant box add [[--name ]box-name] /path/to/your.box

# 也可以使用自己的服务器上的box
$ vagrant box add [[--name ]box-name] URL

# 添加box之后修改Vagrantfile,添加vm.box:
Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.box = &amp;quot;[box-name]&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用box&#34;&gt;使用box&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ vagrant up [box-name]
$ vagrant up --provider docker/aws/vmware/hyperv/... [box-name]

$ vagrant ssh
# 会进入一个vagrant@precise64:~$的环境．
# /vagrant 是一个和/home/user/vagrant同步的路径．
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;结束使用&#34;&gt;结束使用&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ vagrant status # 查看box状态
$ vagrant halt # 关闭box
$ vagrant reload # 重启box
$ vagrant suspend
$ vagrant resume
$ vagrant provision

# 会销毁box占用的所有资源，但不删除box.
$ vagrant destroy
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;管理box&#34;&gt;管理box&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ vagrant box list
$ vagrant box remove
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;其它&#34;&gt;其它&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ vagrant global-status
$ vagrant global-status --prune
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置vagrantfile&#34;&gt;配置Vagrantfile&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;config.vm.box_version = &amp;quot;1.1.0&amp;quot;
cfg.vm.hostname = &amp;quot;ubuntu.labs&amp;quot;

# 端口映射, 把主机的端口映射到vagrant的box
# 访问主机的该端口就是访问vagrant的box
cfg.vm.network :forward_port, guest: 80, host: 8080

# 私有网络，只有主机可以访问vagrant的box.
# 如果多个vagrant的box设定在同一个网段也可以互相访问．
cfg.vm.network :private_network, ip: &amp;quot;192.168.50.10&amp;quot;

# 公有网络，vagrant的box和主机使用一样的网络．
cfg.vm.network :public_network
cfg.vm.network :public_network, ip: &amp;quot;192.168.1.1&amp;quot;

cfg.vm.synced_folder &amp;quot;/var/tmp/pkg-build&amp;quot;, &amp;quot;/var/tmp/pkg-build&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;打包&#34;&gt;打包&lt;/h1&gt;
&lt;p&gt;用户可以打包自己的开发环境，然后分发出去．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vagrant package [options] [name]
$ vagrant package
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;windows&#34;&gt;windows&lt;/h1&gt;
&lt;p&gt;在windows物理机安装virtualbox和vagrant.&lt;/p&gt;
&lt;p&gt;windows不支持ssh,所以需要类似于putty这种客户端．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;host: 127.0.0.1
port: 2222
user: vagrant/root
password: vagrant
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;linux&#34;&gt;linux&lt;/h1&gt;
&lt;p&gt;只能在linux物理机安装virtualbox和vagrant使用．&lt;/p&gt;
&lt;p&gt;如果想在windows物理机里面的virtualbox上安装的linux系统中使用vagrant会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# default: Warning: Connection timeout. Retrying...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为需要在linux上在安装virtualxo，然后不能设置加速．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/vagrant.PNG&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/vagrant1.PNG&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pic1&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;vagrant怎样打包ESXi上的虚拟机．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vagrant能否打包cluster(virtualbox或esxi)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Django Misc</title>
        <link>https://canuxcheng.com/post/django_misc/</link>
        <pubDate>Wed, 04 Jan 2017 01:13:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_misc/</guid>
        <description>&lt;h1 id=&#34;django的国际化和本地化&#34;&gt;Django的国际化和本地化&lt;/h1&gt;
&lt;p&gt;settings.py里面和国际化和本地化相关的设置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;USE_I18N = True
USE_L10N = True
TIME_ZONE = &#39;UTC&#39;
USE_TZ = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;国际化i18n&#34;&gt;国际化(i18N)&lt;/h2&gt;
&lt;p&gt;由开发者完成,本地化的准备工作.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.i18nguy.com/unicode/language-identifiers.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.i18nguy.com/unicode/language-identifiers.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LANGUAGE_CODE = &#39;en-us&#39; # default

LANGUAGES = [
    (&#39;en-US&#39;, _(&#39;English&#39;)),
    (&#39;zh-CN&#39;, _(&#39;Chinese&#39;)),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;本地化l10n&#34;&gt;本地化(l10N)&lt;/h2&gt;
&lt;p&gt;由翻译者完成.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;django的安全&#34;&gt;Django的安全&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;django的性能优化&#34;&gt;Django的性能优化&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/zh-hans/3.2/topics/performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/zh-hans/3.2/topics/performance/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;django的地理框架&#34;&gt;Django的地理框架&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>TSDB</title>
        <link>https://canuxcheng.com/post/database/</link>
        <pubDate>Tue, 03 Jan 2017 14:46:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/database/</guid>
        <description>&lt;h1 id=&#34;rdbms&#34;&gt;RDBMS&lt;/h1&gt;
&lt;p&gt;关系数据库管理系统。&lt;/p&gt;
&lt;p&gt;SQLite&lt;/p&gt;
&lt;p&gt;Oracle&lt;/p&gt;
&lt;p&gt;MSSQL&lt;/p&gt;
&lt;p&gt;Mysql&lt;/p&gt;
&lt;p&gt;Postgre&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nosql&#34;&gt;NoSQL&lt;/h1&gt;
&lt;p&gt;NoSQL: Not only SQL.&lt;/p&gt;
&lt;p&gt;非关系型数据库。&lt;/p&gt;
&lt;p&gt;memcached(cache)&lt;/p&gt;
&lt;p&gt;redis(cache)&lt;/p&gt;
&lt;p&gt;mongodb&lt;/p&gt;
&lt;p&gt;hbase(hadoop)&lt;/p&gt;
&lt;p&gt;cassandra(hadoop)&lt;/p&gt;
&lt;p&gt;rethinkdb&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tsdb&#34;&gt;TSDB&lt;/h1&gt;
&lt;p&gt;Time series database.&lt;/p&gt;
&lt;p&gt;时序数据库&lt;/p&gt;
&lt;p&gt;influxdb&lt;/p&gt;
&lt;p&gt;rrdtool&lt;/p&gt;
&lt;p&gt;graphite&lt;/p&gt;
&lt;p&gt;opentsdb&lt;/p&gt;
&lt;p&gt;premetheus&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Awk</title>
        <link>https://canuxcheng.com/post/shell_awk/</link>
        <pubDate>Wed, 14 Dec 2016 00:55:37 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_awk/</guid>
        <description>&lt;h1 id=&#34;awk&#34;&gt;awk&lt;/h1&gt;
&lt;p&gt;awk 是一门编程语言&lt;/p&gt;
&lt;p&gt;awk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。&lt;/p&gt;
&lt;p&gt;nawk： new awk。&lt;/p&gt;
&lt;p&gt;mawk： awk的解释器&lt;/p&gt;
&lt;p&gt;gawk是gnu的awk，功能更全面。&lt;/p&gt;
&lt;p&gt;awk命令格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;awk [-v var=value [-F *] [–] &#39;/pattern/ {action}&#39;  file
awk [-v var=value [-F *] [-f scriptfile ...] [–] file
awk [-v var=value [-F *] [-] &#39;BEGIN {} /pattern/ {action} END {}&#39;  file
BEGIN { }  在读取输入之前就操作
END { }    在读物输入之后操作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk的指令需要用单引号包围；
模式需要用/pattern/包围；
过程需要用{command1；command2}包围，多个过程需要用；隔开。&lt;/p&gt;
&lt;p&gt;脚本中传递参数格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;awk [-f scriptfile]OR[&#39;/pattern/{action}&#39;] val1=value1 val2=value2 … file1   vala=valuea valb=valueb... file2 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果通过shell传参数，把value改成$n即可。
可以通过命令返回值作为参数value。
也可以使用环境变量作为value，也可以给awk的环境变量赋值。
可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。
只有在-v和在BEGIN中定义的变量能在BEGIN中使用。
在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。
在任何位置定义的变量在END中都可以使用。&lt;/p&gt;
&lt;p&gt;Options:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f: 指定运行脚本文件中的命令,可以指定多个脚本。
-F: 指定输入字段分隔符，默认是空格键和制表符。
-v  $val=value  定义变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk中的由空格或制表符分隔的单元作为一个字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$0	当前行的文本内容
$1	第一个字段的文本内容
$n	第n个字段的文本内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk中的常量和变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常量：字符串型和数字型，字符串常量必须用“”引号引用。
变量：变量名大小写敏感，字母或下划线开头，可以包含数字。
awk会自动将变量根据环境初始化为空串或0.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk中的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print命令：
print a,b   参数用，隔开，打印出来的就是用空格隔开的,eg：a b.
print a“string”b  参数中用双引号打印出来就是原样输出,eg:astringb.
Print     打印匹配到的行
print “”  打印一个空行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;printf命令：&lt;/p&gt;
&lt;p&gt;格式化输出，和c语言中的printf类似。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(format[,arguments])
format是用“”引起来的格式
arguments是一个可选的参数列表
%s:字符串
%d：十进制整数
%f：浮点格式，默认精度小数点后6位。
%%：打印%
|%mX|:对于格式X按照默认的右对齐，精确到m位，左边补空格
|%-mX|：对于格式X按照左对齐，精确到m位，右边补空格
“%*.*g”， m， n， $val ： 动态指定精度，总共m位，小数点后n位。
\t：跳格
\n：换行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;next命令：&lt;/p&gt;
&lt;p&gt;取得下一条记录&lt;/p&gt;
&lt;p&gt;delete命令：&lt;/p&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;exit命令：&lt;/p&gt;
&lt;p&gt;退出输入记录的处理，进入END。
exit n   设置awk的退出状态。&lt;/p&gt;
&lt;p&gt;awk中的内置的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FS  定义输入记录字段分隔符，默认是空格
OFS 输出记录字段分隔符，默认是空格
NF	当前输入记录的字段个数（列号）
RS  输入记录分隔符，默认是换行符
ORS 输出记录分隔符，默认是换行符
NR	读入的输入记录的个数(行号）
FILENAME 当前输入文件的名字
CONVFMT 控制类型转换，默认为%.6g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在BEGIN{}中可以给变量赋值；在{}中用$来引用这些变量；在END{}中可以打印这些变量。&lt;/p&gt;
&lt;p&gt;运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;算数操作符：
+ - * / % ^

赋值操作符：
++ –-
+= -= *= /= %= ^=

关系操作符：
&amp;lt; &amp;gt; &amp;lt;= &amp;gt;=
==(注意和赋值=的区别） !=
~（匹配） !~（不匹配）

布尔操作符：
&amp;amp;&amp;amp; 逻辑与，优先级高于||
|| 逻辑或
！ 逻辑非
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk内置的语句：&lt;/p&gt;
&lt;p&gt;和c语言相似&lt;/p&gt;
&lt;p&gt;条件语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (expression)
    action1
[else if (expression2) {
    action2
    action3
    ...
}]  多个动作需要用{}包围
[else if () {action1;action2;...}]  多个动作写在一行需要用；隔开。
[else if () action ; else action]  在同一行用；结束一个语句
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以用条件运算符代替条件语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expression ? Action1 : action2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (condition)
    action

while (condition) {
    action1
    action2
    …
}

while (condition) { action1 ; action2 ; … }

do
    action
while (condition)

do {
    action1
    action2
    …
} while (condition)

do { action1;action2;...} while (condition)

for (set_counter; test_counter; increment_counter)
    action
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break:&lt;/p&gt;
&lt;p&gt;退出循环&lt;/p&gt;
&lt;p&gt;continue：&lt;/p&gt;
&lt;p&gt;终止本次循环，进入下一次循环&lt;/p&gt;
&lt;p&gt;数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array[subscript] = value
awk中的数组直接给数组元素赋值，不用指定数组大小。通过下标访问。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关联数组：&lt;/p&gt;
&lt;p&gt;awk中的数组是关联数组，也就是可以用数值和字符作为下标来访问。&lt;/p&gt;
&lt;p&gt;in操作符用来测试variable是否是数组array的下标，如果是条件为真。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (variable in array)
    print variable: array[variable]
if (variable in array)
    print variable: array[variable]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除数组元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete array[subscript]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统变量的数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ARGV：
命令行参数数组，下标从0开始，不包括awk脚本本身和任何调用awk脚本指定的选项。
akw -f awk.sh …    #不包括-f和awk.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ENVIRON：&lt;/p&gt;
&lt;p&gt;环境变量数组，下标是环境变量的名字，元素是环境变量的值。&lt;/p&gt;
&lt;p&gt;awk内置的函数：&lt;/p&gt;
&lt;p&gt;函数分为算数函数和字符串函数。&lt;/p&gt;
&lt;p&gt;算数函数有9个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sin(x)：返回x的正弦
cos(x)：返回x的余弦
atan2(y,x)：返回y/x的反正切
exp(x)：返回e的x次幂
log(x)：返回以e为底的x的自然对数
sqrt(x)：返回x的平方根
int(x)：返回x的整数部分
rand()：返回伪随机数r，0=&amp;lt; r &amp;lt;1
srand(x)：建立rand（）的新的种子数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsub(r,s,t) 在字符串t中用s替换和正则表达式r匹配的所有字符串，返回替换的个数。
gsub(r,s) 相当于t=$0
sub(r,s,t)用s替换正则表达式在t中的首次匹配。成功返回1，失败返回0.
sub(r,s)相当于t=$0

substr(s,p)返回s中从位置p开始的子串
substr(s,p,n)返回s中从位置p开始最大长度为n的子串。

index(s,t)返回子串t在s中的位置，如果没有指定s或没有匹配项返回0.也就是返回t中的首字母在s中是第几个字符，如果首字母重复出现返回第一个的位置。

length(s)   返回字符串s长度，没有指定s返回$0的长度，\n \t \r 空格都算一个字节。

match(s,r)如果正则表达式r在s中出现，返回出现的起始位置，没有匹配返回0.

split(string, array, separator)
将字符串string分解到数组array中，数组下标从1到n，string根据指定的分隔符来分解，如果没有指定分隔符，默认为FS。返回数组中元素个数。

sprintf(“format”, expr)和printf一样。

tolower(s)将s中的所有大写字母转换成小写并返回新的字符串
toupper(s)将s中的左右小写字母转换成大写并返回新的字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其它函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getline命令（其实是个函数）：
获取下一条记录给$0,成功返回1，到达EOF返回0，失败返回-1.
getline可以从文件中读取：getline &amp;lt; “filename”,每次读一行。
getline从标准输入读取：getline &amp;lt; “-”,每次从stdin读取一行。
将输入赋给一个变量：getline var_name.
从管道读取：”command”|getline；“command”|getline var_name;把一个命令结果输出给getline.

close()：关闭打开的文件和管道

“command” | ...
close(“command”)关闭输入管道

...| “command“ &amp;gt; filename
close(“command &amp;gt; filename”)关闭输出管道

system()：执行一个命令。
system(“command options”),返回命令的退出状态。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以定义自己的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function yourfunctionname(parameter-list) {
    statements
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用系统定义的变量、语句、函数来定义自己的函数。
使用自己定义的函数可以将函数写成一个单独脚本，使用-f选项来指定多个脚本进行调用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;常用命令&#34;&gt;常用命令&lt;/h1&gt;
&lt;p&gt;删除字符串前后空格:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;string&amp;quot; |　awk &amp;quot;$1=$1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Wordpress</title>
        <link>https://canuxcheng.com/post/wordpress/</link>
        <pubDate>Fri, 18 Nov 2016 00:06:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/wordpress/</guid>
        <description>&lt;h1 id=&#34;wordpress&#34;&gt;WordPress&lt;/h1&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;p&gt;安装依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt install apache2
$sudo apt install mysql-server
$sudo apt install php5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载wordpress：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd /var/www/html
$git clone https://github.com/WordPress/WordPress.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;p&gt;添加mysql数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mysql -u root -p
mysql&amp;gt; create user &#39;wordpress&#39;@&#39;localhost&#39; identified by &#39;******&#39;;
mysql&amp;gt; create database &#39;wordpress&#39;;
mysql&amp;gt; GRANT ALL PRIVILEGES ON wordpress.* TO &amp;quot;wordpress&amp;quot;@&amp;quot;localhost&amp;quot;;
mysql&amp;gt; FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wp-config.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆并安装站点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理界面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost/wp-admin
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;语言&#34;&gt;语言&lt;/h1&gt;
&lt;p&gt;下载相应的语言版本,中文下载中文版的wordpress.&lt;/p&gt;
&lt;p&gt;然后将wordpress/wp-content/languages拷贝到英文版的wordpress/wp-content下&lt;/p&gt;
&lt;p&gt;语言包路径:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wordpress/wp-content/languages
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;主题&#34;&gt;主题&lt;/h1&gt;
&lt;p&gt;修改wp-config.php安装主题不用输入ftp信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(&amp;quot;FS_METHOD&amp;quot;, &amp;quot;direct&amp;quot;);
define(&amp;quot;FS_CHMOD_DIR&amp;quot;, 0777);
define(&amp;quot;FS_CHMOD_FILE&amp;quot;, 0777);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主题安装在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wordpress/wp-content/themes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主题数据导入到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wordpress/wp-content/uploads
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;插件&#34;&gt;插件&lt;/h1&gt;
&lt;p&gt;插件安装在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wordpress/wp-content/plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;wordpress-reset&#34;&gt;WordPress Reset&lt;/h2&gt;
&lt;p&gt;一款可以重置所有数据库数据的插件。&lt;/p&gt;
&lt;h2 id=&#34;widget-settings-importexport&#34;&gt;widget-settings-importexport&lt;/h2&gt;
&lt;h2 id=&#34;wordpress-importer&#34;&gt;wordpress-importer&lt;/h2&gt;
&lt;h2 id=&#34;wordpress-move&#34;&gt;wordpress-move&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;设置&#34;&gt;设置&lt;/h1&gt;
&lt;p&gt;默认的固定连接:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/index.php/%year%/%monthnum%/%day%/%postname%/
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;主题开发&#34;&gt;主题开发&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;插件开发&#34;&gt;插件开发&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Html Form</title>
        <link>https://canuxcheng.com/post/html_form/</link>
        <pubDate>Mon, 31 Oct 2016 04:00:49 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/html_form/</guid>
        <description>&lt;h1 id=&#34;html表单&#34;&gt;html表单&lt;/h1&gt;
&lt;p&gt;html表单用于搜集不同类型的用户输入。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;form&#34;&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;form元素定义html表单。支持全局属性和事件属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;action_page.py&amp;quot;&amp;gt;
&amp;lt;fieldset&amp;gt;
&amp;lt;legend&amp;gt;Form information:&amp;lt;/legend&amp;gt;
First name:&amp;lt;br&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;firstname&amp;quot;&amp;gt;
&amp;lt;br&amp;gt;
Last name:&amp;lt;br&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;lastname&amp;quot;&amp;gt;
&amp;lt;/fieldset&amp;gt;
&amp;lt;/form&amp;gt;

# accept-charset属性规定服务器可处理的表单数据字符集。

# action属性规定当提交表单时向何处发送表单数据。
&amp;lt;form action=&amp;quot;action_page.py&amp;quot;&amp;gt;

# autocomplete属性规定是否启用表单的自动完成功能
on/off

# enctype属性规定在发送表单数据之前如何编码
application/x-www-form-urlencoded, 默认值，表示在发送前编码所有值．
multipart/form-data, 不编码，在使用包含文件上传控件的表单必须使用．
text/plain, 空格转换为&amp;quot;+&amp;quot;加号，不对特殊字符编码．

# method属性规定用于发送form-data的http方法
get/post

# name属性规定表单名称
# novalidate属性规定提交表单时不验证

# target属性规定在何处打开URL。
_blank/_self/_parent/_top
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;input&#34;&gt;&lt;strong&gt;input&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;input元素是最重要的表单元素。支持全局属性和事件属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# type属性规定输入元素类型
button
checkbox
file
hidden
image
password
radio
reset
submit
text

# name属性定义input元素名称
# value属性定义input元素默认值
readonly
disabled
size
maxlength
alt
accept
checked
src

autocomplete
autofocus
form
formaction
formenctype
formmethod
formnovalidate
formtarget
height
width
list
max
min
multiple
pattern
placeholder
required
step
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;fieldset&#34;&gt;&lt;strong&gt;fieldset&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;fieldset元素组合表单中的相关数据，支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# disable属性规定应该禁用fieldset
# form属性规定fieldset所属的一个或多个表单。
# name属性规定fieldset名称。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;legend&#34;&gt;&lt;strong&gt;legend&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;legend元素为fieldset元素定义标题，支持全局属性和事件属性,支持样式。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;select&#34;&gt;&lt;strong&gt;select&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义下拉列表。支持全局属性和事件属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;action_page.py&amp;quot;&amp;gt;
&amp;lt;select name=&amp;quot;cars&amp;quot;&amp;gt;
&amp;lt;option value=&amp;quot;volvo&amp;quot;&amp;gt;volvo&amp;lt;/option&amp;gt;
&amp;lt;option value=&amp;quot;audi&amp;quot;&amp;gt;audi&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&amp;lt;/form&amp;gt;

# autofocus属性规定在页面加载后文本区域自动获得焦点
# disable
# form
# multiple
# name
# required
# size
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;optgroup&#34;&gt;&lt;strong&gt;optgroup&lt;/strong&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;option&#34;&gt;&lt;strong&gt;option&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义选项。支持全局属性和事件属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# disabled
# label
# selected
# value
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;label&#34;&gt;&lt;strong&gt;label&lt;/strong&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;button&#34;&gt;&lt;strong&gt;button&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义可点击的按钮，支持全局属性和事件属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;alert(&amp;quot;hello world&amp;quot;)&amp;quot;&amp;gt;Click Me&amp;lt;/button&amp;gt;

# name属性规定按钮名称
# type属性规定按钮类型
# value属性规定按钮初始值
# autofocus
# disabled
# form
# formaction
# formenctype
# formmethod
# formnovalidate
# formtarget
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;textarea&#34;&gt;&lt;strong&gt;textarea&lt;/strong&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;datalist&#34;&gt;&lt;strong&gt;datalist&lt;/strong&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;keygen&#34;&gt;&lt;strong&gt;keygen&lt;/strong&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;output&#34;&gt;&lt;strong&gt;output&lt;/strong&gt;&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Bootstrap</title>
        <link>https://canuxcheng.com/post/js_bootstrap/</link>
        <pubDate>Thu, 27 Oct 2016 22:19:20 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/js_bootstrap/</guid>
        <description>&lt;h1 id=&#34;bootstrap&#34;&gt;Bootstrap&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/twbs/bootstrap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/twbs/bootstrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bootcss.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bootcss.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install bootstrap@next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML,CSS,JavaScript的支持响应式和移动设备的WEB框架.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>jQuery</title>
        <link>https://canuxcheng.com/post/js_jquery/</link>
        <pubDate>Thu, 27 Oct 2016 22:19:20 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/js_jquery/</guid>
        <description>&lt;h1 id=&#34;jquery&#34;&gt;jQuery&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jquery/jquery&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jquery/jquery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jquery123.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jquery123.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;jquery是一个js库，简化了js编程。&lt;/p&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install jqury
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jquery功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML 元素选取&lt;/li&gt;
&lt;li&gt;HTML 元素操作&lt;/li&gt;
&lt;li&gt;HTML 事件函数&lt;/li&gt;
&lt;li&gt;HTML DOM 遍历和修改&lt;/li&gt;
&lt;li&gt;CSS 操作&lt;/li&gt;
&lt;li&gt;JavaScript 特效和动画&lt;/li&gt;
&lt;li&gt;AJAX&lt;/li&gt;
&lt;li&gt;Utilities&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;syntax&#34;&gt;syntax&lt;/h1&gt;
&lt;p&gt;对元素操作语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(selector).action()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档就绪函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    ......
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;head中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;gt;
$(document).ready(function(){
    $(&amp;quot;button&amp;quot;).click(function(){
        $(&amp;quot;p&amp;quot;).hide();
    })
})
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;独立js文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/path/to/my.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;选择器&#34;&gt;选择器&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://api.jquery.com/category/selectors/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://api.jquery.com/category/selectors/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(this).hide()   this表示当前html元素
$(&amp;quot;p.test&amp;quot;)    class=&amp;quot;test&amp;quot;的&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;元素
$(&amp;quot;p#test&amp;quot;)    id=&amp;quot;test&amp;quot;的&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;元素
$(&amp;quot;div#test .demo&amp;quot;)  id=&amp;quot;test&amp;quot;的&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;中class=demo的元素
$(&amp;quot;ul li:first&amp;quot;)  每个&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;的第一个&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;element选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;p&amp;quot;).hide()   元素&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id选择器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;#test&amp;quot;).hide()  id=&amp;quot;test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class选择器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;.test&amp;quot;).hide()  class=&amp;quot;test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attribute选择器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;quot;[href]&amp;quot;)   所有带href属性的元素
$(&amp;quot;[href=&#39;value&#39;]&amp;quot;)  带有href属性且值等于value的元素
$(&amp;quot;[href!=&#39;value&#39;]&amp;quot;)  带有href元素且值不等于value的元素
$(&amp;quot;[href$=&#39;.jpg&#39;]&amp;quot;) 带有href属性且值以.jpg结尾的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子元素选择器/child:&lt;/p&gt;
&lt;p&gt;后代选择器/descendant:&lt;/p&gt;
&lt;h1 id=&#34;event事件&#34;&gt;Event/事件&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://api.jquery.com/category/events/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://api.jquery.com/category/events/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(selector).click(function) 单击事件
$(selector).dblclick(function) 双击事件
$(selector).focus(function) 焦点事件
$(selector).mouseover(function) 鼠标悬停事件
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;effects效果&#34;&gt;Effects/效果&lt;/h1&gt;
&lt;h2 id=&#34;basic&#34;&gt;basic&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;.hide()
.show()
.toggle()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;custom&#34;&gt;custom&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;.animate()
.stop()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fading&#34;&gt;fading&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;.fadeIn()
.fadeOut()
.fadeTo()
.fadeToggle()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sliding&#34;&gt;sliding&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;.slideDown()
.slideToggle()
.slideUp()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;core&#34;&gt;core&lt;/h1&gt;
&lt;p&gt;核心功能&lt;/p&gt;
&lt;h2 id=&#34;jquery-1&#34;&gt;jQuery()&lt;/h2&gt;
&lt;h2 id=&#34;jquerynoconflict&#34;&gt;jQuery.noConflict()&lt;/h2&gt;
&lt;p&gt;使用其它代替$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;gt;
$.noConflict(); // 兼容其它库也是用$
my(document).ready(function(){
    my(&amp;quot;button&amp;quot;).click(function(){
        my(&amp;quot;p&amp;quot;).hide();
    })
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jqueryready&#34;&gt;jQuery.ready&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;文档操作&#34;&gt;文档操作&lt;/h1&gt;
&lt;h1 id=&#34;属性操作&#34;&gt;属性操作&lt;/h1&gt;
&lt;h1 id=&#34;css操作&#34;&gt;CSS操作&lt;/h1&gt;
&lt;p&gt;jquey css选择器改变元素的css属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.css()
// 修改&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;元素的背景色
$(&amp;quot;p&amp;quot;).css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;); 

.addClass()
.hasClass()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;attributes&#34;&gt;Attributes&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;.attr()

.addClass()
.hasClass()
.html()
.val()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data&#34;&gt;Data&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;.data()

.clearQueue()
.dequeue()
.queue()
.removeData()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ajax&#34;&gt;Ajax&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Test</title>
        <link>https://canuxcheng.com/post/django_test/</link>
        <pubDate>Tue, 04 Oct 2016 04:51:30 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_test/</guid>
        <description>&lt;h1 id=&#34;testspy&#34;&gt;tests.py&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单个测试文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim app/tests.py
from django.test import TestCase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个测试文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p app/tests
vi test_case1.py
vi test_case2.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;配置和运行&#34;&gt;配置和运行&lt;/h1&gt;
&lt;p&gt;默认情况下运行 manage.py test 会创建测试数据库运行testcase，完成后自动销毁测试数据库.&lt;/p&gt;
&lt;p&gt;测试相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim project/settings.py

DATABASES = {
    &#39;default&#39;: {
        &#39;NAME&#39;: &#39;mydb&#39;,
        &#39;TEST&#39;: {
            // 默认测试数据库是&#39;NAME&#39;前加&#39;test_&#39; (eg: &#39;test_mydb&#39;)
            // 可以通过TEST.NAME指定测试数据库
            &#39;NAME&#39;: &#39;mytestdb&#39;
        }
    }
}

# 指定runner
## 默认 django.test.runner.DiscoverRunner
TEST_RUNNER = &#39;site_main.base_tests.TestRunner

# 指定fixture文件路径
FIXTURE_DIRS = (os.path.join(BASE_DIR, &#39;app&#39;, &#39;fixtures&#39;), )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行测试程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python3 manage.py test // 查找test 开头的文件运行里面的 unittest.TestCase的子类.
$ python3 manage.py test &amp;lt;package&amp;gt; // 运行指️定应用内的测试
$ python3 manage.py test &amp;lt;module&amp;gt; // 运行指定模块内的测试
$ python3 manage.py test &amp;lt;module&amp;gt;.tests.MyTestCase // 运行一个指定的testcase
$ python3 manage.py test &amp;lt;module&amp;gt;.tests.MyTestCase.test_method // 运行一个指定的test method

--keepdb // 保留测试数据库
--parallel // 并行运行测试。
-v/--verbosity 0/1/2/3  测试输出信息级别，默认为1， 0表示不输出。
-d/--debug-sql 输出测试执行的sql语句.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;client&#34;&gt;Client&lt;/h1&gt;
&lt;p&gt;测试客户端是一个 Python 类，它充当一个虚拟的 Web 浏览器，
允许你测试视图并以编程方式与 Django 驱动的应用程序交互。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.test import Client
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;测试class&#34;&gt;测试Class&lt;/h1&gt;
&lt;h2 id=&#34;simpletestcase&#34;&gt;SimpleTestCase&lt;/h2&gt;
&lt;p&gt;SimpleTestCase继承自unittest.TestCase.&lt;/p&gt;
&lt;h2 id=&#34;transactiontestcase&#34;&gt;TransactionTestCase&lt;/h2&gt;
&lt;p&gt;TransactionTestCase继承自SimpleTestCase.&lt;/p&gt;
&lt;h2 id=&#34;liveservertestcase&#34;&gt;LiveServerTestCase&lt;/h2&gt;
&lt;p&gt;LiveServerTestCase继承自TransactionTestCase.&lt;/p&gt;
&lt;p&gt;LiveServerTestCase 和 TransactionTestCase` 的功能基本相同，
但多了一个功能：它在设置时在后台启动一个实时的 Django 服务器，并在关闭时将其关闭。
这就允许使用 Django 虚拟客户端 以外的自动化测试客户端，
例如，Selenium 客户端，在浏览器内执行一系列功能测试，并模拟真实用户的操作。&lt;/p&gt;
&lt;h2 id=&#34;testcase&#34;&gt;TestCase&lt;/h2&gt;
&lt;p&gt;TestCase继承自TransactionTestCase.&lt;/p&gt;
&lt;h2 id=&#34;fixtures&#34;&gt;fixtures&lt;/h2&gt;
&lt;p&gt;fixtures是类属性, 可以通过模拟在数据库中插入数据进行测试.&lt;/p&gt;
&lt;p&gt;在setUp的时候会插入fixtures指定的json文件中的数据。&lt;/p&gt;
&lt;p&gt;在tearDown的时候会销毁数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 导出数据为json格式，用于单元测试
$ python3 manage.py dumpdata &amp;gt; test_data.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;databases&#34;&gt;databases&lt;/h2&gt;
&lt;p&gt;databases是类属性&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Form</title>
        <link>https://canuxcheng.com/post/django_form/</link>
        <pubDate>Tue, 04 Oct 2016 04:30:02 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_form/</guid>
        <description>&lt;h1 id=&#34;formspy&#34;&gt;forms.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django import forms
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;表单&#34;&gt;表单&lt;/h1&gt;
&lt;p&gt;用户在浏览器中输入数据提交，对数据验证以及输入框的生成等。&lt;/p&gt;
&lt;p&gt;django的表单系统的核心类是django.forms.Form类,所有的构建的表单都是这个类的子类。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Admin</title>
        <link>https://canuxcheng.com/post/django_admin/</link>
        <pubDate>Tue, 04 Oct 2016 04:29:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_admin/</guid>
        <description>&lt;h1 id=&#34;adminpy&#34;&gt;admin.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib import admin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个管理员用户：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理员登陆界面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8000/admin/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在admin.py中注册模型，然后就可以在登陆界面管理模型了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .models import Question
admin.site.register(Question)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义管理表单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fileds = [&#39;pub_date&#39;, &#39;question_date&#39;]
admin.site.register(Question, QuestionAdmin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把表单分割成字段集：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {&#39;fields&#39;: [&#39;question_text&#39;]}),
        (&#39;Date information&#39;, {&#39;fields&#39;: [&#39;pub_date&#39;]}),
    ]
admin.site.register(Question, QuestionAdmin)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;后台&#34;&gt;后台&lt;/h1&gt;
&lt;p&gt;django的后台管理程序。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>URL</title>
        <link>https://canuxcheng.com/post/django_url/</link>
        <pubDate>Tue, 04 Oct 2016 04:20:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_url/</guid>
        <description>&lt;h1 id=&#34;urlspy&#34;&gt;urls.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django.urls import path, include
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;django请求站点的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ROOT_URLCONF，在settings.py中设置。&lt;/li&gt;
&lt;li&gt;寻找urlpatterns，它是django.conf.urls.url()实例的一个python列表。&lt;/li&gt;
&lt;li&gt;dnango依次匹配每个URL模式，在第一个匹配停下。&lt;/li&gt;
&lt;li&gt;一旦一个正则表达式匹配，django就调用对应的视图，视图获得HttpRequest实例,如果是没有命名的组返回内容作为位置参数，如果是命名的组返回内容作为关键字参数。&lt;/li&gt;
&lt;li&gt;如果没有匹配到或者过程跑出异常，django调用合适的错误处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;项目的url&#34;&gt;项目的URL&lt;/h1&gt;
&lt;p&gt;项目的URL主要用来包含应用的URL以及全局的URL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # 默认的项目的admin的url
    path(&#39;admin/&#39;, admin.site.urls),
    
    # 在项目URL添加链接到应用URL：
    # 在下面添加你的所有应用的url,
    path(&#39;polls/&#39;, include(&#39;polls.urls&#39;)),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;应用的url&#34;&gt;应用的URL&lt;/h1&gt;
&lt;p&gt;将应用的视图映射到URL,需要在应用目录新建urls.py文件,然后在项目的url中包含应用的url。&lt;/p&gt;
&lt;p&gt;urlpatterns是url()实例类型的python列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.urls import path
from . import views

app_name = &#39;polls&#39;

urlpatterns = [
    # 普通视图
    path(&#39;&#39;, views.index, name=&#39;index&#39;),
    # 类视图
    path(&#39;&#39;, views.IndexView.as_view(), name=&#39;index&#39;),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;没有命名的组&#34;&gt;没有命名的组&lt;/h1&gt;
&lt;p&gt;视图函数只有request参数，匹配的正则表达式作为位置参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;url(r&#39;^pattern1/pattern2/$&#39;, views.index, name=&#39;index&#39;),

def index(request):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;命名组&#34;&gt;命名组&lt;/h1&gt;
&lt;p&gt;视图函数除了request参数还有关键字参数，匹配的命名表达式组作为关键字参数,覆盖默认的关键字参数。&lt;/p&gt;
&lt;p&gt;使用命名的正则表达式组： (?P&lt;!-- raw HTML omitted --&gt;pattern)&lt;/p&gt;
&lt;p&gt;name就是关键字参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;url(r&#39;^pattern1/(?P&amp;lt;name&amp;gt;pattern)/pattern2/$), views.index, name=&#39;index),

def index(request, name):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;错误处理&#34;&gt;错误处理&lt;/h1&gt;
&lt;p&gt;django会调用一个错误处理视图处理异常。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;handler404 页面没找到&lt;/li&gt;
&lt;li&gt;handler500 服务器错误&lt;/li&gt;
&lt;li&gt;handler403 权限被拒绝&lt;/li&gt;
&lt;li&gt;handler400 无效的请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你也可以在项目的urls.py中重新定义这些默认视图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;handler404 = &#39;mysite.views.your_custom_page_not_found_view&#39;
handler500 = &#39;mysite.views.your_custom_error_view&#39;
handler403 = &#39;mysite.views.your_custom_permission_denied_view&#39;
handler400 = &#39;mysite.views.your_custom_bad_request_view&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>View</title>
        <link>https://canuxcheng.com/post/django_view/</link>
        <pubDate>Tue, 04 Oct 2016 04:20:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_view/</guid>
        <description>&lt;h1 id=&#34;viewspy&#34;&gt;views.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django.shortcuts import render
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义自己的视图函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.http import HttpResponse
from django.template import RequestContext, loader

# 导入模板中的类
from .models import Question

def index(request):
    ...
    t = loader.get_template(&#39;application/index.html&#39;)
    c = RequestContext(request, {&#39;foo&#39;: &#39;bar&#39;})
    return HttpResponse(t.render(c), content_type=&amp;quot;text/html&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当请求一个页面时django会建立一个包含请求元数据的HttpRequest对象，当django加载对应视图时，这个对象作为视图第一个参数。&lt;/p&gt;
&lt;p&gt;每个视图会返回一个HttpResponse对象。&lt;/p&gt;
&lt;p&gt;每个视图函数都用HttpRequest对象（通常用request）作为第一个参数。&lt;/p&gt;
&lt;p&gt;每个视图函数都返回一个HttpResponse对象，包含生成的响应。&lt;/p&gt;
&lt;p&gt;HttpRquest和HttpResponse在django.http包中，参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/documents/django_182/ref/request-response.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/documents/django_182/ref/request-response.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HttpRequest对象属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.scheme # http/https
request.body
request.path
request.path_info
request.method # GET/POST
request.encoding
request.user
request.session
request.urlconf
request.GET
request.POST
request.REQUEST
request.COOKIES
request.FILES
request.META
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HttpRequest对象方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;request.get_host()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HttpResponse对象属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;response.content
response.charset
response.status_code
response.reason_phrase
response.streaming
response.closed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HttpResponse对象的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;response.getvalue()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回错误：&lt;/p&gt;
&lt;p&gt;HttpResponse的子类提供了对不同类型HTTP响应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.http import HttpResponseBadRequest, HttpResponseNotFound, HttpResponseForbidden, HttpResponseServerError,
return HttpResponseNotFound(&amp;quot;&amp;lt;h1&amp;gt;Page not found&amp;lt;/h1&amp;gt;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;http404异常：&lt;/p&gt;
&lt;p&gt;在应用的模板目录顶层定义一个404.html模板文件，当跑出Http404异常就会调用这个模板文件展示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.http import Http404

def index(request):
    try:
        ...
    except Application.DoesNotExist:
        raise Http404(&amp;quot;Application does not exist&amp;quot;)
    return HttpResponse(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义错误视图：&lt;/p&gt;
&lt;p&gt;参考urls中的内容。&lt;/p&gt;
&lt;h1 id=&#34;快捷函数&#34;&gt;快捷函数&lt;/h1&gt;
&lt;p&gt;django.shortcuts中定义了多个快捷函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.shortcuts import render
render(request, template_name, context=None, context_instance=&amp;lt;object object&amp;gt;, content_type=None, status=None, current_app=&amp;lt;object object&amp;gt;, dirs=&amp;lt;object object&amp;gt;, dictionary=&amp;lt;object object&amp;gt;, using=None)
# render第一个参数是request，根据给定模板和上下文字典，返回一个渲染后的HttpResponse对象。
return render(request, &#39;application/index.html&#39;, {&#39;foo&#39;: &#39;bar&#39;}, content_type=&amp;quot;text/html&amp;quot;)

from django.shortcuts import get_object_or_404
get_object_or_404(klass, *args, **kwargs)
# 在给定的模型管理器调用get()，如果不存在引发Http404异常。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;基于类的视图&#34;&gt;基于类的视图&lt;/h1&gt;
&lt;p&gt;基于类的视图的基类在django.views.generic中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.views.generic import View
def MyView(View):
    def get(self, request):
        return HttpResponse(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;templateresponse和simpletemplateresponse&#34;&gt;TemplateResponse和SimpleTemplateResponse&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django.template.response import TemplateResponse, SimpleTemplateResponse
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;视图装饰器&#34;&gt;视图装饰器&lt;/h1&gt;
&lt;p&gt;django.views.decorators包中定义了视图的装饰器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.views.decorators import *
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;内建的视图&#34;&gt;内建的视图&lt;/h1&gt;
&lt;p&gt;django.views.static.serve定义了开发环境的文件服务器视图，仅用于开发。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.views.static import serve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;django.views.defaults定义了内建的错误处理的视图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.views.defaults import *
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Model</title>
        <link>https://canuxcheng.com/post/django_model/</link>
        <pubDate>Tue, 04 Oct 2016 04:20:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_model/</guid>
        <description>&lt;h1 id=&#34;modelspy&#34;&gt;models.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;django模型是和数据库关联的，代码放在models.py，数据库信息在settings.py中统一配置即可。&lt;/p&gt;
&lt;p&gt;每个模型对应数据库唯一的一张表，是django.db.models.Model的子类。&lt;/p&gt;
&lt;p&gt;每个模型实例代表数据库中的一条特定记录.&lt;/p&gt;
&lt;p&gt;模型的每个属性都表示为数据库中的一个字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在项目的settings.py中激活应用，并设置数据库相关参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让django包含你的应用：&lt;/p&gt;
&lt;p&gt;告诉django你对模型做了更改，并且将这些更改存储为迁移文件polls/migrations/0001_initial.py:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $python manage.py makemigrations polls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以查看迁移文件执行了哪些sql语句,并不真的在数据库执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $python manage.py sqlmigrate polls 0001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以检查项目中的模型是否存在问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $python manage.py check
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据库中创建模型,查找还没有被应用的迁移文件然后和数据库同步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模型的字段类型和字段选项&#34;&gt;模型的字段类型和字段选项&lt;/h1&gt;
&lt;p&gt;模型的每个属性都表示为数据库的一个字段,是Field子类的某个实例。&lt;/p&gt;
&lt;p&gt;模型的字段还有一些选项。&lt;/p&gt;
&lt;p&gt;字段命名规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能是python的保留关键字。&lt;/li&gt;
&lt;li&gt;字段名中连续的下划线不能超过一个。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;访问其它应用的模型,导入即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from &amp;lt;other-aplication&amp;gt;.models import &amp;lt;module-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模型字段类型和选项参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;模型字段类型&#34;&gt;模型字段类型&lt;/h2&gt;
&lt;p&gt;字段的类型都是Field类的子类：&lt;/p&gt;
&lt;p&gt;每个字段都接受一个可选的位置参数(一般是第一个），叫字段的自述名,如果不指定就默认是字段名字（下划线换成空格）。&lt;/p&gt;
&lt;p&gt;自增字段:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AutoField
# 默认django会每个模型添加一个自增主键字段,如果你显示设置一个自增主键字段就不会默认再添加,每个模型只能有一个主键字段。
# id = models.AutoField(primary_key=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;普通字段:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BigIntegerField
BinaryField
BooleanField
CharField
CommaSeparatedIntegerField
DateField
DateTimeField
DecimalField
DurationField
EmailField
FileField
FilePathField
FloatField
GenericIPAddressField
IPAddressField
ImageField
IntegerField
NullBooleanField
PositiveIntegerField
PositiveSmallIntegerField
SlugField
SmallIntegerField
TextField
TimeField
URLField
UUIDField
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关系字段:&lt;/p&gt;
&lt;p&gt;django定义了一系列字段类型描述数据库之间的关联:&lt;/p&gt;
&lt;p&gt;这三个字段要求第一个参数是模型类，用verbose_name选项才能指定自述名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ForeignKey 定义多对一关系
OneToOneField 定义一对一关系
ManyToManyField 定义多对多关系
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;模型字段选项&#34;&gt;模型字段选项&lt;/h2&gt;
&lt;p&gt;django定义的字段的通用的选项：&lt;/p&gt;
&lt;p&gt;每个字段都有特定的选项，也有通用的选项,特定参数参考文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Field.null    django将空值以NULL存储到数据库中,默认是false
Field.blank    该字段允许为空白,默认false
Field.primary_key    true表示该字段为模型的主键字段,默认是false
Field.unique    true表示该字段在表中必须有唯一值,默认是false
Field.unique_for_date
Field.unique_for_month
Field.unique_for_year
Field.choices    可迭代结构,给字段提供选项
Field.default    该字段默认值
Field.help_text    额外的help文本
Field.editable    false表示该字段不会出现在admin,默认是true
Field.error_messages    重写默认抛出的错误信息
Field.verbose_name    该字段可读性更高的名称
Field.validators    该字段要运行的一个Validator的列表
Field.db_column
Field.db_index
Field.db_tablespace
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模型元选项&#34;&gt;模型元选项&lt;/h1&gt;
&lt;p&gt;使用内部类Meta定义模型的元数据。&lt;/p&gt;
&lt;p&gt;模型元数据是任何不是字段的数据，比如排序选项等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models
class Ox(models.Model):
    horn_length = models.IntegerField()
    ...
    class Meta:
        ordering = [&amp;quot;horn_length&amp;quot;]
        verbose_name_plural = &amp;quot;oxen&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模型的元选项：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/models/options.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/models/options.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在元类Meta中使用的选项.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Options.abstract = True 表示模型是抽象基类, 数据库不会创建这个表
Options.db_table 该模型所用的数据表的名称
Options.db_tablespace
Options.default_related_name
Options.get_latest_by
Options.managed
Options.order_with_respect_to
Options.ordering = [&#39;字段名&#39;, &#39;-字段名&#39;] 对象的默认顺序, -表示倒序
Options.permissions
Options.default_permissions
Options.proxy
Options.select_on_save
Options.unique_together
Options.index_together
Options.verbose_name 对象的一个易于理解的名字
Options.verbose_name_plural 该对象复数形式的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模型的属性&#34;&gt;模型的属性&lt;/h1&gt;
&lt;p&gt;模型的属性是表级别的,是对表的操作.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/models/class.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/models/class.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个模型类都要添加一个Manager实例,如果不显示添加，django就会默认添加objects属性，包含Manager实例。&lt;/p&gt;
&lt;p&gt;Manager或object属性是模型进行数据库查询操作的接口,也叫管理器,用于从数据库获取实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models
class Foo(models.Model):
    # 显示添加
    bar = models.Manager()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;执行查询&#34;&gt;执行查询&lt;/h1&gt;
&lt;p&gt;一旦建立数据模型,django会自动生成一套抽象的API,用于创建,检索,更新和删除对象.&lt;/p&gt;
&lt;h2 id=&#34;创建对象&#34;&gt;创建对象&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;q = Question(question_text=&#39;content&#39;, pub_date=&#39;date&#39;)
q.save()

q = Question(question_text=&#39;content&#39;)
q.pub_date=&#39;date&#39;
q.save()

Question.objects.create(question_text=&amp;quot;content&amp;quot;, pub_date=&#39;date&#39;)

# 防止重复,不存在就创建，返回(object, True),存在返回(object, False)
Question.objects.get_or_create(question_text=&#39;content&#39;, pub_date=&#39;date&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取对象&#34;&gt;获取对象&lt;/h2&gt;
&lt;p&gt;通过模型中的管理器构造一个查询集来从数据库获取对象.&lt;/p&gt;
&lt;p&gt;查询集求值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;迭代&lt;/li&gt;
&lt;li&gt;切片&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;li&gt;repr()&lt;/li&gt;
&lt;li&gt;len()&lt;/li&gt;
&lt;li&gt;list()&lt;/li&gt;
&lt;li&gt;bool()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查询集参考QuerySet类的方法：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/models/querysets.html#queryset-api&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/models/querysets.html#queryset-api&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 获取表中所有对象
Question.objects.all()
# 切片获取部分
Question.objects.all()[:10]
# 获取单个
Question.objects.get(question_text=&#39;content&#39;)
# 过滤
Question.objects.filter(**kwargs)
Question.objects.exclude(**kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询集的链式过滤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Question.objects.all().exists()
Question.objects.all().order_by(&#39;name&#39;)
Question.objects.filter(**kwargs).filter(**kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模型的方法&#34;&gt;模型的方法&lt;/h1&gt;
&lt;p&gt;模型的方法是对模型的实例的操作.&lt;/p&gt;
&lt;p&gt;模型中可以自定义方法，可以使用预定义的自动生成的方法，也可以覆盖预定义的方法。&lt;/p&gt;
&lt;p&gt;预定义方法参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/models/instances.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/models/instances.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Model.__unicode__()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python2需要使用__unicode__方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __unicode__(self):
    return u&#39;%s&#39; % self.title

Model.__str__()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python3只需要__str__方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __str__(self):
    return &#39;%s&#39; % self.title
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码兼容python2和python3.&lt;/p&gt;
&lt;p&gt;python_2_unicode_compatible是一个用于类的装饰器，在类中定义__str__并返回文本.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import unicode_literals
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible
class Question(models.Model):
    title = models.CharField(&#39;title&#39;, max_length=256)
    ...

    def __str__(self):
        return self.title

Model.__eq__()

Model.__hash__()

Model.get_absolute_url()

Model.get_FOO_display()

Model.get_next_by_FOO(**kwargs)

Model.get_previous_by_FOO(**kwargs)

Model.DoesNotExist
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Template</title>
        <link>https://canuxcheng.com/post/django_template/</link>
        <pubDate>Tue, 04 Oct 2016 04:12:49 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_template/</guid>
        <description>&lt;h1 id=&#34;模板设置&#34;&gt;模板设置&lt;/h1&gt;
&lt;p&gt;模板引擎在settings.py设置, django有两套模板引擎：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATES = [
    # DjangoTemplates
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        # 定义项目的通用模板, mysite/templates
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        # True 表示在所有安装应用的application/templates中查找。
        &#39;APP_DIRS&#39;: True,
        # 模板的选项：
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ]
        },
    },

    # Jinja2
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.jinja2.Jinja2&#39;,
        # 定义项目的通用模板, mysite/templates
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        # True表示在所有已安装应用的application/jinja2中查找。
        &#39;APP_DIRS&#39;: True,
        # 模板的选项：
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ]
        },
    },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BACKEND定义模板引擎,django内置的模板引擎有两个django.template.backends.django.DjangoTemplates(默认)和django.template.backends.jinja2.Jinja2&lt;/p&gt;
&lt;p&gt;DIRS存放自定义的不在应用路径的模板，模板引擎按列表顺序搜索查找模板源文件,默认就是默认引擎的默认路径。&lt;/p&gt;
&lt;p&gt;APP_DIRS告诉模板引擎是否进入安装应用的templates(jinja2的目录是jinja2)查找模板。&lt;/p&gt;
&lt;p&gt;在视图中使用模板：&lt;/p&gt;
&lt;p&gt;默认django会在项目的所有应用的templates中查找模板，所以为了防止多个应用有同名的模板，需要在templates下新建application同名的目录来存放模板&lt;/p&gt;
&lt;p&gt;应用的模板文件需要在应用目录创建templates文件夹&lt;/p&gt;
&lt;p&gt;默认模板放在polls/templates/polls/XXX.html&lt;/p&gt;
&lt;p&gt;应用的静态文件需要在应用目录创建static文件夹&lt;/p&gt;
&lt;p&gt;默认静态文件存放在polls/static/polls/XXX.css&lt;/p&gt;
&lt;p&gt;静态文件夹用来集中存放和管理图片，js脚本和css样式表等静态文件。&lt;/p&gt;
&lt;p&gt;django.template.loader定义了两个函数加载模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get_template(template_name, dirs=&amp;lt;object object&amp;gt;, using=None)
select_template(template_name_list, dirs=&amp;lt;object object&amp;gt;, using=None)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;模板语言&#34;&gt;模板语言&lt;/h1&gt;
&lt;p&gt;django模板语言由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;标签&lt;/li&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;li&gt;评论&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{{ var }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string = &amp;quot;test string&amp;quot;
return render(request, &#39;index.html&#39;, {&#39;string&#39;: string})

{{ string }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示字典：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict = {&amp;quot;key1&amp;quot;: &amp;quot;value1&amp;quot;, &amp;quot;key2&amp;quot;: &amp;quot;value2&amp;quot;}
return render(request, &#39;index.html&#39;, {&#39;dict&#39;: dict})

{{ dict.name1 }}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{% tag %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考内置标签：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-tags&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-tags&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;for标签：&lt;/p&gt;
&lt;p&gt;遍历列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list = [&#39;val1&#39;, &#39;val2&#39;, &#39;val3&#39;]
return render(request, &#39;index.html&#39;, {&#39;list&#39;: &#39;list&#39;})

```html
{% for i in list %}
{{ i }}
{% endfor %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历字典：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% for key, value in dict.items %}
{{ key }}: {{ value }}
{% endfor %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;empty列表可能为空：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% for i in list %}
...
{% empty %}
...
{% endfor %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;reversed反向循环：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% for i in list reversed %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环有用的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;forloop.counter    # 1 - indexed
forloop.counter0    # 0 - indexed
forloop.revcounter    # 1 - indexed
forloop.revcounter0    # 0 - indexed
forloop.first
forloop.last
forloop.parentloop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% if expression %}
...
{% else %}
...
{% endif %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if可用的布尔操作符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% if expression1 and expression2 %}
{% if not expression %}
{% if expression1 or expression2 %}
{% if not expression1 or expression2 %} # not优先级高于or
{% if expression1 and not expression2 %} # not优先级高于and
{% if expression1 and expression2 or expression3 %} # and优先级高于or
{% if var == value %}
{% if var != value %}
{% if var &amp;lt; value %}
{% if var &amp;gt; value %}
{% if var &amp;lt;= value %}
{% if var &amp;gt;= value %}
{% if var in value %}
{% if a &amp;gt; b and b &amp;gt; c %}
{% if var|filter&amp;quot;arguments expression %} # if中使用过滤器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔操作符的优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;or
and
not
in
==, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;include标签：&lt;/p&gt;
&lt;p&gt;加载模板并以标签内的参数渲染。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% include &#39;XXX.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;load标签：&lt;/p&gt;
&lt;p&gt;加载自定义模板标签集。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% load foo bar from somelibrary %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;now标签：&lt;/p&gt;
&lt;p&gt;显示最近的日期和事件。&lt;/p&gt;
&lt;p&gt;spaceless标签：&lt;/p&gt;
&lt;p&gt;删除html标签之间的空白格，包括制表符和换行。&lt;/p&gt;
&lt;p&gt;url标签：&lt;/p&gt;
&lt;p&gt;返回一个绝对路径的引用，该引用匹配一个给定的视图函数和一些可选的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% &#39;some-url-name&#39; v1 v2 %}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模板继承&#34;&gt;模板继承&lt;/h3&gt;
&lt;p&gt;block标签：&lt;/p&gt;
&lt;p&gt;在底层模板定义一些通用的内容，block标签可以被子模板覆盖。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% block XXX %}
This is default content
{% endblock %}}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;extends标签：&lt;/p&gt;
&lt;p&gt;表示当前模板继承自父模板。&lt;/p&gt;
&lt;p&gt;extends标签必须放在子模板第一行。&lt;/p&gt;
&lt;p&gt;extends用来调用底层的模板，然后修改block标签内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% extends &amp;quot;XXX.html&amp;quot;/variable %}
{% block XXX %}
This is rewrite content
{% endblock %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;block.super:&lt;/p&gt;
&lt;p&gt;如果需要获取父模板的block中的内容，可以用block.super。&lt;/p&gt;
&lt;p&gt;可以在父模板的block中增加内容，而不是完全覆盖。&lt;/p&gt;
&lt;h2 id=&#34;过滤器&#34;&gt;过滤器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{{ var|filter:arguments }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考内置过滤器&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-filters&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-filters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;add过滤器：&lt;/p&gt;
&lt;p&gt;把add后的参数加给value。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|add:&amp;quot;2&amp;quot; }} # value -&amp;gt; value+2
{{ value|addslashes }} # &amp;quot;I&#39;m string&amp;quot; -&amp;gt; &amp;quot;I\&#39;m string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;addslashed过滤器：&lt;/p&gt;
&lt;p&gt;在引号前面加\&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|addslashes }} # I&#39;m canux -&amp;gt; I\&#39;m canux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;capfirst过滤器：&lt;/p&gt;
&lt;p&gt;变量的第一个字母大写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|capfirst }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;center过滤器：&lt;/p&gt;
&lt;p&gt;使value在给定的宽度范围内居中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|center:&amp;quot;15&amp;quot; }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cut过滤器：&lt;/p&gt;
&lt;p&gt;移除value中所有的与给出的变量相同的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|cut:&amp;quot;cut&amp;quot; }} # 移除value中的字符串&amp;quot;cut&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;date过滤器：&lt;/p&gt;
&lt;p&gt;根据给定格式对一个date变量格式化。&lt;/p&gt;
&lt;p&gt;default过滤器：&lt;/p&gt;
&lt;p&gt;给value设定默认值，如果value没有赋值，就用默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|default:&amp;quot;default-value&amp;quot; }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;default_if_none过滤器：&lt;/p&gt;
&lt;p&gt;仅当value是None使用默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value:default_if_none:&amp;quot;nothing&amp;quot; }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dictsort过滤器：&lt;/p&gt;
&lt;p&gt;dictsortreversed过滤器：&lt;/p&gt;
&lt;p&gt;divisibleby过滤器：&lt;/p&gt;
&lt;p&gt;如果value可以被给出的参数整除，返回True。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ value|divisibleby:&amp;quot;3&amp;quot; }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;escape过滤器：&lt;/p&gt;
&lt;p&gt;escapejs过滤器：&lt;/p&gt;
&lt;p&gt;filesizeformat过滤器：&lt;/p&gt;
&lt;p&gt;格式化为人类可读的文件大小。&lt;/p&gt;
&lt;p&gt;first过滤器：&lt;/p&gt;
&lt;p&gt;返回迭代器的第一个元素。&lt;/p&gt;
&lt;p&gt;floatformat过滤器：&lt;/p&gt;
&lt;p&gt;force_escape过滤器：&lt;/p&gt;
&lt;p&gt;get_digit过滤器：&lt;/p&gt;
&lt;p&gt;iriencode过滤器：&lt;/p&gt;
&lt;p&gt;join过滤器：&lt;/p&gt;
&lt;p&gt;last过滤器：&lt;/p&gt;
&lt;p&gt;length过滤器：&lt;/p&gt;
&lt;p&gt;length_is过滤器：&lt;/p&gt;
&lt;p&gt;linebreaks过滤器：&lt;/p&gt;
&lt;p&gt;linebreaksbr过滤器：&lt;/p&gt;
&lt;p&gt;linenumbers过滤器：&lt;/p&gt;
&lt;p&gt;ljust过滤器：&lt;/p&gt;
&lt;p&gt;lower过滤器：&lt;/p&gt;
&lt;p&gt;把字符串转换成小写。&lt;/p&gt;
&lt;p&gt;make_list过滤器：&lt;/p&gt;
&lt;p&gt;phone2numeric过滤器：&lt;/p&gt;
&lt;p&gt;pluralize过滤器：&lt;/p&gt;
&lt;p&gt;pprint过滤器：&lt;/p&gt;
&lt;p&gt;random过滤器：&lt;/p&gt;
&lt;p&gt;romevetags过滤器：&lt;/p&gt;
&lt;p&gt;rjust过滤器：&lt;/p&gt;
&lt;p&gt;slice过滤器：&lt;/p&gt;
&lt;p&gt;slugify过滤器：&lt;/p&gt;
&lt;p&gt;stringformat过滤器：&lt;/p&gt;
&lt;p&gt;striptags过滤器：&lt;/p&gt;
&lt;p&gt;time过滤器：&lt;/p&gt;
&lt;p&gt;timesince过滤器：&lt;/p&gt;
&lt;p&gt;timeuntil过滤器：&lt;/p&gt;
&lt;p&gt;title过滤器：&lt;/p&gt;
&lt;p&gt;truncatechars过滤器：&lt;/p&gt;
&lt;p&gt;truncatechars_html过滤器：&lt;/p&gt;
&lt;p&gt;truncatewords过滤器：&lt;/p&gt;
&lt;p&gt;truncatewords_html过滤器;&lt;/p&gt;
&lt;p&gt;unordered_list过滤器：&lt;/p&gt;
&lt;p&gt;upper过滤器：&lt;/p&gt;
&lt;p&gt;将字符串转换成大写形式。&lt;/p&gt;
&lt;p&gt;urlencode过滤器：&lt;/p&gt;
&lt;p&gt;urlize过滤器：&lt;/p&gt;
&lt;p&gt;urlizetrunc过滤器：&lt;/p&gt;
&lt;p&gt;wordcount过滤器：&lt;/p&gt;
&lt;p&gt;wordwrap过滤器：&lt;/p&gt;
&lt;p&gt;yesno过滤器：&lt;/p&gt;
&lt;p&gt;i18n过滤器：&lt;/p&gt;
&lt;p&gt;l10n过滤器：&lt;/p&gt;
&lt;p&gt;tz过滤器：&lt;/p&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{# this is single line comment #}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% comment %}
line1
line2
{% endcomment %}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;自动html转义&#34;&gt;自动html转义&lt;/h1&gt;
&lt;p&gt;当从模板生成html时，值可能包含影响html最终呈现的字符。&lt;/p&gt;
&lt;p&gt;django的自动转义,默认是打开的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt; 转义成 &amp;amp;lt;
&amp;gt; 转义成 &amp;amp;gt;
&#39; 转义成 &amp;amp;#39
&amp;quot; 转义成 &amp;amp;quot;
$ 转义成 &amp;amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不需要自动转义可以关闭它&lt;/p&gt;
&lt;p&gt;可以用safe过滤器关闭独立变量中的自动转义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data = &amp;lt;b&amp;gt;
{{ data }} -&amp;gt; &amp;amp;lt;b&amp;amp;gt;
{{ data|safe }} -&amp;gt; &amp;lt;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用autoescape标签关闭模板代码中的自动转义：&lt;/p&gt;
&lt;p&gt;autoescape标签有off和on两个参数，表示关闭和打开自动转义。&lt;/p&gt;
&lt;p&gt;父模板中的autoescape可以被子模板继承，也可以被include标签包含的模板继承。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```html
{% autoescape off %}
{{ name }}
{% endautoescape %}
```
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Deploy</title>
        <link>https://canuxcheng.com/post/django_deploy/</link>
        <pubDate>Tue, 27 Sep 2016 10:23:22 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_deploy/</guid>
        <description>&lt;h1 id=&#34;发布django项目&#34;&gt;发布django项目&lt;/h1&gt;
&lt;p&gt;django内置一个轻量级web开发服务器。&lt;/p&gt;
&lt;p&gt;如果要发布django项目需要另外的操作。&lt;/p&gt;
&lt;p&gt;也可以发布到其它的云平台。&lt;/p&gt;
&lt;p&gt;一般通过wsgi或者asgi来部署.&lt;/p&gt;
&lt;h2 id=&#34;deploy时django的设置&#34;&gt;deploy时django的设置&lt;/h2&gt;
&lt;p&gt;settings.py中的设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALLOWED_HOSTS = [&#39;*&#39;]
DEBUG = False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;wsgi-部署&#34;&gt;WSGI 部署&lt;/h1&gt;
&lt;h2 id=&#34;apache2--mod_wsgi&#34;&gt;apache2 + mod_wsgi&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/GrahamDumpleton/mod_wsgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/GrahamDumpleton/mod_wsgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mod_wsgi是C写的apache的模块，实现了兼容WSGI接口，用来部署python的web应用。&lt;/p&gt;
&lt;p&gt;作为apache2的模块安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ubuntu/debian
sudo aptitude install apache2 # 安装apache2
sudo aptitude install libapache2-mod-wsgi # for python2
sudo aptitude install libapache2-mod-wsgi-py3 # for python3

# redhat/centos/fedora
sudo yum install httpd2
sudo yum install httpd-devel
sudo yum install mod_wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ubuntu创建网站的配置文件/etc/apache2/sites-available/mysite.conf:&lt;/p&gt;
&lt;p&gt;Fedora创建网站的配置文件/etc/httpd/conf.d/mysite.conf:&lt;/p&gt;
&lt;p&gt;一般部署到web服务器，/home/user/修改为/var/www/&lt;!-- raw HTML omitted --&gt;/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Include the project dir, can not inside VirtualHost section.
WSGIPythonPath /home/user/mysite
# If use virtualenv and named .venv
# WSGIPythonPath /home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages

&amp;lt;VirtualHost *:80&amp;gt;
    ServerName localhost
    # ServerName yoursite.domain
    ServerAdmin canuxcheng@gmail.com

    Alias /robots.txt /home/user/mysite/static/robots.txt
    Alias /favicon.ico /home/user/mysite/static/favicon.ico

    Alias /media/ /home/user/mysite/media/
    Alias /static/ /home/user/mysite/static/

    &amp;lt;Directory /home/user/mysite/media&amp;gt;
    Required all granted
    &amp;lt;/Directory&amp;gt;

    &amp;lt;Directory /home/user/mysite/static&amp;gt;
    Required all granted
    &amp;lt;/Directory&amp;gt;

    # If use daemon mode to run WSGI process.
    WSGIDaemonProcess mysite python-path=/home/user/mysite
    # If use virtualenv and named .venv
    # WSGIDaemonProcess mysite python-path=/home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages
    # WSGIProcessGroup mysite

    WSGIScriptAlias / /home/user/mysite/mysite/wsgi.py

    &amp;lt;Directory /home/user/mysite/mysite&amp;gt;
    &amp;lt;Files wsgi.py&amp;gt;
    Required all granted
    &amp;lt;/Files&amp;gt;
    &amp;lt;/Directory&amp;gt;

    # check the log in /var/log/apache2/error_mysite.log or access_mysite.log
    ErrorLog ${APACHE_LOG_DIR}/error_mysite.log
    CustomLog ${APACHE_LOG_DIR}/access_mysite.log combined
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改项目的wsgi.py:&lt;/p&gt;
&lt;p&gt;因为环境变量是进程范围的，在同一个进程运行多个站点会出问题，所以推荐多站点使用mod_wsgi的守护进程模式,也可以在单进程中覆盖DJANGO_SETTINGS_MODULE这个变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os

from django.core.wsgi import get_wsgi_application

# If you have more than 1 django project you need to change this.
# Or you can use daemon mode for WSGI process.
# os.environ.setdefault(&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;, &amp;quot;mysite.settings&amp;quot;)
os.environ[&amp;quot;DIANGO_SETTINGS_MODULE&amp;quot;] = &amp;quot;mysite.settings&amp;quot;
application = get_wsgi_application()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改项目的settings.py:&lt;/p&gt;
&lt;p&gt;ROOT表示存放位置，URL表示对应网址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEBUG = False

ALLOWED_HOSTS = [&#39;*&#39;]

# Static files (CSS, JavaScript, Images)
STATIC_URL = &#39;/static/&#39;

STATIC_ROOT = os.path.join(BASE_DIR, &#39;static&#39;)

# Media files (upload files)
MEDIA_URL = &#39;/media/&#39;

MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收集静态文件和迁移：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python manage.py makemigration
$python mamage.py migrate
$python manage.py collectstatic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置权限：&lt;/p&gt;
&lt;p&gt;Ubuntu默认用户和组是www-data,Fedora默认用户和组是apache。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd /home/user
$sudo chgrp www-data mysite
$sudo chmod g+w mysite
$sudo chgrp www-data mysite/db.sqlite3
$sudo chmod g+w mysite/db.sqlite3
$sudo chgrp -R www-data mysite/media/uploads
$sudo chmod -R g+w mysite/media/uploads
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ubuntu激活网站：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo a2ensite &amp;lt;newsite&amp;gt;
$sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fedora激活网站：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo systemctl restart  httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uwsgi&#34;&gt;uWSGI&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/unbit/uwsgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/unbit/uwsgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C写的wsgi应用服务器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python3 -m pip install uwsgi
$ uwsgi --http :8000 --chdir /path/to/project --module mysite.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gunicorn&#34;&gt;Gunicorn&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/benoitc/gunicorn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/benoitc/gunicorn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;纯python写的WSGI服务器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python3 -m pip install gunicorn
$ gunicorn mysite.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;asgi&#34;&gt;ASGI&lt;/h1&gt;
&lt;h2 id=&#34;uvicorn&#34;&gt;Uvicorn&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ python -m pip install uvicorn gunicorn
$ gunicorn myproject.asgi:application -k uvicorn.workers.UvicornWorker
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hypercorn&#34;&gt;Hypercorn&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ python -m pip install hypercorn
$ hypercorn myproject.asgi:application
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;daphne&#34;&gt;Daphne&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ python -m pip install daphne
$ daphne myproject.asgi:application
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Nodejs</title>
        <link>https://canuxcheng.com/post/js_node/</link>
        <pubDate>Tue, 27 Sep 2016 03:31:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_node/</guid>
        <description>&lt;h1 id=&#34;nodejs&#34;&gt;Nodejs&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nodejs/node&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nodejs/node&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。&lt;/p&gt;
&lt;p&gt;Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。&lt;/p&gt;
&lt;p&gt;Node.js 的包管理器npm，是全球最大的开源库生态系统.&lt;/p&gt;
&lt;p&gt;常说的javascript是前端语言，nodejs就是后端版本的javascript。&lt;/p&gt;
&lt;p&gt;安装nodejs(npm):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nodejs
$ brew install nodejs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node --version
$ npm --version
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nvm&#34;&gt;nvm&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nvm-sh/nvm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nvm-sh/nvm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs版本管理器.&lt;/p&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;verify:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;command -v nvm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;usage:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看所有可安装版本
nvm ls-remote

// 安装指定版本
nvm install v14.15.5

// 查看已安装版本
nvm ls

// 指定默认版本
nvm alias default v16.14.0

// 指定版本
nvm use v14.15.5
nvm use default

// 查看版本
nvm run node --version
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>NPM</title>
        <link>https://canuxcheng.com/post/js_npm/</link>
        <pubDate>Tue, 27 Sep 2016 03:31:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/js_npm/</guid>
        <description>&lt;h1 id=&#34;npm&#34;&gt;NPM&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.npmjs.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.npmjs.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;npm: node package manager.&lt;/p&gt;
&lt;p&gt;npm 由三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;website &lt;a class=&#34;link&#34; href=&#34;https://www.npmjs.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.npmjs.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CLI&lt;/li&gt;
&lt;li&gt;registry &lt;a class=&#34;link&#34; href=&#34;https://registry.npmjs.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://registry.npmjs.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改registry
$ npm config set registry https://registry.npm.taobao.org
$ npm config get registry

// 修改默认全局安装路径
mkdir /path/npm_global
npm config set prefix /path/npm_global
echo &#39;export PATH=/path/npm_global/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.profile
source ~/.profile

// 查看配置
$ npm config ls -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据当前目录package.json安装到当前目录node_modules
$ npm install

// 安装pkg到当前目录的 node_modules
$ npm install &amp;lt;pkg&amp;gt;

// 安装到全局的node_modules
$ npm install -g &amp;lt;name&amp;gt;

--save-dev // 安装并自动更新到package.json的devDependencies.
--no-save // 不保存到package.json 和 package-lock.json.
--no-package-lock // 不生成package-lock.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看安装了哪些包
$ npm list --depth=0 --global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;init:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建package.json
$ npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;publish:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 注册npm账号
# 添加账号
npm adduser
# 验证账号 
npm whoami
# 发布
npm publish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发布好了可以去npm网站查看.&lt;/p&gt;
&lt;p&gt;npm + shrinkwrap = yarn lock
npm-shrinkwrap.json = yarn.lock&lt;/p&gt;
&lt;h2 id=&#34;folders&#34;&gt;folders&lt;/h2&gt;
&lt;p&gt;nodejs加载的路径:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当前目录
2. $HOME/.node_modules
   $HOME/.node_libraries
   $PREFIX/lib/node_modules
3. $NODE_PATH

// 查看prefix (也是-g 安装的目录)
$ npm config ls -l | grep prefix
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;npmrc&#34;&gt;npmrc&lt;/h2&gt;
&lt;p&gt;get token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -u&amp;lt;username&amp;gt;:&amp;lt;api-key&amp;gt; https://artifactory.canux.com/artifactory/api/npm/auth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;.npmrc&amp;rdquo; 配置private registry&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;registry=https://artifactory.canux.com/artifactory/api/npm/iep.npm-virtual
always-auth=true 
email=&amp;lt;user-email&amp;gt;
//artifactory.arm.com/artifactory/api/npm/:_auth=&amp;lt;token&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;npmignore&#34;&gt;npmignore&lt;/h2&gt;
&lt;p&gt;打包的时候忽略的文件和目录，优先级高于gitignore。&lt;/p&gt;
&lt;h2 id=&#34;packagejson&#34;&gt;package.json&lt;/h2&gt;
&lt;p&gt;package.json&lt;/p&gt;
&lt;p&gt;package-locks&lt;/p&gt;
&lt;p&gt;package-lock.json&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;yarn&#34;&gt;yarn&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yarnpkg.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yarnpkg.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用corepack安装yarn。&lt;/p&gt;
&lt;p&gt;激活corepack&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ corepack enable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装yarn&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ corepack prepare yarn@3.8.1 --activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CLI:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// yarn config, yarn 会读npmrc
yarn config

cacheFolder: $HOME/.yarn/berry/cache
globalFolder: $HOME/.yarn/berry

// create package.json
$ yarn init

// 设置project的yarn version，自动下载.yarn/release/yarn-&amp;lt;version&amp;gt;.cjs
yarn set version berry

// remove all local archives
$ yarn cache clean  

// add/remove/install dependencies
$ yarn add ...
$ yarn remove ...
$ yarn install --inline-builds

// nodejs
$ yarn node

// check npm package information
$ yarn npm info react

// run script defined in package.json
$ yarn run &amp;lt;scriptName&amp;gt;

//  plugin management
$ yarn plugin ......

//  workspace management
$ yarn workspaces ...
$ yarn workspaces list
$ yarn workspaces foreach // run command on all workspaces

// login to private registry
yarn npm login
yarn npm logout
yarn npm publish

    npmRegistries:
        &amp;quot;https://artifactory.arm.com/artifactory/api/npm/iep.npm-virtual&amp;quot;: 
            npmAuthToken: &amp;lt;token&amp;gt;

yarn build 
&amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: &amp;quot;./src/index.ts&amp;quot;,
    &amp;quot;./alpha&amp;quot;: &amp;quot;./src/alpha.ts&amp;quot;,
    &amp;quot;./package.json&amp;quot;: &amp;quot;./package.json&amp;quot;
},
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Web</title>
        <link>https://canuxcheng.com/post/web/</link>
        <pubDate>Tue, 27 Sep 2016 03:25:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/web/</guid>
        <description>&lt;h1 id=&#34;web&#34;&gt;WEB&lt;/h1&gt;
&lt;p&gt;web一般包括web server, web service, load balancing.&lt;/p&gt;
&lt;p&gt;URL: Uniform Resource Locator, 统一资源定位符．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scheme://host[:port#]/path/.../[?query-string][#anchor]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DNS: Domain Name System, 域名系统.&lt;/p&gt;
&lt;p&gt;header: header中用来保存session，cookie等头部信息．&lt;/p&gt;
&lt;p&gt;session: 服务端的数据存储机制．&lt;/p&gt;
&lt;p&gt;cookie: 客户端的数据存储机制．分为会话cookie和持久cookie.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;webserver&#34;&gt;webserver&lt;/h1&gt;
&lt;p&gt;LAMP: Linux+apache+mysql+php&lt;/p&gt;
&lt;p&gt;LNMP: Linux+nginx+mysql+php&lt;/p&gt;
&lt;h1 id=&#34;blog静态站点&#34;&gt;Blog静态站点&lt;/h1&gt;
&lt;p&gt;hugo是golang开发的静态站点生成器．&lt;/p&gt;
&lt;p&gt;pelican是python开发的静态站点生成器.&lt;/p&gt;
&lt;p&gt;hexo是nodejs开发的静态站点生成器.&lt;/p&gt;
&lt;p&gt;jekyll是ruby开发的静态站点生成器.&lt;/p&gt;
&lt;p&gt;octopress是ruby开发的kekyll的升级版.&lt;/p&gt;
&lt;h1 id=&#34;cms系统&#34;&gt;CMS系统&lt;/h1&gt;
&lt;p&gt;wordpress是php开发的website, blog, app框架。&lt;/p&gt;
&lt;p&gt;joomla是php开发的内容管理系统.&lt;/p&gt;
&lt;p&gt;drupal是php开发的内容管理系统.&lt;/p&gt;
&lt;p&gt;django-cms是python开发的基于django的内容管理系统.&lt;/p&gt;
&lt;p&gt;wagtail是python开发的基于django的内容管理系统.&lt;/p&gt;
&lt;p&gt;mezzanine是python开发的基于django的内容管理系统.&lt;/p&gt;
&lt;h1 id=&#34;forum系统&#34;&gt;Forum系统&lt;/h1&gt;
&lt;p&gt;vanilla是php开发的论坛系统.&lt;/p&gt;
&lt;p&gt;phpbb是php开发的论坛系统.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;webservice&#34;&gt;webservice&lt;/h1&gt;
&lt;p&gt;web service是一种标准,将应用程序转换成网络应用程序.&lt;/p&gt;
&lt;p&gt;WSDL:网络服务描述语言&lt;/p&gt;
&lt;p&gt;UDDI:&lt;/p&gt;
&lt;p&gt;RDF:&lt;/p&gt;
&lt;p&gt;RSS:&lt;/p&gt;
&lt;p&gt;SOAP: 是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>TPL</title>
        <link>https://canuxcheng.com/post/django_tpl/</link>
        <pubDate>Tue, 27 Sep 2016 01:33:42 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django_tpl/</guid>
        <description>&lt;h1 id=&#34;django-third-party-library&#34;&gt;Django Third Party Library.&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rosarior/awesome-django&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/rosarior/awesome-django&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Add this application to your django project in settings.py.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = (
    &#39;south&#39;,
    &#39;debug_toolbar&#39;,
    &#39;crispy_forms&#39;,
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;django-rest-framework&#34;&gt;django-rest-framework&lt;/h1&gt;
&lt;p&gt;django的RESTful API的application。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tomchristie/django-rest-framework/tree/master&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tomchristie/django-rest-framework/tree/master&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-json-api/django-rest-framework-json-api&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-json-api/django-rest-framework-json-api&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SimpleJWT/django-rest-framework-simplejwt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/SimpleJWT/django-rest-framework-simplejwt&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;admin-interface&#34;&gt;admin interface&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/geex-arts/django-jet&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/geex-arts/django-jet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sehmaschine/django-grappelli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sehmaschine/django-grappelli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/darklow/django-suit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/darklow/django-suit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sshwsfc/xadmin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sshwsfc/xadmin&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;authentication&#34;&gt;authentication&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/etianen/django-python3-ldap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/etianen/django-python3-ldap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pennersr/django-allauth/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pennersr/django-allauth/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-guardian/django-guardian&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-guardian/django-guardian&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;database&#34;&gt;database&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-dbbackup/django-dbbackup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-dbbackup/django-dbbackup&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jazzband/django-debug-toolbar&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jazzband/django-debug-toolbar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-extensions/django-extensions/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-extensions/django-extensions/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;form&#34;&gt;form&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-crispy-forms/django-crispy-forms&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-crispy-forms/django-crispy-forms&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;search&#34;&gt;search&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/carltongibson/django-filter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/carltongibson/django-filter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-haystack/django-haystack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-haystack/django-haystack&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;security&#34;&gt;security&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/adamchainz/django-cors-headers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/adamchainz/django-cors-headers&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cms-project&#34;&gt;CMS Project&lt;/h1&gt;
&lt;h2 id=&#34;django-cms&#34;&gt;django-cms&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/divio/django-cms/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/divio/django-cms/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;wagtail&#34;&gt;wagtail&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wagtail/wagtail&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wagtail/wagtail&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mezzanine&#34;&gt;mezzanine&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/stephenmcd/mezzanine/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/stephenmcd/mezzanine/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;e-commerce-project&#34;&gt;e-Commerce Project&lt;/h1&gt;
&lt;h2 id=&#34;django-oscar&#34;&gt;django-oscar&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django-oscar/django-oscar&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django-oscar/django-oscar&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;django-shop&#34;&gt;django-shop&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/awesto/django-shop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/awesto/django-shop&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pm-project&#34;&gt;PM Project&lt;/h1&gt;
&lt;h2 id=&#34;taiga&#34;&gt;taiga&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/taigaio&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/taigaio&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Apache</title>
        <link>https://canuxcheng.com/post/apache/</link>
        <pubDate>Tue, 27 Sep 2016 03:25:26 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/apache/</guid>
        <description>&lt;h1 id=&#34;apache&#34;&gt;Apache&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/httpd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/httpd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://httpd.apache.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://httpd.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ubuntu/debian：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo aptitude install apache2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;redhat/centos/fedora:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install httpd2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动服务器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service apache2 start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动浏览器查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:80
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;apache命令&#34;&gt;apache命令&lt;/h1&gt;
&lt;p&gt;apache2ctl:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 检查配置
$ apache2ctl configtest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2ensite&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 启用一个站点
$ sudo a2ensite &amp;lt;site&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2dissite&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo a2dissite &amp;lt;site&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2enmod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 启用一个模块
$ sudo a2enmod &amp;lt;mod&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2dismod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo a2dismod &amp;lt;mod&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;p&gt;配置站点site-enable/site.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:8080&amp;gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /opt

    # 适合多目录
    Alias /qa /opt/qa
    Alias /dev /opt/dev

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改权限apache2.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Directory /opt/qa&amp;gt;
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
&amp;lt;/Directory&amp;gt;

&amp;lt;Directory /opt/dev&amp;gt;
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改端口ports.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Listen 8080
&amp;lt;IfModule ssl_module&amp;gt;
        Listen 4433
&amp;lt;/IfModule&amp;gt;
&amp;lt;IfModule mod_gnutls.c&amp;gt;
        Listen 4433
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置ssl和basic auth&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装创建账号的工具
sudo apt-get install apache2-utils

创建账号
sudo htpasswd -c /etc/apache2/.htpasswd user
sudo htpasswd /etc/apache2/.htpasswd another_user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启用依赖的模块:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/apache2/mods-enabled
ln -sf ../mods-available/rewrite.load rewrite.load
ln -sf ../mods-available/ssl.conf ssl.conf
ln -sf ../mods-available/ssl.load ssl.load
#ln -sf ../mods-available/slotmem_shm.load slotmem_shm.load
#ln -sf ../mods-available/socache_shmcb.load socache_shmcb.load
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改site-avaliable/site.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www

    // 将http重定向到https, 如果注释掉，http和https都可以访问.
    RewriteEngine on
    RewriteCond %{SERVER_PORT} !^443$
    RewriteRule ^/(.*) https://%{HTTP_HOST}/$1 [NC,R=301,L]

    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:443&amp;gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www

    // 开启ssl
    SSLEngine on
    SSLCertificateFile &amp;quot;/etc/apache2/user.domain.com.crt&amp;quot;
    SSLCertificateKeyFile &amp;quot;/etc/apache2/user.domain.com.key&amp;quot;
    BrowserMatch &amp;quot;MSIE [2-6]&amp;quot; nokeepalive ssl-unclean-shutdown downgrade-1.0 force-response-1.0
    BrowserMatch &amp;quot;MSIE [17-9]&amp;quot; ssl-unclean-shutdown

    // 开启basic auth.
    &amp;lt;Directory &amp;quot;/var/www&amp;quot;&amp;gt;
        AuthType Basic
        AuthName &amp;quot;Restricted Content&amp;quot;
        AuthUserFile /etc/apache2/.htpasswd
        Require valid-user
    &amp;lt;/Directory&amp;gt;

    LogLevel warn
    ErrorLog /var/log/apache2/error.log
    CustomLog /var/log/apache2/access.log combined
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Django</title>
        <link>https://canuxcheng.com/post/django/</link>
        <pubDate>Tue, 20 Sep 2016 23:14:07 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/django/</guid>
        <description>&lt;h1 id=&#34;django&#34;&gt;Django&lt;/h1&gt;
&lt;p&gt;django是python的web框架。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/django/django&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/django/django&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.djangoproject.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.djangoproject.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/zh-hans/3.1/contents/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/zh-hans/3.1/contents/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;django遵守MVC设计模式，采用MTV框架。&lt;/p&gt;
&lt;p&gt;M: model,数据存取&lt;/p&gt;
&lt;p&gt;T: template，如何展现数据&lt;/p&gt;
&lt;p&gt;V: view，展现哪些数据&lt;/p&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;django1.11是最后一个支持python2.7的长期支持版(2017.4).&lt;/p&gt;
&lt;p&gt;django2.0开始只支持python3(2018).&lt;/p&gt;
&lt;p&gt;本文以django3.1为例创建名为next的project.&lt;/p&gt;
&lt;p&gt;virtualenv中安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mkdir next
$cd next
$virtualenv .venv

# mac/linux
$source .venv/bin/activate

# windows
&amp;gt;cd .venv/Scripts
&amp;gt;activate

$pip install django
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python
&amp;gt;&amp;gt;&amp;gt;import django
&amp;gt;&amp;gt;&amp;gt;django.VERSION
&amp;gt;&amp;gt;&amp;gt;django.get_version()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装使用的数据库引擎的库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo udo apt-get install libmysqlclient-dev
$ pip install mysqlclient

$pip install psycopg2

$pip install cx_Oracle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;django默认是mysqlclient，可以使用pymysql替代：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim settings.py
import pymysql
pymysql.version_info = (1, 4, 13, &amp;quot;final&amp;quot;, 0)
pymysql.install_as_MySQLdb()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;project&#34;&gt;project&lt;/h1&gt;
&lt;p&gt;创建一个名为next的项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd next
$ django-admin startproject next.

next
|-- manage.py
|-- next
    |- __init__.py
    |- settings.py
    |- urls.py
    |- wsgi.py
    |- asgi.py
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;next 最外层根目录只是你项目的容器， 根目录名称对Django没有影响，你可以将它重命名为任何你喜欢的名称。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;templates: project的模版.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next 里层的目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 next.urls).&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next/&lt;strong&gt;init&lt;/strong&gt;.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next/asgi.py：作为你的项目的运行在 ASGI 兼容的Web服务器上的入口。阅读 如何使用 ASGI 来部署 了解更多细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;next/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;验证开发服务器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python manage.py runserver
$python manage.py runserver &amp;lt;ip address&amp;gt;:&amp;lt;port&amp;gt;
&amp;gt; py manage.py runserver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://127.0.0.1:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;settingspy&#34;&gt;settings.py&lt;/h2&gt;
&lt;p&gt;默认enable的app:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;, //管理员站点， 你很快就会使用它。 
    &#39;django.contrib.auth&#39;, //认证授权系统。
    &#39;django.contrib.contenttypes&#39;, //内容类型框架。/
    &#39;django.contrib.sessions&#39;, //会话框架。 
    &#39;django.contrib.messages&#39;, //消息框架。 
    &#39;django.contrib.staticfiles&#39;, //管理静态文件的框架。 
]

默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表
$ python manage.py migrate
&amp;gt; py manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认enable的midleware:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MIDDLEWARE = [
    &#39;django.middleware.security.SecurityMiddleware&#39;,
    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,
    &#39;django.middleware.common.CommonMiddleware&#39;,
    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,
    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,
    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,
    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持的template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATES = [
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.jinja2.Jinja2&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        },
    },
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        },
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认的数据库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: BASE_DIR / &#39;db.sqlite3&#39;,
        &#39;TEST&#39;: {
            // 默认测试数据库是test_ 加 default.NAME，TEST可以指定数据库名字.
            &#39;NAME&#39;: &#39;test_db&#39;
        }
    }
}

// 可扩展的数据库
ENGINE:
    django.db.backends.mysql
    django.db.backends.oracle
    django.db.badkends.postgresql_psycopg2

NAME:
    your database name

USER:
    your database username

PASSWORD:
    your database password

HOST:
    local database or remote database

PORT:
    database port
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其它配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = &#39;-%b)79izbio$!(g!0io(he)giaqi1@))fzfq!t3s1g1dzysc(r&#39;

WSGI_APPLICATION = &#39;next.wsgi.application&#39;

ROOT_URLCONF = &#39;next.urls&#39;

DEBUG = True # 开发用来调试
DEBUG = False # 部署之后关闭

ALLOWED_HOSTS = [] # 设置哪些域名可以访问，优先级高于web服务器，debug=false必须设置
ALLOWED_HOSTS = [&#39;&#39;*&#39;&#39;] # 允许所有域名访问

STATIC_URL = &#39;/static/&#39;
STATIC_ROOT = &#39;/path/to/static&#39;
# static目录存放js/css等静态文件,collectstatic命令用来收集静态文件。

LANGUAGE_CODE = &#39;en-us&#39;
TIME_ZONE = &#39;UTC&#39;
USE_I18N = True
USE_L10N = True
USE_TZ = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;urlspy&#34;&gt;urls.py&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path(&#39;polls/&#39;, include(&#39;polls.urls&#39;)),
    path(&#39;admin/&#39;, admin.site.urls),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在项目的urls添加所有应用的urls，为每个应用独立创建urls，方便管理。&lt;/p&gt;
&lt;h2 id=&#34;wsgipy&#34;&gt;wsgi.py&lt;/h2&gt;
&lt;p&gt;Web Server Gateway Interface.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;next.settings&#39;)
application = get_wsgi_application()
django通过wsgi来部署，参考django的deploy。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;asgipy&#34;&gt;asgi.py&lt;/h2&gt;
&lt;p&gt;Asynchronous Server Gateway Interface.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
from django.core.asgi import get_asgi_application

os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;next.settings&#39;)
application = get_asgi_application()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;application&#34;&gt;application&lt;/h1&gt;
&lt;p&gt;应用，一个项目可以有多个应用，一个应用可以用到多个项目中。&lt;/p&gt;
&lt;p&gt;可以单独打包应用发布到pypi，包名格式django-project，参考python的打包方法。&lt;/p&gt;
&lt;p&gt;创建一个名为polls的应用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python manage.py startapp polls
&amp;gt; py manage.py startapp polls

polls/
|- __init__.py
|- admin.py
|- apps.py
|- models.py
|- views.py
|- tests.py (tests/test_case.py)
|- migrations
   |- __init__.py
|- templates
   |- polls
      |- index.html
|- static
   |- polls
      |- style.css
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;admin.py admin管理界面&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;apps.py&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;models.py 模型&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;views.py 视图&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;urls.py 新建的application的url&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;test.py 测试&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;migrations 迁移文件夹&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;templates 应用的模版文件夹&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;static 静态文件&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;django-admin--managepy&#34;&gt;django-admin &amp;amp; manage.py&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;[staticfiles]
    collectstatic # 设置STATIC_ROOT = &#39;/var/www/static/project/&#39;用来收集静态文件
    findstatic
    runserver # 启动django自带的web开发服务器

[sessions]
    clearsessions

[auth]
    changepassword
    createsuperuser
    
[contenttypes]
    remove_stale_contenttypes

[django]

    startapp
    
    startproject
    
    check
    compilemessages
    createcachetable
    dbshell # 数据库命令行
    diffsettings
    
    dumpdata # 导出数据 (json, xml, yaml)
    dumpdata &amp;gt; db.json
    flush # 清空数据库
    loaddata # 导入数据
    loaddata db.json
    
    inspectdb
    makemessages
    
    makemigrations # 创建迁移文件
    migrate # 创建/更新表结构（执行迁移文件）
    
    sendtestemail
    shell # 项目环境终端
    showmigrations # 查看可迁移的文件
    sqlflush
    sqlmigrate # 查看迁移文件会执行哪些sql
    sqlsequencereset
    squashmigrations
    
    test
    
    testserver
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Http</title>
        <link>https://canuxcheng.com/post/http/</link>
        <pubDate>Tue, 13 Sep 2016 01:39:34 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/http/</guid>
        <description>&lt;h1 id=&#34;httphttps&#34;&gt;HTTP/HTTPS&lt;/h1&gt;
&lt;p&gt;http port: 80&lt;/p&gt;
&lt;p&gt;https port: 443&lt;/p&gt;
&lt;p&gt;http/https的请求方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get # 从服务器取出资源
post # 在服务器新建资源
put # 在服务器更新资源，客户端提供改变后的完整资源
delete # 从服务器删除资源
patch # 在服务器更新资源，客户端提供改变的属性
head # 获取资源的源数据
options # 获取资源的哪些信息是客户端可以改变的信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;URL: Uniform Resource Locator&lt;/p&gt;
&lt;p&gt;URI: Universal Resource Identifier&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;scheme&amp;gt;://&amp;lt;netloc&amp;gt;/&amp;lt;path&amp;gt;;&amp;lt;params&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
scheme: http/https/ftp/file
netloc: username:password@host:port
path: /path/to/path
params: options arguments
query: connector&amp;amp;key-value
fragment:
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;http命令&#34;&gt;http命令&lt;/h1&gt;
&lt;h2 id=&#34;curl&#34;&gt;curl&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ curl [options] [URL...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;httpie&#34;&gt;httpie&lt;/h2&gt;
&lt;p&gt;python开发的类似于curl的命令行工具，同时还有wget的功能．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jakubroztocil/httpie&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jakubroztocil/httpie&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum/apt-get install httpie

$ http -a &#39;username:password&#39; GET http://google.com
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的http标准库&#34;&gt;python的http标准库&lt;/h1&gt;
&lt;p&gt;python2的http标准库&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;httplib for client&lt;/li&gt;
&lt;li&gt;BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, cookielib, Cookie for server&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;python3的标准库&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;http&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;python的url标准库&#34;&gt;python的url标准库&lt;/h1&gt;
&lt;p&gt;python2的url标准库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;urlparse&lt;/li&gt;
&lt;li&gt;urllib&lt;/li&gt;
&lt;li&gt;urllib2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;python3的url标准库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;urllib&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_builtins</title>
        <link>https://canuxcheng.com/post/psl_builtins/</link>
        <pubDate>Mon, 15 Aug 2016 11:16:29 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_builtins/</guid>
        <description>&lt;h1 id=&#34;builtins&#34;&gt;builtins&lt;/h1&gt;
&lt;p&gt;python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。&lt;/p&gt;
&lt;p&gt;包括内置类类型以及所属的内置方法，和内置函数.&lt;/p&gt;
&lt;p&gt;内置常量&lt;/p&gt;
&lt;p&gt;内置函数(BIF)&lt;/p&gt;
&lt;p&gt;内置类型(BIT)&lt;/p&gt;
&lt;p&gt;工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．&lt;/p&gt;
&lt;p&gt;内置类型的内置方法(BIM)&lt;/p&gt;
&lt;p&gt;内置异常&lt;/p&gt;
&lt;p&gt;该模块是通过C/C++实现的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import builtins # can be ignored
dir(builtins)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置特殊常量&#34;&gt;内置特殊常量&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;False # 内置类型bool的实例
True # 内置类型bool的实例
None # python的Null对象或types.NoneType,只有一个值None.布尔值始终为False.
NotImplemented # types.NotImplementedType
Ellipsis # types.EllipsisType, 省略对象，布尔值始终为True.
__debug__ # True/False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置函数&#34;&gt;内置函数&lt;/h1&gt;
&lt;p&gt;不需要import可以直接使用的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数

print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False) # python3新增

compile(source, filename, mode[, flags[, dont_inherit]])
# 编译source返回一个code对象(代码对象)．
# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;
module = &amp;quot;for i in xrange(10): print(i)&amp;quot;
code = compile(module, &#39;&#39;, &#39;exec&#39;)
type(code) # code
exec code
# mode: single, 用于单行语句, 也是用exec执行;
code = compile(&amp;quot;print &#39;test&#39;&amp;quot;, &#39;&#39;, single)
type(code) # code
exec code
# mode: eval, 用于表达式 可以用eval()函数执行． eg:
expression = &amp;quot;3 * 4&amp;quot;
code = compile(expression, &#39;&#39;, &#39;eval&#39;)
type(code) # code
eval(code)

eval(source[, globals[, locals]])
# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．

exec(object[, globals[, locals]]) # python3 新增
# object可以是一个文件对象，也可以是一个语句或代码块．

format(value[, format_spec]) # 返回格式化后的字符串形式．

## 环境变量相关
globals() # 返回当前作用域的全局名称空间的字典．
locals() # 返回当前作用域的局部名称空间的字典．

## 数字类型的数学运算
abs(number) # 返回int/long的绝对值
divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组
pow(x, y[, z]) # 返回x**y或(x**y) % z
round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.
chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 &amp;lt;= i &amp;lt; 256.
ord(c) # 返回字符ASCII字符c对应的整数.
bin(number) # 返回int/long的二进制的字符串形式
oct(number) # 返回int/long的八进制的字符串形式．
hex(number) # 返回int/long的十六进制的字符串形式.

## 对象相关的操作
id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.
repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.
ascii(object) # 和repr()函数等效．
callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()
hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.
len(object) # 返回序列（str, tuple, list)或映射（dict)的长度
dir([object]) # 查看对象的信息
getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．
hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.
setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value
delattr(object, name) # 删除对象object的属性name
isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.
issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．
vars([object]) # 没有参数等于locals()，有参数等于object.__dict__.

## related to iterable
min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素
min(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素
max(iterable[, key=func]) # 和min相反
max(a, b, c, ...[, key=func]) # 和min相反
all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,&#39;&#39;则返回True,iterable为空也返回True,否则返回False
any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,&#39;&#39;则返回False,　否则返回True
sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．

## related to iterator
iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.
iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．
next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．

## related to input
input([prompt]) # python3
# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.

## related to file
open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．

// python3 refactor
sorted(iterable, key=None, reverse=False)
// 多维数据排序
dict = {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 1}
sorted(dict.items(), key=lambda x:x[1], reverse=False)
json = [{&amp;quot;time&amp;quot;: 1, &amp;quot;data&amp;quot;: &amp;quot;message&amp;quot;}, {&amp;quot;time&amp;quot;: 2, &amp;quot;data&amp;quot;: &amp;quot;message&amp;quot;}]
sorted(json, key=lambda k:k[&amp;quot;time&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置异常类&#34;&gt;内置异常类&lt;/h1&gt;
&lt;p&gt;BaseException(object) # 所有异常的基类, 继承自object.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# BaseException的四个子类
SystemExit # python解释器请求退出
KeyboardInterrupt # 用户输入ctrl-c中断执行
GeneratorExit # 生成器发出异常来通知退出
Exception # 常规错误的基类
    StopIteration # 迭代器结束抛出的异常
    StandardError # 所有内置标准error的基类
        BufferError
        ArithmeticError # 数值计算错误的基类
            FloatingPointError
            OverflowError
            ZeroDivisionError # 除法分母为０错误
        AsseertionError # 断言语句失败
        AttributeError # 访问未知的对象属性
        EnvironmentError
            IOError # 打开不存在的磁盘文件导致的输入/输出错误
            OSError
                WindowError
                VMSError
        EOFError
        ImportError
        LookupError
            IndexError # 序列的索引错误
            KeyError # 字典的键错误
        MemoryError
        NameError # 未申明或初始化的对象
            UnboundLocalError
        ReferenceError
        RuntimeError # 一般的运行错误
            NotImplementedError # 尚未实现的方法
        SyntaxError # 语法错误， 唯一不在运行时发生的异常
            IndentationError # 缩进错误
                TabError # 跳格和空格混用
        SystemError # 一般的解释器系统错误
        TypeError # 对类型无效的操作
        ValueError # 传入无效的参数
            UnicodeError
                UnicodeDecodeError
                UnicodeEncodeError
                UnicodeTranslateError
    Warning # 所有warning的基类
       DeprecationWarning # 被弃用特征的警告
       RuntimeWarning # 可疑的运行时行为警告
       SyntaxWarning # 可疑的语法行为警告
       UserWarning # 用户代码生成的警告
       FutureWarning # 使用新的语法特征的警告
       ImportWarning # 导入包警告
       UnicodeWarning
       ByteWarning
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;built-in-typesclass&#34;&gt;built-in Types/Class&lt;/h1&gt;
&lt;p&gt;下面是数据类型：&lt;/p&gt;
&lt;h2 id=&#34;int&#34;&gt;int&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int(x=0)
int(x, base=10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bit_length() # 一个int类型的二进制形式的位数．
conjugate()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;denominator
numerator
imag
real
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;boolint&#34;&gt;bool(int)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bool(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置类类型int的内置方法和数据描述符都是继承自基类int.&lt;/p&gt;
&lt;h2 id=&#34;float&#34;&gt;float&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;float(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;as_integer_ratio() # 返回一个整数对，相除的结果是该浮点数
conjugate()
fromhex(string) # 将十六进制的字符转换成浮点型
# float.fromhex(&#39;-0x1p-1074&#39;)
hex() # 将浮点数转换成十六进制形式
is_integer() # 如果浮点数是整数，返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imag
real
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;complex&#34;&gt;complex&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;complex(real[, imag])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conjugate() # 返回一个复数的工軛复数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imag 复数的虚部
real 复数的实部
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;str&#34;&gt;str&lt;/h2&gt;
&lt;p&gt;字符串是不可变类型, 是标量，是序列．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str(object=&#39;&#39;) # 把一个对象转换成字符串．或者返回一个对象的可读性好的字符串表示，无法用语eval()求值．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;capitalize() # 字符串首字母大写, 返回新的字符串
title() # 所有单词首字母大写，返回新的字符串
lower() # 所有字符小写，返回新的字符串
upper() # 所有字符大写，返回新的字符串
swapcase() # 大写字符转换成小写，小写转化成大写
translate(table [,deletechars]) #
join(iterable) # 用字符串分割iterable,返回新的字符串
replace(old, new[, count]) # 用new替换字符串中的前count个old, 返回替换后的字符串
expandtabs([tabsize]) # 把字符串中的tab键替换为tabsize指定的宽度的新tab，默认是8,然后返回新的字符串
format(*args, **kwargs) # 返回格式化后的字符串

lstrip([chars]) # 如果字符串以chars开头,就删除开头chars，然后返回新的字符串, chars默认是空格．
strip([chars]) # 删除开头和结尾的chars,如果有的话，然后返回新的字符串，chars默认是空格．
rstrip([chars]) # 如果字符串以chars结尾，就删除结尾的chars,然后返回新的字符串，chars默认是空格．

center(width[, fillchar]) # 以字符串为中心填充字符串，默认用空格填充,返回填充后的字符串
zfill(width) # 用0填充字符串的左边，直到width长度，返回新的字符串
ljust(width[, fillchar]) # 字符串左对齐，右边填充fillchar,默认空格，直到长度为width,返回新的字符串
rjust(width[, fillchar]) # 字符串右对齐，左边填充fillchar，默认空格，直到长度为width,返回新的字符串

count(sub[, start[, end]]) # 返回sub字符串在str[start:end]中出现的次数

# 参考codecs模块的decode/encode.
decode([encoding[,errors]]) # 解码
encode([encoding[,errors]]) # 编码

startswith(prefix[, start[, end]]) # 如果str[start:end]以prefix开头，返回true.
endswith(suffix[, start[, end]]) # 如果str[start:end]以suffix结尾，返回true.
isalnum() # 如果非空字符串，且元素都是字符或数字，返回True,否则返回False
isalpha() # 如果非空字符串，且元素都是字符，返回True,否则返回False
isdigit() # 如果非空字符串，且元素都是数字，返回True,否则返回False
isspace() # 如果非空字符串，且所有元素都是空格，返回True,否则返回False
istitle() # 如果非空字符串，且所有单词的首字母大写，返回True,否则返回False
islower() # 如果非空字符串，且所有元素都是小写，返回True,否则返回False
isupper() # 如果非空字符串，且所有单词都是大写，返回True,否则返回False

splitlines(keepends=False) # 根据\n,\r,\r\n来拆分字符串，返回拆分后的列表，True表示保留换行符，默认是False．
split([sep [,maxsplit]]) # 将字符串以从左到右的maxsplit个seq分割，返回分割后的列表，默认seq是空格，maxsplit是所有seq．
rsplit([sep [,maxsplit]]) # 和split相反,从右到左的maxsplit个seq分割．

partition(sep) # 字符串根据从左往右根据第一个找到的seq分割，返回一个(head, seq, tail), 如果没有找到seq, 返回(str, &#39;&#39;, &#39;&#39;).
rpartition(sep) # 字符串根据最后一个找到的seq分割，返回(head, seq, tail),如果没有找到seq,返回(&#39;&#39;, &#39;&#39;, str)

find(sub [,start [,end]]) # 在str[start:end]中从左往右查找sub,返回找到的第一个字符所在的下标,没找到返回-1
rfind(sub [,start [,end]]) # 在str[start:end]中查找sub,返回最后一个sub的第一个元素的索引,没有找到返回-1

index(sub [,start [,end]]) # 和find一样，但是没找到抛出异常ValueError．
rindex(sub [,start [,end]]) # 和rfind一样，但是没找到抛出ValueError异常．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytes&#34;&gt;bytes&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bytes(iterable_of_ints) -&amp;gt; bytes
bytes(string, encoding[, errors]) -&amp;gt; bytes
bytes(bytes_or_buffer) -&amp;gt; immutable copy of bytes_or_buffer
bytes(int) -&amp;gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&amp;gt; empty bytes object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;capitalize()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytearray&#34;&gt;bytearray&lt;/h2&gt;
&lt;p&gt;bytearray表示可变字节数组类型, bytearray是可变类型，是序列（可迭代）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bytearray(iterable_of_ints) -&amp;gt; bytearray
bytearray(string, encoding[, errors]) -&amp;gt; bytearray
bytearray(bytes_or_buffer) -&amp;gt; mutable copy of bytes_or_buffer
bytearray(int) -&amp;gt; bytes array of size given by the parameter initialized with null bytes
bytearray() -&amp;gt; empty bytes array
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;append(int)
capitalize()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tuple&#34;&gt;tuple&lt;/h2&gt;
&lt;p&gt;元组是不可变类型, 是容器，是序列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tuple()
tuple(iterable) # 把可迭代对象转换成元组.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(value) # 返回值为value的元素在元组中出现的次数
index(value, [start, [stop]]) # 返回值为value的元素在元组tuple[start:stop]中的第一次出现的索引，没有该元素返回ValueError.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;list&#34;&gt;list&lt;/h2&gt;
&lt;p&gt;列表是可变类型,　是容器，是序列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list()
list(iterable) # 把可迭代的对象转换成列表．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(value) # 返回value在列表中出现的次数
index(value, [start, [stop]]) # 从左往右在list[start:stop]中寻找value,返回第一个找到的元素的索引，否则返回ValueError异常．

# 下列改变列表的值的方法都没有返回值，直接改变原列表的值, 返回None。
append(object) # 在列表结尾追加对象
extend(iterable) # 将可迭代对象iterable的元素依次追加到列表,相当于序列的+运算．
insert(index, object) # 在list[index]前面插入object.
pop([index]) # 删除list[index],默认是最后一个元素，如果列表为空或索引越界，抛出IndexError异常．
remove(value) # 删除第一个出现的value．
reverse() # 翻转列表, 返回None
sort(cmp=None, key=None, reverse=False) # 默认对列表中的元素从小到大排序，reverse=True,则从大到小．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dict&#34;&gt;dict&lt;/h2&gt;
&lt;p&gt;字典是可变类型, 是容器，是映射类型（mapping), 字典可以迭代键．字典是无序的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict()
dict(mapping) # dict(one=1, two=2)
dict(iterable) # dict([(1, &#39;one&#39;), (2, &#39;two&#39;)]), dict([[1,1], [2,2]]), dict(([1,1], [2, 2])), dict(((1,1), (2,2))),
dict(**kwargs) # dict({1:&amp;quot;one&amp;quot;, 2:&amp;quot;two&amp;quot;})

in, not in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy() # 返回字典的一个浅拷贝
clear() # 清空字典所有元素
fromkeys(S[,v]) # 返回以S的元素为键，v为值的新字典，v默认为None.
get(k[,d]) # 如果键k在字典里面，返回dict[k], 否则返回d, d默认为None.
pop(k[,d]) # 从字典中删除键k的键值对，返回dict[k], 如果不存在返回d,如果没有指定d,抛出KeyError异常．
popitem() # 从字典中删除随机的键值对，返回该键值对组成的元组，如果字典为空，抛出KeyError异常．
setdefault(k[,d]) # 如果键k在字典中存在，等效于get(k[,d]), 否则就插入D[k]=d键值对．
update([E, ]**F) # 向字典插入指定的项目(字典或可迭代对象).
keys() # 返回字典的键组成的列表．
values() # 返回字典的值组成的列表．
items() # 返回一个列表，每个元素是字典的键和值组成的元组．
iteritems() # 返回字典的键值对组成的迭代器，next()每次返回一个一对键值组成的元组．
iterkeys() # 返回字典的键组成的迭代器．
itervalues() # 返回字典的值组成的迭代器．
viewitems() # 返回键和值组成的可迭代对象
viewkeys()　# 返回键组成的可迭代对象
viewvalues() # 返回值组成的可迭代对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;frozenset&#34;&gt;frozenset&lt;/h2&gt;
&lt;p&gt;不可变集合frozenset是不可变类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;frozenset()
frozenset(iterable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不可变集合和可变集合共同的内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy() # 返回集合的一个浅拷贝
isdisjoint() # 两个集合交集为空，返回为True.
a.issubset(b) # a是b的非严格子集，　a &amp;lt;= b, 返回True
a.issuperset(b) # a是b的非严格超集, a &amp;gt;= b, 返回True
union() # 联合/并集，OR操作，等效于|运算符
intersection([others, ...]) # 交集，　AND操作，　等效于&amp;amp;运算符
difference([others, ...]) # 差补或相对补充集，等效于-运算符
symmetric_difference() # 对称差分或异或，等效于^运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;p&gt;可变集合set是可变类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set()
set(iterable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set除了有frozenset的所有方法还有自己特有的内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear() # 清空集合所有元素
pop() # 删除并返回任意一个集合元素，集合为空抛出KeyError.
add(obj) # 往集合中添加一个不存在的元素
remove(obj) # 删除集合中的存在的指定的数字元素, 非数字抛出KeyError.
s.discard(obj) # 如果obj是集合s中的元素，从s中删除obj.

update() # 等效于|=运算符
intersection_update() # 等效于&amp;amp;=运算符
difference_update() # 等效于-=运算法
symmetric_difference_update() # 等效于^=运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;slice(stop)
slice(start, stop[, step])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indices(len) -&amp;gt; (start, stop, stride)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;range&#34;&gt;range&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;range(stop) # 返回[0, 1, stop-1]的列表
range(start, stop[, step]) # 返回[start, start+n*step... ], n&amp;gt;=1,start+n*step&amp;lt;stop.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(self, object, /)
index(self, object, /)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;memoryview&#34;&gt;memoryview&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;memoryview(object)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cast(self, /, format, shape=&amp;lt;unrepresentable&amp;gt;)
hex(self, /, sep=&amp;lt;unrepresentable&amp;gt;, bytes_per_sep=1)
release(self, /)
tobytes(self, /, order=&#39;C&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;format
itemsize
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;迭代器/生成器类&lt;/p&gt;
&lt;h2 id=&#34;enumerate&#34;&gt;enumerate&lt;/h2&gt;
&lt;h2 id=&#34;reversed&#34;&gt;reversed&lt;/h2&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;h2 id=&#34;filter&#34;&gt;filter&lt;/h2&gt;
&lt;h2 id=&#34;zip&#34;&gt;zip&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;classmethod&#34;&gt;classmethod&lt;/h2&gt;
&lt;h2 id=&#34;staticmethod&#34;&gt;staticmethod&lt;/h2&gt;
&lt;h2 id=&#34;property&#34;&gt;property&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;
&lt;p&gt;object类是所有类的基类&lt;/p&gt;
&lt;h2 id=&#34;type&#34;&gt;type&lt;/h2&gt;
&lt;p&gt;所有类的类型或元类&lt;/p&gt;
&lt;p&gt;type是用来创建类的类，可以动态创建类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class type(object)
    type(object) -&amp;gt; the object&#39;s type
    type(name, bases, dict, **kwds) -&amp;gt; a new type
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Concurrency</title>
        <link>https://canuxcheng.com/post/psl_concurrency/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_concurrency/</guid>
        <description>&lt;h1 id=&#34;concurrent-execution&#34;&gt;Concurrent Execution&lt;/h1&gt;
&lt;p&gt;进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。&lt;/p&gt;
&lt;p&gt;线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。&lt;/p&gt;
&lt;p&gt;IPC: 进程/线程之间交换信息叫进程间通信．&lt;/p&gt;
&lt;p&gt;python的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.&lt;/p&gt;
&lt;p&gt;IO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.&lt;/p&gt;
&lt;p&gt;python的多进程可以并行,每个进程启动一个解释器进程.&lt;/p&gt;
&lt;p&gt;多进程开销大，消耗内存.&lt;/p&gt;
&lt;p&gt;计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.&lt;/p&gt;
&lt;p&gt;io密集 =》 用异步asyncio或者多线程
计算密集 =》 用多进程&lt;/p&gt;
&lt;h2 id=&#34;multiprocessing&#34;&gt;multiprocessing&lt;/h2&gt;
&lt;p&gt;多进程就是同时执行多个任务.&lt;/p&gt;
&lt;p&gt;python可以通过多进程取代多线程，从而绕过多线程的GIL.&lt;/p&gt;
&lt;p&gt;python是静态语言，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import multiprocessing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# multiprocessing.Process
proc = Process(group=None, target=None, name=None, args=(), kwargs={})
# methods:
run(self)
start(self) # 启动一个进程
join(self, timeout=None) # 父进程等待子进程结束
is_alive()
terminate(self)
# data descriptor:
authkey
daemon # proc.daemon = True 后台运行
exitcode
ident
name
pid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 普通函数
active_children()
allow_connection_pickling()
cpu_count() # 获取cpu个数
current_process()
freeze_support()
get_logger()
log_to_stderr(level=None)

Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)
pool = Pool()
# func只能是顶层函数，不能是方法和内部函数.
# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())
# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.
apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,
map_async(func, iterable, chunksize=None, callback=None) # 非阻塞
# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.
apply(func, args=(), kwargs={}) # 阻塞
map(func, itreable, chunksize=None) # 阻塞
terminate() # 终止所有任务
close() # 关闭pool,不接受新任务
join() # 等待pool中子进程结束，要在close/terminate之后调用.

# IPC: 管道
Pipe(duplex=True) # duplex=True表示默认是双向pipe.
receiver, sender = Pipe()
sender.send(obj)
receiver.recv()
close()

# IPC: 消息队列
# 来自于Queue.Queue, 具体方法参考Queue.Queue
Queue(maxsize=0) # return a queue object
q = Queue()

# IPC: 共享内存
Manager()
list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array

Array(typecode_or_type, size_or_initializer, **kwds)

RawArray(typecode_or_type, size_or_initializer)

Value(typecode_or_type, *args, **kwds)

RawValue(typecode_or_type, *args)

Event()

# 同步：　条件变量
Condition(lock=None)

# 同步：信号量
Semaphore(value=1)

# 同步：有界信号量
BoundedSemaphore(value=1)

# 同步： 锁
Lock()

# 同步: 锁
RLock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SUBDEBUG = 5
SUBWARNING = 25
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;threading&#34;&gt;threading&lt;/h2&gt;
&lt;p&gt;多线程就是把单个任务分成不同部分运行.&lt;/p&gt;
&lt;p&gt;threading支持守护线程(通过join方法实现)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import threading
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# threading.Thread
t = Thread(group=None, target=None, name=None, args=(), kwargs=None, verbose=None)
threads.append(t)
# methods:
run(self) # 子类重写用来定义线程的功能的函数, 通常通过这种方式来创建线程
start(self) # 开始执行线程
join(self, timeout=None) # 主程序挂起，直到线程结束,再继续运行主程序
is_alive(self) # 表示线程是否还在运行的boolean
getName(self) # 返回线程名字
setName(self, name) # 设置线程名字
isDaemon(self) # 返回线程的daemon标志
setDaemon(self, daemonic) # daemonic=True 使线程在后台运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;active_count() # 当前活动的线程对象的数量
current_thread() # 返回当前线程对象
enumerate() # 返回当前活动线程列表
settrace(func) # 为所有的线程设置一个跟踪函数
setprofile(func) # 为所有线程设置一个profile函数
stack_size()

Timer(*args, **kwargs)
t = Timer(30.0, f, args=[], kwargs={})
t.start() # 在一个子线程等待，timeout就执行f(*args, **kwaargs).
t.cancel() # 如果还在等待就取消．

Event(*args, **kwargs)

# 同步：　条件变量
Condition(*args, **kwargs)

# 同步：　信号量
Semaphore(value=1, *args, **kwargs)
# 信号量，默认value=1, 内部计数器不能小于0,当计数器==0时，调用acquire会阻塞.

# 同步：　有界信号量
BoundedSemaphore(value=1, *args, **kwargs)
# 有界信号量，默认value=1，内部计数器不能小于0，并且不能大于value。
# 当计数器==0，调用acquire会阻塞，当&amp;gt;value抛出VAlueError异常
# 可用来控制并发运行的线程数量
bs = BoundSemaphore(number) # bs是全局的.
def thread_function(*args, **kwargs):
    ...
    bs.release() # 使计数器+1
for t in threads:
    bs.acquire() # 使计数器-1
    thread.start()
for t in threads:
    t.join()

# 同步：　锁
Lock()
# 使同一变量在多个线程间同步
lock = Lock()
variable = value
def thread_function(*args, **kwargs):
    global lock
    global variable
    lock.acquire() # 加锁，使线程进入同步阻塞状态
    variable = new_value
    lock.release() # 释放锁

# 同步：　锁
RLock(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;subprocess&#34;&gt;subprocess&lt;/h2&gt;
&lt;p&gt;开启一个子进程来执行外部命令.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import subprocess
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Popen(args,
bufsize=0, executable=None, stdin=None, stdout=None, stderr=None,
preexec_fn=None, close_fds=False, shell=False,cwd=None,
env=None, universal_newlines=False,startupinfo=None, creationflags=0)
# p = Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
# 如果命令和参数是字符串形式，需要参数shell=True
# p = Popen(command_string, shell=True, ...)

# 非交互执行sudo命令, 或者使用sh/pexpect等第三方库
Popen([&#39;sudo&#39;, &#39;-S&#39;] + shlex.split(command), stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, ...)
stdout, stderr = child.communicate(password+&#39;\n&#39;)

# methods:
poll() # 检查子进程是否结束，返回returncode.
wait() # 等待子进程结束，返回returncode.
communicate(input=None) # 返回(stdout, stderr).
kill() # 发送SIGKILL信号
pipe_cloexec()
send_signal(sig)
terminate()

# Data:
stdin
stdout
stderr
pid
returncode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call(*popenargs, **kwargs)
# retcode = call([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;])

check_call(*popenargs, **kwargs)
# check_call([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;]) -&amp;gt; 如果返回码为０就返回，否则抛出CalledProcessError.

check_output(*popenargs, **kwargs) # 返回一个字符串
# output = check_output([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;, &amp;quot;/dev/null&amp;quot;]) -&amp;gt; 如果返回码为０返回命令结果，否则抛出CalledProcessError.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PIPE = -1
STDOUT = -2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;concurrent&#34;&gt;concurrent&lt;/h2&gt;
&lt;p&gt;concurrent模块提供了多线程和多进程的高级接口.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import concurrent.futures
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sched&#34;&gt;sched&lt;/h2&gt;
&lt;h2 id=&#34;queue&#34;&gt;queue&lt;/h2&gt;
&lt;h2 id=&#34;contextvars&#34;&gt;contextvars&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;inter-process-communication-and-networking&#34;&gt;Inter Process Communication and Networking&lt;/h1&gt;
&lt;p&gt;IPC&lt;/p&gt;
&lt;h2 id=&#34;socket&#34;&gt;socket&lt;/h2&gt;
&lt;p&gt;socket协议的标准库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import socket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# socket = class _socketobject(__builtin__.object)
# socket.socket([family[, type[, proto]]])
close() # 关闭socket
shutdown(flag) # 0 关闭读，１关闭写，２全部关闭
# eg: socket.socket(AF_INET, SOCK_STREAM, 0) ipv4+tcp
# eg: socket.socket(AF_INET, SOCK_DGRAM, 0) ipv4+udp

# methods:
bind(address) # 服务器绑定(host, port)到socket
listen(backlog) # 服务器开始监听tcp
accept() # 服务器阻塞等待客户的tcp连接, 返回(socket object, address info)

connect(address) # 客户端主动初始化tcp连接,连接失败抛出异常
connect_ex(address) # 同上，连接失败返回errno

send(data[, flags]) # 发送tcp数据
sendall(data[, flags]) # 发送完整tcp数据
recv(buflen[, flags]) # 接收tcp数据
recv_into(buffer[, nbytes[, flags]])

sendto(data[, flags], addr) # 发送udp数据
recvfrom(buflen[, flags]) # 接收udp数据
recvfrom_into(buffer[, nbytes, [, flags])])

getpeername() # 获取当前socket的远端地址
getsockname() # 获取当前socket的地址
getsockopt(level, option[, buffersize]) # 获取socket参数
setsockopt(level, option, value) # 设置socket参数

setblocking(flag)
gettimeout()
settimeout(timeout)

makefile([mode[, bufsize]])
fileno()

dup()

# data descriptor:
family/type/proto　参考man 2 socket
recv
recv_into
recvfrom
recvfrom_into
send
sendto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class SocketIO:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SocketIO(io.RawIOBase)
sio = SocketIO(sock, mode)

methods:
close()
readinto(b)
write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create_connection(address, timeout=&amp;lt;object object&amp;gt;, source_address=None)
fromfd(fd, family, type[, proto]) # 用一个已经打开的文件描述符创建一个socket对象
getaddrinfo(host, port [, family, socktype, proto, flags])
getdefaulttimeout()
getfqdn(name=&#39;&#39;) # FQDN, 获取完整域的信息
gethostbyaddr(host) -&amp;gt; (name, aliaslist, addresslist)
gethostbyname(host)
gethostbyname_ex(host) -&amp;gt; (name, aliaslist, addresslist)
gethostname()
getnameinfo(sockaddr, flags) --&amp;gt; (host, port)
getprotobyname(name)
getservbyname(servicename[, protocolname])
getservbyport(port[, protocolname])
htonl(integer)
htons(integer)
inet_aton(string)
inet_ntoa(packed_ip)
inet_ntop(af, packed_ip)
inet_pton(af, ip)
ntohl(integer)
ntohs(integer)
setdefaulttimeout(timeout)
socketpair([family[, type[, proto]]]) -&amp;gt; (socket object, socket object)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;asyncio&#34;&gt;asyncio&lt;/h2&gt;
&lt;p&gt;核心异步事件循环库，提供协程、事件循环、任务、Future、队列等核心机制。&lt;/p&gt;
&lt;p&gt;asyncio 往往是构建 IO 密集型和高层级 结构化 网络代码的最佳选择。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import asyncio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;async/await:&lt;/p&gt;
&lt;p&gt;async def 定义一个协程函数，await 用来等待协程的执行结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async def say():
    print(&amp;quot;Hello&amp;quot;)
    await asyncio.sleep(1)
    print(&amp;quot;World&amp;quot;)
asyncio.run(say())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# asyncio.Runner
runner = Runner()
asyncio.run(runner.run(coro, *, debug=False)) # 运行一个协程，返回协程结果

# asyncio.Task
task = Task(coro, *, loop=None)
create_task(coro, *, loop=None) # 创建一个任务，返回Task对象, 协程马上运行。

# asyncio.TaskGroup
task_group = TaskGroup(*, loop=None)

# asyncio.Queue
queue = Queue(maxsize=0, *, loop=None)
# methods:
put(item) # 放入一个元素到队列
get() # 从队列中获取一个元素
task_done() # 标记一个任务完成
join() # 阻塞直到队列中的所有任务都完成
empty() # 返回队列是否为空
full() # 返回队列是否已满
qsize() # 返回队列的大小
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gather(*coros, loop=None) 
sleep(delay, result=None, *, loop=None) # 异步睡眠，返回一个Future对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ssl&#34;&gt;ssl&lt;/h2&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;h2 id=&#34;selectors&#34;&gt;selectors&lt;/h2&gt;
&lt;h2 id=&#34;signal&#34;&gt;signal&lt;/h2&gt;
&lt;h2 id=&#34;mmap&#34;&gt;mmap&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Python</title>
        <link>https://canuxcheng.com/post/psl_python/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_python/</guid>
        <description>&lt;h1 id=&#34;python-runtime-services&#34;&gt;Python Runtime Services&lt;/h1&gt;
&lt;h2 id=&#34;builtins&#34;&gt;builtins&lt;/h2&gt;
&lt;p&gt;builtins - Built-in functions, exceptions, and other objects.&lt;/p&gt;
&lt;p&gt;python2叫__builtin__&lt;/p&gt;
&lt;p&gt;python3叫builtins&lt;/p&gt;
&lt;h2 id=&#34;_main_&#34;&gt;_&lt;em&gt;main&lt;/em&gt;_&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt; - Top-level script environment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当作为顶层脚本运行时(&lt;strong&gt;main&lt;/strong&gt;), 当作为一个模块运行时候就是模块名称．&lt;/p&gt;
&lt;h2 id=&#34;_future_&#34;&gt;_&lt;em&gt;future&lt;/em&gt;_&lt;/h2&gt;
&lt;p&gt;把下一个版本的新特性导入到当前版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import &amp;lt;feature_name&amp;gt;

# feature name:
all_feature_names # 一次导入所有feature
absolute_import # 绝对导入
division
generators
nested_scopes
print_function
unicode_literals # python2中u&#39;string&#39;才表示unicode, &#39;string&#39;表示str，python3中所有字符串都是unicode。
with_statement
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;all_feature_names
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sys&#34;&gt;sys&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import sys
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dynamic objects:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 动态对象
sys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc
sys.path # 搜索的路径．import导入模块的搜索路径．
sys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来．
sys.stdin # 标准输入，用于input()
sys.stdout # 标准输出，用于print
sys.stderr # 标准出错
displayhook -- called to show results in an interactive session
excepthook --
last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback --
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Static objects:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 静态对象
float_info -- a dict with information about the float inplementation.
long_info -- a struct sequence with information about the long implementation.
maxint -- the largest supported integer (the smallest is -maxint-1).
maxsize -- the largest supported length of containers.
maxunicode -- the largest supported character
builtin_module_names -- tuple of module names built into this interpreter
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
hexversion -- version information encoded as a single integer
copyright -- copyright notice pertaining to this interpreter
platform -- platform identifier # 可以判断操作系统类型
sys.platform # &#39;win32&#39;, &#39;linux2&#39;, &#39;darwin&#39;
executable -- absolute path of the executable binary of the Python interpreter
prefix -- prefix used to find the Python library
exec_prefix -- prefix used to find the machine-specific Python library
float_repr_style -- string indicating the style of repr() output for floats
__stdin__ -- the original stdin; don&#39;t touch!
__stdout__ -- the original stdout; don&#39;t touch!
__stderr__ -- the original stderr; don&#39;t touch!
__displayhook__ -- the original displayhook; don&#39;t touch!
__excepthook__ -- the original excepthook; don&#39;t touch!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;displayhook() -- print an object to the screen, and save it in __builtin__._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- 返回当前异常的线程安全的三个信息．type, value, traceback.
exc_clear() -- 清空当前线程的异常状态
exit() -- 抛出 SystemExit 异常退出解释器
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flags # 命令行的状态，-d debug, -v verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysconfig&#34;&gt;sysconfig&lt;/h2&gt;
&lt;h2 id=&#34;warnings&#34;&gt;warnings&lt;/h2&gt;
&lt;p&gt;python的警告模块，只警告，不中断程序运行．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import warnings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warn(message[, category[, stacklevel]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;contextlib&#34;&gt;contextlib&lt;/h2&gt;
&lt;p&gt;编写上下文管理器的模块．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import contextlib
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;abc&#34;&gt;abc&lt;/h2&gt;
&lt;p&gt;实现抽象方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# abc.ABCMeta
ABCMeta

# abc.abstractproperty
abstractproperty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstractmethod(funcobj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;atexit&#34;&gt;atexit&lt;/h2&gt;
&lt;h2 id=&#34;traceback&#34;&gt;traceback&lt;/h2&gt;
&lt;p&gt;For python stack traces. 追踪python的堆栈信息．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import traceback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extract_stack(f=None, limit=None)
extract_tb(tb, limit=None)
format_stack(f=None, limit=None)
format_tb(tb, limit=None) # 格式化后返回字符串
print_stack(f=None, limit=None, file=None)
print_tb(tb, limit=None, file=None) # 直接打印stacktrace信息
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gc&#34;&gt;gc&lt;/h2&gt;
&lt;p&gt;garbage collector：python的垃圾回收模块．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import gc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;inspect&#34;&gt;inspect&lt;/h2&gt;
&lt;p&gt;从运行的python对象获取有用的信息．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import inspect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classify_class_attrs(cls)
stack(context=1)
isgenerator()
isgeneratorfunction() # 检查一个函数是否是生成器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;site&#34;&gt;site&lt;/h2&gt;
&lt;h2 id=&#34;dataclass&#34;&gt;dataclass&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;custom-python-interpreter&#34;&gt;Custom python interpreter&lt;/h1&gt;
&lt;h2 id=&#34;code&#34;&gt;code&lt;/h2&gt;
&lt;h2 id=&#34;codeop&#34;&gt;codeop&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python-language-services&#34;&gt;Python language services&lt;/h1&gt;
&lt;h2 id=&#34;ast&#34;&gt;ast&lt;/h2&gt;
&lt;h2 id=&#34;dis&#34;&gt;dis&lt;/h2&gt;
&lt;h2 id=&#34;keyword&#34;&gt;keyword&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>PSL_System</title>
        <link>https://canuxcheng.com/post/psl_system/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_system/</guid>
        <description>&lt;h1 id=&#34;generic-operating-system-services&#34;&gt;Generic Operating System Services&lt;/h1&gt;
&lt;h2 id=&#34;os&#34;&gt;os&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import os

os.path # 参考PSL_File
os.name
os.curdir
os.pardir # 表示上一级路径.., 需要用abspath解析
# os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))
os.sep
os.extsep
os.altsep
os.pathsep
os.linesep
os.defpath
os.devnull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WCOREDUMP(...)
...

abort(...)
fork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程．
exec*
wait() # 等待子进程结束，返回(pid, status).
waitpid(pid, options) # 等待指定子进程结束.
listdir(path) # 列出目录下的文件和目录
makedirs(path [, mode=0o777], exist_ok=False)
mkdir(path [, mode=0777])
walk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器
remove(path) # 删除文件
rmdir(path) # 删除目录
removedirs(path)
symlink(src, dst)
chown(path, uid, gid)
chmod(path, mode=0o777)
...

# 使用subprocess模块代替下列函数：
system(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果．
spawn*
popen*(command [, mode=&#39;r&#39; [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EX_CANTCREAT = 73
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;time&#34;&gt;time&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clock()
sleep(seconds) # 延迟
tzset()

# 获取时间戳(Epoch seconds)
time() # 获取当前时间戳
mktime(tuple) # mktime((2017,8,23,11,7,10,12)) , 参数是时间元组

# 获取时间元组 (tm_year,tm_mon,tm_mday,tm_hour,tm_min, tm_sec,tm_wday,tm_yday,tm_isdst)
localtime([seconds]) # 参数是时间戳
gmtime([seconds]) # 参数是时间戳
strptime(string, format) # 参数是时间字符串

# 获取时间字符串
asctime([tuple]) # 参数是时间元组
strftime(format[, tuple]) # 参数是时间元组
ctime(seconds) # 参数是时间戳
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;logging&#34;&gt;logging&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import logging
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Logger(Filterer)
# methods:
setLevel(self, level) # 只会输出指定level以上的log, 默认是WARNING
critical(self, msg, *args, **kwargs) # 50
error(self, msg, *args, **kwargs) # 40
warning(self, msg, *args, **kwargs) # 30
info(self, msg, *args, **kwargs) # 20
debug(self, msg, *args, **kwargs) # 10
exception(self, msg, *args, **kwargs) #
log(self, level, msg, *args, **kwargs) #
addHandler(self, hdlr) # 添加handler到logger

Formatter
# %(asctime)s:%(levelname)s:%(name)s:%(message)s&#39;
Formatter(fmt=None, datefmt=None)

Handler(Filterer)
# methods:
setFormatter(self, fmt)
setLevel(self, level)

StreamHandler(Handler) # 默认打印到sys.stderr
StreamHandler(stream=None)

FileHandler(StreamHandler) # 打印到文件
FileHandler(filename, mode=&#39;a&#39;, encoding=None, delay=0)

# from logging.handlers import *
WatchedFileHandler
RotatingFileHandler
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basicConfig(**kwargs) # 设置log的格式
# filename/filemode/format/datefmt/level/stream
# format默认是BASIC_FORMAT.
# level默认是warning/warn.
# stream默认是sys.stderr,当filename和stream同时指定，stream被忽略．
# datafmt
# filename 日志文件名
# filemode w每次覆盖写入，a每次追加写入

getLogger(name=None) # 返回Logger类型对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BASIC_FORMAT = &#39;%(levelname)s:%(name)s:%(message)s&#39;
CRITICAL = 50
FATAL = 50
ERROR = 40
WARN = 30
WARNING = 30
INFO = 20
DEBUG = 10
NOTSET = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;platform&#34;&gt;platform&lt;/h2&gt;
&lt;h2 id=&#34;errno&#34;&gt;errno&lt;/h2&gt;
&lt;h2 id=&#34;ctypes&#34;&gt;ctypes&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;command-line-interface&#34;&gt;Command Line Interface&lt;/h1&gt;
&lt;h2 id=&#34;argparse&#34;&gt;argparse&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import argparse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# argparse.ArgumentParser(_AttributeHolder, _ActionsContainer)
parser = argparse.ArgumentParser()
    prog -- The name of the program (default: sys.argv[0])
    usage -- A usage message (default: auto-generated from arguments)
    description -- A description of what the program does
    epilog -- Text following the argument descriptions
    parents -- Parsers whose arguments should be copied into this one
    formatter_class -- HelpFormatter class for printing help messages
    prefix_chars -- Characters that prefix optional arguments
    fromfile_prefix_chars -- Characters that prefix files  containing additional arguments
    argument_default -- The default value for all arguments
    conflict_handler -- String indicating how to handle conflicts
    add_help -- Add a -h/-help option
# methods:
add_argument_group(self, *args, **kwargs) # -&amp;gt; argparse._ArgumentGroup
add_argument(self, *args, **kwargs)
    name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.
    action - The basic type of action to be taken when this argument is encountered at the command line.
    nargs - The number of command-line arguments that should be consumed.
    const - A constant value required by some action and nargs selections.
    default - The value produced if the argument is absent from the command line.
    type - The type to which the command-line argument should be converted.
    choices - A container of the allowable values for the argument.
    required - Whether or not the command-line option may be omitted (optionals only).
    help - A brief description of what the argument does. # 用来打印默认值：%(default)s
    metavar - A name for the argument in usage messages.
    dest - The name of the attribute to be added to the object returned by.
add_subparsers(self, **kwargs) # -&amp;gt; argparse._SubParsersAction
add_mutually_exclusive_group(self, **kwargs)
set_defaults(self, **kwargs)
parse_args(self, args=None, namespace=None) # -&amp;gt; argparse.Namespace
parse_known_args(self, args=None, namespace=None) # -&amp;gt; argparse.Namespace
convert_arg_line_to_args(self, arg_line)
error(self, message)
exit(self, status=0, message=None)
format_help(self)
format_usage(self)
format_version(self)
print_help(self, file=None)
print_usage(self, file=None)
print_version(self, file=None)
get_default(self, dest)
register(self, registry_name, value, object)

# argparse._ArgumentGroup
# methods:
add_argument(self, *args, **kwargs)
add_argument_group(self, *args, **kwargs)
add_mutually_exclusive_group(self, **kwargs)
get_default(self, dest)
register(self, registry_name, value, object)
set_defaults(self, **kwargs)

# argparse._SubParsersAction
# methods:
add_parser(self, name, **kwargs) # -&amp;gt; argparse.ArgumentParser

# HelpFormatter

# Action
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;optparse&#34;&gt;optparse&lt;/h2&gt;
&lt;h2 id=&#34;getpass&#34;&gt;getpass&lt;/h2&gt;
&lt;h2 id=&#34;curses&#34;&gt;curses&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/psl/mycurses.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/psl/mycurses.py&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import curses
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fileinput&#34;&gt;fileinput&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unixlinux-sytem&#34;&gt;Unix/Linux sytem&lt;/h1&gt;
&lt;h2 id=&#34;pwd&#34;&gt;pwd&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据用户名获取uid和gid
pw = getpwnam(user)  
pw.pw_uid
pw.pw_gid

getpwuid(uid)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;grp&#34;&gt;grp&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import grp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;group = group.getgrnam(&amp;lt;group_name&amp;gt;)
group.gr_name // 返回组名
group.gr_mem // 返回该组的所有用户
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_GUI</title>
        <link>https://canuxcheng.com/post/psl_gui/</link>
        <pubDate>Mon, 15 Aug 2016 10:28:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_gui/</guid>
        <description>&lt;h1 id=&#34;gui&#34;&gt;GUI&lt;/h1&gt;
&lt;h2 id=&#34;tkinter&#34;&gt;Tkinter&lt;/h2&gt;
&lt;h2 id=&#34;ttk&#34;&gt;ttk&lt;/h2&gt;
&lt;h2 id=&#34;tix&#34;&gt;Tix&lt;/h2&gt;
&lt;h2 id=&#34;scrolledtext&#34;&gt;ScrolledText&lt;/h2&gt;
&lt;h2 id=&#34;turtle&#34;&gt;turtle&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;wxwidgets&#34;&gt;wxWidgets&lt;/h2&gt;
&lt;p&gt;python2的库叫wxPython.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wxpython.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wxpython.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Windows下载安装包安装即可．
$ sudo apt-get install python-wxgtk2.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python３启用新的项目phoneix.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxWidgets/Phoenix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wxWidgets/Phoenix&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gtk&#34;&gt;gtk&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;PyGTK
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;qt&#34;&gt;qt&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;PyQt
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_Misc</title>
        <link>https://canuxcheng.com/post/psl_misc/</link>
        <pubDate>Mon, 15 Aug 2016 10:28:46 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_misc/</guid>
        <description>&lt;h1 id=&#34;psl&#34;&gt;PSL&lt;/h1&gt;
&lt;p&gt;Python Standard Library: Python标准库&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;internationalization&#34;&gt;Internationalization&lt;/h1&gt;
&lt;h2 id=&#34;gettext&#34;&gt;gettext&lt;/h2&gt;
&lt;h2 id=&#34;locale&#34;&gt;locale&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;program-frameworks&#34;&gt;Program Frameworks&lt;/h1&gt;
&lt;h2 id=&#34;cmd&#34;&gt;cmd&lt;/h2&gt;
&lt;h2 id=&#34;shlex&#34;&gt;shlex&lt;/h2&gt;
&lt;p&gt;类shell的词法分析．&lt;/p&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shlex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;split(s, comments=False, posix=True)
# split(&amp;quot;command **kwargs&amp;quot;) -&amp;gt; [&#39;command&#39;, &#39;arg1&#39;, ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;custom-python-interpreters&#34;&gt;Custom Python Interpreters&lt;/h1&gt;
&lt;h2 id=&#34;code&#34;&gt;code&lt;/h2&gt;
&lt;h2 id=&#34;codeop&#34;&gt;codeop&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python-language-services&#34;&gt;Python Language Services&lt;/h1&gt;
&lt;h2 id=&#34;keyword&#34;&gt;keyword&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import keyword
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keyword.iskeyword(keyword) # x.__contains__(y) &amp;lt;==&amp;gt; y in x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keyword.kwlist # 返回所有关键字的列表
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;parser&#34;&gt;parser&lt;/h2&gt;
&lt;h2 id=&#34;ast&#34;&gt;ast&lt;/h2&gt;
&lt;h2 id=&#34;symtable&#34;&gt;symtable&lt;/h2&gt;
&lt;h2 id=&#34;symbol&#34;&gt;symbol&lt;/h2&gt;
&lt;h2 id=&#34;token&#34;&gt;token&lt;/h2&gt;
&lt;h2 id=&#34;tokenize&#34;&gt;tokenize&lt;/h2&gt;
&lt;h2 id=&#34;tabnanny&#34;&gt;tabnanny&lt;/h2&gt;
&lt;h2 id=&#34;pyclbr&#34;&gt;pyclbr&lt;/h2&gt;
&lt;h2 id=&#34;py_compile&#34;&gt;py_compile&lt;/h2&gt;
&lt;h2 id=&#34;compileall&#34;&gt;compileall&lt;/h2&gt;
&lt;h2 id=&#34;dis&#34;&gt;dis&lt;/h2&gt;
&lt;h2 id=&#34;pickletools&#34;&gt;pickletools&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;importing-modules&#34;&gt;Importing Modules&lt;/h1&gt;
&lt;h2 id=&#34;imp&#34;&gt;imp&lt;/h2&gt;
&lt;h2 id=&#34;importlib&#34;&gt;importlib&lt;/h2&gt;
&lt;h2 id=&#34;zipimport&#34;&gt;zipimport&lt;/h2&gt;
&lt;h2 id=&#34;pkgutil&#34;&gt;pkgutil&lt;/h2&gt;
&lt;h2 id=&#34;modulefinder&#34;&gt;modulefinder&lt;/h2&gt;
&lt;h2 id=&#34;runpy&#34;&gt;runpy&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;miscellaneous-services&#34;&gt;Miscellaneous Services&lt;/h1&gt;
&lt;h2 id=&#34;formatter&#34;&gt;formatter&lt;/h2&gt;
&lt;h2 id=&#34;ihooks&#34;&gt;ihooks&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>PSL_Cryptographic</title>
        <link>https://canuxcheng.com/post/psl_cryptographic/</link>
        <pubDate>Sun, 14 Aug 2016 21:15:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_cryptographic/</guid>
        <description>&lt;h1 id=&#34;cryptographic-services&#34;&gt;Cryptographic Services&lt;/h1&gt;
&lt;h2 id=&#34;hashlib&#34;&gt;hashlib&lt;/h2&gt;
&lt;p&gt;哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．&lt;/p&gt;
&lt;p&gt;MD5: Message Digest Algorithm 5.&lt;/p&gt;
&lt;p&gt;SHA1: Secure Hash Algorithm.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import hashlib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# methods:
# 哈希对象有下列方法：
update(arg) # 更新字符串
md5.update(&#39;string or read from a file&#39;) # 放入需要转换的内容

digest() # 字符串
hexdigest() # 十六进制字符串
md5.hexdigest() # 获取md5十六进制字符串

copy() # 复制哈希对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 下类函数都返回哈希对象
new(name, string=&#39;&#39;)
md5()
md5 = hashlib.md5() # 创建一个md5的hash对象
sha1()
sha224()
sha256()
sha384()
sha512()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hmac&#34;&gt;hmac&lt;/h2&gt;
&lt;h2 id=&#34;secrets&#34;&gt;secrets&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;pycrypto&#34;&gt;pycrypto&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dlitz/pycrypto&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dlitz/pycrypto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows需要MS Visual C++ compiler for python2.7.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install pycrypto
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ecdsa&#34;&gt;ecdsa&lt;/h2&gt;
&lt;p&gt;pure-python ECDSA signature/verification&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/warner/python-ecdsa&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/warner/python-ecdsa&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install ecdsa
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pygpgme&#34;&gt;pygpgme&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi/pygpgme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi/pygpgme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A Python wrapper for the GPGME library.&lt;/p&gt;
&lt;p&gt;Windows安装失败？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 需要先安装gpgme的开发库
$ sudo apt-get install libgpgme11-dev
$ pip install pygpgme
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_Data</title>
        <link>https://canuxcheng.com/post/psl_data/</link>
        <pubDate>Sun, 14 Aug 2016 20:57:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_data/</guid>
        <description>&lt;h1 id=&#34;text-processing-services&#34;&gt;Text Processing Services&lt;/h1&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ascii_letters
ascii_lowercase
ascii_uppercase
digits
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;re&#34;&gt;re&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import re
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile(pattern, flags=0)
escape(pattern)
findall(pattern, string, flags=0)
finditer(pattern, string, flags=0)
match(pattern, string, flags=0) # if not match, return None, else return object.
search(pattern, string, flags=0)
purge()
split(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表．
sub(pattern, repl, string, count=0, flags=0)
subn(pattern, repl, string, count=0, flags=0)
template(pattern, flags=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# flags:
IGNORECASE # 大小写不敏感
LOCALE
MULTILINE
DOTALL
VERBOSE
UNICODE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;modules:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sre_parse module
# functions:
sre_parse.parse(str, flags=0, pattern=None)
sre_parse.expand_template(template, match)
sre_parse.parse_template(source, pattern)

# sre_compile module
# functions:
sre_compile.compile(p, flags=0)
sre_compile.isstring(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringprep&#34;&gt;stringprep&lt;/h2&gt;
&lt;h2 id=&#34;difflib&#34;&gt;difflib&lt;/h2&gt;
&lt;h2 id=&#34;textwrap&#34;&gt;textwrap&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import textwrap
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unicodedata&#34;&gt;unicodedata&lt;/h2&gt;
&lt;h2 id=&#34;readline&#34;&gt;readline&lt;/h2&gt;
&lt;h2 id=&#34;rlcompleter&#34;&gt;rlcompleter&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;binary-data-services&#34;&gt;Binary Data Services&lt;/h1&gt;
&lt;h2 id=&#34;codecs&#34;&gt;codecs&lt;/h2&gt;
&lt;p&gt;python的编码解码器coder/decoder。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import codecs

# 使用注册名为encoding的编码器编码obj，encoding默认为ascii。
# encode将unicode编码的obj编码成encoding编码对应的字节序列．
codecs.encode(obj, [encoding[,errors]])
codecs.encode(u&#39;hello world&#39;, &#39;utf-8&#39;) # 编码成utf-8字节序．

# 使用注册名为encoding的解码器解码obj，encoding默认是ascii。
# decode将原来按照encoding编码的obj解码成unicode字符串.
codecs.decode(obj, [encoding[,errors]])
codecs.decode(obj, &#39;utf-8&#39;) # 将utf-8编码的obj解码成unicode.

# encoding取下面值:
# ascii是默认值,gb2312, gbk, gb18030, utf-8, utf-16
# ascii利用一个字节把字符转换成数字．
# unicode利用多字节转换，支持多种编码方式，utf-8, uft-16.

# errors取下面值：
# strict, 默认值，抛出UnicodeError异常。
# ignore
# replace
# xmlcharrefreplace
# backslashreplace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open(filename, mode=&#39;rb&#39;, encoding=None, errors=&#39;strict&#39;, buffering=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;struct&#34;&gt;struct&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import struct

# struct模块提供了将C语言的struct转换成python的bytes对象的功能．
# 也可以将bytes对象转换成C语言的struct.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-types&#34;&gt;Data Types&lt;/h1&gt;
&lt;h2 id=&#34;datetime&#34;&gt;datetime&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import datetime
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# datetime.date
date(year, month, day)
# methods:
ctime(...)
...
# data descriptors:
day
month
year

# datetime.datetime(datetime.date)
datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])
# methods:
datetime.datetime.strptime(string, format)
format_datetime = datetime.datetime.strptime(&#39;20160824161431&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)
format_datetime = datetime.datetime.strptime(&#39;24 August 2016 16:14:31&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)

datetime.datetime.strftime(format[, tuple])
string_datetime = format_datetime.strftime(&amp;quot;%d %B %Y %H:%M:%S&amp;quot;) # return: &#39;24 August 2016 16:14:31&#39;
datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # return: &#39;2017-02-07 23:07:32&#39;

str(datetime.datetime.now())
datetime.datetime.now().strftime(&#39;%Y%m%d%H%M%S&#39;) # 当前时间戳

# datetime.time

# datetime.timedelta

# datetime.tzinfo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MAXYEAR = 9999
MINYEAR = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;calendar&#34;&gt;calendar&lt;/h2&gt;
&lt;h2 id=&#34;zoneinfo&#34;&gt;zoneinfo&lt;/h2&gt;
&lt;h2 id=&#34;collections&#34;&gt;collections&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import collections
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Callable 
# 用于检查对象是否可调用

Container 
# 用于检查对象是否是容器类型

Counter(iterable_or_mapping=None, **kwds)
# 返回一个Counter类型的实例，类似于dict，统计元素出现的次数

HashableDict(mapping=None, **kwargs)

Iterable(iterable=None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iterator(iterable=None)&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;namedtuple(typename[, field_names[, verbose[, rename]]]) # 返回一个namedtuple类型的实例，类似于C语言的struct
OrderedDict([items]) # 返回一个OrderedDict类型的实例，类似于dict，但是有序
ChainMap(*maps) # 返回一个ChainMap类型的实例，类似于dict，但是可以合并多个字典
UserDict([mapping]) # 返回一个UserDict类型的实例，类似于dict，但是可以继承
UserList([sequence]) # 返回一个UserList类型的实例，类似于list，但是可以继承
UserString([string]) # 返回一个UserString类型的实例，类似于str，但是可以继承
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;heapq&#34;&gt;heapq&lt;/h2&gt;
&lt;p&gt;heapq模块提供了堆队列算法，也称为优先队列算法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import heapq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;heappush(heap, item) # 把item放到堆中
heappop(heap) # 弹出堆顶元素, 也就是最小的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bisect&#34;&gt;bisect&lt;/h2&gt;
&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;
&lt;h2 id=&#34;weakref&#34;&gt;weakref&lt;/h2&gt;
&lt;h2 id=&#34;types&#34;&gt;types&lt;/h2&gt;
&lt;h2 id=&#34;copy&#34;&gt;copy&lt;/h2&gt;
&lt;p&gt;copy和deepcopy都只拷贝对象的类型和数值，不拷贝对象的ID.也就是==运算为True, is(id())运算为False.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import copy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy.copy(x) # 浅复制, 只拷贝父对象，不拷贝内部的子对象.
copy.deepcopy(x, memo=None, _nil=[]) # 深复制, 拷贝父对象和内部的子对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pprint&#34;&gt;pprint&lt;/h2&gt;
&lt;h2 id=&#34;reprlib&#34;&gt;reprlib&lt;/h2&gt;
&lt;h2 id=&#34;enum&#34;&gt;enum&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import enum
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;graphlib&#34;&gt;graphlib&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-persistence&#34;&gt;Data Persistence&lt;/h1&gt;
&lt;p&gt;pickle/cPickle/marshal提供对象的序列化操作．&lt;/p&gt;
&lt;p&gt;gdb相关的模块anydbm/whichdb/dbm/gdbm/dumbdbm提供类似字典和文件的对象．&lt;/p&gt;
&lt;p&gt;shelve集合了以上两者的功能．&lt;/p&gt;
&lt;h2 id=&#34;pickle&#34;&gt;pickle&lt;/h2&gt;
&lt;p&gt;pickle模块提供了对象的序列化和反序列化操作．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pickle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dump(obj, file[, protocol, *, fix_imports, buffer_callback] # 将对象obj序列化到文件file中
dumps(obj[, protocol, *, fix_imports, buffer_callback] # 将对象obj序列化为字节串
load(file[, *, encoding, errors, buffers]) # 从文件file中反序列化对象
loads(data[, *, encoding, errors, buffers]) # 从字节串data中反序列化对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HIGHEST_PROTOCOL = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;marshal&#34;&gt;marshal&lt;/h2&gt;
&lt;h2 id=&#34;shelve&#34;&gt;shelve&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import shelve

with shelve.open(f, flag=&#39;n&#39;, writeback=True) as f:
r/w: 不存在报错
c: read-write to new/existing，不存在创建
n: read-write to new. 总是创建新的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;copyreg&#34;&gt;copyreg&lt;/h2&gt;
&lt;h2 id=&#34;dbm&#34;&gt;dbm&lt;/h2&gt;
&lt;h2 id=&#34;sqlite3&#34;&gt;sqlite3&lt;/h2&gt;
&lt;p&gt;python访问数据库两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ORM&lt;/li&gt;
&lt;li&gt;DB-API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ORM是对象-关系管理器，相关模块有SQLAlchemy, SQLObject.&lt;/p&gt;
&lt;p&gt;DB-API参考PEP248/249定义了Database的API。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0249/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0249/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sqlite3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sqlite3.Connection
# methods:
close(...)
commit(...)
cursor(...)
execute(...)
...

# sqlite3.Cursor
# methods:
close(...)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adapt(obj, protocol, alternate)
connect(database[, timeout, isolation_level, detect_types, factory])
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-compression-and-archiving&#34;&gt;Data Compression and Archiving&lt;/h1&gt;
&lt;h2 id=&#34;gzip&#34;&gt;gzip&lt;/h2&gt;
&lt;h2 id=&#34;bz2&#34;&gt;bz2&lt;/h2&gt;
&lt;h2 id=&#34;zlib&#34;&gt;zlib&lt;/h2&gt;
&lt;h2 id=&#34;zipfile&#34;&gt;zipfile&lt;/h2&gt;
&lt;h2 id=&#34;tarfile&#34;&gt;tarfile&lt;/h2&gt;
&lt;h2 id=&#34;lzma&#34;&gt;lzma&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_File</title>
        <link>https://canuxcheng.com/post/psl_file/</link>
        <pubDate>Sun, 14 Aug 2016 20:51:28 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_file/</guid>
        <description>&lt;h1 id=&#34;file-and-directory-access&#34;&gt;File and Directory Access&lt;/h1&gt;
&lt;h2 id=&#34;ospath&#34;&gt;os.path&lt;/h2&gt;
&lt;p&gt;windows的路径要写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\\test\\sub\\

import os
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(&amp;quot;~/src&amp;quot;) -&amp;gt; /home/user/src
os.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原．
os.path.dirname(filename) # 返回filename的路径 dirname(&amp;quot;/home/user/file.py&amp;quot;) -&amp;gt; /home/user
os.path.join(a, *p) # 拼结一个完整的路径　
os.path.join(a, os.pardir) # 返回上级目录的路径
os.path.realpath(filename) # 返回filename的真实路径+文件名 realpath(&#39;__file__&#39;)
os.path.abspath(path) # 返回绝对路径, os.path.abspath(&#39;__file__&#39;)
os.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -&amp;gt; (&amp;quot;/home/user/test&amp;quot;, &amp;quot;.py&amp;quot;)
os.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -&amp;gt; test.py
os.path.getsize(filename) # 返回文件大小
os.path.exists(path) # 判断path(文件或目录)是否存在
os.path.isfile(path) # 判断path是否是常规文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pathlib&#34;&gt;pathlib&lt;/h2&gt;
&lt;p&gt;new in python3.4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pathlib import Path
from pathlib import PurePosixPath
from pathlib import PureWindowsPath
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stat&#34;&gt;stat&lt;/h2&gt;
&lt;h2 id=&#34;filecmp&#34;&gt;filecmp&lt;/h2&gt;
&lt;h2 id=&#34;fnmatch&#34;&gt;fnmatch&lt;/h2&gt;
&lt;h2 id=&#34;linecache&#34;&gt;linecache&lt;/h2&gt;
&lt;h2 id=&#34;glob&#34;&gt;glob&lt;/h2&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glob(pathname) # 返回匹配pathname路径下正则表达式的所有文件组成的列表
iglob(pathname) # 同上，返回generator.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shutil&#34;&gt;shutil&lt;/h2&gt;
&lt;p&gt;Utility functions for copying and archiving files and directory trees.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import shutil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy(src, dst)
copy2(src, dst)
...
rmtree(path, ignore_errors=False, onerror=None) # 删除指定的目录,path不能是文件．
unregister_archive_format(name)
move(src, dst)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tempfile&#34;&gt;tempfile&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;file-formats&#34;&gt;File Formats&lt;/h1&gt;
&lt;h2 id=&#34;csv&#34;&gt;csv&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# csv.DictReader
DictReader(self, f, fieldnames=None, restkey=None, restval=None, dialect=&#39;excel&#39;, *args, **kwds)
# methods
next()

# csv.DictWriter
DictWriter(self, f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, *args, **kwargs)
# mthods
writeheader()
writerow(rowdict)
writerows(rowdicts)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回DictReader对象
reader(iterable, dialect=&#39;excel&#39;, **kwargs)

// 返回DictWriter对象
writer(fileobj, dialect=&#39;excel&#39;, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;configparser&#34;&gt;configparser&lt;/h2&gt;
&lt;p&gt;一般用来处理*.ini文件，格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[section]
option-key = option-value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import ConfigParser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ConfigParser.ConfigParser(defaults=None)
# methods:
read(filenames) # 读取ini文件
sections() # 获取所有section
options(section) # 获取section的所有option
get(section, option, raw=False, vars=None) # 返回字符串
getint(section, options)
getfloat(section, options)
getboolean(section, options) # 大小写都可以:0/1, false/true, no/yes, off/on
set(section, option, value)
has_section(section)
has_option(section, option)
remove_section(section)
remove_option(section, option)
write(fp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;默认是全部小写写入.
config = ConfigParser.ConfigParser(allow_no_value=True)
config.optionxform =str # 原样写入

from configparser import ConfigParser, ExtendedInterpolation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 默认interpolation只支持section之间变量
[section1]
1var1 = /opt
1var2 = %(1var1)s/test

// 扩展interpolation支持section变量引用
config = ConfigParser(interpolation=ExtendedInterpolation())

[section1]
1var1 = /opt
[section2]
2var1 = ${section1:1var1}/test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tomllib&#34;&gt;tomllib&lt;/h2&gt;
&lt;h2 id=&#34;netrc&#34;&gt;netrc&lt;/h2&gt;
&lt;h2 id=&#34;plistlib&#34;&gt;plistlib&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Math</title>
        <link>https://canuxcheng.com/post/psl_math/</link>
        <pubDate>Fri, 12 Aug 2016 16:56:45 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_math/</guid>
        <description>&lt;h1 id=&#34;numeric-and-mathematical-modules&#34;&gt;Numeric and Mathematical Modules&lt;/h1&gt;
&lt;h2 id=&#34;random&#34;&gt;random&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import random
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# random.Random
Random()
# methods:
seed([self,], a=None)
randint(a, b) # 随机一个[a,b]中的整数．
choice(self, seq) # 从seq中随机选择一个元素
uniform(self, a, b) # 随机一个[a,b]中的浮点数．
sample(self, population, k)
randint(self, a, b)
randrange(self, start, stop=None, step=1, _int=&amp;lt;type &#39;int&#39;&amp;gt;, _maxwidth=9007199254740992L)

# random.SystemRandom(Random)
SystemRandom(Random)

# random.WichmannHill(Random)
WichmannHill(Random)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;random(self) # 随机一个小于１的数．
# 所有Random类的methods也可以直接使用．
seed(self, a=None) # 设置随机数种子．
uniform(self, a, b) # 随机一个[a,b]中的浮点数．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fractions&#34;&gt;fractions&lt;/h2&gt;
&lt;h2 id=&#34;cmath&#34;&gt;cmath&lt;/h2&gt;
&lt;h2 id=&#34;math&#34;&gt;math&lt;/h2&gt;
&lt;h2 id=&#34;numbers&#34;&gt;numbers&lt;/h2&gt;
&lt;h2 id=&#34;decimal&#34;&gt;decimal&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;functional-programming-modules&#34;&gt;Functional Programming Modules&lt;/h1&gt;
&lt;h2 id=&#34;functools&#34;&gt;functools&lt;/h2&gt;
&lt;p&gt;函数式编程相关的模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import functools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# functools.partial
partial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型.
RED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED)
RED(&amp;quot;show me red&amp;quot;) == lambda content, color: Fore.RED + str(&amp;quot;show me red&amp;quot;) + Fore.RESET
# 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reduce(function, sequence[, initial]) # 如果initial存在，就把initial作为function的第一个参数，如果function有两个参数，就再从sequence取第一个元素作为function的第二个参数，然后调用function，返回的结果作为function的第一个参数，再继续从sequence获取元素作为参数，继续调用function, 直到sequence为空．
reduce(lambda x,y: x+y, range(5))

cmp_to_key(mycmp)
total_ordering(cls)
update_wrapper(wrapper, wrapped, assigned=(&#39;__module__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;), updated=(&#39;__dict__&#39;,))

wraps(wrapped, assigned=(&#39;__module__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;), updated=(&#39;__dict__&#39;,))
# example:
def deco(func):
    @wraps(func):
    def wrapper(*args, **kwargs):
        &amp;quot;&amp;quot;&amp;quot;Docs for wrapper.&amp;quot;&amp;quot;&amp;quot;
        pass

@deco
def foo()
    &amp;quot;&amp;quot;&amp;quot;Docs for new function.&amp;quot;&amp;quot;&amp;quot;
    pass

# 不用wraps被装饰的函数foo的属性其实是原来函数的属性，也就是wrapper的属性
# 用了wraps被装饰的函数foo的属性就是foo自己的属性．
print foo.__name__
print foo.__doc__
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;operator&#34;&gt;operator&lt;/h2&gt;
&lt;p&gt;操作符相关的模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import operator
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;itertools&#34;&gt;itertools&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import itertools
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Multimedia</title>
        <link>https://canuxcheng.com/post/psl_multimedia/</link>
        <pubDate>Fri, 12 Aug 2016 15:51:56 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_multimedia/</guid>
        <description>&lt;h1 id=&#34;multimedia-services&#34;&gt;Multimedia Services&lt;/h1&gt;
&lt;h2 id=&#34;audioop&#34;&gt;audioop&lt;/h2&gt;
&lt;h2 id=&#34;aifc&#34;&gt;aifc&lt;/h2&gt;
&lt;h2 id=&#34;sunau&#34;&gt;sunau&lt;/h2&gt;
&lt;h2 id=&#34;wave&#34;&gt;wave&lt;/h2&gt;
&lt;h2 id=&#34;chunk&#34;&gt;chunk&lt;/h2&gt;
&lt;h2 id=&#34;colorsys&#34;&gt;colorsys&lt;/h2&gt;
&lt;h2 id=&#34;imghdr&#34;&gt;imghdr&lt;/h2&gt;
&lt;h2 id=&#34;sndhdr&#34;&gt;sndhdr&lt;/h2&gt;
&lt;h2 id=&#34;ossaudiodev&#34;&gt;ossaudiodev&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Network</title>
        <link>https://canuxcheng.com/post/psl_network/</link>
        <pubDate>Fri, 12 Aug 2016 14:21:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_network/</guid>
        <description>&lt;h1 id=&#34;internet-protocols-and-support&#34;&gt;Internet Protocols and Support&lt;/h1&gt;
&lt;p&gt;socketserver/http/ftp参考&lt;a class=&#34;link&#34; href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;pop,imap/smtp参考&lt;a class=&#34;link&#34; href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;urllib&#34;&gt;urllib&lt;/h2&gt;
&lt;p&gt;urllib.request&lt;/p&gt;
&lt;p&gt;urllib.respponse&lt;/p&gt;
&lt;p&gt;urllib.parse&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from urllib.parse import urlparse
from urllib.parse import urljoin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;urllib.error&lt;/p&gt;
&lt;p&gt;urllib.robotparser&lt;/p&gt;
&lt;h2 id=&#34;ipaddress&#34;&gt;ipaddress&lt;/h2&gt;
&lt;h2 id=&#34;webbrowser&#34;&gt;webbrowser&lt;/h2&gt;
&lt;h2 id=&#34;cgi&#34;&gt;cgi&lt;/h2&gt;
&lt;h2 id=&#34;cgitb&#34;&gt;cgitb&lt;/h2&gt;
&lt;h2 id=&#34;wsgiref&#34;&gt;wsgiref&lt;/h2&gt;
&lt;h2 id=&#34;xmlrpc&#34;&gt;xmlrpc&lt;/h2&gt;
&lt;h2 id=&#34;socketserver&#34;&gt;socketserver&lt;/h2&gt;
&lt;h2 id=&#34;nntplib&#34;&gt;nntplib&lt;/h2&gt;
&lt;p&gt;network news transfer protocol&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import nntplib
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;telnet&#34;&gt;telnet&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import telnetlib
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;structured-markup-processing-tools&#34;&gt;Structured Markup Processing Tools&lt;/h1&gt;
&lt;h2 id=&#34;html&#34;&gt;html&lt;/h2&gt;
&lt;h2 id=&#34;xml&#34;&gt;xml&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;internet-data-handling&#34;&gt;Internet Data Handling&lt;/h1&gt;
&lt;h2 id=&#34;json&#34;&gt;json&lt;/h2&gt;
&lt;p&gt;http api(restful)一般使用json格式的数据．&lt;/p&gt;
&lt;p&gt;python和json数据类型对应关系参考WEB/JSON.&lt;/p&gt;
&lt;p&gt;complex和class/def不能被编码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将转换后的json格式写入文件
dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)
with open(file, &#39;w&#39;) as f:
    json.dump(dict_data, f)

# 将dict类型转换成json格式
dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)
json_data = json.dumps(dict_data)

indent=4 # 写入自动缩进４个空格

# 将读出的文件(json格式)转换成dict
load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
with open(file, &#39;r&#39;) as f:
    dict_data = json.load(f)

# json类型变成dict类型
loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
response_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;base64&#34;&gt;base64&lt;/h2&gt;
&lt;h2 id=&#34;mailcap&#34;&gt;mailcap&lt;/h2&gt;
&lt;h2 id=&#34;mailbox&#34;&gt;mailbox&lt;/h2&gt;
&lt;h2 id=&#34;minetypes&#34;&gt;minetypes&lt;/h2&gt;
&lt;h2 id=&#34;binhex&#34;&gt;binhex&lt;/h2&gt;
&lt;h2 id=&#34;binascii&#34;&gt;binascii&lt;/h2&gt;
&lt;h2 id=&#34;quopri&#34;&gt;quopri&lt;/h2&gt;
&lt;h2 id=&#34;uu&#34;&gt;uu&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>ReStructuredText</title>
        <link>https://canuxcheng.com/post/restructuredtext/</link>
        <pubDate>Mon, 08 Aug 2016 13:39:38 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/restructuredtext/</guid>
        <description>&lt;h1 id=&#34;restructuredtext&#34;&gt;reStructuredText&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://docutils.sourceforge.net/rst.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;reST是易读所见即所得的文本标记语言，格式类似markdown。&lt;/p&gt;
&lt;p&gt;python的reST参考pep12和pep287:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0012/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0012/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0287/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0287/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主标题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title
=====

=====
title
=====
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;副标题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Subtitle
-----

--------
Subtitle
--------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次级标题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content
^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;星号斜体强调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*text*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双星号加粗重点强调：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**text**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四个或以上的-表示分割线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考式链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`hyperlink`_

.. _hyperlink: http://hyperlink.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;行内式链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`link &amp;lt;https://link.com&amp;gt;`_
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.. image:: https://path/image.png
    :alt: HTTPie compared to cURL
    :width: 679
    :heigh: 781
    :align: center
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原样引用块：&lt;/p&gt;
&lt;p&gt;双冒号加四个空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source code::

    print(&amp;quot;source&amp;quot;)
    return 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档测试块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print doctest block.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无序列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bullet lists:

- This is item 1
- This is item 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有序列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enumerated lists:

1. this is first item
2. this is second item
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;definition lists:

what
    Definition lists.

how
    The term is a one-line phrase.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;域列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field lists:

:Authors:
    Canux

:Version: 1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;option lists:

-a    option &amp;quot;a&amp;quot;
-b file    option for filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;评论：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.. This is commnet.
   As well.
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Debug</title>
        <link>https://canuxcheng.com/post/python_debug/</link>
        <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_debug/</guid>
        <description>&lt;h1 id=&#34;ide&#34;&gt;IDE&lt;/h1&gt;
&lt;p&gt;pycharm可以通过breakpoint和step调试.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;
&lt;h2 id=&#34;bdb&#34;&gt;bdb&lt;/h2&gt;
&lt;h2 id=&#34;pdb&#34;&gt;pdb&lt;/h2&gt;
&lt;h2 id=&#34;hotshot&#34;&gt;hotshot&lt;/h2&gt;
&lt;h2 id=&#34;timeit&#34;&gt;timeit&lt;/h2&gt;
&lt;h2 id=&#34;trace&#34;&gt;trace&lt;/h2&gt;
&lt;h2 id=&#34;cprofile&#34;&gt;cProfile&lt;/h2&gt;
&lt;h2 id=&#34;profile&#34;&gt;profile&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PEP</title>
        <link>https://canuxcheng.com/post/python_pep/</link>
        <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_pep/</guid>
        <description>&lt;h1 id=&#34;pep-8--style-guide-for-python-code&#34;&gt;PEP 8 &amp;ndash; Style Guide for Python Code&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0008/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;pep-257--docstring-conventions&#34;&gt;PEP 257 &amp;ndash; Docstring Conventions&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0257/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0257/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;pep-20pep-20--the-zen-of-python&#34;&gt;PEP-20PEP 20 &amp;ndash; The Zen of Python&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0020/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0020/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看pep20
&amp;gt;import this
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Document</title>
        <link>https://canuxcheng.com/post/python_document/</link>
        <pubDate>Wed, 03 Aug 2016 21:57:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_document/</guid>
        <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;p&gt;python项目文档相关的工具．&lt;/p&gt;
&lt;h1 id=&#34;pydoc&#34;&gt;pydoc&lt;/h1&gt;
&lt;p&gt;python自带的文档命令行接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pydoc --help
$ pydoc -p &amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;h2 id=&#34;sphinx&#34;&gt;Sphinx&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sphinx-doc/sphinx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sphinx-doc/sphinx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sphinx就是python处理reStructuredText格式的工具。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install -U Sphinx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用sphinx：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd your-project/docs

$sphinx-quickstart
# 以下选项需要手动设定，其它都可以用默认值：
&amp;gt; Project name: pydeveloper
&amp;gt; Author name(s): Canux CHENG
&amp;gt; Project version: 1.0.0.0
&amp;gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y
&amp;gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件conf.py包含刚才的所有配置，可以在这里手动修改。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加包的版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys.path.insert(0, os.path.abspath(&amp;quot;..&amp;quot;))
from &amp;lt;project&amp;gt; import __version__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改自己的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copyright = u&#39;2016, &amp;lt;a href=&amp;quot;http://canuxcheng.com&amp;quot;&amp;gt;Canux CHENG&amp;lt;/a&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sphinx-docs&#34;&gt;sphinx-docs&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh-sphinx-doc.readthedocs.io/en/latest/markup/index.html#sphinxmarkup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh-sphinx-doc.readthedocs.io/en/latest/markup/index.html#sphinxmarkup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sphinx的标记把reST格式的文档关联起来。&lt;/p&gt;
&lt;p&gt;index.rst这是文档的首页。&lt;/p&gt;
&lt;h3 id=&#34;sphinx-build&#34;&gt;sphinx-build&lt;/h3&gt;
&lt;p&gt;生成web可读的文档。&lt;/p&gt;
&lt;p&gt;简单方法生成文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 生成html格式的文档
$make html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sphinx-apidoc&#34;&gt;sphinx-apidoc&lt;/h3&gt;
&lt;p&gt;自动生成API文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sphinx-apidoc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;debug&#34;&gt;Debug&lt;/h3&gt;
&lt;p&gt;浏览器打开docs/_build/html/index.html即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$firefox _build/html/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;readthedocs&#34;&gt;ReadTheDocs&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://readthedocs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://readthedocs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://readthedocs.readthedocs.io/zh_CN/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://readthedocs.readthedocs.io/zh_CN/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将项目文档部署到readthedocs站点。&lt;/p&gt;
&lt;p&gt;直接注册帐号，同步github项目，然后导入你的项目即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;alabaster&#34;&gt;alabaster&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bitprophet/alabaster/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bitprophet/alabaster/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个主题是sphinx的默认主题，基于requests和flask的文档的主题而来。&lt;/p&gt;
&lt;p&gt;主题设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html_theme_options = {
    &#39;github_user&#39;: &#39;crazy-canux&#39;,
    &#39;github_repo&#39;: &#39;&amp;lt;your-project&amp;gt;&#39;,
    &#39;github_banner&#39;: True,
    &#39;show_powered_by&#39;: False,
    &#39;show_related&#39;: True,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pypandoc&#34;&gt;pypandoc&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bebraw/pypandoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bebraw/pypandoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档转换工具pandoc的python包。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install pandoc
$ pip install pypandoc
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Ftp</title>
        <link>https://canuxcheng.com/post/ftp/</link>
        <pubDate>Thu, 28 Jul 2016 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ftp/</guid>
        <description>&lt;h1 id=&#34;ftp&#34;&gt;FTP&lt;/h1&gt;
&lt;p&gt;ftp服务器有很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vsftpd&lt;/li&gt;
&lt;li&gt;proftpd&lt;/li&gt;
&lt;li&gt;pyftpdlib&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vsftpd&#34;&gt;vsftpd&lt;/h1&gt;
&lt;p&gt;安装vsftpd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install vsftpd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows开启ftp服务和建立IIS站点即可。&lt;/p&gt;
&lt;p&gt;linux配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/vsftpd.conf
local_root=/home/canux/FTP
anon_root=/home/canux/FTP
local_enable=YES
anonymous_enable=YES
chroot_local_user=YES
$ sudo service vsftpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ftp的网页浏览格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ftp://host/path
ftp://username:password@host:port/path
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ftp命令&#34;&gt;ftp命令&lt;/h1&gt;
&lt;h2 id=&#34;ftp-1&#34;&gt;ftp&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ftp [-46pinegvd] [host [port]]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的ftp标准库&#34;&gt;python的FTP标准库&lt;/h1&gt;
&lt;h2 id=&#34;ftplib&#34;&gt;ftplib&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Ldap</title>
        <link>https://canuxcheng.com/post/ldap/</link>
        <pubDate>Thu, 28 Jul 2016 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ldap/</guid>
        <description>&lt;h1 id=&#34;ldap&#34;&gt;LDAP&lt;/h1&gt;
&lt;p&gt;LDAP占用tcp和udp的389端口。&lt;/p&gt;
&lt;p&gt;使用SSL的LDAP占用tcp和udp的636端口。&lt;/p&gt;
&lt;p&gt;Lightweight Directory Access Protocol.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.openldap.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.openldap.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LDAP的windows工具：LDAPSoft LDAP Browser&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Nfs</title>
        <link>https://canuxcheng.com/post/nfs/</link>
        <pubDate>Thu, 28 Jul 2016 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/nfs/</guid>
        <description>&lt;h1 id=&#34;nfs&#34;&gt;NFS&lt;/h1&gt;
&lt;p&gt;NFS: Network File System&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在nfs服务器安装nfs服务
$ sudo apt-get install nfs-kernel-server
# 添加共享目录并授权
$ sudo vim /etc/exports
/home/user/share *(rw,no_root_squash)
$ sudo service nfs-kernel-server restart

# 在nfs客户端安装nfs客户端
$ sudo apt-get install nfs-common
# 自动挂载
$ sudo vim /etc/fstab
nfs-server-ip:/home/user/share /home/user1/share nfs auto 0 0
$ sudo mount -a
# 手动挂载
$ sudo mount -t nfs nfs-server-ip:/home/user/share /home/user1/share
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nfs-server&#34;&gt;nfs-server&lt;/h1&gt;
&lt;p&gt;配置/etc/exports&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/exports  文件格式
&amp;lt;输出目录&amp;gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nfs-client&#34;&gt;nfs-client&lt;/h1&gt;
&lt;p&gt;配置/etc/fstab&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ntp</title>
        <link>https://canuxcheng.com/post/ntp/</link>
        <pubDate>Thu, 28 Jul 2016 16:08:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ntp/</guid>
        <description>&lt;h1 id=&#34;ntp&#34;&gt;NTP&lt;/h1&gt;
&lt;p&gt;NFS: Network Time Protocol&lt;/p&gt;
&lt;p&gt;UTC: Coordinated Universal Time, 世界统一时间&lt;/p&gt;
&lt;p&gt;GMT: Greenwich Mean Time, 格林尼治标准时间, = UTC&lt;/p&gt;
&lt;p&gt;CET: Central European Time, 欧洲中部时间, = UTC+1, 下令时=UTC+2&lt;/p&gt;
&lt;p&gt;CST: Chinese Standard Time, 中国标准时间, = UTC+8&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;时区管理&#34;&gt;时区管理&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ timedatectl list-timezones # 查看所有时区
$ sudo timedatectl set-timezone Asia/Shanghai # 设置时区
$ sudo timedatectl set-timezone Etc/UTC
$ ls -l /etc/localtime # 应该是一个链接
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ntp-1&#34;&gt;ntp&lt;/h1&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ntp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ntpdate&#34;&gt;ntpdate&lt;/h2&gt;
&lt;p&gt;从目标服务器同步.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ntpdate -u ip
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ntpstat&#34;&gt;ntpstat&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ntpstat
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;chrony&#34;&gt;chrony&lt;/h1&gt;
&lt;p&gt;ntp的升级版.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ssh</title>
        <link>https://canuxcheng.com/post/ssh/</link>
        <pubDate>Thu, 28 Jul 2016 15:53:34 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ssh/</guid>
        <description>&lt;h1 id=&#34;openssh&#34;&gt;OpenSSH&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.openssh.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.openssh.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows上支持ssh协议的客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;putty&lt;/li&gt;
&lt;li&gt;xshell&lt;/li&gt;
&lt;li&gt;MobaXterm&lt;/li&gt;
&lt;li&gt;secureCRT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openssh-server
$ sudo apt-get install openssh-client
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ssh命令&#34;&gt;SSH命令&lt;/h1&gt;
&lt;p&gt;ssh是openssh协议的客户端．&lt;/p&gt;
&lt;p&gt;远程操作的命令包括ssh, scp, sftp.&lt;/p&gt;
&lt;p&gt;ssh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh
# 远程执行命令需要用双引号，不能用单引号
$ ssh username@host &amp;quot;command/script&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;scp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ scp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sftp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sftp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-C   compression
# 不需要输入yes来交互, 或者修改/etc/ssh/ssh_config
-o StrictHostKeyChecking=no
-o UserKnownHostsFile /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh也包括一些密钥管理的命令.&lt;/p&gt;
&lt;p&gt;ssh-keygen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &#39;canuxcheng@gmail.com&#39;

# 通过将本机的公钥拷贝到远程机器实现无密码访问．
# 将本机的public-key拷贝到远程机器的authorized_keys.
$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote
# 另外的拷贝方法
$ ssh user@host &amp;quot;cat &amp;gt;&amp;gt; ~/.ssh/authorized_keys&amp;quot; &amp;lt; ~/.ssh/id_rsa.pub
$ sudo service ssh restart # 需要重启ssh服务

非交互式通过命令行传密码的命令：
$ sshpass -p [password]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh-add&lt;/p&gt;
&lt;p&gt;ssh-keysign&lt;/p&gt;
&lt;p&gt;ssh-keyscan&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;启用root远程ssh&#34;&gt;启用root远程ssh&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo -i
# passwd root
# vim /etc/ssh/sshd_config
&amp;gt; PermitRootLogin prohibit-password
&amp;gt; PermitRootLogin yes
# service ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ssh-tunel&#34;&gt;ssh tunel&lt;/h1&gt;
&lt;p&gt;SSH Tunnel有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地Local（ssh -NfL）, 在ssh client(本地)执行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  正向代理：（a能ssh到b，b能访问c，实现a访问c，相当于a是ssh client）A 通过 中转B连接 server C.

  在A 上建立tunnel:
  ssh -Nf -L  ssh-client-ip:ssh-client-port:remoteServerIp:remoteServerPort  user@agentIp

 访问ssh-client-ip/A的ssh-client-port 即可访问 remoteServerIp/C 的 remoteServerPort 提供的服务.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程Remote（ssh -NfR）, 在ssh server执行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  反向代理：（b能ssh到a，b能访问c，实现a访问c, a相当于ssh server, c相当于remote server) A 通过中转B访问server C.

  在B上建立tunnel:
  ssh -Nf -R  ssh-server-ip:ssh-server-port:remoteServerIp:remoteServerPort    user@agent

  访问ssh-server-ip/A的ssh-server-port端口即可访问remoteServerIp/C 的 remoteServerPort 提供的服务。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态Dynamic（ssh -NfD）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  socks代理： a能ssh到B，b能访问一个网段，实现a访问该网段.

  在a上建立tunnel
  ssh -D [ssh-client-ip]:ssh-client-port user@agent

  socks代理配置ssh-client-ip:ssh-client-port 即可通过B访问该网段。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Remote Management</title>
        <link>https://canuxcheng.com/post/ps_remote/</link>
        <pubDate>Mon, 18 Jul 2016 14:54:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ps_remote/</guid>
        <description>&lt;h1 id=&#34;windows远程管理&#34;&gt;Windows远程管理&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;WinRM, 远程处理,在远程机器上执行命令&lt;/li&gt;
&lt;li&gt;WMI/CIM&lt;/li&gt;
&lt;li&gt;RPC, 远程连接,在发起远程连接的机器上执行命令&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;winrm&#34;&gt;WinRM&lt;/h1&gt;
&lt;p&gt;一对一远程处理:&lt;/p&gt;
&lt;p&gt;类似于linux的ssh。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enter-PSSession -ComputerName name
...
Exit-PSSession
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一对多远程处理:&lt;/p&gt;
&lt;p&gt;同时远程到多台机器执行命令或脚本。&lt;/p&gt;
&lt;p&gt;Invoke-Command一次创建一个连接对象，返回PSComputerName属性，执行完后就关闭连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Invoke-Command -ComputerName name1,name2 -ScriptBlock {command1;command2}

Invoke-Command -ComputerName name1,name2 -FilePath filepath

Invoke-Command -ComputerName (Get-Content hosts.txt) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过argumentlist把本地的参数传给远程的命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$lvar1=&amp;quot;value1&amp;quot;
$lvar2=&amp;quot;value2&amp;quot;
Invoke-Command -ComputerName name
-ScriptBlock {
Param($var1, $var2)
...
}
-ArgumentList $lvar1, $lvar2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过$using:传本地参数到远程机器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$var1=&amp;quot;value1&amp;quot;
Invoke-Command -ComputerName name
-ScriptBlock {
... $using:var1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建持久的远程处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$session1=New-PSSession -ComputerName server1
Enter-PSSession -Session $session1 ...
Invoke-Command -Session $session1 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;wmi&#34;&gt;WMI&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Get-WmiObject
Remove-WmiObject
Invoke-WmiMethod
Register-WmiEvent
Set-WmiInstance

# 用powershell跑一个wql。
Get-WmiObject -Query &amp;quot;select * from win32_service where name=&#39;winRM&#39;&amp;quot; | Format-List -Property Name,status

# 远程管理
Get-WMIObject -ComputerName ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;cim&#34;&gt;CIM&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Get-CimClass
Get-CimInstance
Get-CimSession
Get-CimAssociatedInstance
Invoke-CimMethod
New-CimInstance
New-CimSession
New-CimSessionOption
Register-CimIndicationEvent
Remove-CimInstance
Remove-CimSession
Set-CimInstance
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;rpc&#34;&gt;RPC&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 远程连接
Get-Service -ComputerName ...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>WinRM</title>
        <link>https://canuxcheng.com/post/win_winrm/</link>
        <pubDate>Sun, 17 Jul 2016 08:36:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win_winrm/</guid>
        <description>&lt;h1 id=&#34;winrm&#34;&gt;WinRM&lt;/h1&gt;
&lt;p&gt;Windows Remote Management&lt;/p&gt;
&lt;p&gt;WinRM是WSMAN(WS-Management Protocol)的增强版。&lt;/p&gt;
&lt;p&gt;WinRM是基于SOAP的防火墙友好的远程协议。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/en-us/library/aa384426%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WinRM设置:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/en-us/library/aa384372%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;检查winrm所有配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd&amp;gt; winrm get winrm/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速设置winrm：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd&amp;gt; winrm quickconfig
cmd&amp;gt; winrm quickconfig -transport:https
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看listener配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd&amp;gt; winrm enumerate winrm/config/listener
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WinRM配置包括监听设置,协议设置,Client,Service和Winrs四部分.&lt;/p&gt;
&lt;p&gt;windows的三种网络安全协议。&lt;/p&gt;
&lt;p&gt;Basic是基本的明文协议, NTLM是早期的安全协议,Kerberos是最新的安全协议.&lt;/p&gt;
&lt;h1 id=&#34;service权限管理&#34;&gt;service权限管理&lt;/h1&gt;
&lt;p&gt;查看service的auth配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd&amp;gt; winrm get winrm/config/service/auth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;service只有Negotiate和Kerberos是默认开启的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Basic = false
Kerberos = true
Negotiate = true
Certificate = false
CredSSP = false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Negotiate对domain用户选择kerberos,对local用户选择NTLM.&lt;/p&gt;
&lt;p&gt;设置service的Basic和Certificate和CredSSP(默认关闭)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cmd&amp;gt; winrm set winrm/config/service/auth @{Basic=&amp;quot;true&amp;quot;}
#cmd&amp;gt; winrm set winrm/config/service/auth @{Certificate=&amp;quot;true&amp;quot;}
#cmd&amp;gt; winrm set winrm/config/service/auth @{CredSSP=&amp;quot;true&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置是否允许不加密：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cmd&amp;gt; winrm set winrm/config/service @{AllowUnencrypted=&amp;quot;true&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;client权限管理&#34;&gt;client权限管理&lt;/h1&gt;
&lt;p&gt;查看client的auth配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmd&amp;gt; winrm get winrm/config/client/auth
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置client的CredSSP(默认关闭),其它默认都是开启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cmd&amp;gt; winrm set winrm/config/client/auth @{CredSSP=&amp;quot;true&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置client的trustedhosts:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#cmd&amp;gt; winrm set winrm/config/client @{TrustedHosts=&amp;quot;*&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;winrs&#34;&gt;Winrs&lt;/h1&gt;
&lt;p&gt;winrs是winrm的客户端．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$winrs -r:http://&amp;lt;ip-address&amp;gt; -u:domain/user -p:pass command
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Coreutils</title>
        <link>https://canuxcheng.com/post/ps_coreutils/</link>
        <pubDate>Tue, 12 Jul 2016 17:24:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ps_coreutils/</guid>
        <description>&lt;h1 id=&#34;外部命令&#34;&gt;外部命令&lt;/h1&gt;
&lt;p&gt;powershell可以执行外部命令.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Windows\System32\*.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;cmd&#34;&gt;cmd&lt;/h1&gt;
&lt;h1 id=&#34;ping&#34;&gt;ping&lt;/h1&gt;
&lt;h1 id=&#34;netstat&#34;&gt;netstat&lt;/h1&gt;
&lt;h1 id=&#34;ipconfig&#34;&gt;ipconfig&lt;/h1&gt;
&lt;h1 id=&#34;route&#34;&gt;route&lt;/h1&gt;
&lt;h1 id=&#34;arp&#34;&gt;arp&lt;/h1&gt;
&lt;h1 id=&#34;nslookup&#34;&gt;nslookup&lt;/h1&gt;
&lt;h1 id=&#34;ftp&#34;&gt;ftp&lt;/h1&gt;
&lt;h1 id=&#34;mstsc&#34;&gt;mstsc&lt;/h1&gt;
&lt;p&gt;RDP client.&lt;/p&gt;
&lt;h1 id=&#34;taskmgr&#34;&gt;taskmgr&lt;/h1&gt;
&lt;p&gt;任务管理器．&lt;/p&gt;
&lt;h1 id=&#34;tskill&#34;&gt;tskill&lt;/h1&gt;
&lt;h1 id=&#34;tree&#34;&gt;tree&lt;/h1&gt;
&lt;h1 id=&#34;whoami&#34;&gt;whoami&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;需要下载，然后放入环境变量的第三方命令.&lt;/p&gt;
&lt;h1 id=&#34;windump&#34;&gt;WinDump&lt;/h1&gt;
&lt;p&gt;Windows版本的tcpdump, 依赖WinPcap包．&lt;/p&gt;
&lt;p&gt;通过windump导出的*.pcap文件可以通过wireshark打开．&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Json</title>
        <link>https://canuxcheng.com/post/json/</link>
        <pubDate>Thu, 07 Jul 2016 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/json/</guid>
        <description>&lt;h1 id=&#34;json&#34;&gt;JSON&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.json.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.json.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JSON: JavaScript Object Notation.&lt;/p&gt;
&lt;p&gt;json有两种数据结构.&lt;/p&gt;
&lt;h1 id=&#34;key-value键值对&#34;&gt;key-value/键值对&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;{
    key: value,
    key1: value1,
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;列表数组&#34;&gt;列表/数组&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;[value, value1, ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;bool:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -&amp;gt; True/False
go -&amp;gt; true/false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;string:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 只能用双引号.

python -&amp;gt; str
go -&amp;gt; string
go -&amp;gt; []byte -&amp;gt; base64编码字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;number:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -&amp;gt; int/float
go -&amp;gt; int64/float64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;null:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -&amp;gt; None
go -&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -&amp;gt; tuple/list
go -&amp;gt; array/slice
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;object&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -&amp;gt; dict
go -&amp;gt; struct/map
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Yaml</title>
        <link>https://canuxcheng.com/post/yaml/</link>
        <pubDate>Thu, 07 Jul 2016 16:43:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/yaml/</guid>
        <description>&lt;h1 id=&#34;yaml&#34;&gt;YAML&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yaml.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yaml.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Yaml Ain&amp;rsquo;t Markup Language.&lt;/p&gt;
&lt;h2 id=&#34;yamllint&#34;&gt;yamllint&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/adrienverge/yamllint&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/adrienverge/yamllint&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CSS</title>
        <link>https://canuxcheng.com/post/css/</link>
        <pubDate>Thu, 23 Jun 2016 09:40:45 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/css/</guid>
        <description>&lt;h1 id=&#34;css&#34;&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;CSS是叠层样式表&lt;/p&gt;
&lt;h1 id=&#34;css3&#34;&gt;CSS3&lt;/h1&gt;
&lt;p&gt;CSS3是最新的CSS标准&lt;/p&gt;
&lt;h1 id=&#34;css创建&#34;&gt;CSS创建&lt;/h1&gt;
&lt;p&gt;优先级从上往下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内联样式， 在html中通过style属性定义，仅用于一个html元素。&lt;/li&gt;
&lt;li&gt;内部样式表，在html中通过style标签在头部定义,针对单个页面。&lt;/li&gt;
&lt;li&gt;外部样式表，在html中通过link标签在文档头部定义，方便将样式用于多个页面。&lt;/li&gt;
&lt;li&gt;浏览器的默认值。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css基本语法&#34;&gt;&lt;strong&gt;CSS基本语法&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;CSS由两部分组成，选择器和声明，选择器是html元素，声明由属性和值组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;selector {
  property1: value1;
  property2: value2;
  ...;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个声明用分号隔开，属性的值有空格要用引号。&lt;/p&gt;
&lt;p&gt;CSS对大小写不敏感。&lt;/p&gt;
&lt;p&gt;CSS注释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* comment */
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css选择器&#34;&gt;&lt;strong&gt;CSS选择器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;最常见的选择器是元素选择器,html元素是最基本的选择器。&lt;/p&gt;
&lt;h2 id=&#34;元素选择器&#34;&gt;元素选择器&lt;/h2&gt;
&lt;p&gt;html {color:black;}&lt;/p&gt;
&lt;h2 id=&#34;id选择器&#34;&gt;id选择器&lt;/h2&gt;
&lt;p&gt;id选择器可以为标有特定id的html元素指定特定样式。&lt;/p&gt;
&lt;p&gt;id选择器用#开头定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#red {color: red;}
#green {color: green;}

&amp;lt;p id=&amp;quot;red&amp;quot;&amp;gt;This is red.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id选择器常常用来建立派生选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#sidebar p {
  font-style: italic;
  text-align: right;
  margin-top: 0.5em;
}

&amp;lt;div id=&amp;quot;sidebar&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;class选择器&#34;&gt;class选择器&lt;/h2&gt;
&lt;p&gt;和id选择器功能类似，类选择器以.开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.center {text-align: center}

&amp;lt;h1 class=&amp;quot;center&amp;quot;&amp;gt;...&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类选择器用于建立派生选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.fancy td {
  color: #f60;
  background: #666;
}

&amp;lt;td class=&amp;quot;fancy&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;td.fancy {
  color: #f60;
  background: #666;
}

&amp;lt;td class=&amp;quot;fancy&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;属性选择器&#34;&gt;属性选择器&lt;/h2&gt;
&lt;p&gt;为拥有指定属性的html元素设置样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[title]
{
  color: red;
}

&amp;lt;a title=&amp;quot;title is red&amp;quot;&amp;gt;...&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性和值选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[title=w3c]
{
  border: 5px solid blue;
}

&amp;lt;img title=&amp;quot;w3c&amp;quot; src=&amp;quot;/images/w3c.gif&amp;quot;&amp;gt;

# 属性和值选择器的操作符：
=
~=
|=
^=
$=
*=
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后代选择器descendant&#34;&gt;后代选择器/descendant&lt;/h2&gt;
&lt;h2 id=&#34;子元素选择器child&#34;&gt;子元素选择器/child&lt;/h2&gt;
&lt;h2 id=&#34;相邻兄弟选择器adjacent-sibling&#34;&gt;相邻兄弟选择器/adjacent sibling&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css样式&#34;&gt;&lt;strong&gt;CSS样式&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;内联样式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p style=&amp;quot;background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center&amp;quot;&amp;gt;...&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;样式表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p {
  background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;background样式&#34;&gt;background样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;background: # 可以定义所有背景的值
background-color: gray # 背景颜色
background-image: url(/images/test.gif) # 背景图片,默认水平和垂直都平铺
background-repeat: repeat-x # 水平方向平铺
background-repeat: repeat-y # 垂直方向平铺
background-repeat: no-repeat # 不平铺
background-position: center/top/buttom/left/right # 图像在背景中的位置
background-attachment: fixed # 图像相对于可视区是固定的
background-size
background-origin
background-clip
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文本样式&#34;&gt;文本样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;color: red # 设置文本颜色
line-height # 设置行高
letter-spacing # 设置字符间距
word-spacing # 设置字间距
text-indent # 缩进元素中文本首行
direction: ltr/rtl # 设置文本方向
text-align: left/right/center/justify # 对齐元素中的文本
text-decoration: none/underline/overline/line-through/blink # 向文本添加修饰
text-transform: none/capitalize/uppercase/lowercase # 控制元素的字母
white-space: normal/pre/nowrap/pre-wrap/pre-line # 设置元素中空白的处理方式
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字体样式&#34;&gt;字体样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;font: # 定义所有和字体有关的属性
font-family: # 设置字体系列
font-size:  # 设置字体尺寸
font-style: normal/italic/oblique # 设置字体风格
font-variant: normal/small-caps # 设置字体变体
font-weight: normal/bold/bolder/lighter/... # 设置字体粗细
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链接样式&#34;&gt;链接样式&lt;/h2&gt;
&lt;p&gt;链接可以设置background，color，font等样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a:link {background: red} # 普通的未被访问的链接
a:visited {color: blue} # 用户已访问的链接
a:hover {font: } # 鼠标指针位于链接的上方
a:active {font: } # 链接被点击的时刻
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;列表样式&#34;&gt;列表样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;list-style: # 定义所有和列表相关的属性
list-style-image: # 把图像设置为列表项标志
list-style-position: inside/outside # 设置列表项标志的位置
list-style-type: # 设置列表项标志的位置
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;表格样式&#34;&gt;表格样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;border-collapse: separate/collapse # 设置是否把表格边框合并为单一的边框
border-spacing: # 设置分割单元边框距离
caption-side: top/bottom # 规定表格标题设置方式
empty-cells: hide/show # 设置是否现实表格中的空单元格
table-layout: automatic/fixed # 设置现实单元，行和列的算法
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;轮廓样式&#34;&gt;轮廓样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;outline: # 设置所有和轮廓相关的属性
outline-color: # 设置轮廓颜色
outline-style: none/dotted/dashed/solid/double/groove/ridge/inset/outset # 设置轮廓风格
outline-width: # 设置轮廓宽度
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;尺寸属性&#34;&gt;尺寸属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;height
width
max-height
max-width
min-height
min-width
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css模型框&#34;&gt;&lt;strong&gt;CSS模型框&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;内边距属性&#34;&gt;内边距属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;padding
padding-top
padding-rigit
padding-bottom
padding-left
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;边框属性&#34;&gt;边框属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;border
border-style
border-width
border-color
border-buttom
border-buttom-color/style/width
border-left
border-left-color/style/width
border-right
border-right-color/style/width
border-top
border-top-color/style/width
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;外边距属性&#34;&gt;外边距属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;margin # 依次为上，右，下，左．
margin-right
margin-top
margin-bottom
margin-left
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css定位&#34;&gt;&lt;strong&gt;CSS定位&lt;/strong&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;position # 规定元素的定位
top
right
bottom
left
overflow # 内容益处元素框时，visible/hidden/scroll/auto/inderit
clip
vertical-align
z-index
display # 规定元素应该生成的框的类型, inline/none/block/...
float # none/left/right/inderit, 规定框是否应该浮动
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;color&#34;&gt;color&lt;/h2&gt;
&lt;p&gt;16进制 和 rgb表示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rgb(255,255,255) == #FFFFFF == white
rgb(0,0,0) == #000000 == black
rgb(255,0,0) == red
rgb(0,255,0) == green
rgb(0,0,255) == blue
rgb(255,255,0) == yellow
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Html</title>
        <link>https://canuxcheng.com/post/html/</link>
        <pubDate>Thu, 23 Jun 2016 09:40:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/html/</guid>
        <description>&lt;h1 id=&#34;html&#34;&gt;HTML&lt;/h1&gt;
&lt;p&gt;HTML是超文本标记语言&lt;/p&gt;
&lt;h1 id=&#34;xhtml&#34;&gt;XHTML&lt;/h1&gt;
&lt;p&gt;XHTML是更严谨的更纯净的HTML&lt;/p&gt;
&lt;h1 id=&#34;html5&#34;&gt;HTML5&lt;/h1&gt;
&lt;p&gt;HTML5是下一代HTML&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;html元素和属性&#34;&gt;&lt;strong&gt;html元素和属性&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;html元素指从开始标签到结束标签的所有代码,包括元素内容：&lt;/p&gt;
&lt;p&gt;html元素可以嵌套。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt; This is paragrph &amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; # 空内容的元素
&amp;lt;br /&amp;gt; # 空元素，在开始标签中关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;html标签可以拥有属性，属性总是以name=&amp;lsquo;value&amp;rsquo;的形式出现，属性总是在html元素的开始标签中规定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://www.test.com&amp;quot;&amp;gt;This is a link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;html属性和值大小写不敏感，推荐使用小写,始终给属性值加引号。&lt;/p&gt;
&lt;h2 id=&#34;html的全局属性标准属性&#34;&gt;html的全局属性(标准属性)&lt;/h2&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.w3school.com.cn/tags/html_ref_standardattributes.asp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.w3school.com.cn/tags/html_ref_standardattributes.asp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;html的事件属性&#34;&gt;html的事件属性&lt;/h2&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.w3school.com.cn/tags/html_ref_eventattributes.asp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.w3school.com.cn/tags/html_ref_eventattributes.asp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;html字符实体&#34;&gt;html字符实体&lt;/h2&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.w3school.com.cn/tags/html_ref_entities.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.w3school.com.cn/tags/html_ref_entities.html&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;html基本标签&#34;&gt;&lt;strong&gt;html基本标签&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;doctype&#34;&gt;DOCTYPE&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 文档类型
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
...
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
...
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;html-1&#34;&gt;html&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# html文档,支持全局属性
&amp;lt;html&amp;gt;
...
&amp;lt;/html&amp;gt;

# mainfest属性，定义一个url，描述文档缓存信息

# xmlns属性，定义XML的namespace属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 注释, 浏览器会忽略注释,没有任何属性
&amp;lt;!-- This is a comment --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;空格&#34;&gt;空格&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp;nbsp;    # 空格
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;head&#34;&gt;&lt;strong&gt;head&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;head-1&#34;&gt;head&lt;/h2&gt;
&lt;p&gt;可以在head标签中使用的标签： link, style, base, meta, script, title.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# html文档的头部, head支持全局属性
&amp;lt;head&amp;gt;

  &amp;lt;base&amp;gt;
  &amp;lt;meta&amp;gt;
  &amp;lt;title&amp;gt; 必须的
  
  &amp;lt;link&amp;gt;
  &amp;lt;style&amp;gt;
  
  &amp;lt;script&amp;gt;

&amp;lt;/head&amp;gt;

# profile属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;title&#34;&gt;title&lt;/h2&gt;
&lt;p&gt;定义文档标题，支持全局属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# dir属性规定元素中内容的文本方向
# lang属性规定元素中内容的语言编码
# xml:lang属性规定xhtml文档中元素内容的语言编码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;base&#34;&gt;base&lt;/h2&gt;
&lt;p&gt;定义页面所有的链接的默认地址和默认目标。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# href属性规定页面中所有相对链接的基准url
# target属性规定在何处打开页面中的链接
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;meta&#34;&gt;meta&lt;/h2&gt;
&lt;p&gt;定义元数据,支持全局属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# content属性
# http-equiv
# name
# scheme
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;body&#34;&gt;&lt;strong&gt;body&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;body-1&#34;&gt;body&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# html文档的主体, 支持样式，支持全局属性和事件属性
&amp;lt;body&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;h1-h6&#34;&gt;h1-h6&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 标题,浏览器会自动在标题前后添加空行,支持样式
&amp;lt;h1&amp;gt;This is the max heading&amp;lt;/h1&amp;gt;
...
&amp;lt;h6&amp;gt;This is the min heading&amp;lt;/h6&amp;gt;

# 支持部分全局属性
# id,class,title,style,dir,lang,xml:lang

# 支持部分事件属性
# onclick,ondblclick,onmousedown,onmouseup,onmouseover,
# onmousemove, ommouseout,onkeypress,onkeydown,onkeyup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hr&#34;&gt;hr&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 水平线分割线，支持样式，支持全局属性和事件属性
&amp;lt;hr /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;段落&#34;&gt;&lt;strong&gt;段落&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;p&#34;&gt;p&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 段落, 浏览器会自动在段落前后添加空行,支持样式，支持全局属性和事件属性
&amp;lt;p&amp;gt;This is a paragraph&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;br&#34;&gt;br&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 空行, 支持全局属性和事件属性
&amp;lt;br /&amp;gt;

# clear属性
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;链接和图像&#34;&gt;&lt;strong&gt;链接和图像&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;URL: Uniform Resource Locator&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scheme://host.domain:port/path/filename
scheme: http/https/ftp/file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url只能使用ASCII字符集。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.w3school.com.cn/tags/html_ref_urlencode.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.w3school.com.cn/tags/html_ref_urlencode.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a&#34;&gt;a&lt;/h2&gt;
&lt;p&gt;支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# href属性定义指向另一个文档的链接
&amp;lt;a href=&amp;quot;http://www.test.com&amp;quot;&amp;gt;Click me as link&amp;lt;/a&amp;gt;

# target属性，定义被链接的文档在何处显示, blank在新窗口显示,rect, circle, poly
&amp;lt;a href=&amp;quot;http://www.test.com&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Link&amp;lt;/a&amp;gt;

# name属性定义文档内的书签
&amp;lt;a href=&amp;quot;http://www.test.com&amp;quot; name=&amp;quot;label&amp;quot;&amp;gt;Link&amp;lt;/a&amp;gt;

# hreflang

# rel

# download

# media

# type
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;img&#34;&gt;img&lt;/h2&gt;
&lt;p&gt;支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# src属性定义源
&amp;lt;img src=&amp;quot;url&amp;quot; /&amp;gt;

# alt属性，当图像不能显示，就显示alt的默认值。
&amp;lt;img src=&amp;quot;http://www.test.com/images/test.img&amp;quot; alt=&amp;quot;default value&amp;quot;/&amp;gt;

# height

# ismap

# longdesc

# usemap

# width
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;p&gt;支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# id属性为map定义唯一的名称
&amp;lt;map id=&amp;quot;planetmap&amp;quot;&amp;gt;
  ...
&amp;lt;/map&amp;gt;

# name属性为image-map规定的名称
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;area&#34;&gt;area&lt;/h2&gt;
&lt;p&gt;支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# alt
# coords
# href
# nohref
# shape
# target
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;样式&#34;&gt;&lt;strong&gt;样式&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;内联样式,定义在html元素内部。style样式属性可以包含任何的css属性。&lt;/p&gt;
&lt;p&gt;内联样式优先级最高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h1 style=&amp;quot;font-family:verdana&amp;quot;&amp;gt;A heading&amp;lt;/h1&amp;gt;
&amp;lt;p style=&amp;quot;font-family:arial;color:red;font-size:20px&amp;quot;&amp;gt;A paragraph&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;style&#34;&gt;style&lt;/h2&gt;
&lt;p&gt;内部样式表,位于head标签内部。支持全局属性和事件属性&lt;/p&gt;
&lt;p&gt;优先级仅次于内联样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
    h1 {color: red}
    p {color: blue}
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

# type属性规定样式表的MIME类型

# media属性规定不同的媒体类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;link&#34;&gt;link&lt;/h2&gt;
&lt;p&gt;外部样式表,支持全局属性和事件属性&lt;/p&gt;
&lt;p&gt;优先级仅高于浏览器缺省值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;mystyle.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;

# href属性规定被链接文档的位置
# hreflang属性规定被链接文档中文本的语言
# media属性规定被链接文档被显示在什么设备
# rel属性规定当前文档与被链接文档的关系
# sizes属性规定rel=&#39;icon&#39;的尺寸
# type属性规定被链接文档的MINE类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;div&#34;&gt;div&lt;/h2&gt;
&lt;p&gt;分类块级元素,支持样式，支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt; 使用样式属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;span&#34;&gt;span&lt;/h2&gt;
&lt;p&gt;分类行内元素，支持样式，支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span&amp;gt; 定义文档中的行内的块
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;格式化&#34;&gt;&lt;strong&gt;格式化&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;文本格式化标签&#34;&gt;文本格式化标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;b&amp;gt; 定义粗体文本
&amp;lt;big&amp;gt; 定义大号字
&amp;lt;em&amp;gt; 定义着重文字
&amp;lt;i&amp;gt; 定义斜体字
&amp;lt;small&amp;gt; 定义小号字
&amp;lt;strong&amp;gt; 定义加重语气
&amp;lt;sub&amp;gt; 定义下标字
&amp;lt;sup&amp;gt; 定义上标字
&amp;lt;ins&amp;gt; 定义插入字
&amp;lt;del&amp;gt; 定义删除字
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算机输出标签&#34;&gt;计算机输出标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt; 定义计算机代码
&amp;lt;kbd&amp;gt; 定义键盘码
&amp;lt;samp&amp;gt; 定义计算机代码样本
&amp;lt;tt&amp;gt; 定义打字机代码
&amp;lt;var&amp;gt; 定义变量
&amp;lt;pre&amp;gt; 定义预格式文本
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;引用和术语标签&#34;&gt;引用和术语标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;abbr&amp;gt; 定义缩写
&amp;lt;p&amp;gt;&amp;lt;abbr title=&amp;quot;Hyper Text Markup Language&amp;quot;&amp;gt;HTML&amp;lt;/abbr&amp;gt;is perfect.&amp;lt;/p&amp;gt;

&amp;lt;acronym&amp;gt; 定义首字母缩写
&amp;lt;address&amp;gt; 定义地址
&amp;lt;bdo&amp;gt; 定义文字方向
&amp;lt;blockquote&amp;gt; 定义长的引用
&amp;lt;q&amp;gt; 定义短的引用
&amp;lt;cite&amp;gt; 定义著作的标题
&amp;lt;dfn&amp;gt; 定义一个项目或缩写
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;表格&#34;&gt;&lt;strong&gt;表格&lt;/strong&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;
  &amp;lt;caption&amp;gt;The title&amp;lt;/caption&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;th&amp;gt;Month&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;Saving&amp;lt;/th&amp;gt;
  &amp;lt;/tr&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;Jan.&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;$100&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;table&#34;&gt;table&lt;/h2&gt;
&lt;p&gt;定义表格,支持事件属性和全局属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# border属性规定表格边框宽度
# cellpadding属性规定单元边沿与其内容之间的空白
# cellspacing属性规定单元格之间的空白
# frame属性规定外侧边框的哪个部分是可见的
# rules属性规定内侧边框的哪个部分是可见的
# summary属性规定表格的摘要
# width属性规定表格的宽度
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;caption&#34;&gt;caption&lt;/h2&gt;
&lt;p&gt;定义表格标题,支持样式，支持事件属性和全局属性&lt;/p&gt;
&lt;h2 id=&#34;tr&#34;&gt;tr&lt;/h2&gt;
&lt;p&gt;定义表格的行,支持事件属性和全局属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# align属性定义表格内容对齐方式
# char属性规定根据哪个字符来进行文本对齐
# charoff属性规定第一个对齐字符的偏移量
# valign属性规定表格中内容的垂直对齐方式
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;th-td&#34;&gt;th td&lt;/h2&gt;
&lt;p&gt;th定义表格表头,支持全局属性和事件属性&lt;/p&gt;
&lt;p&gt;td定义表格单元,支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# abbr属性规定单元格中内容的缩写版本
# align属性规定单元格内容的水平对齐方式
# axis属性对单元进行分类
# char
# charoff
# colspan
# headers
# rowspan
# scope
# valign
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;col&#34;&gt;col&lt;/h2&gt;
&lt;p&gt;定义用于表格的属性&lt;/p&gt;
&lt;h2 id=&#34;colgroup&#34;&gt;colgroup&lt;/h2&gt;
&lt;p&gt;定义表格的组&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;列表&#34;&gt;&lt;strong&gt;列表&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;ol&#34;&gt;ol&lt;/h2&gt;
&lt;p&gt;定义有序列表,支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
  &amp;lt;li&amp;gt;first one&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second one&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;

# reversed属性规定列表顺序为降序
# start属性有序列表的起始值
# type属性规定在列表中使用的标记类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ul&#34;&gt;ul&lt;/h2&gt;
&lt;p&gt;定义无序列表,支持样式，支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;coffee&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;tea&amp;lt;/li&amp;gt;
&amp;lt;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;li&#34;&gt;li&lt;/h2&gt;
&lt;p&gt;定义列表项,支持样式，支持全局属性和事件属性&lt;/p&gt;
&lt;h2 id=&#34;dl-dt-dd&#34;&gt;dl dt dd&lt;/h2&gt;
&lt;p&gt;dl定义定义列表,dt定义定义项目,dd定义定义的描述,都支持全局属性和事件属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dl&amp;gt;
  &amp;lt;dt&amp;gt;computer&amp;lt;/dt&amp;gt;
  &amp;lt;dd&amp;gt;used to monitor...&amp;lt;/dd&amp;gt;
&amp;lt;/dl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;网站布局&#34;&gt;&lt;strong&gt;网站布局&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;使用html5的网站布局标签.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;style&amp;gt;
    header {}
    nav {}
    section {}
    footer {}
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;header&amp;gt;...&amp;lt;/header&amp;gt;
  ...
  &amp;lt;footer&amp;gt;...&amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用id选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;style&amp;gt;
  #header {}
  ...
  #footer {}
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;header&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
  ...
  &amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;header标签&#34;&gt;header标签&lt;/h2&gt;
&lt;h2 id=&#34;nav标签&#34;&gt;nav标签&lt;/h2&gt;
&lt;h2 id=&#34;section标签&#34;&gt;section标签&lt;/h2&gt;
&lt;h2 id=&#34;article标签&#34;&gt;article标签&lt;/h2&gt;
&lt;h2 id=&#34;aside标签&#34;&gt;aside标签&lt;/h2&gt;
&lt;h2 id=&#34;footer标签&#34;&gt;footer标签&lt;/h2&gt;
&lt;h2 id=&#34;details标签&#34;&gt;details标签&lt;/h2&gt;
&lt;h2 id=&#34;summary标签&#34;&gt;summary标签&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;框架&#34;&gt;&lt;strong&gt;框架&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;框架可以在一个html添加多个页面。&lt;/p&gt;
&lt;p&gt;垂直框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;frameset cols=&amp;quot;50%, 50%&amp;quot;&amp;gt;
  &amp;lt;frame src=&amp;quot;a.html&amp;quot;&amp;gt;
  &amp;lt;frame src=&amp;quot;b.html&amp;quot;&amp;gt;
&amp;lt;/frameset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;水平框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;frameset rows=&amp;quot;50%, 50%&amp;quot;&amp;gt;
  &amp;lt;frame src=&amp;quot;a.html&amp;quot;&amp;gt;
  &amp;lt;frame src=&amp;quot;b.html&amp;quot;&amp;gt;
&amp;lt;/frameset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;混合框架：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;frameset rows=&amp;quot;50%, 50%&amp;quot;&amp;gt;

  &amp;lt;frame src=&amp;quot;a.html&amp;quot;&amp;gt;

  &amp;lt;frameset cols=&amp;quot;%25, 75%&amp;quot;&amp;gt;
    &amp;lt;frame src=&amp;quot;b.html&amp;quot;&amp;gt;
    &amp;lt;frame src=&amp;quot;c.html&amp;quot;&amp;gt;
  &amp;lt;/frameset&amp;gt;
  
&amp;lt;/frameset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;frameset标签&#34;&gt;frameset标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# cols属性定义框架中列的数目和尺寸
# rows属性定义框架中行的数目和尺寸

# 标准属性：
id,class,title,style
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;frame标签&#34;&gt;frame标签&lt;/h2&gt;
&lt;p&gt;定义frameset中的一个特定的窗口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frameborder属性规定是否现实框架周围的边框
# longdesc属性
# marginheight属性
# marginwidth属性
# name属性
# scrolling属性
# src属性

# 标准属性：
id,class,title,style
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;iframe标签&#34;&gt;iframe标签&lt;/h2&gt;
&lt;p&gt;内联框架。&lt;/p&gt;
&lt;p&gt;把内容放在iframe标签中，在无法理解iframe的浏览器显示。&lt;/p&gt;
&lt;p&gt;支持事件属性和全局属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frameborder属性
# height属性
# width属性
# longdesc属性
# marginheight属性
# marginwidth属性
# name属性
# scrolling属性
# src属性
# sandbox
# seamless
# srcdoc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;noframes标签&#34;&gt;noframes标签&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;脚本&#34;&gt;&lt;strong&gt;脚本&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;在html中插入javascript等脚本&lt;/p&gt;
&lt;h2 id=&#34;script标签&#34;&gt;script标签&lt;/h2&gt;
&lt;p&gt;定义客户端脚本，支持全局属性&lt;/p&gt;
&lt;p&gt;直接嵌入javascript代码时注意代码中如果有&amp;lt;/script&amp;gt;需要转义．&lt;/p&gt;
&lt;p&gt;通过src属性指定外部javascript脚本的script标签中不能包含额外的javascript代码．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 直接嵌入javascript代码 --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  document.write(&amp;quot;hello javascript&amp;quot;)
&amp;lt;/script&amp;gt;

&amp;lt;!-- 指定外部javascript脚本　--&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

# type 可选，指定脚本MIME类型，比如text/javascript
# src 可选，表示指定的外部文件
# charset 可选，表示通过src属性指定的代码的字符集
# defer 可选，表示外部脚本可以延迟到文档完全被解析和显示之后再执行
# async 可选，表示应该立即下载外部脚本

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  ...head content...
  
  &amp;lt;!-- head中的script是调用才执行的，或者是事件触发的，可以提前备加载 --&amp;gt;
  &amp;lt;script&amp;gt;...&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  ...body content...

  &amp;lt;!-- 页面内容先呈现，然后按顺序加载和解析脚本 --&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

  &amp;lt;!-- defer表示整个页面解析完后才加载和解析脚本 --&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; defer=&amp;quot;defer&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

  &amp;lt;!-- async表示在加载页面期间异步加载和解析脚本 --&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; async src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;noscript标签&#34;&gt;noscript标签&lt;/h2&gt;
&lt;p&gt;针对早期不支持javascript的浏览器，为不支持客户端脚本的浏览器定义替代内容,支持全局属性&lt;/p&gt;
&lt;p&gt;当浏览器不支持，就显示noscript标签的内容，否则就不显示．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;noscript&amp;gt;Your browser does not support javascript&amp;lt;/noscript&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/python_package/</link>
        <pubDate>Wed, 22 Jun 2016 05:17:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_package/</guid>
        <description>&lt;h1 id=&#34;package&#34;&gt;Package&lt;/h1&gt;
&lt;p&gt;PEP426是python最新的打包标准，定义了wheel为最新的python包。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0426/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0426/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ensurepip&#34;&gt;ensurepip&lt;/h2&gt;
&lt;p&gt;内置模块.提供使用pip从pypi安装模块。&lt;/p&gt;
&lt;h2 id=&#34;distutils&#34;&gt;distutils&lt;/h2&gt;
&lt;p&gt;内置的模块.处理简单的包安装,一般使用setuptools代替该模块。&lt;/p&gt;
&lt;h2 id=&#34;venv&#34;&gt;venv&lt;/h2&gt;
&lt;p&gt;python3新增了虚拟环境的包．python2中使用virtualenv.&lt;/p&gt;
&lt;h2 id=&#34;zipapp&#34;&gt;zipapp&lt;/h2&gt;
&lt;p&gt;python3新增管理可执行的python的zip包．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;virtualenv&#34;&gt;virtualenv&lt;/h2&gt;
&lt;p&gt;python3.5开始并入了虚拟化标准库venv.&lt;/p&gt;
&lt;p&gt;分离的虚拟的python环境,自动安装setuptools和pip和wheel&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/virtualenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/virtualenv&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd project

# 默认python2.7
$virtualenv .env
# 指定python3, 会安装pip/setuptools/wheel到当前环境.
$$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env

# 激活虚拟环境
$source .env/bin/activate

# 先升级pip和setuptools
$pip install pip
$pip install setuptools
$pip install wheel

# 导出项目用的所有依赖库．
$pip freeze &amp;gt; requirements.txt
# 在其它环境需要安装依赖：
$pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;virtualenvwrapper&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;封装了virtualenv的工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install virtualenvwrapper

# 创建主目录
$ mkdir -p $WORKON_HOME

# 最好写入到.bashrc/.zshrc:
$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
$ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv
$ export WORKON_HOME=~/.virtualenvs
$ source /usr/local/bin/virtualenvwrapper.sh

# 为每个项目创建独立python环境：
$ mkvirtualenv -r requirementx.txt [project-name]
# 不安装setuotools/wheel/pip
$ mkvirtualenv --no-setuptools --no-wheel --no-pip [name]
# 指定查找pip/setuptools的路径
--extra-search-dir=/usr/local/lib/python2.7/dist-packages
--extra-search-dir=/usr/lib/python2.7/dist-packages
$ workon [project-name] # 切换到针对该项目的virtualenv
(pro)$ /path/to/pip install [package] # 安装第三方包
(pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装
(pro)$ lssitepackages # 查看安装的第三方包
$ deactivate # 退出virtualenv
$ rmvirtualenv [project-name] # 删除环境
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pipenv&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/pipenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/pipenv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;封装了virtualenv的工具，用于取代virtualenvwrapper.&lt;/p&gt;
&lt;h2 id=&#34;setuptools&#34;&gt;setuptools&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/setuptools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/setuptools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/wheel&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/wheel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python2.7.9和python3.4以及virtualenv自带setuptools．&lt;/p&gt;
&lt;p&gt;支持sdist打包成tar.gz包,和wheel打包成whl包．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install -U pip
$pip install -U setuotools
$pip install -U wheel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建setup.py文件：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi?%3Aaction=list_classifiers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os

from setuptools import setup, find_packages

import project

def read(readme):
    extend = os.path.splitext(readme)[1]
    # pypi只识别reST格式
    if (extend == &amp;quot;.rst&amp;quot;):
        import codecs
        return codecs.open(readme, &#39;r&#39;, &#39;utf-8&#39;).read()
    # pypandoc可以将markdown格式转换成reST格式
    elif (extend == &amp;quot;.md&amp;quot;):
        import pypandoc
        return pypandoc.convert(readme, &#39;rst&#39;)

setup(
    # metadata:
    name=project,
    version=project.__version__,
    url=&#39;&#39;,
    download_url=&#39;&#39;,
    author=&#39;&#39;,
    author_email=&#39;&#39;,
    maintainer=&#39;&#39;,
    maintainer_email=&#39;&#39;,
    description=&#39;&#39;
    long_description=read(&#39;README.XXX&#39;),
    license=&#39;&#39;,
    platforms=&#39;any&#39;,
    keywords=&#39;&#39;,
    classifiers=[
        &#39;Development Status :: 5 - Production/Stable&#39;,
        ...
    ],

    # options

    # 指定源码的位置
    packages=find_packages(),
    package_dir={},

    # 需要和源码一起安装的非代码文件,写入MANIFEST.in
    # 比如文档和测试文件
    package_data={}, # 将指定的文件放入安装路径
    include_package_data=None, # True表示
    exclude_package_data=None,

    # 不需要和源码一起安装的非代码文件.
    # 比如配置文件
    data_files=[(dest, source),()],

    # 通过pip安装requirement
    install_requires=[&#39;a==1.0.0&#39;, &#39;b&amp;gt;=1.0.0&#39;],
    # python版本的要求
    python_requires=&#39;&amp;gt;=3&#39;,
    setup_requires=[],
    extras_require=None,
    test_require=[]

    zip_safe=True,

    # 安装一个命令
    scripts=[],    # 会被添加到环境变量用于命令.

    entry_points={}

    # preinst/postinst
    cmdclass={
        &amp;quot;develop&amp;quot;: PostInstDevelop,
        &amp;quot;install&amp;quot;: PostInstInstall
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;怎样实现postinst功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from setuptools.command.develop import develop
from setuptools.command.install import install

class InstDevelop(develop):
    def run(self):
        # your preinst code here for develop.
        develop.run(self)
        # your postinst code here for develop.

class InstInstall(install):
    def run(self):
        # your preinst code here for install.
        install.run(self)
        # your postinst code here for install.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建setup.cfg文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[wheel]
universal = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建README.rst文件：&lt;/p&gt;
&lt;p&gt;可以是rst格式也可是是md格式。&lt;/p&gt;
&lt;p&gt;如果是md格式不要使用类似于***的分割线。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参考rst和md的文档
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建MAINFEST.in文件：&lt;/p&gt;
&lt;p&gt;默认只有python模块和包会被打包，如果需要其它文件需要添加到这个文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include LICENSE README.rst AUTHORS.rst CONTRIBUTING.rst
recursive-include docs *
graft examples
graft tests
global-exclude *.py[co]
prune docs/_build
prune docs/_themes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建__init__.py文件：&lt;/p&gt;
&lt;p&gt;位于project/project/__init__.py，安装后用import导入，help(project)看到的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME: 自动获取的项目名字 - 该文件注释的总结部分
FILE: /install_path/project/project/__init__.py
DESCRIPTION: 该文件的注释，除总结部分
PACKAGE CONTENTS: 在project/project/自动获取的py文件名
DATA: __开头和结尾的变量
VERSION: __version__变量的值
AUTHOR: __author__变量的值

#!/usr/bin/env python
# -*- coding: utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
SUMMARY

Descriptions
&amp;quot;&amp;quot;&amp;quot;

__version__ = &#39;&#39;
__author__ = &#39;&#39;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发布到pypi主服务器pypi：&lt;/p&gt;
&lt;p&gt;去pypi注册帐号&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建~/.pypirc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[distutils]
index-servers = pypi

[pypi]
username = &amp;lt;username&amp;gt;
password = &amp;lt;password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在索引中注册项目(不再支持，直接upload)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Deprecated] $ python setup.py register -r pypi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先打包, 在dist目录生成包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python setup.py sdist # 生成tarball
$ python setup.py bdist_wheel # 安装wheel后，可以用setuptools生成wheel包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再上传到pypi(推荐):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install twine
$ twine upload dist/*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包并上传到pypi：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python setup.py sdist upload -r pypi
$python setup.py bdist_wheel upload -r pypi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cython&#34;&gt;cython&lt;/h2&gt;
&lt;p&gt;编译成.so文件&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo pip install cython
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在setup.py中引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from Cython.Build import cythonize
from Cython.Distutils import build_ext

def add_extensions(modules):
    extensions = []
    for module in modules:
        level = module
        for depth in range(10):
            source_dir = level + &amp;quot;.py&amp;quot;
            if glob.glob(source_dir):
                extensions.append(Extension(module, [source_dir], include_dirs=[&amp;quot;.&amp;quot;], extra_compile_args=[&#39;-O3&#39;]),)
            level = os.path.join(level, &amp;quot;*&amp;quot;)
    print(extensions)
    return extensions

INCLUDE_PACKAGES = []
EXCLUDE_PACKAGES = []    

setup(
    ext_modules=cythonize(
        add_extensions(INCLUDE_PACKAGES),
        build_dir=&amp;quot;build&amp;quot;,
        # 指定 .py =&amp;gt; .c 使用8个线程编译.
        nthreads=8,
        compiler_directives=dict(
            always_allow_keywords=True,
            language_level=3),
        exclude=EXCLUDE_PACKAGES),
    cmdclass={
        &amp;quot;install&amp;quot;: InstInstall,
        &amp;quot;build_ext&amp;quot;: build_ext
    },
)

// -j 8 指定.c =&amp;gt; .so 使用8个线程编译.
$ python3 setup.py build_ext --inplace -j 8 
// 删除符号信息
$ find sandbox/ -name &amp;quot;*.so&amp;quot; -exec strip {} \; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pbr&#34;&gt;pbr&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack-dev/pbr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack-dev/pbr&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;扩展点entry-points&#34;&gt;扩展点（Entry Points）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pkg_resources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;entry_point_inspector&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dhellmann/entry_point_inspector&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dhellmann/entry_point_inspector&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stevedore&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://docs.openstack.org/developer/stevedore/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://docs.openstack.org/developer/stevedore/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Summary</title>
        <link>https://canuxcheng.com/post/python_summary/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:20 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_summary/</guid>
        <description>&lt;h1 id=&#34;python难点总结&#34;&gt;python难点总结&lt;/h1&gt;
&lt;h1 id=&#34;多线程&#34;&gt;多线程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GIL&lt;/p&gt;
&lt;p&gt;GIL: Global Interpretror Lock. 全局解释器锁．&lt;/p&gt;
&lt;p&gt;python不建议使用多线程，用多进程代替．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;协程&#34;&gt;协程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;coroutine&lt;/p&gt;
&lt;p&gt;协程就是同时开启两个任务，但一次只顺序执行一个．
如果执行的任务阻塞，就切换到下一个继续执行．节省时间．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>OOP</title>
        <link>https://canuxcheng.com/post/python_oop/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_oop/</guid>
        <description>&lt;h1 id=&#34;面向对象oop&#34;&gt;面向对象/OOP&lt;/h1&gt;
&lt;p&gt;OOD: Object Oriented Design.&lt;/p&gt;
&lt;p&gt;面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．&lt;/p&gt;
&lt;p&gt;OOP: Object Oriented Programming.&lt;/p&gt;
&lt;p&gt;python内置OOP的结构，但是不必一定要使用类和OOP.&lt;/p&gt;
&lt;p&gt;面向对象的两个主题就是类和类实例．&lt;/p&gt;
&lt;p&gt;创建实例的过程叫实例化．&lt;/p&gt;
&lt;p&gt;属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;类class&#34;&gt;类/Class&lt;/h1&gt;
&lt;p&gt;类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．&lt;/p&gt;
&lt;p&gt;类是一种数据结构的定义，实例是申明了一个这种类型的变量．&lt;/p&gt;
&lt;p&gt;类的定义：&lt;/p&gt;
&lt;p&gt;Python 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    &amp;quot;&amp;quot;&amp;quot;Doc string.&amp;quot;&amp;quot;&amp;quot;
    class_suite
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的初始化方法init(相当于构造器):&lt;/p&gt;
&lt;p&gt;如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。&lt;/p&gt;
&lt;p&gt;init方法的第一个参数必须是实例self，而且不能有return语句。&lt;/p&gt;
&lt;p&gt;init方法一般用来设置实例属性(也就是数据属性)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    def __init__(self, *args, **kwargs):
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊方法new:&lt;/p&gt;
&lt;p&gt;如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。&lt;/p&gt;
&lt;p&gt;new方法的第一个参数必须是类cls。并且需要返回一个实例。&lt;/p&gt;
&lt;p&gt;new方法在object中被定义为staticmethod。&lt;/p&gt;
&lt;p&gt;相当于析构器的特殊方法del:&lt;/p&gt;
&lt;p&gt;__del__特殊方法要在实例对象的所有引用都被清除后才会执行。&lt;/p&gt;
&lt;p&gt;不要在del中做与实例没有关系的事情，一般不建议实现该方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):

    def __new__(cls, *args, **kwargs):
        ...
        return ...

    def __del__(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类属性&#34;&gt;类属性&lt;/h2&gt;
&lt;p&gt;类属性分为数据属性和方法属性。&lt;/p&gt;
&lt;p&gt;类的数据属性仅仅是定义的类的变量。&lt;/p&gt;
&lt;p&gt;数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。&lt;/p&gt;
&lt;p&gt;直接通过类名来访问类的数据属性。不建议通过实例来访问类的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    CONST_VARIABLE = &#39;value&#39;

    def __init__(self, *args, **kwargs):
        ClassName.CONST_VARIABLE = &#39;new&#39;

ClassName.CONST_VARIABLE = &#39;new value&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的方法属性仅仅是一个作为类定义的一部分定义的函数, 与类的实例无关。&lt;/p&gt;
&lt;p&gt;类中定义的方法的第一个参数是一个实例self。&lt;/p&gt;
&lt;p&gt;方法属性必须绑定到一个实例才能被直接调用, 非绑定方法没有给出实例对象一般不能直接调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    def func(self, *args, **kwargs):
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python 3 中，直接调用 ClassName.func() 会报错：TypeError: func() missing 1 required positional argument: &amp;lsquo;self&lt;/p&gt;
&lt;p&gt;调用非绑定方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassName.func(ClassName()) # 除非传入实例作为第一个参数self的值
# 常用场景： 调用父类中的非绑定方法
class ClassName(BaseClass):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用绑定方法： 自动把实例作为self传入，不用显式传入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassName().func()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看类的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dir(class) # 内建函数
class.__dict__ # 类的特殊属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__name__ # class namkkk
class.__qualname__
class.__module__
class.__doc__ # 文档的特殊属性, 不会被继承.
class.__annotations

class.__bases__ # 类的父类构成的元组
class.__orig_bases__
# 新式类新增的三个特殊属性:
class.__mro__ # 返回方法解析顺序的元组, mro()
class.__subclasses__() # 返回子类的列表

class.__dict__ # 以字典的形式存储对象的属性
class.__weakref__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法和函数的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;__doc__&#39;,
&#39;__annotations__&#39;
&#39;__qualname__&#39;
&#39;__name__&#39;,
&#39;__module__&#39;,
&#39;__self__&#39;,
&#39;__func__&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;实例instances&#34;&gt;实例/Instances&lt;/h1&gt;
&lt;p&gt;实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ins = ClassName()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例属性&#34;&gt;实例属性&lt;/h2&gt;
&lt;p&gt;实例属性：&lt;/p&gt;
&lt;p&gt;实例严格来说只有数据属性(方法属性应该属于类属性)，数据属性就是和某个实例相关联的数据值，这些值独立于其它实例或类，当一个实例被释放，相应的数据属性也被释放。通常通过init方法来设置实例的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    DATA = &amp;quot;in class&amp;quot; # 类的数据属性

    def __init__(self, default=&amp;quot;default&amp;quot;, *args, **kwargs):
        self.default = default # 当前实例的数据属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别类的数据属性和实例的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj1 = ClassName()
print(obj1.DATA) # &amp;quot;in class&amp;quot;, 当实例没有同名的数据属性，会访问类的数据属性。
obj1.DATA = &amp;quot;in obj1&amp;quot; # 相当于给实例新建了一个数据属性，会覆盖类的数据属性。
print(obj1.DATA) # &amp;quot;in obj1&amp;quot; 访问的是实例的数据属性，覆盖了类的数据属性。
print(ClassName.DATA) # &amp;quot;in class&amp;quot; 访问类的数据属性。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看实例属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance.__dict__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance.__dict__ # 以字典的形式存储对象的属性
instance.__class__ # 实例对应的类
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;封装encapsulation&#34;&gt;&lt;strong&gt;封装/Encapsulation&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;封装描述了对数据／信息进行隐藏的观念，对数据属性提供接口和访问函数．&lt;/p&gt;
&lt;p&gt;默认情况下，数据属性和类属性都是public的．类所在的模块和导入了类的其它模块都可以使用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var # public
def method_name(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个下划线开头的属性是protected,能在类本身和子类使用，类的实例可以直接访问，不可以用from module import *导入．&lt;/p&gt;
&lt;p&gt;用于把属性限制在一个模块中．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_xxx # protected
def _xxx(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双下划线开头的属性是private, 只能类本身使用，类的实例不能直接访问，子类和其它类都不能使用,子类也不能覆盖．&lt;/p&gt;
&lt;p&gt;用于把属性限制在一个类中.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__xxx # private
def __xxx(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统已经定义的特殊方法，也称魔法方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __xxx__(self): # 系统定义的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;composition&#34;&gt;Composition&lt;/h2&gt;
&lt;p&gt;类之间的关系只有两种继承和包含.&lt;/p&gt;
&lt;p&gt;创建复合对象时可以通过composition组合来增加功能和代码的重用性．&lt;/p&gt;
&lt;p&gt;当类之间有显著不同，并且较小的类是较大的类所需的组件时一般使用组合．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .company import Company
from .home import Home
class Emp(object):
    def __init__(self, *args, **kwargs):
        self.comp = Company(args)
        self.home = Home(kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;继承inheritance&#34;&gt;&lt;strong&gt;继承/Inheritance&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;利用类的两种方式就是包装和继承．&lt;/p&gt;
&lt;h2 id=&#34;子类和派生&#34;&gt;子类和派生&lt;/h2&gt;
&lt;p&gt;对于相同的类但是有不同的功能，可以通过derivation派生来实现．&lt;/p&gt;
&lt;p&gt;通过使用一个已经定义好的类，扩展它或者修改，而不会影响系统中使用现存类的其它代码片段．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father(object):
    def woman(self):
        ...

class Mother(object);
    def man(self):
        ...

class Child(Father, Mother):
    def child(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承描述了基类的属性如何遗传给派生类．&lt;/p&gt;
&lt;p&gt;派生类（子类）继承自基类（父类）&lt;/p&gt;
&lt;p&gt;python中的类需要继承一个或多个父类．&lt;/p&gt;
&lt;p&gt;object类是所有类的父类．&lt;/p&gt;
&lt;p&gt;子类继承了基类的属性和方法．&lt;/p&gt;
&lt;p&gt;文档字符串__doc__是唯一的，不能继承．&lt;/p&gt;
&lt;p&gt;一个类的__bases__属性可以查看它的父类组成的元组．不包括父类的父类．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__bases__ # 类的父类构成的元组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例调用方法时，默认调用的该对象的类的本身的方法，如果该类没有实现该方法才会调用父类的方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent(object):
    def foo(self):
        print(&amp;quot;in parent.&amp;quot;)

class Child(Parent):
    def foo(self):
        print(&amp;quot;in child.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;从内置类继承&#34;&gt;从内置类继承&lt;/h2&gt;
&lt;p&gt;可以从内置类型继承子类，修改一些属性．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class RoundFloat(float):
    def __new__(cls, val):
       return super(RoundFloat, cls).__new__(cls, round(val, 2))

class SortedKeyDict(dict):
    def keys(self):
        return sorted(super(SortedKeyDict, self).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;multiple-inheritance多重继承&#34;&gt;Multiple inheritance多重继承&lt;/h2&gt;
&lt;p&gt;由于类，类型，内建类型的子类都重新架构，新的类采用MRO算法来查找子类中使用的属性．&lt;/p&gt;
&lt;p&gt;MRO: Method Resolution Order, 方法解释顺序．采用广度优先，从左至右边，来获取在子类中的属性．&lt;/p&gt;
&lt;p&gt;可以通过新式类的特殊属性查看子类的属性的查找顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__mro__ # 返回方法解析顺序的元组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多继承，mro和super的用法：&lt;/p&gt;
&lt;p&gt;super每次只调用MRO中的第一个父类，和getattr的顺序一样．并且相同的父类只调用一次．&lt;/p&gt;
&lt;p&gt;数据属性，普通方法属性，特殊方法属性都是按照MRO顺序来查找．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;多态polymorphism&#34;&gt;&lt;strong&gt;多态/Polymorphism&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python不支持方法重载，但是可以通过对参数的判断，对不同的参数进行不同的处理。以此来实现重载的功能。&lt;/p&gt;
&lt;p&gt;python可以重载魔法方法。&lt;/p&gt;
&lt;h2 id=&#34;magicmethod&#34;&gt;magicmethod&lt;/h2&gt;
&lt;p&gt;python类有一些可自定义的特殊方法集，它们中的一些有预定义的默认行为，一些没有，留到需要的时候去实现。&lt;/p&gt;
&lt;p&gt;这些特殊方法是python中用来扩充类的方法。可以用来模拟标准类型或者重载操作符。&lt;/p&gt;
&lt;p&gt;这些特殊方法都是用双下划线开头和结尾的，也被称为魔法方法。&lt;/p&gt;
&lt;p&gt;对象创建和销毁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__init__(self, *args, **kwargs) # 构造器，带一些可选的参数
__new__(cls, *args, **kwargs) # 构造器，带一些可选的参数，通常用来设置不可变数据类型的子类。
__del__(self) # 解构器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串表示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__str__(self) # str(), print() 
obj = ClassName()
print(obj) # 没有定义__str__ 会调用__repr__

__repr__(self)  # repr()
obj = ClassName()
obj # 默认的打印对象的运行时的字符串，&amp;lt;test.RoundFloat at 0x7fb715253e90&amp;gt;
# 可以通过重写__repr__()改变打印的内容

__bool__(self) # 用于bool判断真假
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可调用对象的特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__call__(self, *args) # 表示可调用的实例, callable(object) 会返回true.

class TestClass(object):
    def __call__(self, *args):
        print(&amp;quot;Instance is callable after implement call method in class.&amp;quot;)
        print(&amp;quot;Args come from instance invoke is: {}&amp;quot;.format(args))

tc = TestClass()
callable(tc) # True
tc()
tc(&#39;arg1&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例和类的检查相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__instancecheck__(self, instance) # isinstance(instance, class)
__subclasscheck__(self, subclass) # issubclass(subclass, class)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__getattr__(self, name) # getattr(), 仅当属性没有在实例／类／父类的__dict__中找到才会调用．
__getattribute__(self, name)
__setattr__(self, name, value)
__delattr__(self, name)
__dir__(self) # dir()

# 描述符相关
__get__(self, instance, owner)
__set__(self, instance, value)
__delete__(self, instance)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with上下文管理特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__enter__(self) # return self, 需要返回self
__exit__(self, exc_type, exc_value, traceback)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象比较特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__cmp__(self, other) # cmp()
__lt__(self, other)
__le__(self, other)
__eq__(self, other)
__ne__(self, other)
__gt__(self, other)
__ge__(self, other)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容器类型相关特殊方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__len__(self) #　len()
__getitem__(self, key) #
__setitem__(self, key, value) #
__delitem__(self, key) # del
__reversed__(self) # reversed()
__iter__(self) # iter()
__contains__(self, item)
__missing__(self, key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数值类型相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__add__(self, other)
__sub__(self, other)
__mul__(self, other)
__div__(self, other)
__truediv__(self, other)
__floordiv__(self, other)
__mod__(self, other)
__divmod__(self, other)
__pow__(self, other[, module])
__lshift__(self, other)
__rshift__(self, other)
__and__(self, other)
__xor__(self, other)
__or__(self, other)

__rxxx__(self, other)

# 原位运算必须返回self.
__ixxx__(self, other) # self += other -&amp;gt; self = self + other

__neg__(self)
__pos__(self)
__abs__(self)
__invert__(self)

__complex__(self)
__int__(self)
__long__(self)
__float__(self)

__oct__(self)
__hex__(self)

__index__(self)
__coerce__(self, other)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;delegation--wrapping&#34;&gt;Delegation &amp;amp; Wrapping&lt;/h2&gt;
&lt;p&gt;Wrapping包装就是对一个已经存在的对象增加，删除或修改已经存在的功能．&lt;/p&gt;
&lt;p&gt;Delegation授权(代理)是Wrapping包装的一个特性,用于简化处理相关命令性功能，最大化重用代码．&lt;/p&gt;
&lt;p&gt;实现delegation的关键在于覆盖__getattr__()特殊方法．通过调用内置函数getattr()得到一个对象的默认行为．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Wrapper(object):
    def __init__(self, obj):
        self.__data = obj

    def __getattr__(self, attr):
        return getattr(self.__data, attr)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;metaclass元类&#34;&gt;metaclass元类&lt;/h1&gt;
&lt;p&gt;metaclass 是&amp;quot;创建类的类&amp;quot;。正如实例是类的实例化，类也是元类的实例化。在 Python 中，类本身也是对象，而元类就是用来创建这些类对象的。&lt;/p&gt;
&lt;p&gt;元类用来定义某些类是如何被创建的。改变类的默认行为和创建方式。&lt;/p&gt;
&lt;p&gt;大多数情况下不需要创建元类，一般使用系统的元类的默认方式。&lt;/p&gt;
&lt;p&gt;在执行类定义的时候，解释器必须知道这个类的元类；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(metaclass=MetaClassName):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行类定义时候检查元类，元类传递三个参数到构造器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类名
从基类继承数据的元组, __bases__
类的属性字典, __dict__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元类相关的可定制属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__metaclass__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个元类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MetaClassName(type):
    def __new__(cls, name, bases, dicts):
        super().__new__(cls, name, bases, dicts)
        # 在这里做一些你希望使用该元类的类在定义时做的操作
    def __call__(cls, *args, **kwargs):
       if cls not in cls._instances:
          cls._instances[cls] = super().__call__(*args, **kwargs)
      return cls._instances[cls]

class ClassName(metaclass=MetaClassName):
    def __init__(self, value):
        self.value = value
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/metaclass&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/metaclass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;自动注册类&lt;/li&gt;
&lt;li&gt;属性验证和转&lt;/li&gt;
&lt;li&gt;ORM模型创建&lt;/li&gt;
&lt;li&gt;抽象基类和接口检查&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;abstractmethod&#34;&gt;abstractmethod&lt;/h2&gt;
&lt;p&gt;抽象方法，类似于java的interface.&lt;/p&gt;
&lt;p&gt;最简单的抽象方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 如果子类没有实现同名的该方法，就会抛出异常．
def base_method(self):
    raise NotImplementedError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用abc标准库来实现：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;descriptors描述符&#34;&gt;descriptors描述符&lt;/h1&gt;
&lt;p&gt;普通对象访问(set/get/delete)属性的优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.__dict__[&#39;attr&#39;] # 先访问实例对象
obj.__class__.__dict__[&#39;attr&#39;] # 再访问类对象
obj.__class__.__base__.__dict__[&#39;attr&#39;] # 接着访问基类的对象,不包括metaclass.
__getattr__ # 如果实现了的话，优先级最低
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是一个对象，它定义了当另一个对象的属性被访问时应该如何处理。任何定义了 &lt;strong&gt;get&lt;/strong&gt;()、&lt;strong&gt;set&lt;/strong&gt;() 或 &lt;strong&gt;delete&lt;/strong&gt;() 方法的类都是描述符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__get__(self, obj, type=None) # 返回一个属性的值
__set__(self, obj, value) # 设置一个属性的值，返回None
__delete__(self, obj) # 属性的引用递减，返回None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是数据property，class，staticmethod，classmethod, 以及super的机制．&lt;/p&gt;
&lt;p&gt;data descriptor:定义了__get__和__set__的对象是数据描述符, 主要用于数据属性．&lt;/p&gt;
&lt;p&gt;non data descriptor:仅仅定义了__get__的对象是非数据描述符，主要用于方法属性．&lt;/p&gt;
&lt;p&gt;如果实例的字典(obj.&lt;strong&gt;dict&lt;/strong&gt;)具有与数据描述符相同名称的条目，则数据描述符优先。&lt;/p&gt;
&lt;p&gt;如果实例的字典(obj.&lt;strong&gt;dict&lt;/strong&gt;)具有与非数据描述符相同名称的条目，则字典条目优先。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DescriptorName(object):
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, typ):
        print(&#39;__get__&#39;, instance, typ)
        return self.name

    def __set__(self, instance, value):
        print(&#39;__set__&#39;, instance, value)
        self.name = value

class TestClass(object):
    name = DescriptorName(&#39;canux&#39;)

tc = TestClass()
print(tc.name) # __get__(tc, type(tc))被调用
print(TestClass.name) # __get__(None, TestClass)被调用
tc.__dict__[&#39;name&#39;] = &#39;test&#39; # 无效
tc.name = &#39;test&#39; # __set__被调用
TestClass.name = &#39;test&#39; # 仅仅是重新定义类的属性，覆盖了描述符
# 此时tc.__dict__有同名属性，如果定义了__set__
print(tc.name) # __get__被调用，属性已经修改
print(TestClass.name) # __get__被调用,属性已经修改
# 如果没有定义__set__，就是调用的tc.__dict__里面的．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符访问属性的优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数据描述符(__set__, __get__)
# 对于访问实例属性obj.__getattribute__调用方式：type(obj).__dict__[&#39;attr&#39;].__get__(obj, type(obj))
# 对于访问类属性class.__getattribute__调用方式：ClassName.__dict__[&#39;attr&#39;].__get__(None, ClassName)
instance.__dict__
非数据描述符(__get__)
__getattr__ # 如果实现了的话，在描述符中优先级最低
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是由__getattribute__特殊方法调用，覆盖该方法可以防止描述符自动调用.&lt;/p&gt;
&lt;p&gt;obj.__getattribute__和class.__getattribute__的调用方式不同．&lt;/p&gt;
&lt;p&gt;描述符的三个特殊方法一般是通过属性访问自动调用．&lt;/p&gt;
&lt;p&gt;函数和方法的描述符：&lt;/p&gt;
&lt;p&gt;在属性访问期间函数包括了__get__方法用于绑定方法．因此函数和方法是非数据描述符．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TClass(object):
    def __get__(self, obj, typ=None):
        return types.MethodType(self, obj, typ)


    def tmethod(self, args):
        return args

class Foo(object):
    @Tclass
    def bar(self):
        print(&#39;in bar&#39;)

obj = TClass()
TClass.__dict__[&#39;tmethod&#39;] # __tion __main__.f
TClass.tmethod # unbound method TClass.tmethod
obj.tmethod # bound method TClass.tmethod of &amp;lt;__main__.TClass object at 0x7f8a4f084c10&amp;gt;

obj.function(*args) -&amp;gt; function(obj, *args)
Class.function(*args) -&amp;gt; function(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;property&#34;&gt;property&lt;/h2&gt;
&lt;p&gt;property属性是一种有用的特殊类型的描述符． 也是descriptor的主要用途．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;property(fget=None, fset=None, fdel=None, doc=None) # 返回一个property类型的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的descriptor的普通方式实现纯pytho写的property:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Property(object):
    def __init__(self, fget, fset, fdelete):
        self.fget = fget
        self.fset = fset
        self.fdelete = fdelete

    def __get__(self, obj, typ=None):
        return self.fget(obj)

    def __set__(self, obj, val):
        self.fset(obj, val)

    def __delete__(self, obj):
        self.fdelete(obj)

class Foo(object):
    def fget(self):
        print &#39;fget called&#39;

    def fset(self, val):
        print &#39;fset called&#39;

    def fdelete(self):
        print &#39;fdelete called&#39;

    bar = Property(fget, fset, fdelete)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过装饰器@property来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person(object):
    def __init__(self):
        self._email = None

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        m = re.match(&#39;\W+@\W+\.\W+&#39;, value)
        if not m:
            raise Exception(&#39;email not valid&#39;)
        self._email = value

    @email.deleter
    def email(self):
        del self._email
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/descriptor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/descriptor&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;super&#34;&gt;super&lt;/h1&gt;
&lt;p&gt;因为同名的方法子类会覆盖父类，在子类中调用父类的同名方法可以通过super内置函数。&lt;/p&gt;
&lt;p&gt;super()方法实际是一个构造器。自动找到基类方法，同时传入self参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super().__init__() # 不需要传递参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于单继承, super用来调用父类同名方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Child(Parent):
    def foo(self):
        Parent.foo(self) # 可以手动调用父类同名的方法，调用非绑定方法，传入self参数。

class Child(Parent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs) 
        ...

    def foo(self, *args, **kwargs):
        super().foo(*args, **kwargs) 
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于多继承，super用法参考上面的多继承．&lt;/p&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用父类构造函数&lt;/li&gt;
&lt;li&gt;扩展父类方法&lt;/li&gt;
&lt;li&gt;多重继承场景&lt;/li&gt;
&lt;li&gt;属性设置场景&lt;/li&gt;
&lt;li&gt;合作式继承&lt;/li&gt;
&lt;li&gt;类方法中使用&lt;/li&gt;
&lt;li&gt;静态方法中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;super()返回的对象有一个用于调用Descriptor的定制__getattribute__()方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super(B, obj).method() -&amp;gt;
obj.__class__.__mro__ -&amp;gt;
A.__dict__[&#39;method&#39;].__get__(obj, B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考面向对象编程．&lt;/p&gt;
&lt;h1 id=&#34;classmethod&#34;&gt;classmethod&lt;/h1&gt;
&lt;p&gt;classmethod 是一个内置装饰器，用于将方法转换为类方法。类方法的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是类本身 cls，而不是实例 self&lt;/li&gt;
&lt;li&gt;可以通过类或实例调用&lt;/li&gt;
&lt;li&gt;可以访问类属性，但不能直接访问实例属性&lt;/li&gt;
&lt;li&gt;常用于创建备选构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类方法通常用于替代类构造函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    @classmethod
    def demo_cm(cls, *args, **kwargs):
        ...

# 可以通过类来调用, 也就是可以直接调用非绑定方法．自动传入类作为第一个参数．
ClassName.demo_cm(args, kwargs)
# 也可以通过实例来调用, 自动传入类作为第一个参数
ClassName().demo_cm(args, kwargs) // not recommend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符相关：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.function(*args) -&amp;gt; function(type(obj), *args)
Class.function(*args) -&amp;gt; function(Class, *args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备选构造函数&lt;/li&gt;
&lt;li&gt;工厂方法模式&lt;/li&gt;
&lt;li&gt;访问和修改类属性&lt;/li&gt;
&lt;li&gt;配置和设置相关方o&lt;/li&gt;
&lt;li&gt;继承中的类方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;staticmethod&#34;&gt;staticmethod&lt;/h1&gt;
&lt;p&gt;staticmethod 是一个内置装饰器，用于将方法转换为静态方法。静态方法的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不接收隐式的第一个参数（不需要 self 或 cls）&lt;/li&gt;
&lt;li&gt;可以通过类或实例调……&lt;/li&gt;
&lt;li&gt;不能访问类或实例的属性&lt;/li&gt;
&lt;li&gt;行为类似普通函数，只是在类的命名空间中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    @staticmethod
    def demo_sm():
        ...

ClassName.demo_sm()
ClassName().demo_sm()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符相关：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.function(*args) -&amp;gt; function(*args)
Class.function(*args) -&amp;gt; function(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具函数&lt;/li&gt;
&lt;li&gt;验证和转换函数&lt;/li&gt;
&lt;li&gt;常量和配置相关&lt;/li&gt;
&lt;li&gt;工厂方法辅助函数&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;class-decorators&#34;&gt;Class Decorators&lt;/h1&gt;
&lt;p&gt;类装饰器比函数装饰器更灵活，高内聚，封装性等优点．&lt;/p&gt;
&lt;p&gt;类装饰器用于装饰一个类.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(cls):
    class WrapperName(cls, ...):
        def __init__(self, *args, **kwargs):
            cls.__init__()
            ....__init__()
            ...
    return WrapperName

@deco_name
class ClassName(object):
    def __init__(self, *args, **kwargs):
        ...
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Python</title>
        <link>https://canuxcheng.com/post/python/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python/</guid>
        <description>&lt;h1 id=&#34;python概述&#34;&gt;&lt;strong&gt;Python概述&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/2.7/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/2.7/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/python_278/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/python_278/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/3.5/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/3.5/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/python_352/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/python_352/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python是一门优雅而健壮的语言.&lt;/p&gt;
&lt;p&gt;继承了编译语言(静态语言)的强大性和通用性.&lt;/p&gt;
&lt;p&gt;同时也借鉴了脚本语言(动态语言)的易用性．&lt;/p&gt;
&lt;p&gt;python特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高级&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;可升级&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;易学&lt;/li&gt;
&lt;li&gt;易读&lt;/li&gt;
&lt;li&gt;易维护&lt;/li&gt;
&lt;li&gt;健壮性&lt;/li&gt;
&lt;li&gt;高效的快速原型开发工具&lt;/li&gt;
&lt;li&gt;内存管理器&lt;/li&gt;
&lt;li&gt;解释性和编译性&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python基本语法&#34;&gt;&lt;strong&gt;python基本语法&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python源程序叫xxx.py&lt;/p&gt;
&lt;p&gt;python中一切皆对象．&lt;/p&gt;
&lt;p&gt;python大小写敏感．&lt;/p&gt;
&lt;p&gt;python通过缩进和冒号:区分语法块，而不是大括号{}.&lt;/p&gt;
&lt;p&gt;python中的表达式(条件/循环表达式等)不需要用小括号()括起来．&lt;/p&gt;
&lt;p&gt;python标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．&lt;/p&gt;
&lt;p&gt;python不支持方法或函数重载．&lt;/p&gt;
&lt;p&gt;python不支持char和type类型．&lt;/p&gt;
&lt;p&gt;python没有switch语句．&lt;/p&gt;
&lt;p&gt;python支持多继承．&lt;/p&gt;
&lt;p&gt;python不支持++/&amp;ndash;自增和自减运算符．&lt;/p&gt;
&lt;p&gt;python支持连续比较，a&amp;lt;b&amp;lt;c.&lt;/p&gt;
&lt;p&gt;命名规则&lt;/p&gt;
&lt;p&gt;variable: snake_case, case
function:  get_user_info(), get()
class: User, UserInfo
module: snake_case.py
package: myapp, utils&lt;/p&gt;
&lt;h2 id=&#34;lexical-analysis&#34;&gt;lexical analysis&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/2/reference/lexical_analysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/2/reference/lexical_analysis.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Logical lines and physical lines：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python通过行尾的令牌NEWLINE表示逻辑行
expression
# 以操作系统的换行符表示物理行．
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;encoding declarations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python脚本中的第一行或第二行的
coding[=:]\s*([-\w.]+)
# 注释与正则表达式匹配将被作为编码申明处理．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[Deprecated] explicit line joining:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 多个物理行通过反斜线backslash续行进行显示换行
# 推荐用隐式换行．
if a == b \
       and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释.
    print(&#39;more than one physical line.&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;implicit line joining：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在括号(parentheses),方括号(square brackets)，大括号(curly braces)中的表达式可以分割多个物理行而不需要显示换行．
test_list = [
    &#39;a&#39;, # 每一行都可以注释
    &#39;b&#39;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;indentation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 逻辑行的开头的空格和跳格用于缩进，python根据行的缩进级别区分语法块．
# 缩进级别用于生成INDENT和DEDENT两个令牌
pep8建议用四个空格表示一个缩进级别．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行python代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python mycode.py
# OR
$ chmod u+x mycode.py
$ ./mycode.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;f-string&#34;&gt;f-string&lt;/h3&gt;
&lt;p&gt;格式字符串字面值则是可在运行时求值的表达式。&lt;/p&gt;
&lt;p&gt;!s call str()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f&amp;quot;his name is {name!r}&amp;quot;
f&amp;quot;his name is {repr(name)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;!r call repr()&lt;/p&gt;
&lt;p&gt;!a call ascii()&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python注释&#34;&gt;&lt;strong&gt;python注释&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
comment1

comment2
comment3
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python3键字&#34;&gt;&lt;strong&gt;python3键字&lt;/strong&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;def lambda class import from
if elif else while for continue break try except finally return pass
global raise assert del yield with as
and or not is in nonlocal
False None True 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python运算符和优先级&#34;&gt;&lt;strong&gt;python运算符和优先级&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;优先级从高到底：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 函数调用
f(x)

# 序列的切片
seq[ind1:ind2:step]

# 序列下标索引
seq[index]

# 属性运算.
object.attribute

# 算术运算符
**   幂运算，乘方运算符, 等效内置函数pow(), 优先级高于单目运算符

# 位运算(只能用于整数)
~    按位取反
# 单目运算符．
+expr    # 结果符号不变
-expr    # 对结果符号取负

# 算术运算符, 优先级一样
*
/    python2两个操作数都是整数时，结果是商舍去小数后的整数,也就是地板除; 只要有一个以上的浮点操作数,结果就是浮点数，也就是真正的除法．
/    python3会自动转化成两个浮点数出发，结果永远是浮点数，永远是真正的除法．
//   地板除，结果总是舍去小数部分．
%

# 算术运算符, 优先级一样
+
-

# 位运算(只能用于整数), 优先级一样．
&amp;lt;&amp;lt;   左移位运算
&amp;gt;&amp;gt;   右移位运算

# 位运算(只能用于整数)
&amp;amp;    按位与

# 位运算(只能用于整数), 优先级一样
^    按位异或
|    按位或

# 关系运算, 优先级一样
&amp;lt;
&amp;gt;
&amp;lt;=
&amp;gt;=

# 关系运算, 优先级一样
==
!=
# Python2的&amp;lt;&amp;gt;不再支持，使用!=

# 赋值运算符和增量赋值
=
+=
-=
*=
/=
%=
**=
&amp;lt;&amp;lt;=
&amp;gt;&amp;gt;=
&amp;amp;=
|=
^=

# [New] 对象运算符, 优先级一样
is
is not

# [New] 序列的元素/字典的键/集合的元素 成员运算符, 优先级一样
in
not in

# boolean逻辑运算符
not    逻辑非

# boolean逻辑运算符, 优先级一样
and    逻辑与
or     逻辑或
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python数据类型&#34;&gt;&lt;strong&gt;python数据类型&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python中一切皆对象，每个对象都有身份(id()), 类型(type()) 和 值三个属性．&lt;/p&gt;
&lt;p&gt;python中对象的类型和内存占用都是在运行时确定的．&lt;/p&gt;
&lt;p&gt;is和is not可以判断两个变量是否指向同一个对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a is b # 等价于 id(a) == id(b), 表示a和b是同一个对象
a is not b # 等价于 id(a) != id(b), 表示a和b不是同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is和is not可以判断变量的类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import types
type(a) is types.IntType
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;垃圾回收&#34;&gt;&lt;em&gt;垃圾回收&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Garbage Collector垃圾回收机制是引用计数为主，标记清除和分代收集为辅．&lt;/p&gt;
&lt;p&gt;当对象被引用，包括对象在被创建，对象被作为参数传递给函数，对象成为容器对象的一个元素时，引用值增加．&lt;/p&gt;
&lt;p&gt;当对象的引用被销毁，包括一个本地引用离开其作用域，对象的别名被del显示销毁，对象的别名被赋值给其它对象，对象被从一个窗口对象中移除，窗口对象本身被del显示销毁，引用值减少．&lt;/p&gt;
&lt;p&gt;del语句会删除对象的一个引用．&lt;/p&gt;
&lt;h2 id=&#34;变量和常量&#34;&gt;&lt;em&gt;变量和常量&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python是动态类型语言，变量不需要先申明，变量的类型和值在赋值的时候被初始化．&lt;/p&gt;
&lt;p&gt;用全部小写表示变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;counter = 0
miles = 100.03
name = &amp;quot;canux&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用全部大写表示常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PIE = 3.14
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型总结&#34;&gt;&lt;em&gt;类型总结&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;更新模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可变类型:immutable不可变类型就是变量的值是固定的，再次赋值就是重新创建了新的对象: 数字类型，字符串str，元组tuple，不可变集合frozenset.&lt;/li&gt;
&lt;li&gt;可变类型:mutable可变类型就是变量的值是可以改变的: 列表list，字典dict，可变集合set.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scalar标量/原子类型:只能容纳单个对象：数字类型，字符串str&lt;/li&gt;
&lt;li&gt;container容器类型:可以容纳多个对象：元组tuple，列表list，字典dict,集合set/frozenset.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接存取:数字类型&lt;/li&gt;
&lt;li&gt;索引访问:sequence序列是顺序访问：字符串str，元组tuple，列表list.&lt;/li&gt;
&lt;li&gt;映射访问:mapping映射类型是映射访问,元素无序存放，通过唯一的key来访问：字典dict.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据拷贝&#34;&gt;数据拷贝&lt;/h2&gt;
&lt;p&gt;浅拷贝:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只拷贝顶层数据.

对不可变对象不开辟新空间,相当于赋值操作;修改原数据,相当于定义了一个新的数据.拷贝的数据不变.
a=10
b=copy.copy(a)
old_id  = id(a) == id(b)
a=5 # 修改a相当于定义了新变量
id(a) != old_id
id(b) == old_id # id(b) 不变
id(b) == 10

对可变对象会在内存开辟新空间保存拷贝的数据;只拷贝第一层中的引用,原数据被修改,拷贝的对象也被修改.
a=[1,2,3]
b=copy.copy(a)
id(a) != id(b)
a[0]=5 # 改变a的数据
b == a # b的数据也改变

copy.copy()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;深拷贝:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;逐层拷贝数据,直到拷贝的所有引用都是不可变引用.

深拷贝,一份数据改变,不影响另一份数据.

copy.deepcopy()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sequences序列类型&#34;&gt;&lt;em&gt;Sequences序列类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;sequence序列是指成员有序排列，可以通过下标偏移量访问，同时可以进行切片操作．序列是可迭代的．&lt;/p&gt;
&lt;p&gt;sequence索引操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq[ind] # 获取下标为ind的元素，下标从0开始．
seq[-1] # 取最后一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence切片操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq[ind1:ind2] # 获取下标从ind1到ind2间的元素的集合．不包括ind2.
seq[:ind2] # ind1缺省默认为０.
seq[ind1:] # ind2缺省表示从ind1到最后一个元素

seq[ind1:ind2:step] # 以步长为step来切片
seq[:ind2:step]
seq[::step] # ind1缺省为０，ind2缺省为整个序列长度．
seq[::-1]  # 翻转序列
seq[::-step]  # 以步长为step翻转序列．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence算术运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq * number # 序列重复number次
sql1 + seq2 # 两个序列连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence成员运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj in seq # obj在包含在序列中,返回True
obj not in seq # obj不包含在序列中返回True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数字类型&#34;&gt;&lt;em&gt;数字类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;数字类型是不可变类型(immutable),是标量(scalar),是直接存储的．&lt;/p&gt;
&lt;p&gt;0b开头表示二进制&lt;/p&gt;
&lt;p&gt;0开头表示八进制&lt;/p&gt;
&lt;p&gt;0x开头表示十六进制&lt;/p&gt;
&lt;p&gt;数字类型转换的关系是整数转换成浮点数，非复数转换成复数．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;p&gt;Python3的int类型整合了short、int、long三种长度，统一为int类型，且没有长度限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bool(int)&lt;/p&gt;
&lt;p&gt;bool类继承自int.&lt;/p&gt;
&lt;p&gt;bool类型只有True和False两个值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  bool类型取反: 
  a = True
  b = bool(1-a) # b=False
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;float&lt;/p&gt;
&lt;p&gt;python中的float其实就包括了单精度和双精度，相当于float和double都可以用．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complex&lt;/p&gt;
&lt;p&gt;python中有复数类型．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;str&#34;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python2中str和unicode继承自basestring, basestring继承自object.&lt;/p&gt;
&lt;p&gt;python3中unicode和basestring在python3中被废弃．str直接继承自object.&lt;/p&gt;
&lt;p&gt;python3中不再需要u/U来表示unicode字符串．&lt;/p&gt;
&lt;p&gt;str类型是不可变类型(immutable),是标量(scalar),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;字符串表示方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;This is a string&#39;
&amp;quot;This is a string&amp;quot;
&amp;quot;&amp;quot;&amp;quot;This is a string&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串的续行：&lt;/p&gt;
&lt;p&gt;下面都表示一个只有一行的字符串．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一个引号的情况,需要在引号内部空格表示和下一行有空格，续行符前的空格可有可无．
a = &#39;This is a &#39; \
&#39;string&#39;

b = &#39;This is a \
string&#39;

c = &amp;quot;This is a &amp;quot; \
&amp;quot;string&amp;quot;

d = &amp;quot;This is a \
string&amp;quot;

# 三引号续行符前的空格就表示和下一行有空格．
c = &amp;quot;&amp;quot;&amp;quot;This is a \
string&amp;quot;&amp;quot;&amp;quot;
&amp;gt; This is a string

c = &amp;quot;&amp;quot;&amp;quot;line1
line2&amp;quot;&amp;quot;&amp;quot;
&amp;gt; line1\nline2   没有续行符会在行尾加换行符号.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译时字符串连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo = &amp;quot;hello&amp;quot; &#39;world&#39;
urllib.urlopen(&#39;http://&#39; # protocol
&#39;localhost&#39; # hostname
&#39;:8000&#39; # port
&#39;/&#39;) # path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原始字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 正常情况下在字符串中的特殊字符串(\加一个字符)表示特殊含义．是不可打印的．
print(&#39;\n&#39;)
# 如果需要表示正常含义需要转译(\用来转意)．
print(&#39;\\n&#39;) # 需要转译．
# 也可以使用原始字符串来表示正常含义．r&#39;&#39;和R&#39;&#39;都可以．
print(r&#39;\n&#39;)
open(r&#39;C:\windows\test.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串编码解码:&lt;/p&gt;
&lt;p&gt;Unicode: Universal Multiple-Octet Coded Character Set. 使用十六进制表示．加上前缀U+&lt;/p&gt;
&lt;p&gt;ASCII: American Standard Code for Information&lt;/p&gt;
&lt;p&gt;UFT-8: Unicode Transformation Format&lt;/p&gt;
&lt;p&gt;python2因为比unicode出现要早，所以python2默认使用的是ASCII编码．&lt;/p&gt;
&lt;p&gt;python3 默认使用utf-8编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 获取默认编码
import sys
print(sys.getdefaultencoding())

// python2
a = u&#39;测试&#39;
type(a) # unicode
a # u&#39;\u6d4b\u8bd5&#39;,　十六进制表示

// python2
# str类型
b = &#39;测试&#39;
type(b) # str
b # \xe6\xb5\x8b\xe8\xaf\x95

// python2
# encode将unicode类型编码成str类型用于数据传输．
encode([encoding[,errors]]) # 编码
c = a.encode(&#39;uft-8&#39;)
type(c) # str
c # \xe6\xb5\x8b\xe8\xaf\x95

// python2
# decode将str类型根据原来的编码类型解码成unicode类型进行阅读．
decode([encoding[,errors]]) # 解码
d = c.decode(&#39;utf-8&#39;) # 参数必须是原来的编码的类型
type(d) # unicode
d # u&#39;\u6d4b\u8bd5&#39;

// python2
# python2默认ascii编码，所以encode和decode默认都是ascii. 不能处理中文
u&#39;测试&#39;.encode() # UnicodeEncodeError

// python2
# str+unicode, str会隐式的转换成unicode.
&#39;测&#39; + u&#39;试&#39; -&amp;gt; &#39;测&#39;.decode() + u&#39;试&#39; # 因为decode默认是ascii不能解码中文,UnicodeDecodeError．
&#39;测&#39;.decode(&#39;uft-8&#39;) + u&#39;试&#39;

// python2
# 对非unicode进行encode编码，会先隐式解码成unicode再编码
&#39;测试&#39;.encode(&#39;utf-8&#39;) # UnicodeDecodeError, 因为&#39;测试&#39;.decode()默认用ascii解码
&#39;测试&#39;.decode(&#39;utf-8&#39;).decode(&#39;utf-8&#39;)

# python2程序中出现字符串一定加前缀u.表示成unicode格式
u&#39;hello world&#39;
# 不要用str(), 用unicode().
# 只在写入文件／数据库／网络时才调用编码函数encode().
# 只在读回数据时才调用解码函数decode().
# 始终使用utf-8编码．否则容易出现乱码．

// python3 默认类型非str，而是bytes。
str.encode()  # str类型通过encode编码成types类型
bytes.decode() # bytes类型通过decode解码成str类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可迭代对象转换成字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39;.join((&#39;a&#39;, &#39;b&#39;)) # 可迭代对象的元素需要是str类型.
&#39;&#39;.join([&#39;a&#39;, &#39;b&#39;]) # 可迭代对象的元素需要是str类型.
&#39;&#39;.join({&#39;a&#39;: &#39;b&#39;}) # 字典迭代键，可迭代对象的元素需要是str类型.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tuple&#34;&gt;&lt;em&gt;tuple&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;tuple类型是不可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;元组是不可变类型，不能对元组的元素进行增删操作．&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;list类型是可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;列表元素增删修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 除了使用内置方法还可以使用序列的索引．
lst[index] = value
del lst[index]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;list-comprehensions列表解析&#34;&gt;&lt;em&gt;list comprehensions列表解析&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;List Comprehensions列表解析,来自函数式编程语言Haskell.&lt;/p&gt;
&lt;p&gt;列表解析使用中括号，列表解析返回一个列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lst = [expression for item in iterable]
# 嵌套if
lst = [expression for item in iterable if condition]
# 嵌套for
lst = [expression for item in iterable for item1 in iterable1]

[x ** 2 for x in range(10)]
等效于,python2的内置函数map(), filter()都是函数式编程的应用．
map(lambda x: x**2, range(10))

[(x+1, y+1) for x in range(10) for y in range(10)]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;range&#34;&gt;&lt;em&gt;range&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;用于生成整数序列的内建类型，返回对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;range(stop)
range(start, stop)
range(start, stop, step)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytes&#34;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&#34;bytearray&#34;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&#34;memoryview&#34;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dict&#34;&gt;&lt;em&gt;dict&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;dict类型是可变类型(immutable),是容器(container),是映射(mapping)类型,是无序的,通过映射访问．&lt;/p&gt;
&lt;p&gt;字典迭代键，字典的键必须是可哈希的，字典的键必须是不可变类型．列表/字典/可变集合等不可哈希对象不能用作字典的键．&lt;/p&gt;
&lt;p&gt;所有不可变类型都是可哈希的，都可以作为字典的键．&lt;/p&gt;
&lt;p&gt;可用内置函数hash()获取或判断是否能用作字典的键．&lt;/p&gt;
&lt;p&gt;字典的键必须是唯一的，不能一个键对应多个值．有这种情况取最后一个赋值．&lt;/p&gt;
&lt;p&gt;字典的键操作符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 字典通过键操作符来读取元素的值
dic[&#39;key&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;键成员操作符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 取代has_key()和keys()内置方法
&#39;key&#39; in dic # 推荐用 &#39;key&#39; in dic 判断键是否存在
&#39;key&#39; not in dic
# Python3中dict.keys()、dict.values()、dict.items()返回的是视图对象（可迭代），如需列表可用list(dict.keys())等。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字典元素增删修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dic[&#39;key&#39;] = &#39;value&#39;
del dic[&#39;key&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dict-comprehensions&#34;&gt;dict comprehensions&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;{key: value for item in iterable if condition}

modified = {
    k: (expected[k], actual[k])
    for k in expected
    if k in actual and expected[k] != actual[k]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sets集合&#34;&gt;&lt;em&gt;Sets集合&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;集合是一组无序排列的值，不能进行索引和切片操作，也不能进行键操作，只能通过for循环迭代集合元素．&lt;/p&gt;
&lt;p&gt;集合分为可变集合和不可变集合.&lt;/p&gt;
&lt;p&gt;集合运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;element&#39; in st 是成员
&#39;element&#39; not in st 不是成员
== 等于
!= 不等于
&amp;lt;  严格子集
&amp;lt;= 非严格子集, 等效于issubset()
&amp;gt; 严格超集
&amp;gt;= 非严格超集, 等效于issuperset()
| 联合, OR操作，等效于union()内置方法
&amp;amp; 交集, AND操作，等效于intersection()内置方法
- 差补或相对补集, 等效于difference()内置方法
^ 对称差分或异或, XOR操作，等效于symmetric_difference()内置方法

仅用于可变集合的运算符：
|= 等效于update()内置方法
&amp;amp;= 等效于intersection_update()内置方法
-= 等效于difference_update()内置方法
^= 等效于symmetric_difference_update()内置方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;集合运算返回结果的类型与左操作数的类型相同，左边是可变集合，结果就是可变集合，否则是不可变集合．&lt;/p&gt;
&lt;h3 id=&#34;frozenset&#34;&gt;frozenset&lt;/h3&gt;
&lt;p&gt;frozenset类型是不可变类型(immutable),是容器(container).&lt;/p&gt;
&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;
&lt;p&gt;set类型是可变类型(mutable)，是容器(container).&lt;/p&gt;
&lt;h3 id=&#34;set-comprehensions&#34;&gt;set comprehensions&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;{expression for item in iterable if condition}

{x for x in range(10) if x % 2 == 0}
等效于
set(filter(lambda x: x % 2 == 0, range(10)))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python控制流&#34;&gt;&lt;strong&gt;python控制流&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;continue语句:表示立即终止本次循环，启动循环的下一次迭代．&lt;/p&gt;
&lt;p&gt;break语句：表示结束当前循环块，跳转到后面的语句．&lt;/p&gt;
&lt;p&gt;pass语句： 表示不做任何事情，NOP.&lt;/p&gt;
&lt;h2 id=&#34;if条件语句&#34;&gt;&lt;em&gt;if条件语句&lt;/em&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if condition:
    expression
elif condition:
    expression
else:
    expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python中的三目运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X if C else Y
等效于
if C:
    X
else:
    Y

# 三目运算符高于赋值运算符．
a = b if c else d
# 等效于
a = (b if c else d)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python没有switch，可以用if实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if var == &amp;quot;a&amp;quot;:
    return &amp;quot;A&amp;quot;
elif var == &amp;quot;b&amp;quot;:
    return &amp;quot;B&amp;quot;
else:
    return &amp;quot;unknown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.10+引入match-case。&lt;/p&gt;
&lt;h2 id=&#34;while循环语句&#34;&gt;&lt;em&gt;while循环语句&lt;/em&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;while condition:
    expression

# while执行完会执行else(包括while不执行)，break会跳过else．
while condition:
    expression
else:
    expression
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;for循环语句&#34;&gt;&lt;em&gt;for循环语句&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;for循环可以用于遍历序列，字典的键 和 文件的行，集合，列表解析，生成器表达式.&lt;/p&gt;
&lt;p&gt;for循环会自动调用迭代器的next()方法，捕获StopIteration异常结束循环．&lt;/p&gt;
&lt;p&gt;用for迭代可变对象的时候，不应该改变可变对象的元素的值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for condition:
    expression

# for执行完成会执行else, break会跳过else.
for condition:
    expression
else:
    expression

# 字典有两种写法
for loop in dic.keys()
等效于
for loop in dic

# 文件有两种写法
for loop in open(&#39;file&#39;, &#39;r&#39;).readlines():
等效于
for loop in open(&#39;file&#39;,&#39;r&#39;):
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;iterator迭代器-类型&#34;&gt;&lt;em&gt;iterator迭代器 类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Iterable可迭代对象: 能直接用于for循环的对象为可迭代对象Iterable. 只需要实现__iter__()方法即可。&lt;/p&gt;
&lt;p&gt;Iterator迭代器: 能被next(g)内置函数调用并不断返回下一个值的对象为迭代器Iterator,迭代完成后抛出StopIteration异常, 也能用for循环，要同时实现__iter__()和__next__()&lt;/p&gt;
&lt;p&gt;enumerate和reversed内置类类型的工厂函数返回的都是迭代器类型．&lt;/p&gt;
&lt;p&gt;创建迭代器的3种方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过内建函数iter()
iter()

# 通过工厂函数
enumerate() # 迭代时同时获取元素值和索引

reversed() # 反转序列对象

# 自定义类，需要实现 __iter__() 和__next__() 两个方法(python3)
class TestIterator(object):
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        for item in self.data
            yield item

    def __next__(self):
        if condition:
            ...
        else:
            raise StopIteration()

i = TestIterator()
type(i) 
&amp;gt; iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;generator生成器类型&#34;&gt;&lt;em&gt;generator生成器类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;生成器就是一个迭代器对象，在每次调用next()方法时返回一个值．直到抛出StopIteration异常, 生成器通常用于迭代一个巨大的数据集．&lt;/p&gt;
&lt;p&gt;generator类类型,是一个迭代器，可以用for循环迭代:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;generator.close() # 在生成器内部抛出GeneratorExit异常要求生成器退出．
generator.send(arg) # 将值回送给生成器．
generator.throw(typ[,val[,tb]]) # 在生成器抛出异常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建生成器的两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用列表解析的变种&lt;/p&gt;
&lt;p&gt;g = (expression for item1 in iterable1 if condition1)
type(g)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;generator&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;next(g)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用yield关键字&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有yield的函数返回的就是一个生成器．&lt;/p&gt;
&lt;p&gt;yield函数能记住上一次返回时在函数体中的位置，迭代生成器会跳转至该函数中间，而且上次调用的所有局部变量保持不变．&lt;/p&gt;
&lt;p&gt;yield函数和普通函数执行顺序不一样，普通函数顺序执行，遇到return或最后一行语句返回．yield函数遇到yield语句返回，下次执行从上次返回的yield语句开始继续执行．遇到return语句抛出StopIteration异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def gena():
    yield &#39;first&#39;
    yield &#39;second&#39;

g = gena()
type(g) 
&amp;gt; generator

next(g) # first
next(g) # second
next(g) # StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;generator-expressions生成器表达式&#34;&gt;&lt;em&gt;generator expressions生成器表达式&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Generator Expressions生成器表达式, 是列表解析的一个扩展．&lt;/p&gt;
&lt;p&gt;列表解析的缺点就是要迭代整个对象用来创建列表，对大的对象来说性能差.&lt;/p&gt;
&lt;p&gt;生成器表达式就是结合生成器和列表解析解决这个问题．&lt;/p&gt;
&lt;p&gt;生成器表达式不必创建完整的列表，而是一边循环一边计算，返回一个生成器对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g = (expression for item1 in iterable1 if condition1)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python文件和输入输出&#34;&gt;&lt;strong&gt;python文件和输入输出&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python2使用open()内置函数打开文件，返回file类类型的对象，出错返回IOError异常.&lt;/p&gt;
&lt;p&gt;file类类型对象是迭代器，同时也是上下文管理器．&lt;/p&gt;
&lt;p&gt;python3废弃了file类类型，open()内置函数返回IO流．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2
open(name[, mode=&#39;r&#39;[, buffering=-1]])

mode
r: 读，文件必须存在
w: 写，文件不存在则创建，否则先清空文件再写入．
a: 追加，文件存在就追加到文件结尾,否则就创建．
t: text模式，这个是默认模式．不用指定．
rb/wb/ab: 二进制读写．
r+/w+/a+: 以读写模式打开文本文件．
rb+/wb+/ab+: 以读写模式打开二进制文件．
U: 提供通用换行符支持，文件必须存在

buffering
0: 不缓冲
1: 只缓冲一行数据
&amp;lt;0: 使用系统默认缓冲机制
&amp;gt;1: 使用给定值作为缓冲区大小
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通用换行符UNS:&lt;/p&gt;
&lt;p&gt;Universal Newline Support.&lt;/p&gt;
&lt;p&gt;如果是二进制文件读写rb/wb/ab，不会有换行符的问题，如果是文本文件建议用rU/wU/aU来读写.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# UNS会把
\r\n
\r
\n
# 都被替换为
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件可以使用with上下文管理器，并且迭代文件的行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with open(&#39;file&#39;, &#39;rU&#39;) as f:
    for line in f:
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准文件:&lt;/p&gt;
&lt;p&gt;系统默认的三个标准文件: sys.stdin, sys.stdout, sys.stderr.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2的关键字print会把语句打印到sys.stdout,并默认在语句结尾加换行符.
print(expression)
print(expression, end=&#39;&#39;) # 可以避免默认加换行符

# 内置函数input()会从sys.stdin接受输入
a = input()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python错误和异常&#34;&gt;&lt;strong&gt;python错误和异常&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;参考内置的错误和异常.&lt;/p&gt;
&lt;p&gt;BaseException是所有异常的基类． Exception是常规错误的基类.&lt;/p&gt;
&lt;p&gt;错误和异常的检测和处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    try_suite
except Exception0[ as reason]: # reason可以用于在except_suite中打印具体的异常信息，reason是一个Exception0类型的实例．
    except_suite
except Exception1[ as reason]: # 可以有多个except用来捕获不同的异常，但是只有一个except会被执行.
    except_suite
except (Exception2, Exception3)[ as reason]: # 也可以在一个except中同时检测多个异常．放入一个tuple中. reason是一个实例的元组．
    except_suite
except Exception[, reason]: # 可以用Exception来捕获所有异常，而不用区分具体的异常．不推荐用逗号，应该用as代替．
    except_suite
[Deprecated] except:    # 不推荐此用法，和上面一个等效
    except_suite
...
else:    # 可选， 没有异常触发except时运行else,　except和else只能运行一个．
    expression
finally:    # 可选，无论是否捕捉到异常都会执行的．
    expression

# 也可以不对异常处理
try:
    try_suite
finally:
    finally_suite

# 异常的参数
reason.__clas__.__name__  # 就是异常类的名字
print(reason) # 打印异常参数．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;raise触发异常&#34;&gt;&lt;em&gt;raise触发异常&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;除了上面捕获解释器触发的异常，用户还可以用raise自己触发异常:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise [SomeException [, args [, traceback]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SomeException可以是字符串，内置异常，第三方库异常类，自定义异常类, 或实例.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise ExceptionClass[, args[, traceback]] # 类
raise ExceptionClass(arguments)[, args[, traceback]] # 实例
raise ExceptionClass, instance # [TODO]
raise instance # 触发实例异常, raise reason 就是跑出一个ExceptionClass类型的instance.
raise string # 触发字符串异常
raise # 重新触发前一个异常，如果之前没有异常触发TypeError.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义异常和错误&#34;&gt;&lt;em&gt;自定义异常和错误&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;自定义异常需要继承一个标准异常或者第三方库的异常来实现一个类．&lt;/p&gt;
&lt;p&gt;通过raise来触发自定义的异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyError(Exception/StandardError/Warning):
    def __init__(self, msg):
        super(...).__init__(self, ...)
        ...
    ...

raise MyError, args
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;assert断言&#34;&gt;&lt;em&gt;assert断言&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;断言语句等效assert表达式, 如果断言成功不采取任何措施，否则触发AssertionError异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert expression[, arguments]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以提供一个异常参数和捕获AssertionError异常:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    assert expression, &amp;quot;If raise AssertionError, print this message.&amp;quot;
except AssertionError as e:
    print(&#39;%s: %s&#39; % (e.__class__.__name__, e))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;with上下文管理&#34;&gt;&lt;em&gt;with上下文管理&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;CMP: context management protocol.&lt;/p&gt;
&lt;p&gt;with上下文管理仅用于支持上下文管理协议(CMP)的对象．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with context_expr [as var]:
    with_suite
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with语句执行时就执行上下文符号（with和as之间的内容）来获得一个上下文管理器．&lt;/p&gt;
&lt;p&gt;上下文管理器调用__context__()方法来返回一个上下文对象．&lt;/p&gt;
&lt;p&gt;上下文对象会调用__enter_()方法完成with语句块执行前的准备工作．返回值赋给as后面的var变量．&lt;/p&gt;
&lt;p&gt;with语句块执行完毕后调用__exit__()方法，&lt;strong&gt;exit&lt;/strong&gt;()有三个参数，如果没有异常都是None,否则是sys.exc_info()的三个返回值．&lt;/p&gt;
&lt;p&gt;自定义上下文管理器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class CMPTest(object):
    def __init__(self):
        pass

    def __enter__(self):
        ...
        return self

    def __exit__(self, type, value, traceback):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类实现了上下文管理协议，子类可以直接使用with.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数function&#34;&gt;&lt;strong&gt;函数function&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义/申明一个函数:&lt;/p&gt;
&lt;p&gt;python对函数的申明和定义是一起的．&lt;/p&gt;
&lt;p&gt;函数必须先定义/申明才能引用/调用.&lt;/p&gt;
&lt;p&gt;通过关键字def来定义一个函数.&lt;/p&gt;
&lt;p&gt;def function_name(arguments)
expression&lt;/p&gt;
&lt;p&gt;函数引用：&lt;/p&gt;
&lt;p&gt;引用一个函数名并不会执行函数内容．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_copy = function_name

# 可以将函数作为参数传给另外一个函数，然后在另外一个函数调用该函数
def fun_name(arg):
    print(arg(10))
fun_name(str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数调用:&lt;/p&gt;
&lt;p&gt;调用一个函数才会执行函数内容.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_name(arguments)
# 可以通过引用的副本来调用函数
function_copy(args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的返回值：&lt;/p&gt;
&lt;p&gt;省略return表示返回None. 单个return表示返回None.其它表示返回一个对象．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return
return return_value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的实参：&lt;/p&gt;
&lt;p&gt;位置参数，调用的时候通过先后顺序传递的参数,函数定义时需要放在前面．&lt;/p&gt;
&lt;p&gt;默认参数，在函数定义时就已经初始化的参数，调用时可以不再赋值．&lt;/p&gt;
&lt;p&gt;默认参数在函数定义时需要放在位置参数的后面．否则抛出SytaxError.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def function_test(position_args, keyword_args, *args, **kwargs):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的形参：&lt;/p&gt;
&lt;p&gt;位置参数，在函数调用时根据定义的参数的顺序来传递．&lt;/p&gt;
&lt;p&gt;默认参数，在函数调用时如果没有传值则使用定义的默认值．&lt;/p&gt;
&lt;p&gt;关键字参数，在函数调用时，根据定义时的参数名称来传值.&lt;/p&gt;
&lt;p&gt;非关键字参数的传值不能在关键字参数后面．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func_test(arg1, arg2, arg3=&amp;quot;val1&amp;quot;, arg4=&amp;quot;val2&amp;quot;):
    pass
func_test(1, 2, 3, 4) # 位置参数
func_test(1, 2) # 使用默认参数
func_test(arg2=2, arg1=1) # 关键字传参
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变长度参数:&lt;/p&gt;
&lt;p&gt;当函数参数不确定时，可以使用可变长度参数．&lt;/p&gt;
&lt;p&gt;一个星号表示一个非关键字参数组成的元组(可以是其它序列，会自动转换成元组)．&lt;/p&gt;
&lt;p&gt;两个星号表示一个关键字参数组成的字典．&lt;/p&gt;
&lt;p&gt;函数定义时可变长度参数必须在位置参数和默认参数后面．而且关键字变长参数应该在最后.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func_test(position, default=&#39;value&#39;, *args, **kwargs):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用可变长度参数时，可以把非关键字变长参数放到一个元组，把关键字变长参数放到一个字典．&lt;/p&gt;
&lt;p&gt;也可以在元组和字典中放部分参数，另外一部分直接传递, 非关键字参数的传值不能在关键字参数后面．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 注意，函数定义的时候星号是必须的，函数调用的时候也需要星号．
args = (&#39;val1&#39;, &#39;val2&#39;)
kwargs = {key1: &#39;val1&#39;, key2: &#39;val2&#39;}
func_test(&#39;position&#39;, &#39;default&#39;, *args, **kwargs)
# 部分传递，多出来的非关键字参数属于变长非关键字参数，多出来的关键字参数属于变长关键字参数．
func_test(&#39;position&#39;, &#39;default&#39;, &#39;non-keyword&#39;, key=&#39;keyword&#39;, *(1,2), **{3: &#39;three&#39;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的属性：&lt;/p&gt;
&lt;p&gt;通过小数点来调用函数的属性．&lt;/p&gt;
&lt;p&gt;内置函数的特殊属性(BIF)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_test.__doc__
function_test.__name__
function_test.__module__ # __builtin__
function_test.__self__ # None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义函数的属性(UDF)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dir(function_test)
&#39;__doc__&#39;,
&#39;__name__&#39;,
&#39;func_closure&#39;,
&#39;func_code&#39;,
&#39;func_defaults&#39;,
&#39;func_dict&#39;,
&#39;func_doc&#39;,
&#39;func_globals&#39;,
&#39;func_name&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;偏函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from functools import partial
partial(func, *args, **keywords) # 一个偏函数的类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量作用域:&lt;/p&gt;
&lt;p&gt;python搜索一个标识符先从局部作用域开始搜索，如果没有找到就在全局作用域找，否则抛出NameError异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 当在函数外部和内部都定义了同一个变量，局部变量会覆盖全局变量
var = &#39;global&#39;
def func_test(*args, **kwargs):
    var = &#39;local&#39;
    print(var)
func_test() # local

# 如果在函数内部使用一个不在函数内部定义的变量，就会在函数外部查找．
var = &#39;global&#39;
def func_test(*args, **kwargs):
    print(var)
func_test() # global

# 在函数内部不能修改外部变量,只能引用.
var = &#39;global&#39;
def func_test(*args, **kwargs):
    var += &#39;local&#39;
    print(var)
func_test() # UnboundLocalError: local variable &#39;var&#39; referenced before assignment

# 如果需要在局部引用全局变量需要使用global关键字
var = &#39;global&#39;
def func(*args, **kwargs):
    global var
    var = &#39;local&#39;
    print(var)
func() # local
print(var) # local # 全局变量在局部被修改．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func1(arg1: int, arg2: str) -&amp;gt; bool:
    ......

// with default value
def func2(arg1: str = &amp;quot;hello&amp;quot;) -&amp;gt; str
    ......

def func3(arg1: Optional[str]) -&amp;gt; int
    ......

def func4() -&amp;gt; Tuple[int, int]:
    ......
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lambda匿名函数&#34;&gt;&lt;em&gt;lambda匿名函数&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;lambda匿名函数就是一个只有一行表达式，不需要通过def来命名的函数.&lt;/p&gt;
&lt;p&gt;lambda匿名函数返回一个可调用的函数对象．&lt;/p&gt;
&lt;p&gt;lambda匿名函数支持通过def定义的函数的所有功能．&lt;/p&gt;
&lt;p&gt;lambda匿名函数中不能有return语句, expression的结果就是函数返回值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lambda [arg1[, arg2, ...argN]]: expression
lambda *args, **kwargs: expression
lambda : expression
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functional-programming函数式编程&#34;&gt;&lt;em&gt;Functional Programming函数式编程&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python涉及到函数式编程主要有几个内置类类型的工厂函数和lambda匿名函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zip(*iterables, strict=False)

filter(function, iterable, /)
result = filter(lambda x: x%2==0, [1,2,3,4,5])
&amp;gt; x=1, 1%2==0 False
&amp;gt; x=2, 2%2==0, True
&amp;gt; x=3, 3%2==0, False
print(list(result))
&amp;gt; [2]

map(function, iterable, /, *iterables)
result = map(lambda x: x**2, [1,2,3])
&amp;gt; x=1, x**2 =1
&amp;gt; x=2, 2**2=4
&amp;gt; x=3, 3**2=9
print(list(result))
&amp;gt; [1,4,9]

from functools import reduce
reduce(func, iterable[, initializer]) 
reduce(lambda x,y: x*y, [1,2,3,4]
&amp;gt; x=1,y=2, x*y=2
&amp;gt; x=2, y=3, x*y=6
&amp;gt; x=6, y=4, x*y=24
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;内嵌函数&#34;&gt;&lt;em&gt;内嵌函数&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;可以在函数内部定义函数，内部函数不能在外部函数以外的地方调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def outer(*args, **kwargs):
    expression
    def inner(arg): # 内嵌函数的参数不能是外部函数的参数．内部函数必须完全独立．
        expression
    inner(args)

def outer(*args, **kwargs):
    filter(lambda arg: expression, sequence)
    map(lambda arg: expression, sequence)
    functools.reduce(lambda arg: expression, sequence)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在函数内部内嵌匿名函数，匿名函数可以使用外部函数的参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x, y):
    bar = lambda :x + y
    print(bar())
foo(4,3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在函数中调用函数本身是一种递归方法
def fib(n):
    if n in[0, 1]:
        val = 1
    else:
        val = fib(n-1) + fib(n-2)
    return val
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;closure闭包&#34;&gt;&lt;em&gt;closure闭包&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;在一个内部函数里对在外部作用域的变量进行引用，内部函数被认为是closure.&lt;/p&gt;
&lt;p&gt;定义在外部函数内的但由内部函数引用的变量称为自由变量．&lt;/p&gt;
&lt;p&gt;当自由变量是一个函数时，闭包就是一个装饰器，decorator是closure最常见的应用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def outer(free):
    def clos(*args, **kwargs):
        print(free)
        print(args, kwargs)
    return clos

# 调用外部函数，返回一个内部函数的引用,　传入外部函数的就是自由变量,返回的内部函数就是闭包.
first_clos = outer(1)

# 调用closure
first_clos(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decorator装饰器&#34;&gt;&lt;em&gt;decorator装饰器&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;装饰器分为函数(方法)装饰器和类装器．函数中再定义函数是函数装饰器，函数中再定义类是类装饰器．&lt;/p&gt;
&lt;p&gt;函数装饰器修饰函数和类中的方法，类装饰器修饰类．类装饰器参考OOP．&lt;/p&gt;
&lt;p&gt;装饰器本质是一个函数，可以让其它函数在不做修改的情况下增加额外的功能．&lt;/p&gt;
&lt;p&gt;常用于插入日志，性能测试，事务处理，缓存，权限校验等场景．&lt;/p&gt;
&lt;p&gt;装饰器是用来装饰函数的包装，返回一个修改后的函数对象．将其重新赋值给原来的标识符，并永久失去对原始函数对象的访问．&lt;/p&gt;
&lt;p&gt;符号@是装饰器的语法糖.&lt;/p&gt;
&lt;p&gt;不带参数的装饰器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(func):
    def wrapper_name(*args, **kwargs): # 抽象出相同的部分进行包装
        &amp;quot;&amp;quot;&amp;quot;Docs for wrapper_name.&amp;quot;&amp;quot;&amp;quot;
        print(func.__name__) # 抽象出来的部分在这里实现
        print(args, kwargs) # 可以引用func传入的参数
        return func(*args, **kwargs) # 最后调用新增加的功能
    return wrapper_name # 返回包装函数的引用.

# 增加新功能,装饰后返回包装函数的一个引用,赋值给原来的foo．此时包装函数wrapper_name并不会执行
@deco_name
def foo(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Docs for foo.&amp;quot;&amp;quot;&amp;quot;
    print(&#39;call foo&#39;)
# 等效于
foo = deco_name(foo)

# 调用装饰后的函数,　调用的是装饰后的新的函数．
foo(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带参数的装饰器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(arg):
    def deco_inner(func):
        def wrapper_name(*args, **kwargs):
            &amp;quot;&amp;quot;&amp;quot;Docs for wrapper_name.&amp;quot;&amp;quot;&amp;quot;
            print(arg) # 通过装饰器的参数arg来做一些判断
            print(func.__name__)
            print(func.__doc__)
            print(args, kwargs)
            return func(*args, **kwargs)
        return wrapper_name
    return deco_inner

# deco_name(arg)(foo) -&amp;gt; deco_inner(foo) -&amp;gt; wrapper_name
@deco_name(arg=&amp;quot;value&amp;quot;)
def foo(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Docs for foo.&amp;quot;&amp;quot;&amp;quot;
    pass

# wrapper_name(*args, **kwargs)
foo(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;装饰器的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo.__name__ #  wrapper_name, 并非foo
foo.__doc__ # &amp;quot;Docs for wrapper_name.&amp;quot;, 并非foo的doc.
# 可以通过import functools.wraps来修饰wrapper_name改变这一属性．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/psl/myfunctools.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/psl/myfunctools.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多层装饰器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@foo
@bar
def func(*args, **kwargs):
    ...

func = foo(bar(func))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/decorator/function_decorator.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/decorator/function_decorator.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python模块和包&#34;&gt;&lt;strong&gt;python模块和包&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;名称空间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部名称空间&lt;/li&gt;
&lt;li&gt;全局名称空间&lt;/li&gt;
&lt;li&gt;内建名称空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;python解释器模块加载顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中已经加载的模块，也就是缓存(sys.modules)&lt;/li&gt;
&lt;li&gt;最先加载内建名称空间，也就是内置模块．&lt;/li&gt;
&lt;li&gt;sys.path路径中的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后加载执行模块的全局名称空间，在模块执行时是活动名称空间．&lt;/p&gt;
&lt;p&gt;最后加载局部名称空间，在执行期间是不断变化的．&lt;/p&gt;
&lt;p&gt;名称空间和变量的作用域是有区别的．&lt;/p&gt;
&lt;p&gt;变量／函数／方法先从局部名称空间开始查找，在找全局名称空间，最后查找内建名称空间．&lt;/p&gt;
&lt;p&gt;如果都没找到就抛出NameError异常．&lt;/p&gt;
&lt;p&gt;无限制名称空间，可以通过属性运算小数点来指定名称空间．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.var
module.function()
module.method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜索路径:&lt;/p&gt;
&lt;p&gt;搜索路径在不同的操作一同一般不同.&lt;/p&gt;
&lt;p&gt;搜索路径通过两个变量来设置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;shell的环境变量PYTHONPATH．&lt;/li&gt;
&lt;li&gt;python解释器的变量sys.path列表里.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在代码里修改搜索路径sys.path&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys.path.append(os.path.abspath(..))&lt;/li&gt;
&lt;li&gt;sys.path.insert(0, os.path.abspath(..)) # 插入到最前面，也就是在sys.path的第一个&amp;rsquo;&amp;rsquo;(当前路径)的前面．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有导入并加载的模块会存放在sys.modules中，导入模块时的搜索顺序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先搜索当前目录.(会覆盖同名的标准库), 其实是在运行过程中动态添加到sys.path中第一个&amp;rsquo;&amp;lsquo;的位置．&lt;/li&gt;
&lt;li&gt;没有的话再搜索sys.path,按照这个列表的顺序搜索找到第一个，然后加载该模块.&lt;/li&gt;
&lt;li&gt;没搜到抛出ImportError异常．&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;module模块&#34;&gt;&lt;em&gt;module模块&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;模块就是一个python程序的源文件．模块是用来组织python代码的方法．&lt;/p&gt;
&lt;p&gt;把其他模块中属性附加到你的模块中的操作叫做导入(import).&lt;/p&gt;
&lt;p&gt;那些自我包含并且有组织的代码片断就是模块( module ).&lt;/p&gt;
&lt;p&gt;查看所有模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help(&#39;modules&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;package&#34;&gt;&lt;em&gt;package&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;包就是把多个模块放在一个目录中，然后必须加上__init__.py文件．包是用来组织模块的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 包支持模糊导入.
[Deprecated] from package.module import * # 会导入包里面所有的变量，函数，类．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在__init__.py导入属性，导入时可以省略模块名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;robot/__init__.py
from robot.run import run, run_cli

test.py
from robot import run, run_cli # 可以省略属性所在的模块名
run()
run_cli()

等效:
test.py
from robot.run import run, run_cli # 通过包名和模块名直接导入．
run()
run_cli()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在__init__.py定义__all__变量来决定导入哪些属性．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from robot.run import run, run_cli
__all__ = [run, run_cli]

from robot import * # 仅仅导入__all__指定的属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;import导入模块和包&#34;&gt;&lt;em&gt;import导入模块和包&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;如果模块第一次被导入，就会被加载并执行．也就是说模块被加载时顶层的代码会被执行，一般包括全局变量，类和函数的申明．&lt;/p&gt;
&lt;p&gt;一个模块无论被导入(import)多少次，只在第一次导入时被加载一次．除非用reload()函数．&lt;/p&gt;
&lt;p&gt;写代码时候import导入顺序(中间空一格)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准库模块&lt;/li&gt;
&lt;li&gt;第三方库模块&lt;/li&gt;
&lt;li&gt;自定义模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;import关键字导入模块/包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import module
import package
# 包可以多层嵌套
import package.subpackage
import package.subpackage.module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from-import关键字导入模块中的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from module import function/method/variable
from package.module import function/method/variable
from package.subpackage.module import function/method/variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from-import关键字导入包中的的包/模块到当前的名称空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from package import subpackage
from package...subpackage import sub-subpackage
from package import module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as关键字可以给模块/包/属性取别名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import module/package/package.subpackage as alias
from module/package.module/package.subpackage.module import function/method/variable as alias
from package/package.subpackage import module/subpackage/sub-subpackage alias
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关的内置函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;locals()
global()
[Deprecated] reload() # 推荐用from imp import reload(), 重新导入一个已经导入的模块．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__name__ # 模块的特殊属性
# 如果模块直接运行，也就是作为top-level脚本运行．值为__main__.
# 如果作为module,也就是(import/python -m)，值为模块名称.
# 一般用来做单元测试.
if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pep0328&#34;&gt;&lt;em&gt;PEP0328&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;多行导入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过续行符
from module import a, b, c, \
    d, e, f

# 通过分成两行导入
from module import a, b, c
from module import d, e, f

# PEP328建议使用分组导入
from module import (a, b, c,
    d, e, f)

# 不推荐使用模糊导入．
[Deprecated] from module import *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绝对导入：&lt;/p&gt;
&lt;p&gt;默认采用绝对导入，也就是通过完整的包路径来导入，避免和标准库模块冲突．&lt;/p&gt;
&lt;p&gt;默认的包路径就是sys.path或PYTHONPATH.&lt;/p&gt;
&lt;p&gt;只有import没有from的一定是绝对导入．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import package/module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对导入： [TODO]&lt;/p&gt;
&lt;p&gt;小数点开头表示相对导入，一个小数点表示当前的包，两个小数点表示上一层的包，以此类推．&lt;/p&gt;
&lt;p&gt;相对导入一定是import-from结构．&lt;/p&gt;
&lt;p&gt;相对导入的优先级低于绝对导入，也就是先去sys.path中查找，然后根据当前模块的相对位置查找．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from . import package/module
from .foo import bar
from ..foo import bar
from ...foo import bar
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python文档&#34;&gt;&lt;strong&gt;python文档&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;文档注释:&lt;/p&gt;
&lt;p&gt;python的文档注释采用reST风格的注释.&lt;/p&gt;
&lt;p&gt;包/模块文档:&lt;/p&gt;
&lt;p&gt;包括作者,版权,模块的信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
File Summary

Copyright

License

:author:
:version:
:since:

Description
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类/函数/方法文档:&lt;/p&gt;
&lt;p&gt;包括作用,初始化方法参数和类型,函数和方法的参数和类型,返回类型和抛出异常,以及用法用例.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;Summary

:param param1: param1 used for what
:type param1: param1 type
:param param2: param2 used for what
:type param2: param2 type
...
:returns param: return what
:rtype param: return type
...
:raise exceptionname: raise what exception

Usage/Description
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档的特殊属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__doc__ # 函数/类/方法的特殊属性，用来表示文档的属性
# 文档字符串不能被子类继承．
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Tmux</title>
        <link>https://canuxcheng.com/post/devops_tmux/</link>
        <pubDate>Sun, 19 Jun 2016 11:17:53 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_tmux/</guid>
        <description>&lt;h1 id=&#34;tmux&#34;&gt;tmux&lt;/h1&gt;
&lt;p&gt;tmux是终端复用工具，类似于gnu screen。&lt;/p&gt;
&lt;p&gt;tmux三个基本概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;会话（session）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口（window）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面板（pane）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tmux使用c/s架构，tmux命令启动tmux服务器，一个tmux服务有多个session，
每个session就是tmux管理下的伪终端集合，一个session有多个window与之关联，
每个window就是一个伪终端，占据整个屏幕，一个window可以被分割成多个pane。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tmux安装和配置&#34;&gt;tmux安装和配置&lt;/h1&gt;
&lt;p&gt;tmux依赖libevent和ncurses库。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://libevent.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://libevent.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install libevent-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://invisible-island.net/ncurses/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://invisible-island.net/ncurses/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install ncurese-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://tmux.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://tmux.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install tmux
sudo yum install tmux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户配置文件： ~/.tmux.conf&lt;/p&gt;
&lt;p&gt;系统配置文件： /etc/tmux.conf&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tmux相关项目&#34;&gt;tmux相关项目&lt;/h1&gt;
&lt;h2 id=&#34;tpm&#34;&gt;TPM&lt;/h2&gt;
&lt;p&gt;Tmux Plugins Manager.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tmux-plugins/tpm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tmux-plugins/tpm&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tmux用法&#34;&gt;tmux用法&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;man tmux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开启tmux：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tmux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;退出tmux：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exit
ctrl + d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出tmux会话：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tmux ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tmux快捷键&#34;&gt;tmux快捷键&lt;/h2&gt;
&lt;p&gt;tmux的prefix是ctrl-b&lt;/p&gt;
&lt;p&gt;按下ctrl-b然后松开，通知tmux下面的按键是快捷键。&lt;/p&gt;
&lt;p&gt;查看所有快捷键：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + ?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + t
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;session操作&#34;&gt;session操作&lt;/h2&gt;
&lt;p&gt;交互式选择一个session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择一个session来detach：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;detach当前session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重命名当前的session：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + $
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;window操作&#34;&gt;window操作&lt;/h2&gt;
&lt;p&gt;交互式选择一个window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + w
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个新window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关闭当前window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到上一个window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到下一个window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移到之前选中的window：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用window号切换window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + [number]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重命名window:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + ,
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pane操作&#34;&gt;pane操作&lt;/h2&gt;
&lt;p&gt;横向分屏:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + %
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;纵向分屏:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择pane:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + [方向键]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关闭当前pane:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示pane号:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + q
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把当前的pane变成一个window：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + !
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移动到之前的活跃的pane：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择当前window的下一个pane：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + o
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tmux使用鼠标和粘贴复制&#34;&gt;tmux使用鼠标和粘贴复制&lt;/h2&gt;
&lt;p&gt;复制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shift-鼠标左键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;粘贴：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shift-鼠标右键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出所有粘贴缓冲区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + #
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;交互式选择一个缓冲区的内容粘贴：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + =
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用复制模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + [
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用粘贴模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl-b + ]
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Jaeger</title>
        <link>https://canuxcheng.com/post/tracing_jaeger/</link>
        <pubDate>Wed, 08 Jun 2016 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/tracing_jaeger/</guid>
        <description>&lt;h1 id=&#34;jaeger&#34;&gt;Jaeger&lt;/h1&gt;
&lt;p&gt;一款uber贡献给cncf的微服务tracing监控工具.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jaegertracing.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jaegertracing.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jaegertracing/jaeger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jaegertracing/jaeger&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;deploy-jaeger-on-k8s&#34;&gt;Deploy Jaeger on K8S&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jaegertracing/jaeger-operator&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jaegertracing/jaeger-operator&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Metrics</title>
        <link>https://canuxcheng.com/post/metrics/</link>
        <pubDate>Wed, 08 Jun 2016 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics/</guid>
        <description>&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;Tranditional monitoring is for Datacenter, like nagios, zabbix.&lt;/p&gt;
&lt;p&gt;Modern monitoring is for Cloud and Container.&lt;/p&gt;
&lt;p&gt;Modern monitoring based on metrics, logs and tracing.&lt;/p&gt;
&lt;h1 id=&#34;tick-stack&#34;&gt;TICK stack&lt;/h1&gt;
&lt;p&gt;influxdb: tsdb.&lt;/p&gt;
&lt;p&gt;kapacitor: alerting.&lt;/p&gt;
&lt;p&gt;chronograf: GUI.&lt;/p&gt;
&lt;p&gt;telegraf(agent): metrics collector.&lt;/p&gt;
&lt;h1 id=&#34;prometheus&#34;&gt;Prometheus&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;graphing&#34;&gt;Graphing&lt;/h1&gt;
&lt;p&gt;最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>https://canuxcheng.com/post/monitoring/</link>
        <pubDate>Wed, 08 Jun 2016 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/monitoring/</guid>
        <description>&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;Tranditional monitoring is for Datacenter, like nagios, zabbix.&lt;/p&gt;
&lt;p&gt;Modern monitoring is for Cloud and Container.&lt;/p&gt;
&lt;p&gt;Modern monitoring based on metrics, logs and tracing.&lt;/p&gt;
&lt;p&gt;现代的监控系统在DevOps的基础上，除了传统的metrics和logging的采集，还需要tracing应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;metrics&#34;&gt;metrics&lt;/h1&gt;
&lt;h2 id=&#34;tick-stack&#34;&gt;TICK stack&lt;/h2&gt;
&lt;p&gt;influxdb: tsdb.&lt;/p&gt;
&lt;p&gt;kapacitor: alerting.&lt;/p&gt;
&lt;p&gt;chronograf: GUI.&lt;/p&gt;
&lt;p&gt;telegraf(agent): metrics collector.&lt;/p&gt;
&lt;h2 id=&#34;prometheus&#34;&gt;Prometheus&lt;/h2&gt;
&lt;h2 id=&#34;graphing&#34;&gt;Graphing&lt;/h2&gt;
&lt;p&gt;最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;
&lt;h2 id=&#34;elk&#34;&gt;ELK&lt;/h2&gt;
&lt;h2 id=&#34;lokigrafana&#34;&gt;Loki+Grafana&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tracing&#34;&gt;Tracing&lt;/h1&gt;
&lt;h2 id=&#34;jeager&#34;&gt;Jeager&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Sentry</title>
        <link>https://canuxcheng.com/post/tracing_sentry/</link>
        <pubDate>Wed, 08 Jun 2016 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/tracing_sentry/</guid>
        <description>&lt;h1 id=&#34;sentry&#34;&gt;Sentry&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/getsentry/sentry&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/getsentry/sentry&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;deploy-sentry-on-k8s&#34;&gt;Deploy Sentry on K8S&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/getsentry/onpremise&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/getsentry/onpremise&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Tracing</title>
        <link>https://canuxcheng.com/post/tracing/</link>
        <pubDate>Wed, 08 Jun 2016 09:46:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/tracing/</guid>
        <description>&lt;h1 id=&#34;tracing&#34;&gt;Tracing&lt;/h1&gt;
&lt;p&gt;APM 监控，也叫全链路监控。&lt;/p&gt;
&lt;h1 id=&#34;sentry&#34;&gt;sentry&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/getsentry/sentry&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/getsentry/sentry&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;zipkin&#34;&gt;zipkin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openzipkin/zipkin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openzipkin/zipkin&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;open-telemetry&#34;&gt;open-telemetry&lt;/h1&gt;
&lt;p&gt;opentracing和opencensus 合并成open-telemetry.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/opentracing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/opentracing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/census-instrumentation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/census-instrumentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/open-telemetry&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/open-telemetry&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;jaeger&#34;&gt;jaeger&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jaegertracing/jaeger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jaegertracing/jaeger&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/linux_package/</link>
        <pubDate>Tue, 07 Jun 2016 16:57:45 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_package/</guid>
        <description>&lt;h1 id=&#34;dpkg&#34;&gt;DPKG&lt;/h1&gt;
&lt;p&gt;debian的包管理机制。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dpkg-1&#34;&gt;dpkg&lt;/h2&gt;
&lt;p&gt;dpkg的本地前端工具。&lt;/p&gt;
&lt;h3 id=&#34;deb---debian-binary-package-format&#34;&gt;deb - Debian binary package format&lt;/h3&gt;
&lt;h3 id=&#34;dpkg---package-manager-for-debian&#34;&gt;dpkg - package manager for Debian&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dpkg
dpkg -X  ./xxx.deb  xxx  # 将deb包解压到xxx目录
dpkg -e  ./xxx.deb  xxx/DEBIAN # 将control信息解压
dpkg -l | grep pkg # 查看安装的包
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dpkg-reconfigure---reconfigure-an-already-installed-package&#34;&gt;dpkg-reconfigure - reconfigure an already installed package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dpkg-reconfigure
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dpkg-deb---debian-package-archive-deb-manipulation-tool&#34;&gt;dpkg-deb - Debian package archive (.deb) manipulation tool&lt;/h3&gt;
&lt;p&gt;目录结构, DEBIAN/control是必需的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|- debian_root
   |- DEBIAN
      |- control
      |- preinst/preinstallation # 解压deb包之前执行
      |- prerm/preremove
      |- postinst/postinstallation # 解压完成之后执行，通常用来配置
      |- postrm/postremove
      |- copyright
      |- changelog
      |- conffiles
   |- etc
      |- init.d/systemd
         |- &amp;lt;service&amp;gt;
      |- logrotate.d
         |- &amp;lt;service&amp;gt;
   |- user/local/...
   |- opt/...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;control:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Package
Version
Description
Maintain:
Section: utils/net/mail/text/x11/...
Priority: required/standard/optional/extra/...
Essential: yes/no
Architecture: i386/amd64/...
Source:
Depends:    # 运行该process需要的依萊, 只能安装之前安装好，或者用gdebi安装
Pre-Depends:
Recommends:
Suggests:
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;postrm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case &amp;quot;$1&amp;quot; in
    remove)
        remove
        echo &amp;quot;Remove complete&amp;quot;
    ;;

    purge)
        purge
        echo &amp;quot;Purge complete&amp;quot;
    ;;

    upgrade|failed-upgrade|disappear)
        echo &amp;quot;Do nothing&amp;quot;
    ;;

    abort-install|abort-upgrade)
        echo &amp;quot;Do nothing&amp;quot;
    ;;

    *)
        echo &amp;quot;$0 called with unknown argument \`$1&#39;&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建debian包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dpkg-deb -b|--build &amp;lt;directory&amp;gt; [&amp;lt;deb&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看包信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dpkg-deb -I XXX.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dpkg-query---a-tool-to-query-the-dpkg-database&#34;&gt;dpkg-query - a tool to query the dpkg database&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;dpkg-query
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gdebi---simple-tool-to-install-deb-files&#34;&gt;gdebi - Simple tool to install deb files&lt;/h2&gt;
&lt;p&gt;dpkg的本地前端工具。&lt;/p&gt;
&lt;p&gt;使用gdebi安装deb包会自动解决依赖问题:&lt;/p&gt;
&lt;p&gt;安装gdebi:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install gdebi-core
$ sudo apt-get install gdebi-gtk
$ sudo aptitude install gdebi-core # install gdebi itself
$ sudo aptitude install gdebi-gtk # install gdebi GUI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用gdebi:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gdebi XXX.deb # install package
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;apt---command-line-interface&#34;&gt;apt - command-line interface&lt;/h2&gt;
&lt;p&gt;dpkg的远程前端工具。&lt;/p&gt;
&lt;p&gt;apt - command-line interface&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ apt install package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;apt-get - APT package handling utility &amp;ndash; command-line interface&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get option command package

# command:
install
remove
purge
download
source
update

# install
# 可以通过apt-cache madison查看version
apt-get install &amp;lt;package&amp;gt;=&amp;lt;version&amp;gt;

# option:
-d, --download-only
--print-uris
-y,--yes,--assume-yes    # 交互时确认
-f,--force-yes
--reinstall
--allow-unauthenticated
--allow-downgrades (&amp;gt;= ubuntu1604)

# 打印在当前环境安装该包需要的所有以来的下载连接信息
apt-get --print-uris install package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;aptitude - high-level interface to the package manager&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo aptitude install package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;apt-cache - query the APT cache&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ apt-cache showpkg &amp;lt;pkg&amp;gt;
$ apt-cache showsrc &amp;lt;pkg&amp;gt;
$ apt-cache search &amp;lt;pkg&amp;gt;
$ apt-cache madison &amp;lt;pkg&amp;gt; # 查看当前源可以安装的版本
$ apt-cache policy &amp;lt;pkg&amp;gt;

# 查看哪些包依赖该包
$ apt-cache rdepends &amp;lt;pkg&amp;gt;
# 查看该包依赖哪些包
$ apt-cache depends &amp;lt;pkg&amp;gt;
# 查看依赖，　以及依赖的依赖
$ apt-cache --recurse depends &amp;lt;pkg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;rpm&#34;&gt;RPM&lt;/h1&gt;
&lt;p&gt;redhat的包管理机制。&lt;/p&gt;
&lt;h2 id=&#34;rpm-1&#34;&gt;rpm&lt;/h2&gt;
&lt;p&gt;rpm的本地前端工具。&lt;/p&gt;
&lt;p&gt;rpm - RPM Package Manager&lt;/p&gt;
&lt;h2 id=&#34;yum&#34;&gt;yum&lt;/h2&gt;
&lt;p&gt;rpm的远程前端工具。&lt;/p&gt;
&lt;p&gt;yum - redirecting to DNF Command Reference&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;zypper&#34;&gt;zypper&lt;/h1&gt;
&lt;p&gt;suse的包管理机制。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;alien&#34;&gt;Alien&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;alien is a program that converts between Red Hat rpm, Debian deb, Stampede slp, Slackware tgz, and Solaris pkg file formats.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;gbp&#34;&gt;gbp&lt;/h1&gt;
&lt;p&gt;通过git来管理deb或rpm包．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/agx/git-buildpackage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/agx/git-buildpackage&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo -E pip install gbp
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fpm&#34;&gt;fpm&lt;/h1&gt;
&lt;p&gt;通过fpm来创建deb/rpm包&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jordansissel/fpm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jordansissel/fpm&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;patch&#34;&gt;patch&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Oracle</title>
        <link>https://canuxcheng.com/post/oracle/</link>
        <pubDate>Wed, 01 Jun 2016 22:40:22 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/oracle/</guid>
        <description>&lt;h1 id=&#34;oracle&#34;&gt;Oracle&lt;/h1&gt;
&lt;p&gt;oracle的GUI：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;oracle sql developer(officer)&lt;/li&gt;
&lt;li&gt;pl/sql&lt;/li&gt;
&lt;li&gt;toad&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;oracle的CLI：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sqlplus&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;oracle命令&#34;&gt;Oracle命令&lt;/h1&gt;
&lt;p&gt;sys是oracle默认管理员权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sqlplus / as sysdba
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;system是oracle的默认最高权限，默认密码是manager，需要sys授权才能登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sqlplus / as sysdba
&amp;gt; alter user system account unlock;
&amp;gt; alter user system identified by manager;
&amp;gt; conn system/manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;scott是oracle的默热你的普通用户，默认密码是tiger，需要sys授权才能登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sqlplus / as sysdba
&amp;gt; alter user scott account unlock;
&amp;gt; alter user scott identified by tiger;
&amp;gt; conn scott/tiger
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地命令行执行sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ &amp;lt;sql query&amp;gt; | &amp;lt;sqlplus&amp;gt; &amp;lt;db user&amp;gt;/&amp;lt;db password&amp;gt;@&amp;lt;db sid&amp;gt; | sudo ORACLE_HOME=&amp;lt;oracle home&amp;gt; -i -u &amp;lt;oracle user&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dbsnmp是oracle的用户智能代理用户，用来监控和管理数据库相关性能。&lt;/p&gt;
&lt;p&gt;sysman是oracle的数据库用户EM管理用户。&lt;/p&gt;
&lt;p&gt;监听管理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;su - oracle
lsnrctl start
lsnrctl stop
lsnrctl status
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;先用sqlplus命令进入oracle的命令行．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help index
? index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看命令帮助信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help &amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆和退出sqlplus：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sqlplus
exit/quit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不退出sqlplus执行shell命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户登陆和退出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;connect/conn &amp;lt;username&amp;gt;/&amp;lt;password&amp;gt;
disconnect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;清屏：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear
! clear
clear scr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改密码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;password
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;p&gt;isnull函数:&lt;/p&gt;
&lt;p&gt;　　　　NVL(column, 0)    column为null函数返回0&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql&#34;&gt;SQL&lt;/h1&gt;
&lt;p&gt;创建用户：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE USER &amp;lt;username&amp;gt; IDENTIFIED BY &amp;lt;password&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户授权：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GRANT DBA TO &amp;lt;username&amp;gt;;
GRANT UNLIMITED TABLESPACE TO &amp;lt;username&amp;gt;;
GRANT SELECT ANY TABLE TO &amp;lt;username&amp;gt;;
GRANT SELECT ANY DICTIONARY TO &amp;lt;username&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM global_name; 查看默认数据库
SELECT * FROM dba_tables; DBA权限查询数据所有表
SELECT * FROM all_users; 查看所有用户
SELECT username FROM dba_users; 查看所有DBA用户
SELECT user FROM dual; 查看当前登陆用户
SELECT * FROM user_tables; 查询当前用户有哪些表
SELECT * FROM all_tables; 查询当前用户可以访问的所有表
SELECT banner FROM sys.v_$version; 查询数据库版本
SELECT count(*) FROM v$version; 查询oracle连接数
SELECT count(*) FROM v$version WHERE STATUS = &#39;ACTIVE&#39;; 查询oracle并发连接数
ALTER system SET processes = &amp;lt;number&amp;gt; scope = spfile; 修改数据库允许最大连接数
SELECT value FROM v$parmeter WHERE name = &#39;processes&#39;; 查询数据库允许最大连接数
SELECT value FROM v$parmeter WHERE name = &#39;open_cursor&#39;; 查询数据库允许最大游标数
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python&#34;&gt;python&lt;/h1&gt;
&lt;h2 id=&#34;cx_oracle&#34;&gt;cx_Oracle&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://cx-oracle.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://cx-oracle.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要安装oracle数据库或者oracle instant client并设置环境变量。&lt;/p&gt;
&lt;p&gt;参考oracle网站下载安装配置oracle instant client&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import cx_Oracle
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>SQL</title>
        <link>https://canuxcheng.com/post/sql/</link>
        <pubDate>Wed, 25 May 2016 22:06:13 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/sql/</guid>
        <description>&lt;h1 id=&#34;sql&#34;&gt;SQL&lt;/h1&gt;
&lt;p&gt;sql是结构化查询语言。&lt;/p&gt;
&lt;p&gt;sql是一种标准，几乎所有关系型数据库都遵守。&lt;/p&gt;
&lt;p&gt;但是不同的数据库又有自己的扩展。&lt;/p&gt;
&lt;p&gt;SQL分为两部分，DML和DDL。&lt;/p&gt;
&lt;p&gt;SQL大小写敏感，文本使用单引号，数值不需要引号。&lt;/p&gt;
&lt;h1 id=&#34;sql语法&#34;&gt;sql语法&lt;/h1&gt;
&lt;p&gt;sql注释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 多行注释
/*
comment multi lines
in a sql file.
*/

# 单行注释
/* comment single line */

# 单行注释还可以直接用 -- 表示
select * from table -- where condition;
-- select * from table where condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ddl&#34;&gt;DDL&lt;/h1&gt;
&lt;p&gt;DDL: 数据定义语言&lt;/p&gt;
&lt;h2 id=&#34;create&#34;&gt;create&lt;/h2&gt;
&lt;p&gt;创建数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE database_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table(
    column1 type1,
    column2 type2,
    ...
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create也可以用来创建索引和视图．&lt;/p&gt;
&lt;h2 id=&#34;drop&#34;&gt;drop&lt;/h2&gt;
&lt;p&gt;删除数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP DATABASE database_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TABLE table;
# 仅仅删除表中的数据，保留表
TRUNCATE TABLE table;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drop也可以用来删除索引和视图．&lt;/p&gt;
&lt;h2 id=&#34;alter&#34;&gt;alter&lt;/h2&gt;
&lt;p&gt;变更表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 添加列
ALTER TABLE table ADD COLUMN column type;

# 删除列
ALTER TABLE table DROP COLUMN column;

# 改变列的数据类型
# sql server
ALTER TABLE table ALTER COLUMN column type;
# mysql
ALTER TABLE table MODIFY COLUMN column type;
# mysql/oracle
ALTER TABLE table MODIFY column type;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;dml&#34;&gt;DML&lt;/h1&gt;
&lt;p&gt;DML: 数据操作语言&lt;/p&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;查询操作:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM table;
# 单表查询
SELECT column FROM table;
# 多表查询
SELECT table1.column1, table2.column2 FROM table1, table2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where子句选取数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column FROM table WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引号的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 文本使用单引号，大部分数据库也接受双引号
SELECT column FROM table WHERE name=&#39;text&#39;;
# 数字不能使用引号．
SELECT column FROM table WHERE id=number;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where子句条件表达式可用的运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=
&amp;lt;&amp;gt;
!=
&amp;gt;
&amp;lt;
&amp;gt;=
&amp;lt;=

BETWEEN [value1, value2]
BETWEEN value1 AND value2
NOT BETWEEN

IN (value1, value2)
NOT IN

IS NULL
IS NOT NULL

LIKE
NOT LIKE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;like运算符的通配符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%    替代一个或多个字符
_    替代一个字符
[char list]    字符列中的任何单一字符
[^char list]    不在字符列中的任何单一字符
[!char list]    和上面一个等效
SELECT * FROM table WHERE name LIKE &#39;[abc]%&#39; # 以abc开头的name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where子句多个条件可以使用的运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AND    与运算
SELECT * FROM table WHERE name=&#39;canux&#39; AND id=10;
OR    或运算
SELECT * FROM table WHERE name=&#39;canux&#39; OR id=10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;order by子句对结果进行排序,默认升序(ASC)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认升序
SELECT column, column1 FROM table ORDER BY column;
SELECT column, column1 FROM table ORDER BY column, column1;
SELECT column, column1 FROM table ORDER BY column ASC;
# DESC降序
SELECT column, column1 FROM table ORDER BY column DESC;
SELECT column, column1 FROM table ORDER BY column DESC, column1 ASC;
# 根据第几个字段排序
SELECT column, column1 FROM table ORDER BY number;
# 多个字段排序，优先级从前到后
SELECT column FROM table ORDER BY column1, column2
SELECT column FROM table ORDER BY column1 DESC, column2 DESC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;top子句用于规定要返回的记录数目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# SQL Server
SELECT TOP number * FROM table;
# mysql
SELECT * FROM table LIMIT number;
# oracle
SELECT * FROM table WHERE ROWNUM &amp;lt;= number;

Top 一般需要order by
# number最小的10个
select top 10 from table order by number
# number最大的10个
select top 10 from table order by number desc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;group by子句用来分组，放在where子句后面如果有的话:&lt;/p&gt;
&lt;p&gt;group by一定要用合计函数(count, max, min, sum, avg, &amp;hellip;).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, aggregate_function(column2) FROM table GROUP BY column1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;having子句用来过滤group by的结果(相当where)，放在group by子句后面：&lt;/p&gt;
&lt;p&gt;因为where不能和合计函数一起使用，所以使用having子句．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column1, aggregate_function(column2) FROM table GROUP BY column1 HAVING aggregate_function(column) condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;distinct关键字排除重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT DISTINCT column FROM table;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as关键字指定别名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定表的别名
SELECT alias_table1.column1, alias_table2.column2
FROM table1 AS alias_table1, table2 AS alias_table2
WHERE alias_table1.column2=&#39;test&#39;;

# 指定字段别名
SELECT column1 AS alias1, column2 AS alias2 FROM table;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from -&amp;gt; where -&amp;gt; group by -&amp;gt; having -&amp;gt; select -&amp;gt; distinct -&amp;gt; union -&amp;gt; order by -&amp;gt; top
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;insert-into&#34;&gt;insert into&lt;/h2&gt;
&lt;p&gt;向表格插入新的行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一次插入完整行
INSERT INTO table VALUES (value1, value2, ...);
# 一次插入多行
INSERT INTO table VALUES (val11, val12, ...) (val21, val22, ...) ...
# 一次插入一行的一部分
INSERT INTO table (column1, column2, ...) VALUES (value1, value2, ...);
# 一次插入多行的一部分
INSERT INTO table (col1, col2, ...) VALUES (val11, val12, ...) (val21, val22, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;update-set&#34;&gt;update set&lt;/h2&gt;
&lt;p&gt;修改表中数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE table SET column1=value1 WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;delete-from&#34;&gt;delete from&lt;/h2&gt;
&lt;p&gt;删除表中的行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE FROM table WHERE condition;
DELETE FROM table; # 删除所有行

TRUNCATE TABLE table; # mysql清空表的内容，不可恢复
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;p&gt;不同的数据库内置的部分函数不同．下面只列出大部分数据库都有的函数．&lt;/p&gt;
&lt;p&gt;sql内置两种函数：合计(aggregate)函数　和　标量(scalar)函数.&lt;/p&gt;
&lt;p&gt;sql函数的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT FUNCTION(args) FROM table ...;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;aggregate-function&#34;&gt;aggregate function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;AVG()：　求平均值
COUNT(): 统计行数
FIRST(): 返回指定字段中第一个记录的值
LAST():　返回指定字段中最后一个记录的值
MAX():　返回一列中的最大值
MIN():　返回一列中的最小值
SUM():　返回一列的和
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scalar-function&#34;&gt;scalar function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;UCASE():　把字段的值转换为大写
LCASE():　把字段的值转换为小写
MID(column, start[, length]):　从文本字段中提取字符，start从１开始
LEN(): 返回文本字段中的长度
FORMAT(column, format): 对字段进行格式化
ROUND(column, decimals): 把数值字段舍入为指定的小数位数
NOW()    返回当前的日期和时间
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;join&#34;&gt;join&lt;/h1&gt;
&lt;p&gt;为了从多个表中获取结果，就需要用join.&lt;/p&gt;
&lt;h2 id=&#34;inner-join&#34;&gt;inner join&lt;/h2&gt;
&lt;p&gt;inner join也就是默认的join.&lt;/p&gt;
&lt;p&gt;全部匹配才返回．相当于table1和table2与.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 两张表连接
SELECT table1.column, table2.column
FROM table1 INNER JOIN table2
ON table1.column = table2.column;

# 三张表连接
SELECT column
FROM ((table1 INNER JOIN table2 ON table1.column1 = table2.column1) INNER JOIN table3
ON table1.column2 = table3.column2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;left-join&#34;&gt;left join&lt;/h2&gt;
&lt;p&gt;左连接．返回左表table1的所有行，和右表table2匹配的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column
FROM table1 LEFT JOIN table2
ON table1.column = table2.column;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;right-join&#34;&gt;right join&lt;/h2&gt;
&lt;p&gt;右连接，返回右表table2的所有行，和左表table1匹配的行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column
FROM table1 RIGHT JOIN table2
ON table1.column = table2.column;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;full-join&#34;&gt;full join&lt;/h2&gt;
&lt;p&gt;返回两张表的所有行．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column
FROM table1 FULL JOIN table2
ON table1.column = table2.column;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;union&#34;&gt;union&lt;/h1&gt;
&lt;p&gt;union操作符用于合并两个或多个select语句的结果集．&lt;/p&gt;
&lt;p&gt;union只选取不同的值,也就是说table1和table2中的相同column只出现一次．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column FROM table1
UNION
SELECT column FROM table2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;union all会列出所有的值，包括重复的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column FROM table1
UNION ALL
SELECT column FROM table2;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;select-into&#34;&gt;select into&lt;/h1&gt;
&lt;p&gt;创建表的备份复件．&lt;/p&gt;
&lt;p&gt;把table1的所有列插入到table2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * INTO table2 FROM table1 WHERE condition;
# table2属于另外一个数据库externaldatabase
SELECT * INTO table2 IN externaldatabase FROM table1 WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把table1的部分列插入到table2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column INTO table2 FROM table1 WHERE condition;
# table2属于另外一个数据库externaldatabase
SELECT column INTO table2 IN externaldatabase FROM table1 WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mysql需要用insert into &amp;hellip; select:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 如果table2已经存在
INSERT INTO table2 SELECT * FROM table1 WHERE condition;
# 如果table2不存在
CREATE TABLE table2 AS SELECT * FROM table1 WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;constraints&#34;&gt;constraints&lt;/h1&gt;
&lt;p&gt;constraints约束用于限制加入表的数据的类型．&lt;/p&gt;
&lt;h2 id=&#34;not-null&#34;&gt;NOT NULL&lt;/h2&gt;
&lt;p&gt;not null强制约束列不能接受null值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE tablename (
    id int NOT NULL,
    name varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unique&#34;&gt;UNIQUE&lt;/h2&gt;
&lt;p&gt;unique约束唯一标识数据库表中的每条记录．&lt;/p&gt;
&lt;p&gt;每个表可以有多个unique约束．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
CREATE TABLE table (
    id int NOT NULL,
    name varchar(255),
    UNIQUE (id)
);

# sql server/oracle:
CREATE TABLE table(
    id int NOT NULL UNIQUE,
    name varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给约束命名，并且标记多个列到unique:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table (
    id int NOT NULL,
    firstname varchar(255),
    lastname varchar(255),
    CONSTRAINT constraintname UNIQUE (id, lastname)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给已经存在的表添加约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table ADD UNIQUE (id);
# 给约束命名，并且标记多个列到unique
ALTER TABLE table ADD CONSTRAINT constraintname UNIQUE (id, lastname);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table DROP INDEX constraintname;
# sql server/oracle:
ALTER TABLE table DROP CONSTRAINTNAME constraintname;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;primary-key&#34;&gt;PRIMARY KEY&lt;/h2&gt;
&lt;p&gt;primary key主键必须包含唯一的值，主键列不能包含NULL值．&lt;/p&gt;
&lt;p&gt;每张表最多只能有一个主键．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
CREATE TABLE table (
    id int NOT NULL,
    firstname varchar(255),
    lastname varchar(255),
    PRIMARY KEY (id)
);

# sql server/oracle:
CREATE TABLE table (
    id int NOT NULL PRIMARY KEY,
    firstname varchar(255),
    lastname varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给主键命名，并且添加多个列到primary key:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table (
    id int NOT NULL,
    firstname varchar(255),
    lastname varchar(255),
    CONSTRAINT constraintname PRIMARY KEY (id, lastname)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给已经存在的表添加约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table ADD PRIMARY KEY (id);
# 给约束命名，并且添加多个列到主键：
ALTER TABLE table ADD CONSTRAINT constraintname PRIMARY KEY (id, lastname);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table DROP PRIMARY KEY;
# sql server/oracle:
ALTER TABLE talbe DROP CONSTRAINT constraintname;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;foreign-key&#34;&gt;FOREIGN KEY&lt;/h2&gt;
&lt;p&gt;一个表中的外键指向另一个表中的主键．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
CREATE TABLE table1 (
    id_1 int NOT NULL,
    id_2 int,
    PRIMARY KEY (id_1),
    FOREIGN KEY (id_2) REFERENCES table2(id_2)
);

# sql server/oracle:
CREATE TABLE table1 (
    id_1 int NOT NULL PRIMARY KEY,
    id_2 int FOREIGN KEY REFERENCES table2(id_2)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给外键命名，并且添加多个列到foreign key:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table1 (
    id_1 int NOT NULL,
    id_2 int,
    PRIMARY KEY (id_1),
    CONSTRAINT constraintname FOREIGN KEY (id_2) REFERENCES table2(id_2)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给已经存在的表添加约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table1 ADD FOREIGN KEY (id_2) REFERENCES table2(id_2);
# 给外键命名，并且添加多列到外键
ALTER TABLE table1 ADD CONSTRAINT constraintname FOREIGN KEY (id_2) REFERENCES table2(id_2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table1 DROP FOREIGN KEY constraintname;
# sql server/oracle:
ALTER TABLE table1 DROP CONSTRAINT constraintname;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;check&#34;&gt;CHECK&lt;/h2&gt;
&lt;p&gt;check用于限制列中的值的范围．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
CREATE TABLE table (
    id int NOT NULL,
    firstname varchar(255),
    lastname varchar(255),
    CHECK (id&amp;gt;0)
);

# sql server/oracle:
CREATE TABLE table (
    id int NOT NULL CHECK (id&amp;gt;0),
    firstname varchar(255),
    lastname varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给约束命名，并且添加多个列到约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table (
    id int NOT NULL,
    firstname varchar(255),
    lastname varchar(255),
    CONSTRAINT constraintname CHECK (id&amp;gt;0 AND lastname=&#39;cheng&#39;)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给已经存在的表添加约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table ADD CHECK (id&amp;gt;0);
# 给约束命名，并且添加多列到约束
ALTER TABLE table ADD CONSTRAINT constraintname CHECK (id&amp;gt;0 AND lastname=&#39;cheng&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table DROP CONSTRAINT constraintname;
# sql server/oracle:
ALTER TABLE table DROP CHECK constraintname;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;default&#34;&gt;DEFAULT&lt;/h2&gt;
&lt;p&gt;default约束用于向列中插入默认值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE table (
    id int NOT NULL,
    country varcha(255) DEFAULT &#39;china&#39;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给已经存在的表添加约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql
ALTER TABLE table ALTER country SET DEFAULT &#39;china&#39;;
# sqlserver/oracle
ALTER TABLE table ALTER COLUMN country SET DEFAULT &#39;china&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table ALTER country DROP DEFAULT;
# sql server/oracle:
ALTER TABLE table ALTER COLUMN country DROP DEFAULT;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;increment&#34;&gt;increment&lt;/h1&gt;
&lt;p&gt;auto increment在每次插入新记录时，自动创建主键字段的值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql使用auto_increment
CREATE TABLE table (
    id int NOT NULL AUTO_INCREMENT,
    firstname varchar(255),
    lastname varchar(255),
    PRIMARY KEY (id)
);

# sql server使用identity:
CREATE TABLE table (
    id int PRIMARY KEY IDENTITY;
    firstname varchar(255),
    lastname varchar(255)
);

# oracle使用sequence对:
CREATE SEQUENCE sequencename
MINVALUE 1
START WITH 1
INCRREMENT BY 1
CACHE 10
# 使用nextval函数获取下一个值：
INSERT INTO table (id, firstname, lastname) VALUES (sequencename.nextval, &#39;canux&#39;, &#39;cheng&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;auto increment的默认起始值是1,每次插入一行默认加一，可以修改起始值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE table AUTO_INCREMENT=10;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;index&#34;&gt;index&lt;/h1&gt;
&lt;p&gt;创建索引可以快速高效查询数据，但是用户无法看到索引．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在表中创建简单索引，允许使用重复的值:
CREATE INDEX indexname ON table (column, column1, ...);

# 在表中创建唯一索引，两个行不能有相同索引值:
CREATE UNIQUE INDEX indexname ON table (column, column1, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql:
ALTER TABLE table DROP INDEX indexname;
# sql server:
DROP INDEX table.indexname;
# oracle:
DROP INDEX indexname;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;view&#34;&gt;view&lt;/h1&gt;
&lt;p&gt;视图是基于sql语句的结果集的可视化的表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE VIEW viewname AS SELECT * FROM table WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新视图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE OR REPLACE VIEW viewname AS SELECT column FROM table WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查询视图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM viewname;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除视图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP VIEW viewname;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Mysql</title>
        <link>https://canuxcheng.com/post/mysql/</link>
        <pubDate>Wed, 25 May 2016 12:14:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/mysql/</guid>
        <description>&lt;h1 id=&#34;mysql&#34;&gt;Mysql&lt;/h1&gt;
&lt;p&gt;安装mysql服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install mysql-server
$ sudo yum install mysql-community-server

$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
# 注意mysql的/etc/mysql/my.cnf和相关文件如果设置了bind-address = 127.0.0.1就无法远程访问，需要注释掉．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装mysql客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install mysql-client
$ sudo yum install mysql-community-client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装开发工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CLI工具： mysql&lt;/p&gt;
&lt;p&gt;GUI工具： mysql workbench&lt;/p&gt;
&lt;p&gt;安装完成默认的数据库是 mysql。&lt;/p&gt;
&lt;p&gt;mysqld的默认端口是3306.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mysql命令&#34;&gt;mysql命令&lt;/h1&gt;
&lt;p&gt;tips: 用户名密码有特殊字符用引号.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql [OPTIONS] [database]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化时需要用root用户进入mysql命令行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql -uroot -p
$ mysql -h&amp;lt;host&amp;gt; -P&amp;lt;port&amp;gt; -uroot -p&amp;lt;password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建用户后用其它用户操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql -u&amp;lt;user&amp;gt; -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地执行sql语句或mysql客户端命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql -u&amp;lt;username&amp;gt; -p&amp;lt;password&amp;gt; &amp;lt;database&amp;gt; -e/--execute &amp;lt;sql query&amp;gt;
$ mysql -u&amp;lt;username&amp;gt; -p&amp;lt;password&amp;gt; &amp;lt;database&amp;gt; &amp;lt; test.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;远程执行sql语句或mysql客户端命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql -h&amp;lt;host&amp;gt; -P&amp;lt;port&amp;gt; -u&amp;lt;username&amp;gt; -p&amp;lt;password&amp;gt; &amp;lt;database&amp;gt; -e/--execute &amp;lt;sql query&amp;gt;
$ mysql -h&amp;lt;host&amp;gt; -P&amp;lt;port&amp;gt; -u&amp;lt;username&amp;gt; -p&amp;lt;password&amp;gt; &amp;lt;database&amp;gt; &amp;lt; test.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启用&amp;rsquo;load data local&amp;rsquo;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 交互式
$ mysql --local-infile=1 -uroot -ppassword
# 非交互式
$ mysql --local-infile=1 -uroot -pchengca w3c -e &amp;quot;LOAD DATA LOCAL INFILE &#39;/home/user/customers.txt&#39; INTO TABLE Customers COLUMNS TERMINATED BY &#39;\t&#39; LINES TERMINATED BY &#39;\n&#39;;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出数据命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysqldump -u&amp;lt;username&amp;gt; -p&amp;lt;password&amp;gt; &amp;lt;databasename&amp;gt;  &amp;gt;  dump.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mycli:&lt;/p&gt;
&lt;p&gt;A command line client for MySQL that can do auto-completion and syntax highlighting.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dbcli/mycli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dbcli/mycli&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install -U mycli
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;先用mysql命令进入mysql的命令行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?         (\?) Synonym for help.
help      (\h) Display this help.

exit      (\q) Exit mysql. Same as quit.
quit      (\q) Quit mysql.

clear     (\c) Clear the current input statement.
connect   (\r) Reconnect to the server. Optional arguments are db and host.
delimiter (\d) Set statement delimiter.
edit      (\e) Edit command with \$EDITOR.
ego       (\G) Send command to mysql server, display result vertically.
go        (\g) Send command to mysql server.
nopager   (\n) Disable pager, print to stdout.
notee     (\t) Don&#39;t write into outfile.
pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.
print     (\p) Print current command.
prompt    (\R) Change your mysql prompt.
rehash    (\#) Rebuild completion hash.

source    (\.) Execute an SQL script file. Takes a file name as an argument.
mysql&amp;gt; source /path/to/dump.sql # 从sql导入数据

status    (\s) Get status information from the server.
system    (\!) Execute a system shell command.
tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.

use       (\u) Use another database. Takes database name as argument.
mysql&amp;gt; use database # 切换到数据库

charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.
warnings  (\W) Show warnings after every statement.
nowarning (\w) Don&#39;t show warnings after every statement.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其它可以在mysql客户端执行的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从本地一个文件导入数据，列分隔符为\t,行分隔符为\n
LOAD DATA LOCAL INFILE &#39;/home/user/customers.txt&#39; INTO TABLE Customers COLUMNS TERMINATED BY &#39;\t&#39; LINES TERMINATED BY &#39;\n&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数和运算符&#34;&gt;函数和运算符&lt;/h1&gt;
&lt;p&gt;date and time：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NOW() // &#39;2018-11-18 16:00:28&#39;
UTC_TIMESTAMP() // &#39;2018-11-18 08:01:04&#39;
CURDATE()  // &#39;2018-11-18&#39;
UTC_DATE() // &#39;2018-11-18&#39;
CURTIME()  // &#39;16:02:18&#39;
UTC_TIME() // &#39;08:03:36&#39;

UNIX_TIMESTAMP() // &#39;1542528051&#39;
DATE() // &#39;2021-1-12&#39;
TIME() // &#39;14:28:00&#39;
DATEDIFF() 
date_format(column, &#39;%Y-%m-%d&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;control flow:：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CASE

IF()
IFNULL(column, 0)
NULLIF()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comparison:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COALESCE(column, 0)

ISNULL()
IS NULL

IN()
NOT IN()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sql&#34;&gt;SQL&lt;/h1&gt;
&lt;p&gt;注意：hostname 指定能连接的server，%表示任何server．&lt;/p&gt;
&lt;p&gt;查看版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT VERSION();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有用户：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT DISTINCT(USER) FROM mysql.user;
SELECT user,host,plugin FROM mysql.user;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前用户：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT USER();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建/删除用户：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE USER &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;;
DROP USER &#39;username&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置和更改密码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE mysql.user SET PASSWORD(&#39;password&#39;) WHRER USER=&#39;username&#39; AND HOST=&#39;hostname&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT DATABASE();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建/删除数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE databasename;
DROP DATABASE databasename;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定数据库对用户授权：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GRANT ALL PRIVILEGES ON databasename.* TO &#39;username&#39;@&#39;%&#39;;
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW GRANTS FOR &#39;username&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use databasename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看表结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;desc tablename;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 类似like，特殊字符要用双反斜杠转义.
select * from tablename where colume REGEXP &#39;...&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看系统配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &#39;version&#39;;
select @@version;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;issue&#34;&gt;Issue&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;mysql8  workbench 连不上的问题 :&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;authentication plugin &#39;caching_sha2_password&#39; cannot be loaded: the specified module could not be found。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fix：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql8 开始默认授权插件改成caching_sha2_password.
可以指定为--default-authentication-plugin=mysql_native_password，
alter user &#39;sandbox&#39;@&#39;%&#39; identified with mysql_native_password by &#39;password&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;max_commection 问题:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当连接池连接数量超过最大连接数就无法再建立连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show processlist;
show variables like &#39;max_connections&#39;;
set global max_connections = 2048;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;1153, &amp;ldquo;Got a packet bigger than &amp;lsquo;max_allowed_packet&amp;rsquo; bytes&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;请求数据超过限制，默认可能是4M
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置成最大值1G
select @@max_allowed_packet;
SET GLOBAL max_allowed_packet = 1024 * 1024 * 1024;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;1205, &amp;lsquo;Lock wait timeout exceeded; try restarting transaction&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;后提交的事务等待前面处理的事务释放锁，但是在等待的时候超过了mysql的锁等待时
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 首先优化表索引.
select @@innodb_lock_wait_timeout
set global innodb_lock_wait_timeout=100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5. 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.&lt;/p&gt;
&lt;p&gt;fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;mysql&amp;gt; reset master&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Builtins</title>
        <link>https://canuxcheng.com/post/ps_builtins/</link>
        <pubDate>Tue, 24 May 2016 10:44:44 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ps_builtins/</guid>
        <description>&lt;h1 id=&#34;get-help和help&#34;&gt;Get-Help和Help:&lt;/h1&gt;
&lt;p&gt;get-help查看帮助信息,help分页查看帮助信息，man是help的别名&lt;/p&gt;
&lt;p&gt;命令说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help
Help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有命令和概念：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help *
Help *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模糊查找命令和概念：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help *&amp;lt;name&amp;gt;*
Help *&amp;lt;name&amp;gt;*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看具体命令帮助：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help {&amp;lt;CmdletName&amp;gt; | &amp;lt;TopicName&amp;gt;}
Help {&amp;lt;CmdletName&amp;gt; | &amp;lt;TopicName&amp;gt;}
&amp;lt;CmdletName&amp;gt; -?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get-help/help的选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get-help get-help
-examples # 查看示例
-full # 查看所有帮助
-parameter # 查看选项的帮助
-detailed # 查看详细信息
-online # 打开文档中的link
-showwindow # 用窗口打开
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;helpfile&#34;&gt;Helpfile&lt;/h1&gt;
&lt;p&gt;3.0/4.0 需要先下载帮助手册：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update-help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有helpfile：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help/Help about_*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看具体helpfile：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Help/Help about_&amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cmdlets&#34;&gt;Cmdlets&lt;/h1&gt;
&lt;p&gt;cmdlets是powershell的内置命令,类型是System.Management.Automation.CmdletInfo&lt;/p&gt;
&lt;p&gt;cmdlets的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Equals
GetHashCode
GetType
ToString
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cmdlets的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CommandType
DefaultParameterSet
Definition
HelpFile
ImplementingType
Module
ModuleName
Name
Noun
OutputType
Parameters
ParameterSets
PSSnapln
Verb
Visibility
DLL
HelpUri
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用cmdlets命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Command -CommandType cmdlet # 查看所有cmdlet

Get-Command
Invoke-Command
Measure-Command
Show-Command
Trace-Command

Get-Service
New-Service
Restart-Service
Resume-Service
Set-Service
Stop-Service
Suspend-Service

Get-Process
Debug-Process
Start-Process
Stop-Process
Wait-Process

Get-Member  # 查看属性
Add-Member

Get-Host
Read-Host
Write-Host
Out-Host

Out-Default
Out-File    # 重定向，也可以用&amp;gt;, &amp;gt;&amp;gt;
Out-GridView
Out-Null
Out-Printer
Out-String

Write-Debug
Write-Error
Write-EventLog
Write-Output
Write-Progress
Write-Verbose
Write-Warning
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;function&#34;&gt;Function&lt;/h1&gt;
&lt;p&gt;powershell内置函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Command -CommandType function # 查看所有function
ls function:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有function：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prompt
TabExpansion2
Clear-Host
more
help
mkdir
Get-Verb
oss
cd..
cd\
ImportSystemModules
Pause
A:
...
Z:
Get-FileHash
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;alias&#34;&gt;Alias&lt;/h1&gt;
&lt;p&gt;powershell内置别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-Command -CommandType alias # 查看所有alias
dir alias: # 查看所有alias
ls alias: | where {$_.Definition.Startswith(&amp;quot;Start&amp;quot;)}

Get-Alias # 查看所有alias
Set-Alias
New-Alias
Import-Alias
Export-Alias
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用alias：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ForEach-Object    %/foreach
Where-Object    ?/where
Select-Object    select
Compare-Object    compare/diff
Tee-Object    tee
Sort-Object    sort

Set-Location    cd/chdir/sl
Get-Location    pwd/gl

Clear-Content    clc
Get-Content    cat/type/gc

Clear-History    clhy
Get-History    h/history/ghy
Invoke-History    ihy/r

Clear-Variable    clv
Set-Variable    set/sv

Clear-Item    cli
Clear-ItemProperty    clp
Copy-Item    copy/cp/cpi
Remove-Item    del/erase/rd/ri/rm/rmdir
Move-Item    mv/move/mi
Get-ChildItem    dir/ls/gci

Get-Process    ps/gps
Stop-Process    kill/spps
Start-Process    start/saps

Clear-Host    clear/cls

Write-Output    echo/write

New-PSDrive    mount

Invoke-WebRequest    curl/wget

Start-Sleep    sleep

help    man
mkdir    md
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;provider&#34;&gt;Provider&lt;/h1&gt;
&lt;p&gt;provider相关cmdlet：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Get-PSProvider # 查看provider
Get-PSDrive    # 查看驱动器
New-PSDrive    # 新建驱动器
Remove-PSDrive    # 删除驱动器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有provider：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 这三个驱动器可以用ls或dir直接查看内容
ls alias:
dir function:
Alias   # 别名驱动器
Function    # 函数驱动器
Variable    # 变量驱动器

# 这三个驱动器需要具体的驱动器,然后cd进去查看
FileSystem    # 文件系统驱动器
Environment
Registry

help/get-help &amp;lt;provider_name&amp;gt;    # 查看provider帮助
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;object&#34;&gt;object&lt;/h1&gt;
&lt;p&gt;object主要通过管道|使用。&lt;/p&gt;
&lt;p&gt;object相关的cmdlet：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Compare-Object
ForEach-Object
Group-Object
Measure-Object
New-Object
Select-Object
Sort-Object
Tee-Object
Where-Object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;object转化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get-command -verb *convert*
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出object：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get-command -verb *export*
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入object：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get-command -verb *import*
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;module&#34;&gt;module&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Get-Module
get-module -listavailable # 查找安装的模块
Import-Module
import-module sqlps # 导入第三方mssql模块
get-command -module sqlps # 查看模块中所有命令
New-Module
Remove-Module
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;format&#34;&gt;format&lt;/h1&gt;
&lt;p&gt;安装路径有一些xml文件已经做了一些默认的格式化。&lt;/p&gt;
&lt;p&gt;格式化的数据只能传给Out-File/out-host/out-printer/out-null/out-string/out-default.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Export-FormatData
Get-FormatData
Update-FormatData
Format-Custom
Format-List
Format-Table
Format-Wide
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Snmp</title>
        <link>https://canuxcheng.com/post/snmp/</link>
        <pubDate>Tue, 26 Apr 2016 09:56:04 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/snmp/</guid>
        <description>&lt;h1 id=&#34;snmp&#34;&gt;SNMP&lt;/h1&gt;
&lt;p&gt;Simple Network Management Protocol, 简单网络管理协议&lt;/p&gt;
&lt;p&gt;MIB&lt;/p&gt;
&lt;p&gt;SMI&lt;/p&gt;
&lt;p&gt;安装和配置snmp:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install snmp snmpd snmp-mibs-downloader
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;snmp命令&#34;&gt;snmp命令&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Admin</title>
        <link>https://canuxcheng.com/post/win_admin/</link>
        <pubDate>Tue, 26 Apr 2016 09:54:45 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win_admin/</guid>
        <description></description>
        </item>
        <item>
        <title>PowerShell</title>
        <link>https://canuxcheng.com/post/ps/</link>
        <pubDate>Tue, 26 Apr 2016 09:52:02 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ps/</guid>
        <description>&lt;h1 id=&#34;powershell&#34;&gt;PowerShell&lt;/h1&gt;
&lt;p&gt;Console: command line interface&lt;/p&gt;
&lt;p&gt;ISE: script editor and console combination&lt;/p&gt;
&lt;p&gt;Version:&lt;/p&gt;
&lt;p&gt;2.0,3.0,4.0,5.0&lt;/p&gt;
&lt;p&gt;C:\Windows\System32\powershell 存放64位powershell&lt;/p&gt;
&lt;p&gt;C:\Windows\SysWOW64\powershell 存放32位powershell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;$PSVersionTable
&amp;gt;$HOST
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Install/Update:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.microsoft.com/zh-CN/download/details.aspx?id=40855&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.microsoft.com/zh-CN/download/details.aspx?id=40855&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装Windows Management Framework4.0即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;$PSHOME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多版本时切换版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;powershell -version 2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;powershell相关项目&#34;&gt;powershell相关项目&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Microsoft&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Microsoft&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShellOrg&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShellOrg&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;win32-openssh&#34;&gt;win32-openssh&lt;/h2&gt;
&lt;p&gt;windows的SSH。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/Win32-OpenSSH&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/Win32-OpenSSH&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;powershell命令&#34;&gt;powershell命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;powershell -?
&amp;gt;powershell /?
&amp;gt;powershell -help
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;powershell-script&#34;&gt;powershell script&lt;/h1&gt;
&lt;p&gt;powershell是默认大小写不敏感的。&lt;/p&gt;
&lt;p&gt;同一行多个命令需要用分号;隔开。&lt;/p&gt;
&lt;p&gt;powershell的安全策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;restricted(default)&lt;/li&gt;
&lt;li&gt;allsigned&lt;/li&gt;
&lt;li&gt;remotesigned&lt;/li&gt;
&lt;li&gt;unrestricted&lt;/li&gt;
&lt;li&gt;bypass&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;注释&#34;&gt;注释&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释(文档注释)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;#
comment1
comment2
...
#&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;帮助文档:&lt;/p&gt;
&lt;p&gt;在脚本开头的注释中用下面关键字插入文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;#
.SYNOPSIS
Write your synopsis here.

.DESCRIPTION
Write your description here.

.PARAMETER param1
Write your param1 information here.

.EXAMPLE
Write your example1 here.

.NOTES
Write your notes here.

.LINK
http://test.com
#&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;p&gt;所有的变量都存储在Variable驱动器中,可以用Variable驱动器对变量操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls Variable: # 查看所有变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$_    # 表示管道中的当前对象
?    # True表示上一个命令成功执行,False失败
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义变量：&lt;/p&gt;
&lt;p&gt;变量以$开头定义,但是$不是变量名的一部分。&lt;/p&gt;
&lt;p&gt;变量包含数字，字母和小划线。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$var1=&amp;quot;test&amp;quot;
$var1

# 交换两个变量的值
$var1,$var2=$var2,$var1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量类型：&lt;/p&gt;
&lt;p&gt;可以不用指定变量类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[string]$str=&amp;quot;123&amp;quot;
[int]$num=123
[boolean]bool=&amp;quot;True&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断变量类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$str -is [string]
$num -as [int]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;包含多个变量就是一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$var2=1,2,3
$var2[index]
$var2[0] # 数组第一个元素
$var2[-1] # 数组最后一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字典&#34;&gt;字典：&lt;/h2&gt;
&lt;p&gt;hash类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@{L=&amp;lt;key&amp;gt;;
E={$_.&amp;lt;value&amp;gt;};
formatstring=&amp;lt;format&amp;gt;}

@{N=&amp;lt;key&amp;gt;;E={$_.&amp;lt;value&amp;gt;}}
@{Label=&amp;lt;key&amp;gt;;E={$_.&amp;lt;value&amp;gt;}}
@{Name=&amp;lt;key&amp;gt;;E={$_.&amp;lt;value&amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;运算符&#34;&gt;运算符&lt;/h1&gt;
&lt;p&gt;基本运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;= # 赋值运算符，可以把任何数据类型包括对象赋值给变量
+ # 加法和字符串拼接
- # 减法
* # 乘法
/ # 除法
() # 优先运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$($procs[0].name) # 子变量
&#39;$var&#39; # 单引号中的变量原样输出
&amp;quot;$var&amp;quot; # 双引号中的变量被替换
&amp;quot;`$var&amp;quot; # `重音符可以用在双引号中转义
`t    # 制表符
`n    # 换行符
kb/mb/gt/tb/pb # 单位可以运算
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-eq
-ne
-gt
-ge
-lt
-le
-contains 包含
-notcontains
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-not 求反
-and
-or
-xor
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;控制流&#34;&gt;控制流&lt;/h1&gt;
&lt;p&gt;powershell支持foreach循环。&lt;/p&gt;
&lt;p&gt;if条件语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ($this -eq $that) {
    expression
} elseif ($those -gt $these) {
    expression2
} else {
    expression3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;switch条件语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch ($condition) {
    val1 {
        expression
        break
    }
    val2 {
        expression2; break
    }
    default {
        default_expression
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;foreach循环语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foreach ($name in $names) {
    expression
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for ($loop=1; condition; $loop++)
{
    expression
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while循环语句:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (condition)
{
    expression
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;do-while循环语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;do {
    expression
} while (condition)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break语句：&lt;/p&gt;
&lt;p&gt;break用于循环和switch语句。&lt;/p&gt;
&lt;p&gt;continue语句：&lt;/p&gt;
&lt;p&gt;continue用于循环语句。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;p&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function name {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\file.ps1
name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[CmdletBinding()]
Param(
    [Parameter(Mandatory=$True)]
    [String]$ComputerName, # ComputerName强制为通过命令行输入参数

    [int]$EventID=1234, # EventID有默认参数

    [Parameter(Mandatory=$True)][ValidateRange(0,23)]
    [int]$Number # 给出参数的范围
)

[CmdletBinding(SupportsShouldProcess$True)] # 支持-whatif和-confirm
[ValidateSet(1,3,8)] # 给出参数的可选值
[alias(&amp;quot;id&amp;quot;, &amp;quot;nunber&amp;quot;)] # 给参数指定别名
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;模块&#34;&gt;模块&lt;/h1&gt;
&lt;p&gt;系统模块路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c:\Windows\System32\WindowsPowershell\v1.0\Modules\
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数可以打包成模块放在系统模块路径或用户自己的模块路径。&lt;/p&gt;
&lt;p&gt;模块放到同名的目录mytools下，取名mytools.psm1&lt;/p&gt;
&lt;p&gt;导入用户自己路径下的模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Import-Module -name C:\Modules\mytools
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;异常和错误处理&#34;&gt;异常和错误处理&lt;/h1&gt;
&lt;p&gt;调试语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Write-Verbose &amp;quot;print verbose information.&amp;quot; # 打印调试信息

Write-Debug &amp;quot;print debug information.&amp;quot; # 使用-Debug进入debug模式，exit退出。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调试相关系统变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ErrorActionPreference=&#39;Continue&#39; # 调试的系统变量，默认报错继续执行

$DebugPreference=&#39;SilentlyContinue&#39;

$ErrorView=&#39;NormalView&#39;

$Error 存储整个shell的错误。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异常捕获：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Try {
    expressions
}
Catch {
    &amp;quot;execute when catch the error.&amp;quot;
}
Finally {
    &amp;quot;execute anyway.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;断点调试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$Condition = {if ($a -is [int] -and $a -gt 100) {Write-Host &amp;quot;`$a was modified&amp;quot;}}
$Breakpoint = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath -Action $Condition
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Utils</title>
        <link>https://canuxcheng.com/post/ps_utils/</link>
        <pubDate>Tue, 26 Apr 2016 09:52:02 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/ps_utils/</guid>
        <description>&lt;h1 id=&#34;windows相关项目&#34;&gt;windows相关项目：&lt;/h1&gt;
&lt;h2 id=&#34;choco&#34;&gt;choco&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/chocolatey&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/chocolatey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows的apt/yum。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/chocolatey/choco&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;choco&lt;/a&gt; is replacement of &lt;a class=&#34;link&#34; href=&#34;https://github.com/chocolatey/chocolatey&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chocolatey&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;choco install openssh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmder&#34;&gt;cmder&lt;/h2&gt;
&lt;p&gt;cmd的升级版。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cmderdev/cmder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cmderdev/cmder&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;babun&#34;&gt;babun&lt;/h2&gt;
&lt;p&gt;a linux-shell like on windows.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/babun/babun&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/babun/babun&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;flinux&#34;&gt;flinux&lt;/h2&gt;
&lt;p&gt;run unmodified linux applications inside windows&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wishstudio/flinux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wishstudio/flinux&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Tivoli</title>
        <link>https://canuxcheng.com/post/metrics_tivoli/</link>
        <pubDate>Wed, 20 Apr 2016 13:57:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_tivoli/</guid>
        <description>&lt;h1 id=&#34;itm&#34;&gt;ITM&lt;/h1&gt;
&lt;p&gt;ITM: IBM Tivoli Monitoring&lt;/p&gt;
&lt;p&gt;是IBM的Cloud &amp;amp; Smart Infrastructure监控解决方案。&lt;/p&gt;
&lt;p&gt;Architecture Overview:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/tivoli.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ITM主要由管理组件和可选组件组成。&lt;/p&gt;
&lt;p&gt;Tivoli Management Services:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TEMS&lt;/li&gt;
&lt;li&gt;TEPS&lt;/li&gt;
&lt;li&gt;TEP client&lt;/li&gt;
&lt;li&gt;Historical data collection(warehouse agent)
&lt;ul&gt;
&lt;li&gt;warehouse proxy&lt;/li&gt;
&lt;li&gt;summarization and pruning agent&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS agent&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Optional components:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dashboard Application Services Hub
&lt;ul&gt;
&lt;li&gt;Tivoli Monitoring dashboards(Infrastructure Management Dashboards for Servers)&lt;/li&gt;
&lt;li&gt;Tivoli Common Reporting&lt;/li&gt;
&lt;li&gt;Tivoli Enterprise Monitoring Automation Server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tivoli Event Synchronization component&lt;/li&gt;
&lt;li&gt;Authorization Policy Components(tivcmd)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装itm&#34;&gt;安装ITM&lt;/h2&gt;
&lt;p&gt;Windows: C:\IBM\ITM&lt;/p&gt;
&lt;p&gt;Linux/Unix: /opt/IBM/ITM&lt;/p&gt;
&lt;p&gt;分为本地安装和分布式安装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需要先为TEPS和TDW安装DB(ODBC/JDBC)。&lt;/p&gt;
&lt;p&gt;DB2&lt;/p&gt;
&lt;p&gt;MSSQL&lt;/p&gt;
&lt;p&gt;Oracle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在windows/linux/unix安装ITM framework&lt;/p&gt;
&lt;p&gt;TEMA&lt;/p&gt;
&lt;p&gt;Warehouse Proxy agent&lt;/p&gt;
&lt;p&gt;Summarization and Pruning agent&lt;/p&gt;
&lt;p&gt;Tivoli performance Analyzer&lt;/p&gt;
&lt;p&gt;TEMS&lt;/p&gt;
&lt;p&gt;TEPS&lt;/p&gt;
&lt;p&gt;TEPD&lt;/p&gt;
&lt;p&gt;TEMAS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装agent&lt;/p&gt;
&lt;p&gt;安装操作系统的agent：&lt;/p&gt;
&lt;p&gt;monitoring agent for your OS。&lt;/p&gt;
&lt;p&gt;安装数据库的agent：&lt;/p&gt;
&lt;p&gt;TEMA/TEMS/TEPS同时勾选DB的agent。&lt;/p&gt;
&lt;p&gt;安装agent builder的agent。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www-933.ibm.com/support/fixcentral/swg/downloadFixes?parent=ibm%2FTivoli&amp;amp;product=ibm/Tivoli/IBM&amp;#43;Tivoli&amp;#43;Monitoring&amp;amp;release=All&amp;amp;platform=All&amp;amp;function=fixId&amp;amp;fixids=6.3.0-TIV-ITM-FP0005&amp;amp;includeRequisites=1&amp;amp;includeSupersedes=0&amp;amp;downloadMethod=http&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www-933.ibm.com/support/fixcentral/swg/downloadFixes?parent=ibm%2FTivoli&amp;product=ibm/Tivoli/IBM+Tivoli+Monitoring&amp;release=All&amp;platform=All&amp;function=fixId&amp;fixids=6.3.0-TIV-ITM-FP0005&amp;includeRequisites=1&amp;includeSupersedes=0&amp;downloadMethod=http&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;tems&#34;&gt;TEMS&lt;/h1&gt;
&lt;p&gt;TEMS:  Tivoli Enterprise Monitoing Server&lt;/p&gt;
&lt;p&gt;TEMS分为remote和hub，remote最后都汇总到hub。&lt;/p&gt;
&lt;p&gt;HTEMS: Hub Tivoli Enterprise Monitoring Server&lt;/p&gt;
&lt;p&gt;RTEMS: Remote Tivoli Enterprise Monitoring Server&lt;/p&gt;
&lt;p&gt;一个TEMS建议管理700个agent&lt;/p&gt;
&lt;h1 id=&#34;tema&#34;&gt;TEMA&lt;/h1&gt;
&lt;p&gt;TEMA: Tivoli Enterprise Monitoring Agent&lt;/p&gt;
&lt;p&gt;安装agent之后通过GUI工具Tivoli Enterprise Monitoring Service来配置和启动agent。&lt;/p&gt;
&lt;p&gt;也可以通过命令行来配置和启动agent。&lt;/p&gt;
&lt;p&gt;agent配置需要指定HTEMS服务器。&lt;/p&gt;
&lt;h2 id=&#34;agentless&#34;&gt;Agentless&lt;/h2&gt;
&lt;p&gt;TEMS -&amp;gt; Agentless server -&amp;gt; servers&lt;/p&gt;
&lt;p&gt;就是用一个中间服务器通过snmp等协议来监控不需要安装agent的被监控服务器。&lt;/p&gt;
&lt;p&gt;一个agentless可以设置10个实例(操作系统)，一个实例可以监控100个节点(被监控服务器)。&lt;/p&gt;
&lt;p&gt;Agentless OS agents:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Agentless Monitoring for AIX OS - SNMP&lt;/li&gt;
&lt;li&gt;Agentless Monitoring for HP-UX OS - SNMP&lt;/li&gt;
&lt;li&gt;Agentless Monitoring for Linux OS - SNMP&lt;/li&gt;
&lt;li&gt;Agentless Monitoring for Solaris OS - SNMP,CIM-XML&lt;/li&gt;
&lt;li&gt;Agentless Monitoring for Windows OS - SNMP,WMI&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;agent&#34;&gt;Agent&lt;/h2&gt;
&lt;p&gt;TEMS -&amp;gt; servers(agent)&lt;/p&gt;
&lt;p&gt;一个agent连2个TEMS,一个primary，一个backup。&lt;/p&gt;
&lt;p&gt;agent分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Operating System agent&lt;/li&gt;
&lt;li&gt;specialized agent&lt;/li&gt;
&lt;li&gt;Application agent&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OS agent：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;li&gt;Unix&lt;/li&gt;
&lt;li&gt;Linux&lt;/li&gt;
&lt;li&gt;IBM i5/OS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;specialized agent：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;warehouse proxy agent&lt;/li&gt;
&lt;li&gt;warehouse summarization and pruning agent&lt;/li&gt;
&lt;li&gt;Log file agent&lt;/li&gt;
&lt;li&gt;System p® agents (AIX Premium, CEC Base, HMC Base, VIOS Premium)&lt;/li&gt;
&lt;li&gt;Systems Director base agent&lt;/li&gt;
&lt;li&gt;Tivoli zEnterprise® Agent&lt;/li&gt;
&lt;li&gt;Performance Analyzer&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;tepsdb&#34;&gt;TEPS+DB&lt;/h1&gt;
&lt;p&gt;TEPS: Tivoli Enterprise Portal Server&lt;/p&gt;
&lt;p&gt;使用MTEMS来配置TEPS,添加DB。&lt;/p&gt;
&lt;h1 id=&#34;tepdtep-client&#34;&gt;TEPD(TEP client)&lt;/h1&gt;
&lt;p&gt;TEP -&amp;gt; TEPS&lt;/p&gt;
&lt;p&gt;TEP: Tivoli Enterprise Portal client&lt;/p&gt;
&lt;p&gt;TEP是GUI界面，分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Desktop&lt;/li&gt;
&lt;li&gt;Browser&lt;/li&gt;
&lt;li&gt;JavaWS: java web start&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要安装IBM的java，在C:\Program Files\IBM\Java70。&lt;/p&gt;
&lt;p&gt;使用TEP来查看监控结果。&lt;/p&gt;
&lt;p&gt;默认用户是sysadmin, 需要为TEPD指定TEPS服务器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Browser版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; http://&amp;lt;TEPS Server&amp;gt;:15200/cnp.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Desktop版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; http://&amp;lt;TEPS Server&amp;gt;:15200/tep.jnlp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装ITM可以选择安装桌面版,也可以从Java Web Start获取桌面版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java Web Start版本&lt;/p&gt;
&lt;p&gt;结合了desktop和browser的优点,从web下载，在桌面运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TEP的结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Navigator view&lt;/p&gt;
&lt;p&gt;Enterprise&lt;/p&gt;
&lt;p&gt;Operating Platform(操作系统类型)&lt;/p&gt;
&lt;p&gt;Node(一台服务器一个节点)&lt;/p&gt;
&lt;p&gt;Agent(一个节点上的agent)&lt;/p&gt;
&lt;p&gt;Situation(一个agent上的situation)&lt;/p&gt;
&lt;p&gt;Event(一个situation有多个event)&lt;/p&gt;
&lt;p&gt;Attribute group(相同的Situation是一个group)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigator workspace&lt;/p&gt;
&lt;p&gt;每个view项目都有一个默认的workspace。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;history-data-collectiontdw&#34;&gt;History data collection(TDW)&lt;/h1&gt;
&lt;p&gt;TDW: Tivoli Data Warehouse&lt;/p&gt;
&lt;p&gt;存储历史数据。支持DB2，Oracle， MSSQL。&lt;/p&gt;
&lt;p&gt;也就是将agent收集的数据存到数据库。&lt;/p&gt;
&lt;h2 id=&#34;warehouse-proxy&#34;&gt;Warehouse Proxy&lt;/h2&gt;
&lt;p&gt;TDW使用该agent从agents收集和加载数据。&lt;/p&gt;
&lt;p&gt;使用MTEMS配置warehouse proxy。&lt;/p&gt;
&lt;h2 id=&#34;summarization-and-pruning-agent&#34;&gt;Summarization and Pruning agent&lt;/h2&gt;
&lt;p&gt;TDW使用该agent控制数据库大小。&lt;/p&gt;
&lt;p&gt;使用MTEMS配置summarization and pruning agent。&lt;/p&gt;
&lt;h1 id=&#34;jazz-for-service-managementvisualization&#34;&gt;Jazz for Service Management(Visualization)&lt;/h1&gt;
&lt;h2 id=&#34;dashboard-application-services-hubdashvisualization-services&#34;&gt;Dashboard Application Services Hub(DASH)(visualization services)&lt;/h2&gt;
&lt;h2 id=&#34;ibm-tivoli-common-reportingreporting-services&#34;&gt;IBM Tivoli Common Reporting(reporting services)&lt;/h2&gt;
&lt;h2 id=&#34;registry-services&#34;&gt;Registry Services&lt;/h2&gt;
&lt;h2 id=&#34;security-services&#34;&gt;Security Services&lt;/h2&gt;
&lt;h2 id=&#34;administration-services&#34;&gt;Administration Services&lt;/h2&gt;
&lt;h2 id=&#34;tivoli-directory-integrator&#34;&gt;Tivoli Directory Integrator&lt;/h2&gt;
&lt;h2 id=&#34;ibm-http-server&#34;&gt;IBM HTTP Server&lt;/h2&gt;
&lt;h2 id=&#34;ibm-websphere-application-server&#34;&gt;IBM WebSphere® Application Server&lt;/h2&gt;
&lt;h2 id=&#34;web-server-plug-ins-for-ibm-websphere-application-server&#34;&gt;Web Server Plug-ins for IBM WebSphere Application Server&lt;/h2&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;management&#34;&gt;Management&lt;/h1&gt;
&lt;p&gt;管理所有组件一般使用GUI叫manage tivoli monitoring services&lt;/p&gt;
&lt;p&gt;windows/linux/unix都可以用GUI。&lt;/p&gt;
&lt;p&gt;也可以使用CLI（命令行）,见后文.&lt;/p&gt;
&lt;p&gt;一般使用GUI来启动、停止和配置组件。&lt;/p&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;Command Line Interface&lt;/p&gt;
&lt;h2 id=&#34;tacmd&#34;&gt;tacmd&lt;/h2&gt;
&lt;p&gt;支持windows/linux/unix。&lt;/p&gt;
&lt;p&gt;/opt/IBM/ITM/bin/tacmd&lt;/p&gt;
&lt;p&gt;C:\IBM\ITM\BIN\tacmd&lt;/p&gt;
&lt;p&gt;查看tacmd手册：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd help
./tacmd ?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆和登出HTEMS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd login -s [PROTOCOL://]HOST[:PORT] -u [USERNAME] -p [PASSWORD] -t [TIMEOUT]
./tacmd logout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆和登出TEPS：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd tepsLogin -s [TEPS_HOSTNAME] -u [USERNAME] -p [TEPS_PASSWORD] -t [TIMEOUT] -i [IGNORE]
./tacmd tepsLogout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理agent：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd startAgent/stopAgent/restartAgent/viewAgent/updateAgent ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷新Netcool/OMNIbus：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd refreshTECinfo {-t|--type} {eif|maps|attr|all}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;itmcmd&#34;&gt;itmcmd&lt;/h2&gt;
&lt;p&gt;用于Linux/Unix系统的命令&lt;/p&gt;
&lt;p&gt;/opt/IBM/ITM/bin/itmcmd&lt;/p&gt;
&lt;p&gt;查看itmcmd手册：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./itmcmd help
./itmcmd ?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动或停止TEMS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./itmcmd server [-options] {start|stop} tems_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动或停止agent：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./itmcmd agent [-options] {start|stop} {pc ...|all}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动MTEMS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./itmcmd manage &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tivcmd&#34;&gt;tivcmd&lt;/h2&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;advanced-administration&#34;&gt;Advanced Administration&lt;/h1&gt;
&lt;h2 id=&#34;queriesquery-editor&#34;&gt;Queries(query editor)&lt;/h2&gt;
&lt;p&gt;DB agent -&amp;gt; normal way to get data source from database servers.&lt;/p&gt;
&lt;p&gt;ODBC -&amp;gt; get data source from windows database&lt;/p&gt;
&lt;p&gt;JDBC -&amp;gt; get data source from linux/unix database&lt;/p&gt;
&lt;h2 id=&#34;advanced-link-topics&#34;&gt;Advanced link topics&lt;/h2&gt;
&lt;p&gt;Simple link:&lt;/p&gt;
&lt;p&gt;Just used to navigate portal workspaces without using the navigator.&lt;/p&gt;
&lt;p&gt;Advanced link:&lt;/p&gt;
&lt;p&gt;Can be used to manipulate data that is displayed in the target workspace.&lt;/p&gt;
&lt;h2 id=&#34;advanced-situation-techniquessituation-editor&#34;&gt;Advanced situation techniques(situation editor)&lt;/h2&gt;
&lt;h2 id=&#34;agent-autonomy&#34;&gt;Agent autonomy&lt;/h2&gt;
&lt;h2 id=&#34;policyworkflow-editor&#34;&gt;Policy(workflow editor)&lt;/h2&gt;
&lt;h2 id=&#34;agentless-monitoring&#34;&gt;Agentless monitoring&lt;/h2&gt;
&lt;p&gt;TEPS -&amp;gt; Agentless Monitoring Serve -&amp;gt; Servers&lt;/p&gt;
&lt;h2 id=&#34;agent-managent-servicesams&#34;&gt;Agent Managent Services(AMS)&lt;/h2&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;agent-builder&#34;&gt;Agent Builder&lt;/h1&gt;
&lt;p&gt;IBM Agent Builder agents&lt;/p&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Program Files(x86)\IBM\AgentBuilder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;aix/linux:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/opt/ibm/AgentBuilder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Data source:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDBC&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;SOAP&lt;/li&gt;
&lt;li&gt;Ping&lt;/li&gt;
&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;Java API&lt;/li&gt;
&lt;li&gt;WMI&lt;/li&gt;
&lt;li&gt;Perfmon&lt;/li&gt;
&lt;li&gt;CIM&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;li&gt;JMX&lt;/li&gt;
&lt;li&gt;command return code&lt;/li&gt;
&lt;li&gt;output from a script&lt;/li&gt;
&lt;li&gt;A log file&lt;/li&gt;
&lt;li&gt;AIX Binary Log&lt;/li&gt;
&lt;li&gt;windows event log&lt;/li&gt;
&lt;li&gt;A process&lt;/li&gt;
&lt;li&gt;A Windows service&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;create-agent&#34;&gt;create agent&lt;/h1&gt;
&lt;p&gt;Every agent have a unique produce code.&lt;/p&gt;
&lt;p&gt;Like: k00-k99, k{0-9}{A-Z}.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Create the agent in the Agent Builder
agent information
data source
runtime configuration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install and test the agent
output and install the agent
config and start agent in MTEMS.
confirm agent data
revise and retest as needed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add application support
create in TEP, including queries, workspaces, situations, and take actions.
Import application support into agent in Agent Builder.
Retest the agent and application support&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create an installation solution.
Create solution install package from the agent.
Create solution install package from the package.
Run the image on the target location.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;install-agent&#34;&gt;install agent&lt;/h1&gt;
&lt;p&gt;Three ways to instal the agent.&lt;/p&gt;
&lt;p&gt;You must install the TEMS and TEPS support on TEMS(HTEMS) and TEPS server.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;generate the agent files in an ITM installation on this machine&lt;/p&gt;
&lt;p&gt;通过GUI快速安装，Agent Builder和ITM（TEMS和TEPS）安装在同一台机器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generate a solution install package&lt;/p&gt;
&lt;p&gt;创建安装镜像来安装，windows的.exe和linux/unix的.bin。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create a compressed file so that the agent can be installed on another system&lt;/p&gt;
&lt;p&gt;命令行安装。
生成一个.zip和一个.tgz文件。
包括windows的.bat和linux/unix的.sh安装文件&lt;/p&gt;
&lt;p&gt;安装下面三个包(等效方法一）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; InstallIra.bat/.sh itm_install_location [[-h Hub_TEMS_hostname] -u HUB_TEMS_username -p Hub_TEMS_password]
 InstallIra.bat C:\IBM\ITM -h &amp;lt;HTEMS&amp;gt; -u &amp;lt;username&amp;gt; -p &amp;lt;password&amp;gt; # for windows
 ./InstallIra.sh /opt/IBM/ITM -h &amp;lt;HTEMS&amp;gt; -u &amp;lt;username&amp;gt; -p &amp;lt;password&amp;gt; # for linux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在被监控机器安装agent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; installIraAgent.bat/.sh itm_install_location
 installIraAgent.bat C:\IBM\ITM # for windows
 ./installIraAgent.sh /opt/IBM/ITM # for linux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在TEMS(HTEMS)服务器安装对agent的支持：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; installIraAgentTEMS.bat/.sh itm_install_location [[-h Hub_TEMS_hostname] -u HUB_TEMS_username -p Hub_TEMS_password]
 installIraAgentTEMS.bat C:\IBM\ITM # for local HTEMS windows server.
 ./installIraAgentTEMS.sh /opt/IBM/ITM # for local HTEMS linux server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在TEPS服务器安装对agent的支持：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; installIraAgentTEPS.bat/.sh itm_install_location [[-h TEPS_hostname] -u TEPS_username -p TEPS_password]
 installIraAgentTEPS.bat C:\IBM\ITM # for local TEPS windows server.
 ./installIraAgentTEPS.sh /opt/IBM/ITM # for local TEPS linux server.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;config-agent&#34;&gt;config agent&lt;/h1&gt;
&lt;p&gt;需要为agent指定HTEMS服务器，并重启agent，然后重启TEPD。&lt;/p&gt;
&lt;p&gt;可以通过Tivoli Enterprise Monitoring Service来配置和启动，也可以通过命令行。&lt;/p&gt;
&lt;p&gt;查看所有agent信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/opt/IBM/ITM/bin/cinfo -i # check the productcode and platformCode.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;config agent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./itmcmd config -A productcode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;start agent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./tacmd agent start productcode
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;uninstall-agent&#34;&gt;uninstall agent&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;uninstall from commandline.&lt;/p&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; cd ITM_INSTALL/TMAITM6
 cd C:\IBM\ITM\TMAITM6_x64
 kxx_uninstall.vbs ITM_INSTALL
 K&amp;lt;product code&amp;gt;_uninstall.vbs C:\IBM\ITM
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux/unix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /opt/IBM/ITM/bin/uninstall.sh [-f] [-i] [-h install_dir] productcode platformCode
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remove from TEP client(clear offline entry)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;monitoring-windows-resources&#34;&gt;Monitoring windows resources&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows Management Instrumentation(WMI)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Performance Monitor(Perfmon)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows Event Log&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;monitoring-process-and-command-return-codes&#34;&gt;Monitoring process and command return codes&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Monitoring process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitoring command return code&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;monitoring-custom-data-sources&#34;&gt;Monitoring custom data sources&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Monitoring script output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitoring log file&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;monitoring-remote-resources&#34;&gt;Monitoring remote resources&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Monitoring SNMP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitoring CIM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Moitoring JMX&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netcoolomnibus&#34;&gt;Netcool/OMNIbus&lt;/h1&gt;
&lt;p&gt;IBM Tivoli Netcool/OMNIbus&lt;/p&gt;
&lt;p&gt;TEC: Tivoli Enterprise Console, 已经被Netcool/OMNIbus替代。&lt;/p&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Program Files(x86)\IBM\NCOhome
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux/aix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/opt/IBM/NCOhome
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Browser版本需要安装IBM的JRE，在C:\Program Files\IBM\Java70。&lt;/p&gt;
&lt;h1 id=&#34;eif&#34;&gt;EIF&lt;/h1&gt;
&lt;p&gt;EIF: Event Integration Facility&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Find</title>
        <link>https://canuxcheng.com/post/shell_find/</link>
        <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_find/</guid>
        <description>&lt;h1 id=&#34;find&#34;&gt;find&lt;/h1&gt;
&lt;p&gt;Find     查找，用于在目录中查找。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find  path  options  tests  actions
path 路径
options 选项
tests 测试
actions 动作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;optioins选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-follow
-depth
-maxdepth
-mindepth

find dir -mindepth  n     指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。
find dir -maxdepth  n      指定最大目录深度，不搜索n级之后的目录。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test选项很多：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-newer   pattern   比pattern文件要新
-user    pattern      文件属主是pattern
-name   pattern    查找和type匹配的
-iname  pattern    查找和type匹配的，会忽略大小写
-iwholename
-path   pattern     按照文件路径匹配

-type   c           c是文件类型，按照文件类型匹配文件
c可以是：f  常规文件 d  目录  p  命名管道  l  符号链接  b  块设备 c  字符设备 s  套接字

-size   +/-    nk/c/w/k/b/M/G    匹配大于或小于n  kb/..  的文件
find dir -size +10M  # 查找大于10M的文件

-perm   XXX       基于文件权限的匹配
find dir -perm 644  # 查找权限是644的文件

find dir  –atime/mtime/ctime    +/-n    根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。

-a/-and   pattern
-o/-or     pattern
！/-not    pattern
find  dir  !  test   pattern   列出所有没有按照-options  pattern模式的项
\(...\)    使用括号需要用引号来引用。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;action选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-prune     如果是一个指定的目录就忽略这个目录,要用-path指定目录.
-print          打印，换行符结尾,所有结果一行一个。
-print0        打印，空字符结尾，所有结果打印到一行。
-delete       删除
-exec   command     # 执行一个命令
exec   command   {}   \;

operators: find可以用一些运算符来连接多个test条件。
！expr   #取反
expr1    -a    expr2    #与运算，可以省略-a
expr1    -o    expr2    #或运算

查找当前目录下除了develop里面的文件以外的30天之内修改过的.txt文件
find .   -path ./develop -prune  -o  -mtime -30  -type f  -name  &amp;quot;*.txt&amp;quot;   -print
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将前面的命令的结果通过管道和xargs作为后面命令的输入，类似于find命令的-exec选项。&lt;/p&gt;
&lt;p&gt;格式 ：command1   |   xargs   -options   command2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xargs   -n    number    设置每行显示的参数数量为number。
xargs  -d     char   指定char为界定符，也就是将char换成空格。
xargs  -I   {}    将命令参数用STDIN的参数替换掉。
xargs   -0       以/0为定界符，而不是空格。

find . -name “*.c” | xargs wc -l
find . -name “*.c” -exec wc -l {}   \;
wc -l  `find . -name “*.c”`
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Grep</title>
        <link>https://canuxcheng.com/post/shell_grep/</link>
        <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_grep/</guid>
        <description>&lt;h1 id=&#34;grep&#34;&gt;grep&lt;/h1&gt;
&lt;p&gt;grep相关的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep
egrep == grep -E
fgrep == grep -F
rgrep == grep -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;grep:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep [OPTIONS] PATTERN [FILE/DIR...]
grep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;options:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Matcher Selection
-G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE
-E, --extended-regexp 选择ERE, 可以使用扩展的RE
# grep -E &amp;quot;pattern1|pattern2&amp;quot; 比如支持或运算
-F, --fixed-strings
-P, --perl-regexp perl RE

# Matching Control
-e PATTERN, --regexp=PATTERN    可以指定多个pattern
# grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来
-f FILE, --file=FILE    文件的每一行就是一个pattern.
-i, --ignore-case    忽略大小写
-v, --invert-match   忽略含有pattern的行
-w, --word-regexp    精确匹配一个单词
-x, --line-regexp    精确匹配一行
-y

# General Output Control
-c, --count    统计匹配到的行数
--color[=WHEN], --colour[=WHEN]    输出匹配的pattern高亮
-L, --files-without-match    列出没有匹配到的文件名
-l, --files-with-matches    列出匹配到的文件的文件名
# grep -rl pattern1 | xargs grep -r pattern2    相当于与运算，过滤同时满足两个pattern
-m NUM, --max-count=NUM
-o, --only-matching    只输出匹配的部分
# grep -o pattern filename | wc -l 统计匹配的行数
-q, --quiet, --silent    不打印查找的结果
-s, --no-messages

# Output Line Prefix Control
-b, --byte-offset    打印匹配的字符数或偏移量
-H, --with-filename
-h, --no-filename
--label=LABEL
-n, --line-number    打印匹配的行的行号
-T, --initial-tab
-u, --unix-byte-offsets
-Z, --null

# Context Line Control
-A NUM, --after-context=NUM    打印匹配到的行的后NUM行
-B NUM, --before-context=NUM    打印匹配到的行的前NUM行j
-C NUM, -NUM, --context=NUM    打印匹配到的行的前NUM行和后NUM行

# File and Directory Selection
-a, --text
--binary-files=TYPE
-D ACTION, --devices=ACTION
-d ACTION, --directories=ACTION
--exclude=GLOB    排除查找指定的文件
--exclude-from=FILE
--exclude-dir=DIR   排除查找指定的目录
-I
--include=GLOB     指定查找的文件
-r, --recursive    递归查找
-R, --dereference-recursive    递归查找
# grep -nR/-nr pattern filename    阅读源码可以递归查找并打印行号

# Other Options
--line-buffered
--mmap
-U, --binary
-z, --null-data
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ack&#34;&gt;ack&lt;/h1&gt;
&lt;p&gt;ack/ack2是grep的升级版&lt;/p&gt;
&lt;p&gt;ack:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/beyondgrep/ack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/beyondgrep/ack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ack2(ack-grep):&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/beyondgrep/ack2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/beyondgrep/ack2&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;ag&#34;&gt;ag&lt;/h1&gt;
&lt;p&gt;ack/ack2的升级版&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ggreer/the_silver_searcher&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ggreer/the_silver_searcher&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install silversearcher-ag
$sudo yum install the_silver_searcher
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$man ag
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Development</title>
        <link>https://canuxcheng.com/post/devops_dev/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_dev/</guid>
        <description>&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;
&lt;p&gt;开发相关的工具&lt;/p&gt;
&lt;p&gt;传统的软件开发采用的是瀑布式开发流程．&lt;/p&gt;
&lt;p&gt;现代的软件开发采用的是敏捷开发流程(Agile development).&lt;/p&gt;
&lt;p&gt;Alpha: inner test version.&lt;/p&gt;
&lt;p&gt;Beta: outer test version.&lt;/p&gt;
&lt;p&gt;RC: release candidate. 最终版本之前的最后一个版本．也叫gamma.&lt;/p&gt;
&lt;p&gt;RTM: release to manufacture, 最终版&lt;/p&gt;
&lt;p&gt;GA: generally avaliable. stable/production.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;怎样选择licenses&#34;&gt;怎样选择Licenses&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://choosealicense.com/licenses/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://choosealicense.com/licenses/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://choosealicense.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://choosealicense.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/license.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;semver&#34;&gt;semver&lt;/h1&gt;
&lt;p&gt;语义化版本．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://semver.org/lang/zh-CN/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://semver.org/lang/zh-CN/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mojombo/semver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mojombo/semver&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主版本号.次版本号.修订号
Major.Minor.Patch

Major: 做了不兼容的API修改
Minor: 做了向下兼容的功能性新增
Patch: 做了向下兼容的问题修正
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;文档阅读工具&#34;&gt;文档阅读工具&lt;/h1&gt;
&lt;h2 id=&#34;zeal&#34;&gt;zeal&lt;/h2&gt;
&lt;h2 id=&#34;dash&#34;&gt;dash&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cookiecutter&#34;&gt;cookiecutter&lt;/h1&gt;
&lt;p&gt;一个快速建立工程模板的命令行工具．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/audreyr/cookiecutter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/audreyr/cookiecutter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/audreyr/cookiecutter-pypackage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/audreyr/cookiecutter-pypackage&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo -E pip install cookiecutter
# 创建python项目
$cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git
# 创建django格式的python项目
$cookiecutter https://github.com/pydanny/cookiecutter-django
# 创建openstack格式的python项目
$cookiecutter https://git.openstack.org/openstack-dev/cookiecutter.git
$cookiecutter https://github.com/openstack-dev/cookiecutter.git
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bumpversion&#34;&gt;bumpversion&lt;/h1&gt;
&lt;p&gt;版本管理工具&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/peritus/bumpversion&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/peritus/bumpversion&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo -E pip install bumpversion
# put config in setup.cfg
[bumpversion]
current_version = 1.2.0
files = pymonitoringplugins/__init__.py
$bumpversion major/minor/patch --commit # commit新版本
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>DevOps</title>
        <link>https://canuxcheng.com/post/devops/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops/</guid>
        <description>&lt;h1 id=&#34;devops&#34;&gt;DevOps&lt;/h1&gt;
&lt;p&gt;DevOps包括ChatOps, 敏捷开发，持续集成,持续交付,持续发布/部署，QA(自动化测试），智能监控和日志管理等内容．&lt;/p&gt;
&lt;p&gt;DevOps涉及到三个部门：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Development&lt;/li&gt;
&lt;li&gt;Operations&lt;/li&gt;
&lt;li&gt;Quality Assurance&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ci&#34;&gt;CI&lt;/h1&gt;
&lt;p&gt;Continuous Integration.&lt;/p&gt;
&lt;p&gt;持续集成包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译代码.&lt;/li&gt;
&lt;li&gt;静态代码分析.&lt;/li&gt;
&lt;li&gt;自动化测试，例如selenium.&lt;/li&gt;
&lt;li&gt;代码覆盖率分析.&lt;/li&gt;
&lt;li&gt;构建，例如docker.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cd&#34;&gt;CD&lt;/h1&gt;
&lt;p&gt;Continuous Delivery.&lt;/p&gt;
&lt;p&gt;持续交付包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将通过测试的代码部署到Staging.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;continuous-releasedeploy&#34;&gt;Continuous Release/Deploy&lt;/h1&gt;
&lt;p&gt;持续部署/发布包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将通过评审的交付代码部署到Production.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cicd的工具&#34;&gt;CI/CD的工具&lt;/h1&gt;
&lt;p&gt;持续集成和部署&lt;/p&gt;
&lt;h2 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h2&gt;
&lt;h2 id=&#34;travis-ci&#34;&gt;travis CI&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://travis-ci.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://travis-ci.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;travis CI是基于github的CI工具, 部署代码然后运行测试代码.&lt;/p&gt;
&lt;p&gt;在github项目添加.travis.yml文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;language: python
python:
  - &amp;quot;2.7&amp;quot;
install:
  - pip install -r requirements.txt
  - pip install coveralls
script:
  - coverage run --source=pymonitoringplugins setup.py test
after_success:
  - coveralls
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;circleci&#34;&gt;circleci&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://circleci.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://circleci.com/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;coverage的工具&#34;&gt;coverage的工具&lt;/h1&gt;
&lt;p&gt;统计单元测试的覆盖率&lt;/p&gt;
&lt;h2 id=&#34;coveralls&#34;&gt;coveralls&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://coveralls.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://coveralls.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;codecov&#34;&gt;codecov&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://codecov.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://codecov.io/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;stackstorm&#34;&gt;stackstorm&lt;/h1&gt;
&lt;p&gt;StackStorm is a platform for integration and automation across services and tools, taking actions in response to events.&lt;/p&gt;
&lt;p&gt;For DevOps and ChatOps.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/StackStorm/st2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/StackStorm/st2&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;drone&#34;&gt;Drone&lt;/h1&gt;
&lt;p&gt;Drone is a Continuous Delivery platform built on Docker, written in Go&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/drone/drone&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/drone/drone&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;supervisor&#34;&gt;supervisor&lt;/h1&gt;
&lt;p&gt;Supervisor process control system for UNIX/Linux.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Supervisor/supervisor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Supervisor/supervisor&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install supervisor
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;redmine&#34;&gt;redmine&lt;/h1&gt;
&lt;p&gt;ruby开发的项目管理工具,集成bug和wiki工具．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;dokuwiki&#34;&gt;dokuwiki&lt;/h1&gt;
&lt;p&gt;php开发的wiki管理工具&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;atlassian&#34;&gt;Atlassian&lt;/h1&gt;
&lt;p&gt;Jira for Porject Management.&lt;/p&gt;
&lt;p&gt;Bitbucket for Source code management.&lt;/p&gt;
&lt;p&gt;Bamboo for CI/CD.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bugzilla&#34;&gt;bugzilla&lt;/h1&gt;
&lt;p&gt;perl开发的bug追踪系统．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;errbot&#34;&gt;errbot&lt;/h1&gt;
&lt;p&gt;python开发的ChatOps工具．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/errbotio/errbot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/errbotio/errbot&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;zulip&#34;&gt;zulip&lt;/h1&gt;
&lt;p&gt;团队聊天工具介绍&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zulip/zulip&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/zulip/zulip&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Gitlab</title>
        <link>https://canuxcheng.com/post/devops_gitlab/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_gitlab/</guid>
        <description>&lt;h1 id=&#34;gitlab&#34;&gt;Gitlab&lt;/h1&gt;
&lt;p&gt;gitlab是开源的有web界面的git服务器．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://about.gitlab.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://about.gitlab.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装gitlab:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install -y curl openssh-server ca-certificates
sudo apt-get install -y postfix
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash
sudo EXTERNAL_URL=&amp;quot;http://gitlab.example.com&amp;quot; apt-get install gitlab-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/gitlab/gitlab.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;升级gitlab:&lt;/p&gt;
&lt;p&gt;需要先升级到下个major版本的最后一个稳定版.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;current:   9.4.7
patch: gitlab-ce=9.5.10
patch: gitlab-ce_10.8.7
patch: gitlab-ce=11.11.8
patch: gitlab-ce=12.0.12
target: 12.10.14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;runner:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64
sudo chmod +x /usr/local/bin/gitlab-runner
sudo gitlab-runner install --user=canux --working-directory=/home/canux/gitlab
sudo gitlab-runner register
sudo gitlab-runner start
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;备份：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 修改备份路径：gitlab_rails[&#39;backup_path&#39;] = &amp;quot;/var/opt/gitlab/backups&amp;quot;
# gitlab-rake gitlab:backup:create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新加载配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# gitlab-ctl restart/start/stop
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Jenkins</title>
        <link>https://canuxcheng.com/post/devops_jenkins/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_jenkins/</guid>
        <description>&lt;h1 id=&#34;jenkins&#34;&gt;Jenkins&lt;/h1&gt;
&lt;p&gt;Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks such as building, testing, and deploying software.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/jenkins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/jenkins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装好Jenkins后安装需要的插件．&lt;/p&gt;
&lt;p&gt;安装jenkins:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# download jenkins.war and install java8.
$ java -jar jenkins.war --httpPort=8080
$ firefox http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置开机自动启动，不用每次从终端启动:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/systemd/system/jenkins.service
$ systemctl daemon-reload
$ systemctl enable jenkins.service
$ systemctl start jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jinkens主目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 默认主目录在/home/canux/.jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nodes&#34;&gt;nodes&lt;/h1&gt;
&lt;p&gt;添加节点需要安装和master版本一样的java.&lt;/p&gt;
&lt;p&gt;on jenkins agent:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;install java.&lt;/li&gt;
&lt;li&gt;create folder and grant permission. (/home/jenkins)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;on jenkins:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create credential and node.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;plugins&#34;&gt;plugins&lt;/h1&gt;
&lt;h2 id=&#34;thinbackup&#34;&gt;thinbackup&lt;/h2&gt;
&lt;p&gt;备份插件，主要备份jenkins主目录.&lt;/p&gt;
&lt;h2 id=&#34;pipeline&#34;&gt;pipeline&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/pipeline-plugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/pipeline-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用pipeline需要先安装pipeline插件.&lt;/p&gt;
&lt;p&gt;pipeline是groovy语法的jenkins的DSL.&lt;/p&gt;
&lt;h2 id=&#34;blueocean&#34;&gt;blueocean&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/blueocean-plugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/blueocean-plugin&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;git-plugin&#34;&gt;git plugin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/git-plugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/git-plugin&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;docker-plugin&#34;&gt;docker plugin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/docker-workflow-plugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/docker-workflow-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;k8s&#34;&gt;k8s&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jenkinsci/kubernetes-plugin&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;docker&#34;&gt;docker&lt;/h1&gt;
&lt;p&gt;在docker上执行流水线&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;agent {
    docker {
        image &#39;maven:3-alpine&#39;
        label &#39;my-defined-label&#39;
        args  &#39;-v /tmp:/tmp&#39;
    }
}

agent {
    // Equivalent to &amp;quot;docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/
    dockerfile {
        filename &#39;Dockerfile.build&#39;
        dir &#39;build&#39;
        label &#39;my-defined-label&#39;
        additionalBuildArgs  &#39;--build-arg version=1.0.2&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Operations</title>
        <link>https://canuxcheng.com/post/devops_ops/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_ops/</guid>
        <description>&lt;h1 id=&#34;operations&#34;&gt;Operations&lt;/h1&gt;
&lt;p&gt;运维相关的工具．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;批量配置管理&#34;&gt;批量配置管理&lt;/h1&gt;
&lt;h2 id=&#34;puppet&#34;&gt;puppet&lt;/h2&gt;
&lt;h2 id=&#34;chef&#34;&gt;chef&lt;/h2&gt;
&lt;h2 id=&#34;salt&#34;&gt;salt&lt;/h2&gt;
&lt;h2 id=&#34;ansible&#34;&gt;ansible&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;密码管理工具&#34;&gt;密码管理工具&lt;/h1&gt;
&lt;h2 id=&#34;keepass&#34;&gt;keepass&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://keepass.info/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://keepass.info/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;keepassx&#34;&gt;KeePassX&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.keepassx.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.keepassx.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/keepassx/keepassx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/keepassx/keepassx&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Admin</title>
        <link>https://canuxcheng.com/post/linux_admin/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_admin/</guid>
        <description>&lt;h1 id=&#34;linux-admin&#34;&gt;Linux Admin&lt;/h1&gt;
&lt;p&gt;dpkg: ubuntu, debian.&lt;/p&gt;
&lt;p&gt;rpm: fedora, centos, redhat.&lt;/p&gt;
&lt;p&gt;zypper: suse.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;linux系统常用的安装和配置&#34;&gt;Linux系统常用的安装和配置&lt;/h1&gt;
&lt;h2 id=&#34;terminalizer&#34;&gt;terminalizer&lt;/h2&gt;
&lt;p&gt;终端录制工具&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/faressoft/terminalizer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/faressoft/terminalizer&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;virtualbox&#34;&gt;virtualbox&lt;/h2&gt;
&lt;p&gt;开机自动挂载共享文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 手动挂在命令, 需要安装增强功能
$ mount -t vboxsf FolderNameOnWindows /path/on/linux

# 实现开机自动挂载
$ sudo vim /etc/rc.local
mount.vboxsf -w ShareFolderNameOnWindows MountPointOnLinux
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;xrdp&#34;&gt;xrdp&lt;/h2&gt;
&lt;p&gt;从windows的RDP远程连接linux.&lt;/p&gt;
&lt;p&gt;use RDP on windows to connect to ubuntu16.04.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo dpkg -i tigervncserver_1.6...deb # download and install tigervncserver first.
sudo apt-get install -f
sudo apt-get instal xrdp -y
echo unity &amp;gt; ~/.xsession
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;use RDP on windows to connect to ubuntu14.04.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install xrdp
sudo apt-get install xfce4
echo xfce4-session &amp;gt; ~/.xsession
sudo vim /etc/xrdp/startwm.sh
# add &#39;startxfce4&#39; to last line.
sudo service xrdp restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;清理内存的buffcache&#34;&gt;清理内存的buff/cache&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;echo 3 &amp;gt; /proc/sys/vm/drop_caches
# reboot才能改回默认的0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;终端现实超大艺术字&#34;&gt;终端现实超大艺术字&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install figlet
$ figlet &amp;lt;text&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ubuntudebian安装后的基本配置&#34;&gt;Ubuntu/Debian安装后的基本配置&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential make libssl-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;apt-mirror&#34;&gt;apt mirror&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/apt/sources.list
# deb http://ip:port/path   ubuntu16/
# deb [trusted=yes] https://&amp;lt;user&amp;gt;:&amp;lt;pw&amp;gt;@ip:port/path   ubuntu16/
deb [trusted=yes] https://user:pw@mirror.com/mirror ubuntu16/

vim /etc/apt/apt.conf
Acquire::https::mirror.com::Verify-Peer &amp;quot;false&amp;quot;;
Acqhire::https::mirror.com::Verify-Host &amp;quot;false&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;中文输入法&#34;&gt;中文输入法&lt;/h2&gt;
&lt;p&gt;安装一个中文输入法框架fcitx(IBus, SCIM, UIM)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install fcitx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装一种输入法引擎：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install fcitx-googlepinyin
sudo apt-get install fcitx-sunpinyin
sudo apt-get install fcitx-libpinyin
sudo apt-get install fcitx-sougoupinyin
sudo apt-get install fcitx-cloudpinyin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kcm-fcitx - for qt - &amp;lt;https://github.com/fcitx/kcm-fcitx&amp;gt;
fcitx-configtool - for gtk - &amp;lt;https://github.com/fcitx/fcitx-configtool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在键盘输入方式系统从ibus改为fcitx，然后重启。&lt;/p&gt;
&lt;h2 id=&#34;dconf修改配置&#34;&gt;dconf修改配置&lt;/h2&gt;
&lt;p&gt;也可以通过系统自带的dconf命令修改．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dconf-editor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gedit打开txt文件乱码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# org-&amp;gt;gnome-&amp;gt;gedit-&amp;gt;preferences-&amp;gt;encodings-&amp;gt;auto-detected 添加&#39;GB2312&#39;,&#39;GBK&#39;,...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开启远程桌面无密码登陆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dconf write /org/gnome/desktop/remote-access/require-encryption false
or
# org-&amp;gt;gnome-&amp;gt;desktop-&amp;gt;remote-access-&amp;gt;require-encryption false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;挂载u盘失败&#34;&gt;挂载U盘失败&lt;/h2&gt;
&lt;p&gt;移动硬盘或者u盘不能挂载，删掉/etc/fstab的关于sdb的行，保存后重新插拔。&lt;/p&gt;
&lt;h2 id=&#34;创建桌面图标比如eclipse&#34;&gt;创建桌面图标（比如eclipse）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/share/applications
sudo vi XXX.desktop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加必要属性后拖到桌面或启动栏即可。&lt;/p&gt;
&lt;h2 id=&#34;安装qq&#34;&gt;安装QQ&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install libgtk2.0-0:i386
sudo apt-get install lib32ncurses5
sudo apt-get install -f
sudo dpkg -i fonts-wqy-microhei_0.2.0-beta-2_all.deb
sudo dpkg -i ttf-wqy-microhei_0.2.0-beta-2_all.deb
sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装文档的包&#34;&gt;安装文档的包&lt;/h2&gt;
&lt;p&gt;手册位于/usr/share/man&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install glibc-doc manpages-dev manpages-posix-dev manpages-zh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;记录终端操作&#34;&gt;记录终端操作&lt;/h2&gt;
&lt;p&gt;安装相关工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install ttyrec
$sudo apt-get install imagemagick
$hg clone https://bitbucket.org/antocuni/tty2gif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开始记录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ttyrec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在终端播放记录文件ttyrecord:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ttyplay ttyrecord
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将ttyrecord文件转化成gif文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$tty2gif.py typing ttyrecord
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将多个gif文件合并成一个文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$convert -limit memory 2mb -limit map 2mb -delay 2 -loop 0 *.gif example.gif
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;添加用户为管理员&#34;&gt;添加用户为管理员&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/sudoers
user     ALL = (ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ubuntu网络设置&#34;&gt;Ubuntu网络设置&lt;/h2&gt;
&lt;p&gt;查看dns：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ systemd-resolve --status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ubuntu修改hostname:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/hostname
new-hostname
$ sudo vim /etc/hosts
ip-address hostname
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统代理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/profile.d/sys_proxy.sh
http_proxy=&amp;quot;http://proxy-server:port&amp;quot;
https_proxy=&amp;quot;http://proxy-server:port&amp;quot;
ftp_proxy=&amp;quot;http://proxy-server:port&amp;quot;
no_proxy=localhost,127.0.0.1,...
export http_proxy ftp_proxy https_proxy no_proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置静态IP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ifconfig
# 查看网卡，ubuntu14.04 eth0, ubuntu16.04 ens160
$ vim /etc/network/interfaces
auto eth0
iface eth0 inet static
    address 192.168.0.1
    netmask 255.255.255.0
    gateway 192.168.0.0
    dns-nameservers 8.8.8.8
$ sudo service networking restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ubuntu18:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;netplan:
$ sudo vim /etc/netplan/*.yaml

network:
  version: 2
  renderer: networkd
  ethernets:
    ens160:
      dhcp4: no
      addresses: [192.168.1.0/23]
      gateway4: 193.168.0.1
      nameservers:
        addresses: [8.8.8.8]

$ sudo netplan apply
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ubuntu-vlan&#34;&gt;ubuntu vlan&lt;/h2&gt;
&lt;p&gt;vlan需要内核模块8021q&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;8021q&amp;quot; &amp;gt;&amp;gt; /etc/modules

auto vlan1023
iface vlan1023 inet static
    address 18.28.4.123
    netmask 255.255.255.0
    gateway 18.28.4.1
    vlan-raw-device eth0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建vlan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建vlan(eth0.10), attach到interface(eth0)
auto eth0.10
iface eth0.10 inet manual
    vlan-raw-device eth0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ubuntu-bridge&#34;&gt;ubuntu bridge&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 需要绑定到interface才需要配置interface.
auto eth0
iface eth0 inet manual

auto br0
iface br0 inet dhcp
# For static configuration delete or comment out the above line and uncomment the following:
# iface br0 inet static
#  address 192.168.1.10
#  netmask 255.255.255.0
#  gateway 192.168.1.1
#  dns-nameservers 192.168.1.5
#  dns-search example.com
bridge_ports eth0
# 不绑定到interface就是none
# bridge_ports none 
bridge_stp off
bridge_fd 0
bridge_maxwait 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建bridge&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建bridge，attach到vlan.
auto br0
iface br0 inet static
    address 172.16.0.4
    netmask 255.255.240.0
    bridge_ports eth0.10
    bridge_stp off
    bridge_fd 0
    bridge_vlan_aware yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;e-sub-process-usrbindpkg-returned-an-error-code-1&#34;&gt;E: Sub-process /usr/bin/dpkg returned an error code (1)&lt;/h2&gt;
&lt;p&gt;method1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /var/lib/dpkg/info/package
$ sudo mv /var/lib/dpkg/info/package.* /var/lib/dpkg/info/package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge package
$ sudo apt-get install package
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ubuntu安装配置python37&#34;&gt;ubuntu安装配置python3.7&lt;/h2&gt;
&lt;p&gt;ubuntu16.04自带python3.5, ubuntu18.04自带python3.6.&lt;/p&gt;
&lt;p&gt;测试: ubuntu16.04/18.04安装python3.7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:deadsnakes/ppa
$ sudo apt-get update
$ sudo apt-get install python3.7 python3.7-gdbm python3.7-dev

$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.7 1
$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7  1
$ sudo update-alternatives --config python
$ sudo update-alternatives --config python3

$ sudo apt-get purge python-pip python3-pip
$ sudo rm -rf /usr/bin/pip* /usr/local/bin/pip* /usr/lib/python3*/dist-packages/pip /usr/local/lib/python3.*/dist-packages/pip

$ sudo apt-get install python3-pip
$ sudo pip3 install -U pip

// ubuntu16.04通过apt-get安装的c-binding包默认还是到python3.5.
// ubuntu18.04 是到python3.6.
#!/usr/bin/env bash
for PKG in `find /usr/lib/python3/dist-packages -name &amp;quot;*.so&amp;quot;`
do
    DIR=`dirname ${PKG}`
    OLD=`basename ${PKG}`
    NEW=`echo ${OLD} | sed &#39;s/35m/37m/g&#39;`
    cp -f ${PKG} ${DIR}/${NEW}
done
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;centosfedoraredhat安装后的基本配置&#34;&gt;Centos/Fedora/Redhat安装后的基本配置&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum -y install epel-release kernel-devel gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;centos网络配置&#34;&gt;Centos网络配置&lt;/h2&gt;
&lt;p&gt;安装mini版本之后配置网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vi /etc/sysconfig/network-scripts/ifcfg-enxxx
ONBOOT=no -&amp;gt; yes
# service network restart
$ sudo yum install net-tools
$ ifconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置静态IP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/sysconfig/network-scripts/ifcfg-enxxx
ONBOOT=yes
BOOTPROTO=static # dhcp(自动获取), static(固定IP), node(手动设置)
PREFIX=&amp;quot;21&amp;quot;
IPADDR=&amp;quot;192.168.0.1&amp;quot;
NETMASK=&amp;quot;255.255.255.0&amp;quot;
GATEWAY=&amp;quot;192.168.0.0&amp;quot;
DNS1=&amp;quot;192.168.0.0&amp;quot;
$ sudo nmcli c reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置可以同时访问外网和本地连接的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 网卡１用于外网连接
# settings -&amp;gt; network -&amp;gt; network card1 -&amp;gt; NAT
$ cat /etc/sysconfig/network-scripts/ifcfg-en01
BOOTPROTO=dhcp # 自动获取ip
ONBOOT=yes
UUID # 通过$ nmcli con show 命令查看
HWADDR # 通过 $ ip addr 命令查看, 这个可以不设置

# 网卡２用于本地局域网
setting -&amp;gt; network-&amp;gt; network card2 -&amp;gt; host-only
# cp /etc/sysconfig/network-scripts/ifcfg-en01 /etc/sysconfig/network-scripts/ifcfg-en02
$ vim /etc/sysconfig/network-scripts/ifcfg-en02
NAME
DEVICE
BOOTPROTO=static
ONBOOT=yes
UUID
HWADDR
IPADDR=192.168.56.102

$ sudo service network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改hostname,局域网可以根据hostname相互访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=new-hostname

$ sudo vim /etc/hostname
new-hostname
$ sudo vim /etc/hosts
ip-address hostname

$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;centos安装增强功能&#34;&gt;centos安装增强功能&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /media/cdrom
$ sudo mount /dev/cdrom /media/cdrom
$ cd /media/cdrom
$ sudo ./VBoxLinuxAdditions.run --nox11
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Agile</title>
        <link>https://canuxcheng.com/post/devops_agile/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_agile/</guid>
        <description>&lt;h1 id=&#34;agile-methodologies&#34;&gt;Agile methodologies&lt;/h1&gt;
&lt;p&gt;Agile的具体方法有Scrum, XP和kanban.&lt;/p&gt;
&lt;p&gt;ThoughtWorks公司的Martin Fowler提出的敏捷方法．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;scrum&#34;&gt;Scrum&lt;/h1&gt;
&lt;p&gt;Scrum方法由Ken Schwaber和Jeff Sutherland 提出.&lt;/p&gt;
&lt;p&gt;scrum是一个用于开发和维护复杂产品的框架，是一个增量的，迭代的开发过程．&lt;/p&gt;
&lt;p&gt;sprint: 一个短的迭代周期．一般２到４周．&lt;/p&gt;
&lt;p&gt;backlog: 按商业价值排序的需求列表．&lt;/p&gt;
&lt;h2 id=&#34;scrum框架的三个角色&#34;&gt;scrum框架的三个角色&lt;/h2&gt;
&lt;p&gt;product owner: 产品负责人&lt;/p&gt;
&lt;p&gt;scrum master: 敏捷教练和领导者&lt;/p&gt;
&lt;p&gt;scrum team：developer&lt;/p&gt;
&lt;h2 id=&#34;scrum框架的三个工件&#34;&gt;scrum框架的三个工件&lt;/h2&gt;
&lt;p&gt;Product backlog: 整个产品待开发需求列表&lt;/p&gt;
&lt;p&gt;sprint backlog: 一次迭代的待开发需求列表&lt;/p&gt;
&lt;p&gt;increment: 产品增量&lt;/p&gt;
&lt;h2 id=&#34;scrum框架的五个事件&#34;&gt;scrum框架的五个事件&lt;/h2&gt;
&lt;p&gt;sprint planning meeting: sprint计划会议&lt;/p&gt;
&lt;p&gt;Daily Scrum Meeting/DSM: 每日站立会议&lt;/p&gt;
&lt;p&gt;sprint review meeting: sprint评审会议&lt;/p&gt;
&lt;p&gt;sprint retrospective meeting: sprint回顾会议&lt;/p&gt;
&lt;p&gt;product backlog refinement: 产品backlog梳理会议&lt;/p&gt;
&lt;h2 id=&#34;scrum框架的五个价值观&#34;&gt;scrum框架的五个价值观&lt;/h2&gt;
&lt;p&gt;承诺&lt;/p&gt;
&lt;p&gt;专注&lt;/p&gt;
&lt;p&gt;开放&lt;/p&gt;
&lt;p&gt;尊重&lt;/p&gt;
&lt;p&gt;勇气&lt;/p&gt;
&lt;h2 id=&#34;scrum框架的四大支柱&#34;&gt;scrum框架的四大支柱&lt;/h2&gt;
&lt;p&gt;迭代开发&lt;/p&gt;
&lt;p&gt;增量交付&lt;/p&gt;
&lt;p&gt;自组织团队&lt;/p&gt;
&lt;p&gt;高优先级的需求驱动&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;xp&#34;&gt;XP&lt;/h1&gt;
&lt;p&gt;Extreme Programming&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ansible</title>
        <link>https://canuxcheng.com/post/devops_ansible/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_ansible/</guid>
        <description>&lt;h1 id=&#34;ansible&#34;&gt;Ansible&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ansible/ansible&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ansible/ansible&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ansible.com.cn/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.ansible.com.cn/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ansible通过SSH来远程管理Linux/Unix机器．&lt;/p&gt;
&lt;p&gt;ansible通过winrm+powershell来远程管理Windows机器．&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo pip install ansible
$ sudo apt-get install ansible
$ sudo yum install ansible

$ brew install ansible sshpass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;p&gt;参考Network-SSH实现从controller到所有node的无密码登陆&lt;/p&gt;
&lt;p&gt;配置文件执行顺序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ANSIBLE_CONFIG
ansible.cfg
.ansible.cfg
/etc/ansible/ansible.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手动配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/ansible/ansible.cfg
[defaults]
ask_pass = False
host_key_checking = False
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ansible命令&#34;&gt;ansible命令&lt;/h2&gt;
&lt;p&gt;ansible运行命令的两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ad-hoc相当于直接运行shell命令&lt;/li&gt;
&lt;li&gt;playbooks相当于运行shell脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ansible:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible group1:group1:group3/all  -i inventory  ......

$ansible --help
-m MODULE_NAME, --module-name=MODULE_NAME # 执行模块，默认是command
-M MODULE_PATH, --module-path=MODULE_PATH # 指定模块的路径
-a MODULE_ARGS, --args=MODULE_ARGS # 模块的参数
-i INVENTORY, --inventory INVENTORY # 默认/etc/ansible/hosts, 需要指定hosts分组
-f FORKS, --forks=FORKS # 指定并发进程的数量
-C, --check
-D, --diff
-l SUBSET, --limit=SUBSET
--syntax-check
--list-hosts
-v, --verbose # -v, -vvv, -vvvv

# 提权选项
-b, --become
--become-method=BECOME_METHOD # sudo(default)/su/pbrun/pfexec/runas/doas
--become-user=BECOME_USER # root(default)
-K, --ask-become-pass

# 连接选项
-u REMOTE_USER
--ssh-common-args
--ssh-extra-args
-T TIMEOUT # default 10s
-K, --ask-pass
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;inventory&#34;&gt;inventory&lt;/h2&gt;
&lt;p&gt;inventory包括主机和分组,以及主机变量和分组变量. 默认是&lt;code&gt;/etc/ansible/hosts&lt;/code&gt;文件.&lt;/p&gt;
&lt;p&gt;可以是ini格式，也可以是yaml格式.&lt;/p&gt;
&lt;p&gt;可以是一个文件，可以是多个文件，也可以是一个目录.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible all -i inventory/folder/ ......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ini格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义主机和主机变量
[host1]
node1 
ansible_connection=ssh 
ansible_host=host 
ansible_port=port 
ansible_user=user 
ansible_ssh_pass=password

定义分组和分组变量
[group1]
node1
node2
[group1:vars]
ansible_connection=local/smart/ssh/paramiko
ansible_host=
ansible_port=
ansible_user=
ansible_ssh_pass=
ansible_ssh_common_args=
ansible_ssh_extra_args=
ansible_become=
ansible_become_method=
ansible_become_user=
ansible_become_pass=
ansible_become_exe=
ansible_become_flags=

定义分组的分组, children是固定写法
[big-group:children]
group1
group2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yaml:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;all:
  hosts:    # hosts, 定义主机和主机变量
    node1:
      ansible_host:
      ansible_port:
      ansible_user:
      ansible_ssh_pass: &amp;quot;${{ ansible_ssh_pass }}&amp;quot;    # use ansible-vault
  children:    # children, 定义分组和分组变量
    production:
      hosts:
        node1:
        node2:
      vars:
        env: prod
    staging:
      hosts:
        node3:
        node4:
      vars:
        env: staging
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;module&#34;&gt;module&lt;/h2&gt;
&lt;p&gt;module也就是所说的task plugins/library plugins.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-doc -l/--list  #　查看所有已经安装的模块
$ ansible-doc apt # 查看apt模块的文档
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内置的模块&#34;&gt;内置的模块&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-docs -l | grep &amp;quot;ansible.builtin&amp;quot;

ping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;command # 默认模块，用于在远程机器上执行命令
shell # 和command相同，只是该模块支持管道和特殊字符，一般用来执行脚本和复杂命令
raw
expect
script
telnet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;files modules:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy src dest mode ...
synchronize src dest ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package modules:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt name/deb state=present/absent/latest/build-dep update_cache autoclean autoremove
apt_repository repo state=present/absent
apt_rpm pkg state=present/absent
yum name state=present/absent/latest/installed/removed
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;adhoc&#34;&gt;adhoc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ansible group -m &amp;lt;module&amp;gt; -a &amp;lt;args&amp;gt; ...
$ ansible all -i inventory.yml -m ping  -e &amp;quot;@vault.yml&amp;quot; --ask-vault-pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;copy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible group -m copy -a &amp;quot;src=https://canuxcheng.com/sr dest=/dest mode=0655&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ansible-playbooks&#34;&gt;ansible-playbooks&lt;/h2&gt;
&lt;p&gt;playbook的格式是YAML.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-playbook -i inventory playbook.yaml -K -vvv &amp;gt; output.txt
$ ansible-playbook -i inventory.yml playbook.yml -e &amp;quot;@vault.yml&amp;quot; --ask-vault-pass
$ ansible-playbook -i inventory.yml playbook.yml -e &amp;quot;@vault.yml&amp;quot; --vault-password-file ~/.vault_pass.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;playbook:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: install
  hosts: host-or-group
  become: true
  vars:
    var1: value1
    var2: value2
  tasks:
  - name: &amp;quot;{{ var1 }}&amp;quot;
    module: args
    debug:
      msg: &amp;quot;This is a debug message&amp;quot;
  - name: &amp;quot;{{ var2 }}&amp;quot;
    module: args
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;variables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;register: var   # 用var来存储task的结果,查看不同模块的返回值．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;become:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;become: true
become_user: root
become_method: sudo
become_flags:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strategy: debug
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-vault&#34;&gt;ansible-vault&lt;/h2&gt;
&lt;p&gt;ansible-vault用于加密敏感数据，比如密码等.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-vault create vault.yml
$ ansible-vault edit vault.yml
$ ansible-vault view vault.yml
$ ansible-vault encrypt vault.yml
$ ansible-vault decrypt vault.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-inventory&#34;&gt;ansible-inventory&lt;/h2&gt;
&lt;p&gt;ansible-inventory用于查看inventory的内容.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-inventory --list -i inventory.yml
$ ansible-inventory --graph -i inventory.yml

$ ansible-inventory --host host1 -i inventory.yml # 查看主机的详细信息
$ ansible-inventory --tree -i inventory.yml # 查看分组树状图

$ ansible-inventory --export -i inventory.yml # 导出inventory到标准输出
$ ansible-inventory --validate -i inventory.yml # 验证inventory文件的语法
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-config&#34;&gt;ansible-config&lt;/h2&gt;
&lt;p&gt;ansible-config用于查看和管理ansible的配置.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-config view # 查看当前配置
$ ansible-config dump --only-changed # 查看修改过的配置
$ ansible-config list --type=defaults # 列出所有默认配置
$ ansible-config list --type=privilege # 列出特权配置
$ ansible-config list --type=all # 列出所有配置

$ ansible-config init --disabled &amp;gt; ansible.cfg # 初始化一个新的ansible.cfg文件
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-pull&#34;&gt;ansible-pull&lt;/h2&gt;
&lt;p&gt;ansible-pull用于从远程仓库拉取playbook并执行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-pull -U &amp;lt;repo_url&amp;gt; -i inventory.yml playbook.yml

-U, --url &amp;lt;repo_url&amp;gt; # 指定远程仓库的URL
-i, --inventory &amp;lt;inventory&amp;gt; # 指定inventory文件
-d, --directory &amp;lt;directory&amp;gt; # 指定工作目录
-C, --checkout &amp;lt;branch&amp;gt; # 指定分支
-c, --clean # 清理工作目录
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-console&#34;&gt;ansible-console&lt;/h2&gt;
&lt;p&gt;ansible-console是一个交互式的命令行界面，可以执行ansible命令和playbook.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-console -i inventory.yml

-i, --inventory &amp;lt;inventory&amp;gt; # 指定inventory文件
-c, --connection &amp;lt;connection&amp;gt; # 指定连接方式，默认是ssh
-u, --user &amp;lt;user&amp;gt; # 指定远程用户
-k, --ask-pass # 提示输入SSH密码
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ansible-galaxy&#34;&gt;ansible-galaxy&lt;/h2&gt;
&lt;p&gt;ansible-galaxy用于管理Ansible的角色和集合.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ansible-galaxy install &amp;lt;role_name&amp;gt; # 安装角色
$ ansible-galaxy remove &amp;lt;role_name&amp;gt; # 卸载角色
$ ansible-galaxy list # 列出已安装的角色
$ ansible-galaxy init &amp;lt;role_name&amp;gt; # 初始化一个新的角色

$ ansible-galaxy collection install &amp;lt;collection_name&amp;gt; # 安装集合
$ ansible-galaxy collection remove &amp;lt;collection_name&amp;gt; # 卸载集合
$ ansible-galaxy collection list # 列出已安装的集合
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Terraform</title>
        <link>https://canuxcheng.com/post/cloud_terraform/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/cloud_terraform/</guid>
        <description>&lt;h1 id=&#34;terraform&#34;&gt;Terraform&lt;/h1&gt;
&lt;p&gt;install:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.hashicorp.com/tutorials/terraform/install-cli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.hashicorp.com/tutorials/terraform/install-cli&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cli&#34;&gt;CLI&lt;/h2&gt;
&lt;p&gt;操作工作目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 初始化目录，会根据配置下载和安装provider.
terraform init

terraform get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作tf文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 格式化文件
terraform fmt -recursive

// 验证文件
terraform validate 

// 可以通过终端验证函数.
terraform console
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作基础设施:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform plan
terraform plan -out test.tfplan

terraform apply -auto-approve
terraform apply test.tfplan

terraform destroy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查基础设施:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform show
terraform graph
terraform output
terraform state list/show
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;认证:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform login
terraform logout
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tf&#34;&gt;TF&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.terraform.io/language&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.terraform.io/language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注释:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment 
// comment
/* comment */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;backend-and-state&#34;&gt;backend and state&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.terraform.io/language/settings/backends&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.terraform.io/language/settings/backends&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.terraform.io/language/state&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.terraform.io/language/state&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;provider&#34;&gt;provider&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;data-sources&#34;&gt;data sources&lt;/h3&gt;
&lt;p&gt;data source: 获取服务的参数&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;module&#34;&gt;module&lt;/h3&gt;
&lt;p&gt;管理provider上的模块/服务.定义了input, resource/data source, output的就可以认为是module.&lt;/p&gt;
&lt;h4 id=&#34;meta-arguments&#34;&gt;meta-arguments&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;providers&lt;/li&gt;
&lt;li&gt;depends_on&lt;/li&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;for_each&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;resources&#34;&gt;resources&lt;/h3&gt;
&lt;p&gt;resources: 创建服务的参数&lt;/p&gt;
&lt;h4 id=&#34;meta-arguments-1&#34;&gt;meta-arguments&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;depends_on&lt;/li&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;for_each&lt;/li&gt;
&lt;li&gt;provider&lt;/li&gt;
&lt;li&gt;lifecycle&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;provisioner&#34;&gt;provisioner&lt;/h4&gt;
&lt;p&gt;特殊的resource，可以在本地或远程机器做一些准备工作。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;variable&#34;&gt;Variable&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.terraform.io/language/values/variables&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.terraform.io/language/values/variables&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;input variable: 输入变量&lt;/p&gt;
&lt;p&gt;local variable: 本地变量&lt;/p&gt;
&lt;p&gt;output variable: 输出参数&lt;/p&gt;
&lt;p&gt;子模块无法引用父模块的local变量， resource属性，input变量。但是可以通过output参数引用。&lt;/p&gt;
&lt;p&gt;父模块无法引用子模块的local变量，resource属性。但是可以通过output参数引用，而且父模块可以通过input变量传值给子模块。&lt;/p&gt;
&lt;h3 id=&#34;表达式&#34;&gt;表达式&lt;/h3&gt;
&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;h3 id=&#34;workspace&#34;&gt;workspace&lt;/h3&gt;
&lt;p&gt;多环境构建（development, UAT, production).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform workspace new dev
terraform workspace list
terraform select &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用terraform.workspace作为参数.&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Vault</title>
        <link>https://canuxcheng.com/post/devops_vault/</link>
        <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_vault/</guid>
        <description>&lt;h1 id=&#34;vault&#34;&gt;Vault&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hashicorp/vault&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hashicorp/vault&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Install:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.hashicorp.com/tutorials/vault/getting-started-install&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.hashicorp.com/tutorials/vault/getting-started-install&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;可以通过环境变量或者命令行参数指定server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-address VAULT_ADDR
-namespace VAULT_NAMESPACE
vault [subcommand] -address=&amp;quot;https://server:8200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 启动vault
$ vault server -config=/etc/vault/config.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;agent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vault agent
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;login:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 跟据token登陆.
$ vault login

$vault login -token-only -method=oidc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;operator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// init生成keys和token.
$ vault operator init

// 通过keys  unseal
$ vault operator unseal

// 通过token seal
$ vault operator seal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;auth:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看auth
$ vault auth list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;secrets&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看secrets engine
$ vault secrets list

// enable kv
$ vault secrets enable -path=&amp;lt;ns&amp;gt;/&amp;lt;name&amp;gt; kv
$ vault secrets enable kv

// disable kv
$ vault secrets disable kv

// 创建一个database engine
vault secrets enable -path &amp;lt;ns&amp;gt;/mysql database
// 创建rabbitmq engine
vault secrets enable -path &amp;lt;ns&amp;gt;/rabbitmq rabbitmq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;policy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看policy
$ vault policy list

// 创建policy
$ vault policy write &amp;lt;my-policy&amp;gt; ./my-policy.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vault plugin list database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;read/write/delete/list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vault read
$ vault write
$ vault write my-secret/my-app my-field=value
$ vault delete
$ vault list
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.vaultproject.io/api-docs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vaultproject.io/api-docs&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl --header &amp;quot;X-Vault-Token: TOKEN&amp;quot; https://FQDN/v1/&amp;lt;engine-path&amp;gt;/data/&amp;lt;secret-path&amp;gt;
$ curl --header &amp;quot;X-Vault-Token: TOKEN&amp;quot; https://FQDN/v1/&amp;lt;engine-path&amp;gt;/data/&amp;lt;secret-path&amp;gt;?version=&amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;auth-methods&#34;&gt;auth methods&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.vaultproject.io/docs/auth&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vaultproject.io/docs/auth&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;secrets-engine&#34;&gt;secrets engine&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.vaultproject.io/docs/secrets&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vaultproject.io/docs/secrets&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vault-pki&#34;&gt;vault PKI&lt;/h1&gt;
&lt;p&gt;通过pki engine来生成和管理证书。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.hashicorp.com/tutorials/vault/pki-engine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.hashicorp.com/tutorials/vault/pki-engine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;generate:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vault write -format=json -namespace=&amp;lt;ns&amp;gt;  &amp;lt;pki_root&amp;gt;/issue/&amp;lt;role&amp;gt; \
common_name=&amp;quot;canuxcheng.com&amp;quot; \
alt_names=&amp;quot;canuxcheng.com,*.canuxcheng.com&amp;quot; \
ttl=8760h \
format=pem/der/pem_bundle \
| tee \
&amp;gt;(jq -r &#39;.data.certificate&#39; &amp;gt; canuxcheng.crt) \
&amp;gt;(jq -r &#39;.data.private_key&#39; &amp;gt; private.key) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;list:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vault list -namespace=&amp;lt;ns&amp;gt; &amp;lt;pki_root&amp;gt;/certs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;verify:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vault read -namespace=iac-phoenix/test it/pki/cert/&amp;lt;sn&amp;gt;

curl -s https://vault.canux.com/v1/&amp;lt;ns&amp;gt;/&amp;lt;pki_root&amp;gt;/cert/&amp;lt;serial-num&amp;gt; | jq -r &#39;.data.certificate&#39; | openssl x509 -in - -noout -text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;revoke:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vault write &amp;lt;ns&amp;gt;/&amp;lt;pki_root&amp;gt;/revoke serial_number=&amp;quot;******&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;remove expired ca:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vault write &amp;lt;pki_root&amp;gt;/tidy tidy_cert_store=true tidy_revoked_certs=true
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vault--k8s&#34;&gt;vault + k8s&lt;/h1&gt;
&lt;p&gt;vault提供两种方式在k8s中使用secret.&lt;/p&gt;
&lt;h2 id=&#34;vault-sidecar-agent-injector&#34;&gt;Vault Sidecar Agent Injector&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.vaultproject.io/docs/platform/k8s/injector&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vaultproject.io/docs/platform/k8s/injector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hashicorp/vault-k8s&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hashicorp/vault-k8s&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mutating-webhook-of-bank-vaults&#34;&gt;mutating webhook of Bank-Vaults&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://banzaicloud.com/docs/bank-vaults/mutating-webhook/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://banzaicloud.com/docs/bank-vaults/mutating-webhook/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/banzaicloud/bank-vaults&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/banzaicloud/bank-vaults&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://banzaicloud.com/blog/inject-secrets-into-pods-vault-revisited/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://banzaicloud.com/blog/inject-secrets-into-pods-vault-revisited/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;vault-csi-provider&#34;&gt;Vault CSI Provider&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.vaultproject.io/docs/platform/k8s/csi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vaultproject.io/docs/platform/k8s/csi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kubernetes-sigs/secrets-store-csi-driver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kubernetes-sigs/secrets-store-csi-driver&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PSL_Test</title>
        <link>https://canuxcheng.com/post/psl_devops/</link>
        <pubDate>Mon, 11 Apr 2016 22:58:13 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_devops/</guid>
        <description>&lt;h1 id=&#34;devops&#34;&gt;DevOps&lt;/h1&gt;
&lt;p&gt;development, debugging, profiling&lt;/p&gt;
&lt;h2 id=&#34;typing&#34;&gt;typing&lt;/h2&gt;
&lt;p&gt;用于类型提示，提供类型检查，代码可读性和编辑器自动补全支持。&lt;/p&gt;
&lt;p&gt;基础类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tuple[int, int], Tuple[int, ...]
List[str]
Dict[str, int]
Set[str]
Optional[int]
Union[int, str, float]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;泛型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeVar
Generic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数签名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Callable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类相关&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Type
Protocol
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;高级类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Linteral
Final
Annotated
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pydoc&#34;&gt;pydoc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import pydoc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;doctest&#34;&gt;doctest&lt;/h2&gt;
&lt;p&gt;python内置的文档测试库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import doctest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unittest&#34;&gt;unittest&lt;/h2&gt;
&lt;p&gt;python内置的单元测试库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import unittest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;debugging-and-profiling&#34;&gt;Debugging and Profiling&lt;/h1&gt;
&lt;h2 id=&#34;bdb&#34;&gt;bdb&lt;/h2&gt;
&lt;h2 id=&#34;pdb&#34;&gt;pdb&lt;/h2&gt;
&lt;h2 id=&#34;timeit&#34;&gt;timeit&lt;/h2&gt;
&lt;h2 id=&#34;trace&#34;&gt;trace&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;unittest2&#34;&gt;unittest2&lt;/h2&gt;
&lt;p&gt;unittest2是unittest的升级版．&lt;/p&gt;
&lt;p&gt;python3集成了unittest2到unittest,像使用unittest一样使用即可．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2.7
$pip install unittest2
import unittest2

# python3
import unittest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;OK 表示测试通过&lt;/p&gt;
&lt;p&gt;FAIL 表示测试没有通过，并引发一个AssertionError异常．&lt;/p&gt;
&lt;p&gt;ERROR 表示测试过程引发一个不是AssertionError的异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是标准库的unittest.
import unittest
import MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．
unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.
unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.
unittest.TestResult: 用来保存测试的结果．

unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．
fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．

unittest.TextTestRunner: 用来执行测试用例．
unittest.TextTestResult: 用来打印格式化的测试结果．

# unittest.TestCase
# methods:
assertXXX　系列方法．
failXXX 系列方法
fail(self, msg=None) # test立即失败
addCleanup(self, function, *args, **kwargs)
addTypeEqualityFunc(self, typeobj, function)
countTestCases(self)
debug(self)
defaultTestResult() # return unittest.TestResult()
doCleanups(self)
id(self)
run(self, result=None) # 可以在子类覆盖该方法．
shortDescription(self)
skipTest(self, reason)
setUp(self) # 重写之后，每个case运行之前都会调用一次．
tearDown(self) # 同上

# classmethods:
setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．
tearDownClass(cls) # 同上

# data:
failureException = AssertionError
longMessage = False
maxDiff = 640
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;findTestCases(module, prefix=&#39;test&#39;, sortUsing=&amp;lt;built-in function cmp&amp;gt;, suiteClass=&amp;lt;class &#39;unittest.suite.TestSuite&#39;&amp;gt;)
getTestCaseNames(testCaseClass, prefix, sortUsing=&amp;lt;built-in function cmp&amp;gt;)
installHandler()
makeSuite(testCaseClass, prefix=&#39;test&#39;, sortUsing=&amp;lt;built-in function cmp&amp;gt;, suiteClass=&amp;lt;class &#39;unittest.suite.TestSuite&#39;&amp;gt;)
registerResult(result)
removeHandler(method=None)
removeResult(result)

# unittest.case实现了几个函数用来增强unittest.TestCase的方法, 一般当装饰器用．
expectedFailure(func) # 如果这个case失败了，不计入失败的数目．
# @unittest.expectedFailure
skip(reason) # 无条件跳过一个test case.
skipIf(condition, reason) # condition为true就跳过一个test case.
skipUnless(condition, reason) # 和上面相反
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyClassTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print &#39;Just execute before the first test case start.&#39;

    @classmethod
    def tearDownClass(cls):
        print &#39;Just execute after all test case end.&#39;

    def setUp(self):
        &amp;quot;&amp;quot;&amp;quot;重载setUp进行测试之前的初始化工作.运行每个test_func之前都会运行该方法&amp;quot;&amp;quot;&amp;quot;
        print &amp;quot;start&amp;quot;

    def tearDown(self):
        &amp;quot;&amp;quot;&amp;quot;重载tearDown进行测试结束后的清理工作.结束运行每个test_func之后都会运行该方法&amp;quot;&amp;quot;&amp;quot;
        print &amp;quot;end&amp;quot;

    def test_func(self):
        &amp;quot;&amp;quot;&amp;quot;具体的测试用例，需要用test开头,多个test_func会根据func名字中的数字或字母的顺序来执行，和位置无关.
        不是用test开头的方法默认不会被执行&amp;quot;&amp;quot;&amp;quot;
        self.assertEqual(MyClass.method(args), value, &amp;quot;message&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main()

# 自动发现和批量执行testcase/testsuite:
def discover_test_case():
    test_cases = []
    _module = ...
    tests.append(unittest.defaultTestLoader.loadTestsFromModule(_module))
    unittest.defaultTestLoader.discover()
    return tests

def get_test_suite():
    &amp;quot;&amp;quot;&amp;quot;打包一个testsuite.&amp;quot;&amp;quot;&amp;quot;
    return unittest.TestSuite(discover_test_case())

unittest.TextTestRunner
if __name__ == &amp;quot;__main__&amp;quot;:
    runner = unittest.TextTestRunner()
    result = runner.run(get_test_suite())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mock&#34;&gt;mock&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/testing-cabal/mock&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/testing-cabal/mock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python3集成了mock到unittest模块，导入unittest.mock即可．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7
$pip install mock
import mock

# Python3
import unittest.mock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mock就是在测试中对于不容易构造或获取的对象，用一个虚拟的对象来代替以便测试的方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是第三方库mock
from mock import Mock, patch, PropertyMock, MagicMock
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nose2&#34;&gt;nose2&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nose-devs/nose2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nose-devs/nose2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nose是unittest/unittest2的升级版．&lt;/p&gt;
&lt;p&gt;nose2是nose的升级版．&lt;/p&gt;
&lt;p&gt;nose2用于单元测试．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install nose

import nose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pytest&#34;&gt;pytest&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pytest-dev/pytest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pytest-dev/pytest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pytest用于单元测试．推荐使用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install -U pytest

import pytest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;coverage&#34;&gt;coverage&lt;/h2&gt;
&lt;p&gt;分析单元测试的代码覆盖率&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nedbat/coveragepy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nedbat/coveragepy&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install coverage

# 通过命令进行测试，可以集成到其它工具．
$ coverage run --source=&amp;lt;package-name&amp;gt; setup.py test
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tox&#34;&gt;tox&lt;/h2&gt;
&lt;p&gt;virtualenv management and test command line tool.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tox-dev/tox&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tox-dev/tox&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install tox

# 通过命令进行测试，可以集成unittest, nose2, pytest等工具．
$ tox
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>DevOps</title>
        <link>https://canuxcheng.com/post/c_devops/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_devops/</guid>
        <description>&lt;h1 id=&#34;ide&#34;&gt;IDE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;VSCode&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;compilers&#34;&gt;Compilers&lt;/h2&gt;
&lt;p&gt;编译器组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;frontend&lt;/li&gt;
&lt;li&gt;optimizer&lt;/li&gt;
&lt;li&gt;backend&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.cppreference.com/w/cpp/compiler_support&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh.cppreference.com/w/cpp/compiler_support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;llvm clang&lt;/li&gt;
&lt;li&gt;Mingw&lt;/li&gt;
&lt;li&gt;Msvc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;llvm clang&lt;/li&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mac:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;llvm clang&lt;/li&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;apple clang&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gcc&#34;&gt;gcc&lt;/h3&gt;
&lt;p&gt;gnu gcc,g++&lt;/p&gt;
&lt;h3 id=&#34;llvm-clang&#34;&gt;llvm clang&lt;/h3&gt;
&lt;p&gt;llvm: low level virtual machine. (backend)&lt;/p&gt;
&lt;p&gt;clang: c language.(frontend)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tools&#34;&gt;tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CMake&lt;/li&gt;
&lt;li&gt;MSBuild&lt;/li&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;gcc-1&#34;&gt;GCC&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;-ansi&amp;rdquo;&lt;/p&gt;
&lt;p&gt;for c: == -std=c90
for cpp: ==-std=c++98&lt;/p&gt;
&lt;p&gt;&amp;ldquo;-std&amp;rdquo;&lt;/p&gt;
&lt;p&gt;c++17, gnu++17, gnu17,c17
gnu2x: 下个ISO C标准。
c2x:下个ISO C标准。
c++2a: 下个ISO C++标准
gnu+2a:下个ISO C++标准&lt;/p&gt;
&lt;p&gt;gcc8 开始支持c++20.
gcc11开始支持c++23.&lt;/p&gt;
&lt;h2 id=&#34;vscode&#34;&gt;vscode&lt;/h2&gt;
&lt;p&gt;for macOS:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xcode-select --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;extentions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c/c++&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Document</title>
        <link>https://canuxcheng.com/post/c_document/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_document/</guid>
        <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;doxygen&#34;&gt;Doxygen&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Hadoop</title>
        <link>https://canuxcheng.com/post/hadoop/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hadoop/</guid>
        <description>&lt;h1 id=&#34;hadoop&#34;&gt;Hadoop&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/apache/hadoop&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/apache/hadoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;apache hadoop是一个框架，允许使用简单的编程模型在大量计算机上对大型数据集进行分布式处理．&lt;/p&gt;
&lt;p&gt;hadoop1只有HDFS和MapReduce两个模块，hadoop2开始分为HDFS, YARN, MapReduce三个模块．&lt;/p&gt;
&lt;p&gt;hadoop的版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apache hadoop&lt;/li&gt;
&lt;li&gt;hortonworks hadoop (HDP)&lt;/li&gt;
&lt;li&gt;cloudera hadoop (CDH)&lt;/li&gt;
&lt;li&gt;mapr&lt;/li&gt;
&lt;li&gt;transwarp&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;安装hadoop&#34;&gt;安装hadoop&lt;/h1&gt;
&lt;p&gt;hadoop有三种安装模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单节点模式&lt;/li&gt;
&lt;li&gt;伪分布式模式&lt;/li&gt;
&lt;li&gt;分布式模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考Linux Admin和Network SSH如何安装多台centos，并且配置局域网，让本地多台机器相互访问．&lt;/p&gt;
&lt;p&gt;下载hadoop的二进制安装包，然后放到/home/hadoop/目录下并解压．&lt;/p&gt;
&lt;p&gt;推荐的cluster node:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NameNode(hdfs)
Secondary NameNode(hdfs)
DataNode(hdfs)
ResourceManager server(yarn)
NodeManager server(yarn)
WebAppProxy server(yarn)
MapReduceJobHistory server(mapreduce)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim ~/.bash_profile
export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-.../jre
export HADOOP_HOME=/home/hadoop/hadoop-3.0.0-alpha2
export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PATH
$ source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改hadoop的环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd hadoop-3.0.0-alpha2/etc/hadoop
$ vim hadoop-env.sh
export JAVA_HOME=&#39;/usr/lib/jvm/java-1.8.0-openjdk-.../jre

# 测试java和hadoop的环境是否可用：
$ hadoop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分布式环境搭建：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/ClusterSetup.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/ClusterSetup.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim core-site.xml

$ vim hdfs-site.xml # namenode, datanode

$ vim yarn-site.xml # resourcemanager, nodemanager, webappproxy

$ vim mapred-site.xml # mr application, mr jobhistory

# slaves file
$ vim workers
namenode
secondnamenode
datanode
datanode2
yarnserver
mjhserver

# hadoop rack awareness

# logging
$ vim log4j.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CLI for hadoop cluster:&lt;/p&gt;
&lt;p&gt;启动一个hadoop　cluster需要同时启动hdfs和yarn, 推荐用单独的用户分别启动这两个组件．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 第一次启动hdfs，需要格式化hdfs
$ hdfs namenode -format &amp;lt;cluster_name&amp;gt;

# 启动hdfs namenode 和　datanode
$ hdfs --daemon start namenode
$ hdfs --daemon start datanode
# 如果ssh已经实现无密码连接，可以一次启动cluster的所有node
$ $HADOOP_HOME/sbin/start-dfs.sh

# 启动yarn resourcemanager　和　nodemanager
$ yarn --daemon start resourcemanager
$ yarn --daemon start nodemanager
# 如果配置了slaves file 并且cluster node实现ssh无密码登陆，可以一次启动
$ $HADOOP_HOME/sbin/start-yarn.sh

# 启动webappproxy server
$ yarn --daemon start proxyserver

# 启动MapReduce Jobhistory server.
$ mapred --daemon start historyserver

# stop namenode
$ hdfs --daemon stop namenode
# stop datanode
$ hdfs --daemon stop datanode
# stop at the same time
$ $HADOOP_HOME/sbin/stop-dfs.sh

# stop resourcemanager
$ yarn --daemon stop resourcemanager
# stop nodemanager
$ yarn --daemon stop nodemanager
# stop at the same time
$ $HADOOP_HOME/sbin/stop-yarn.sh

# stop webappproxy server
$ yarn stop proxyserver

# stop jobhistory server
$ mapred --daemon stop historyserver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GUI for hadoop cluster:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# namenode
http://nn:9870
# resource manager
http:rm:8080
# mapreduce job history server
http://jhs:19888
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hadoop-commands&#34;&gt;Hadoop Commands&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt; hadoop [--config confdir] [--loglevel loglevel] [COMMAND] [GENERIC_OPTIONS] [COMMAND_OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hadoop archive
$ hadoop fs
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;admin command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hadoop daemonlog
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;fs-commands&#34;&gt;fs commands&lt;/h1&gt;
&lt;p&gt;file system command:&lt;/p&gt;
&lt;p&gt;支持本地文件系统，hdfs文件系统，还有其它文件系统．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hadoop fs

$ hadoop fs -cat URI [URI ...]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Hadoop HDFS</title>
        <link>https://canuxcheng.com/post/hadoop_hdfs/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hadoop_hdfs/</guid>
        <description>&lt;h1 id=&#34;hdfs&#34;&gt;HDFS&lt;/h1&gt;
&lt;p&gt;Hadoop Distributed File System: hadoop分布式文件系统&lt;/p&gt;
&lt;p&gt;hadoop hdfs分为三部分:&lt;/p&gt;
&lt;p&gt;NameNode -&amp;gt; JobTracker&lt;/p&gt;
&lt;p&gt;secondary NameNode&lt;/p&gt;
&lt;p&gt;DataNode -&amp;gt; TaskTracker&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hdfs-commands&#34;&gt;hdfs commands&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hdfs [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hdfs classpath

$ hdfs dfs # 参考 hadoop fs命令
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;admin commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hdfs balancer
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hdfs verify

$ hdfs recoverLease
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Hadoop YARN</title>
        <link>https://canuxcheng.com/post/hadoop_yarn/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hadoop_yarn/</guid>
        <description>&lt;h1 id=&#34;yarn&#34;&gt;YARN&lt;/h1&gt;
&lt;p&gt;作业调度和集群资源管理的框架．&lt;/p&gt;
&lt;p&gt;yarn的两个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;resourcemanager&lt;/li&gt;
&lt;li&gt;nodemanager&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;yarn-commands&#34;&gt;yarn commands&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;yarn [--config confdir] COMMAND [--loglevel loglevel] [GENERIC_OPTIONS] [COMMAND_OPTIONS]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yarn application
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;admin commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yarn daemonlog
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;resource-manager&#34;&gt;resource manager&lt;/h1&gt;
&lt;p&gt;resource manager由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scheduler&lt;/li&gt;
&lt;li&gt;applicationmanager&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ResourceManager功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理客户请求&lt;/li&gt;
&lt;li&gt;启动／监控applicationmaster&lt;/li&gt;
&lt;li&gt;监控nodemanager&lt;/li&gt;
&lt;li&gt;资源分配与调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ApplicationMaster功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据切分&lt;/li&gt;
&lt;li&gt;为应用申请资源, 并分配给内部任务&lt;/li&gt;
&lt;li&gt;任务监控与容错&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;node-manager&#34;&gt;node manager&lt;/h1&gt;
&lt;p&gt;node manager功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个节点的资源管理&lt;/li&gt;
&lt;li&gt;处理来自resourcemanager的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/c_package/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_package/</guid>
        <description>&lt;h1 id=&#34;package&#34;&gt;Package&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>BigData</title>
        <link>https://canuxcheng.com/post/bigdata/</link>
        <pubDate>Mon, 11 Apr 2016 22:57:37 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/bigdata/</guid>
        <description>&lt;h1 id=&#34;bigdata&#34;&gt;BigData&lt;/h1&gt;
&lt;p&gt;大数据最流行的框架是hadoop.&lt;/p&gt;
&lt;p&gt;大部分工具都属于Apache基金会的项目．&lt;/p&gt;
&lt;h1 id=&#34;mpp&#34;&gt;MPP&lt;/h1&gt;
&lt;p&gt;Massive Parallel Process&lt;/p&gt;
&lt;p&gt;大规模并行处理数据库包括impala, hawq&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;分布式存储&#34;&gt;分布式存储&lt;/h1&gt;
&lt;h2 id=&#34;hadoop-hdfs&#34;&gt;hadoop hdfs&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;资源调度&#34;&gt;资源调度&lt;/h1&gt;
&lt;h2 id=&#34;hadoop-yarn&#34;&gt;hadoop yarn&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;分布式计算框架&#34;&gt;分布式计算框架&lt;/h1&gt;
&lt;h2 id=&#34;hadoop-mapreduce&#34;&gt;hadoop mapreduce&lt;/h2&gt;
&lt;h2 id=&#34;spark&#34;&gt;Spark&lt;/h2&gt;
&lt;h1 id=&#34;流式计算框架&#34;&gt;流式计算框架&lt;/h1&gt;
&lt;h2 id=&#34;storm&#34;&gt;Storm&lt;/h2&gt;
&lt;h2 id=&#34;flink&#34;&gt;Flink&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;部署工具&#34;&gt;部署工具&lt;/h1&gt;
&lt;h2 id=&#34;ambari&#34;&gt;Ambari&lt;/h2&gt;
&lt;p&gt;用于配置，管理，监控hadoop集群的web工具．&lt;/p&gt;
&lt;h2 id=&#34;bigtop&#34;&gt;Bigtop&lt;/h2&gt;
&lt;p&gt;对hadoop相关软件打包，分发，测试的工具．&lt;/p&gt;
&lt;h2 id=&#34;whirr&#34;&gt;whirr&lt;/h2&gt;
&lt;h2 id=&#34;cloudera-hue&#34;&gt;Cloudera Hue&lt;/h2&gt;
&lt;h2 id=&#34;hortonworks-hoya&#34;&gt;Hortonworks hoya&lt;/h2&gt;
&lt;h1 id=&#34;服务编程&#34;&gt;服务编程&lt;/h1&gt;
&lt;h2 id=&#34;zookeeper&#34;&gt;Zookeeper&lt;/h2&gt;
&lt;p&gt;分布式应用程序的高性能协调服务&lt;/p&gt;
&lt;h2 id=&#34;curator&#34;&gt;Curator&lt;/h2&gt;
&lt;h2 id=&#34;avro&#34;&gt;Avro&lt;/h2&gt;
&lt;h2 id=&#34;chuckwa&#34;&gt;chuckwa&lt;/h2&gt;
&lt;p&gt;用于监控大型分布式系统的数据收集系统．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;交互式分析框架sql-on-hadoop&#34;&gt;交互式分析框架(Sql On Hadoop)&lt;/h1&gt;
&lt;h2 id=&#34;facebook-presto&#34;&gt;Facebook Presto&lt;/h2&gt;
&lt;h2 id=&#34;hive&#34;&gt;Hive&lt;/h2&gt;
&lt;h2 id=&#34;hawqpivotal&#34;&gt;Hawq(Pivotal)&lt;/h2&gt;
&lt;p&gt;Hortonworks的HDP集成了HAWQ.&lt;/p&gt;
&lt;h2 id=&#34;impalacloudera&#34;&gt;Impala(Cloudera)&lt;/h2&gt;
&lt;p&gt;Cloudera的CHD集成了Impala.&lt;/p&gt;
&lt;h1 id=&#34;交互式分析框架nosql-on-hadoop&#34;&gt;交互式分析框架(NoSQL On Hadoop)&lt;/h1&gt;
&lt;h2 id=&#34;hbase&#34;&gt;HBase&lt;/h2&gt;
&lt;h2 id=&#34;cassandra&#34;&gt;Cassandra&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据管理工具&#34;&gt;数据管理工具&lt;/h1&gt;
&lt;h2 id=&#34;sqoop&#34;&gt;Sqoop&lt;/h2&gt;
&lt;h2 id=&#34;flume&#34;&gt;Flume&lt;/h2&gt;
&lt;h1 id=&#34;消息队列&#34;&gt;消息队列&lt;/h1&gt;
&lt;h2 id=&#34;kafka&#34;&gt;Kafka&lt;/h2&gt;
&lt;h2 id=&#34;pivotal-rabbitmq&#34;&gt;Pivotal RabbitMQ&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;dsl&#34;&gt;DSL&lt;/h1&gt;
&lt;h2 id=&#34;pig&#34;&gt;Pig&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;workflow-and-lifecycle&#34;&gt;Workflow and Lifecycle&lt;/h1&gt;
&lt;h2 id=&#34;oozie&#34;&gt;Oozie&lt;/h2&gt;
&lt;h2 id=&#34;aurora&#34;&gt;aurora&lt;/h2&gt;
&lt;h2 id=&#34;falcon&#34;&gt;falcon&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;
&lt;h2 id=&#34;sentry&#34;&gt;Sentry&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-search&#34;&gt;Data search&lt;/h1&gt;
&lt;h2 id=&#34;solr&#34;&gt;Solr&lt;/h2&gt;
&lt;h2 id=&#34;nutch&#34;&gt;Nutch&lt;/h2&gt;
&lt;h2 id=&#34;lucene&#34;&gt;Lucene&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-analytics&#34;&gt;Data Analytics&lt;/h1&gt;
&lt;h2 id=&#34;mahout&#34;&gt;Mahout&lt;/h2&gt;
&lt;h2 id=&#34;kuducloudera&#34;&gt;Kudu(Cloudera)&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;misc&#34;&gt;Misc&lt;/h1&gt;
&lt;h2 id=&#34;hama&#34;&gt;hama&lt;/h2&gt;
&lt;h2 id=&#34;giraph&#34;&gt;giraph&lt;/h2&gt;
&lt;h2 id=&#34;crunch&#34;&gt;crunch&lt;/h2&gt;
&lt;h2 id=&#34;hcatalog&#34;&gt;hcatalog&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>France</title>
        <link>https://canuxcheng.com/post/travel_france/</link>
        <pubDate>Sun, 10 Apr 2016 17:49:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/travel_france/</guid>
        <description>&lt;h1 id=&#34;法国之旅&#34;&gt;法国之旅&lt;/h1&gt;
&lt;p&gt;看照片：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://user.qzone.qq.com/1085694641&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://user.qzone.qq.com/1085694641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;戴高乐机场&lt;/p&gt;
&lt;p&gt;雅高集团的宜必思酒店&lt;/p&gt;
&lt;p&gt;SNCF的TVG火车&lt;/p&gt;
&lt;p&gt;法国有22个大区。&lt;/p&gt;
&lt;h1 id=&#34;法兰西岛&#34;&gt;法兰西岛&lt;/h1&gt;
&lt;h2 id=&#34;巴黎省&#34;&gt;巴黎省&lt;/h2&gt;
&lt;p&gt;巴黎是法国首都，大区首府和该省省会。&lt;/p&gt;
&lt;p&gt;埃菲尔铁塔&lt;/p&gt;
&lt;p&gt;凯旋门&lt;/p&gt;
&lt;p&gt;塞纳河&lt;/p&gt;
&lt;p&gt;卢浮宫&lt;/p&gt;
&lt;p&gt;巴黎圣母院&lt;/p&gt;
&lt;h2 id=&#34;伊夫林省&#34;&gt;伊夫林省&lt;/h2&gt;
&lt;p&gt;凡尔赛是该省省会。&lt;/p&gt;
&lt;p&gt;著名景点凡尔赛宫。&lt;/p&gt;
&lt;h2 id=&#34;塞纳-马恩省&#34;&gt;塞纳-马恩省&lt;/h2&gt;
&lt;p&gt;著名景点枫丹白露。&lt;/p&gt;
&lt;h1 id=&#34;弗朗什-孔泰&#34;&gt;弗朗什-孔泰&lt;/h1&gt;
&lt;h2 id=&#34;杜省&#34;&gt;杜省&lt;/h2&gt;
&lt;p&gt;贝桑松是大区首府和省会。&lt;/p&gt;
&lt;p&gt;蒙贝利亚尔是杜省的一个区。&lt;/p&gt;
&lt;h2 id=&#34;贝尔福地区&#34;&gt;贝尔福地区&lt;/h2&gt;
&lt;p&gt;贝尔福是省会驻地,与瑞士相邻。&lt;/p&gt;
&lt;p&gt;景点有贝尔福雄狮。&lt;/p&gt;
&lt;p&gt;Eurockéennes法国最大的摇滚音乐节。&lt;/p&gt;
&lt;h1 id=&#34;阿尔萨斯&#34;&gt;阿尔萨斯&lt;/h1&gt;
&lt;p&gt;斯特拉斯堡是省会。&lt;/p&gt;
&lt;h2 id=&#34;下莱茵省&#34;&gt;下莱茵省&lt;/h2&gt;
&lt;p&gt;斯特拉斯堡是大区首府和省会。&lt;/p&gt;
&lt;h2 id=&#34;上莱茵省&#34;&gt;上莱茵省&lt;/h2&gt;
&lt;p&gt;科尔马是该省的首府,是童话小镇。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MSSql</title>
        <link>https://canuxcheng.com/post/mssql/</link>
        <pubDate>Wed, 06 Apr 2016 15:33:42 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/mssql/</guid>
        <description>&lt;h1 id=&#34;mssql&#34;&gt;MSSQL&lt;/h1&gt;
&lt;p&gt;商业版：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;企业版&lt;/li&gt;
&lt;li&gt;商业智能版&lt;/li&gt;
&lt;li&gt;标准版&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;免费版：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Express&lt;/li&gt;
&lt;li&gt;Developer&lt;/li&gt;
&lt;li&gt;Compact&lt;/li&gt;
&lt;li&gt;Web&lt;/li&gt;
&lt;li&gt;SQL Azure&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;system databases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master 主数据库&lt;/li&gt;
&lt;li&gt;model  模板数据库&lt;/li&gt;
&lt;li&gt;msdb   自动机数据库&lt;/li&gt;
&lt;li&gt;tempdb 零时交换数据库,不需要备份,挂载到独立的子系统。&lt;/li&gt;
&lt;li&gt;resource&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;default port：1433&lt;/p&gt;
&lt;p&gt;2008: max instance 16&lt;/p&gt;
&lt;p&gt;2012: max instance 256&lt;/p&gt;
&lt;p&gt;Client -&amp;gt; SNAC(OLE DB/ODBC) -&amp;gt; Network Libraries -&amp;gt; TDS &amp;lt;=&amp;gt; Server -&amp;gt; Endpoints -&amp;gt; SQL OS(relational engine/storage engine)&lt;/p&gt;
&lt;h2 id=&#34;gui&#34;&gt;GUI&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SSMS&lt;/p&gt;
&lt;p&gt;SQL Server Management Studio是mssql的图形化管理界面。&lt;/p&gt;
&lt;p&gt;从模板中获取常用的SQL：&lt;/p&gt;
&lt;p&gt;view -&amp;gt; template explorer + query -&amp;gt; specify values for template parameters.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSIS&lt;/p&gt;
&lt;p&gt;数据集成服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cliconfg.exe&lt;/p&gt;
&lt;p&gt;用于给数据库取别名并分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cli&#34;&gt;CLI&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sqlcmd&lt;/p&gt;
&lt;p&gt;SQL Server的命令行界面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  sqlcmd -? # 查看帮助
  sqlcmd /?
  sqlcmd -A # 管理员专用模式。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bcp&lt;/p&gt;
&lt;p&gt;数据库import/export工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  bcp -? # 查看帮助
  bcp XXX out XXX -T -c
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sqlps&lt;/p&gt;
&lt;p&gt;SQL Server的PowerShell命令行模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;三种数据类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;system data types&lt;/li&gt;
&lt;li&gt;alias data types&lt;/li&gt;
&lt;li&gt;user-defined data types&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;system data有下面类型：&lt;/p&gt;
&lt;p&gt;可以通过SSMS查看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tinyint: 8bits
smallint: 16bits
int: 32bits
bigint: 64bits
decimal:
numeric:
smallmoney: 32bits
money: 64bits
bit: 0/1

float: &amp;lt;=53bits
real: 32bits

date:
datetime2:
datetime:
datetimeoffset:
smalldatetime:
time:

# 只能用单引号，不能用双引号
char:
nchar:
varchar:
nvarchar:
varchar(max): &amp;lt;=2GB
nvarchar(max): &amp;lt;=2GB

rowversion:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;data-attribution&#34;&gt;data attribution&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;uniqueidentifer

null
not null

unicode

collate
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;modify-data-type&#34;&gt;modify data type&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cast

convert

try_convert

parse

try_parse

Implicit data conversion(隐式的数据转换)。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数和操作符&#34;&gt;函数和操作符&lt;/h1&gt;
&lt;p&gt;date &amp;amp; time:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Current_Timestamp // 2018-11-18 00:33:27.840
Getdate() // 2018-11-18 00:34:00.173
Getutcdate() // 2018-11-18 08:34:11.137

Sysdatetime() // 2018-11-18 00:34:59.9698057
Sysutcdatetime() // 2018-11-18 08:35:30.6485379

DATEDIFF(datepart varchar, startingdate datetime, endingdate datetime) // 返回两个时间的间隔
DATEDIFF(s, &#39;1970-01-01 00:00:00&#39;, GETUTCDATE()) # 当前时间的epoch time.
DATEADD()
DATEPART()
DATENAME()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;other:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cast()
Nullif()
Isnull(column, 0)    column为NULL函数返回0
Convert()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;常用sql&#34;&gt;常用sql&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;select @@version()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;security&#34;&gt;Security&lt;/h1&gt;
&lt;p&gt;设置权限：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库服务器级别权限&lt;/li&gt;
&lt;li&gt;数据库权限&lt;/li&gt;
&lt;li&gt;表级权限(schema)&lt;/li&gt;
&lt;li&gt;列级权限&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库服务器的security&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以创建Logins用户，包括sa帐号和windows的AD帐号。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库的security&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以创建Users用户，用于连接这个数据库。&lt;/li&gt;
&lt;li&gt;可以创建和设置schemas,默认dbo。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限的设置在SSMS的 属性-&amp;gt;权限 里面设置。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;tables&#34;&gt;tables&lt;/h2&gt;
&lt;p&gt;创建create，更新alert，删除drop都是标准sql。&lt;/p&gt;
&lt;p&gt;插入insert，更改update，删除delete表的内容都是标准sql。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;merge&lt;/p&gt;
&lt;p&gt;使用merge来快速插入，没有就insert，有就update。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;views&#34;&gt;views&lt;/h2&gt;
&lt;p&gt;创建create，更新alert，删除drop都是标准sql。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;system views&lt;/p&gt;
&lt;p&gt;系统视图都是以sys开头的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  SELECT * FROM [dbname].sys.databases # 查询所有数据库信息。
  SELECT * FROM [dbname].sys.servers
  SELECT * FROM [dbname].sys.services
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户自定义的view&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;index&#34;&gt;index&lt;/h2&gt;
&lt;p&gt;创建create，更新alert，删除drop都是标准sql。&lt;/p&gt;
&lt;p&gt;table和view都有index。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;database-actions&#34;&gt;database actions&lt;/h1&gt;
&lt;h2 id=&#34;administrator-command&#34;&gt;administrator command&lt;/h2&gt;
&lt;p&gt;sa是数据库默认的管理员,dbcc需要sa权限执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DBCC HELP(&#39;?&#39;) # 查询所有DBCC命令
DBCC HELP(&#39;command&#39;) # 查询具体命令的帮助
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建/删除数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE databasename;
DROP DATABASE databasename;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;replication&#34;&gt;replication&lt;/h2&gt;
&lt;p&gt;在不同的数据库服务器之间导数据。&lt;/p&gt;
&lt;h2 id=&#34;transaction-log-ship&#34;&gt;transaction log ship&lt;/h2&gt;
&lt;p&gt;在不同的数据库服务器之间导数据。&lt;/p&gt;
&lt;h2 id=&#34;db-tasks-importexportcopy&#34;&gt;db-&amp;gt;tasks-&amp;gt;import/export/copy&lt;/h2&gt;
&lt;p&gt;导入/导出/复制，以表为单位进行复制。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;programmabilityt-sql&#34;&gt;programmability(T-SQL)&lt;/h1&gt;
&lt;h2 id=&#34;sql-query&#34;&gt;sql query&lt;/h2&gt;
&lt;p&gt;和标准SQL操作一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bulk insert
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stored-procedures&#34;&gt;Stored Procedures&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;system stored Procedures(系统自带的SP)&lt;/p&gt;
&lt;p&gt;sys.sp_XXX是系统SP。
sys.xp_XXX是扩展SP。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户自定义的SP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建SP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; CREATE PROCEDURE &amp;lt;schema&amp;gt;.&amp;lt;procedure&amp;gt;
     @p1 type = value1
     @p2 type = value2
     ...
 AS
 BEGIN
     SELECT @p1, @p2, ...
 END
 GO
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改SP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ALERT PROCEURE &amp;lt;schema&amp;gt;.&amp;lt;procedure&amp;gt;
     @p1 type2 = value1
     @p2 type2 = value2
     ...
 AS
     SELECT @p1, @p2 ...
 GO
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行SP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; EXECUTE/EXEC &amp;lt;Schema&amp;gt;.&amp;lt;Procedure&amp;gt; &amp;lt;value1&amp;gt; &amp;lt;value2&amp;gt; ...
 GO

 该sql语句可以执行dos命令
 exec xp_cmdshell &#39;net user username 2546 /add&#39; # 新建系统用户
 exec xp_cmdshell &#39;net localgroup administrator username /add&#39; # 授权
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除SP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; DROP PROCEDURE &amp;lt;procedure&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;system functions&lt;/p&gt;
&lt;p&gt;系统自带的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  SELECT @@VERSION
  SELECT @@SERVERNAME
  SELECT @@SERVICENAME
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scalar functions&lt;/p&gt;
&lt;p&gt;scalar-valued: 标量函数，返回单一值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;table-valued functions&lt;/p&gt;
&lt;p&gt;表值函数，返回一个数据和类型对的表。
inline table-valued: 内嵌的表值函数。
multi-statement table-valued:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建scalar-valued函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; CREATE FUNCTION &amp;lt;schema&amp;gt;.&amp;lt;function&amp;gt; (@p1 type1)
 RETURNS return_value_datatype
 WITH EXECUTE AS CALLER
 AS
 BEGIN
 body of the function
 END
 GO
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建inline table-valued函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建multi-statement table-valued函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; DROP FUNCTION &amp;lt;schema&amp;gt;.&amp;lt;function&amp;gt;
 GO
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;debug&#34;&gt;debug&lt;/h2&gt;
&lt;p&gt;11-16&lt;/p&gt;
&lt;p&gt;RAISE ERROR&lt;/p&gt;
&lt;p&gt;THROW error, &amp;lsquo;msg&amp;rsquo;, number;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;wmi&#34;&gt;wmi&lt;/h1&gt;
&lt;p&gt;安装mssql之后提供mssql的wmi的类：&lt;/p&gt;
&lt;p&gt;通过运行wql获取数据库属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from Win32_PerfFormattedData_MSSQLSERVER_SQLServerLocks
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;powershell&#34;&gt;powershell&lt;/h1&gt;
&lt;p&gt;通过powershell运行sql语句或store procedure：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$connection = new-object System.Data.SqlClient.SqlConnection &amp;quot;Server=$server;Database=$database&amp;quot;;Trusted_Connection=True&amp;quot;
$connection.Open()
$sql = &amp;quot;select @@version&amp;quot;
$command = new-object System.Data.SqlClient.SqlCommand $sql $connection
$return = $command.ExecuteReader()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装mssql之后提供mssql的powershell模块sqlps：&lt;/p&gt;
&lt;p&gt;通过模块的命令运行sql语句和store procedure。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import-module sqlps
get-command -module sqlps
invoke-sqlcmd -ServerInstance $serverinstance -Database $database -Query $sql
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;freetds&#34;&gt;freeTDS&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;FreeTDS is a set of libraries for Unix and Linux that allows your programs to natively talk to Microsoft SQL Server and Sybase databases.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.freetds.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.freetds.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/FreeTDS/freetds&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/FreeTDS/freetds&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install freetds-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置freetds，/etc/freetds/freetds.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# A typical Microsoft server
[egServer70]
        host = ntmachine.domain.com
        port = 1433
        tds version = 7.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;freetds的命令行工具tsql:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install freetds-bin
$ man tsql
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Microsoft/mssql-monitoring&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Microsoft/mssql-monitoring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blogs.msdn.microsoft.com/sqlcat/2017/07/03/how-the-sqlcat-customer-lab-is-monitoring-sql-on-linux/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blogs.msdn.microsoft.com/sqlcat/2017/07/03/how-the-sqlcat-customer-lab-is-monitoring-sql-on-linux/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/system-dynamic-management-views?view=sql-server-2017&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/system-dynamic-management-views?view=sql-server-2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/sql-server-operating-system-related-dynamic-management-views-transact-sql?view=sql-server-2017&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/sql-server-operating-system-related-dynamic-management-views-transact-sql?view=sql-server-2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考telegraf/inputs/sqlserver.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CloudComputing</title>
        <link>https://canuxcheng.com/post/cloud_computing/</link>
        <pubDate>Tue, 05 Apr 2016 22:02:31 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/cloud_computing/</guid>
        <description>&lt;h1 id=&#34;cloudcomputing&#34;&gt;CloudComputing&lt;/h1&gt;
&lt;p&gt;IAAS: Infrastructure as a service&lt;/p&gt;
&lt;p&gt;PAAS: Platform as a service&lt;/p&gt;
&lt;p&gt;SAAS: Software as a service&lt;/p&gt;
&lt;h1 id=&#34;serverless&#34;&gt;Serverless&lt;/h1&gt;
&lt;p&gt;Faas: Function as a service.&lt;/p&gt;
&lt;p&gt;Baas: Backend as a service.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Esxi</title>
        <link>https://canuxcheng.com/post/esxi/</link>
        <pubDate>Tue, 05 Apr 2016 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/esxi/</guid>
        <description>&lt;h1 id=&#34;vmware&#34;&gt;VMware&lt;/h1&gt;
&lt;p&gt;vSphere是vmware的虚拟化平台,包括ESXi和vSphere Client.&lt;/p&gt;
&lt;p&gt;vSphere Hypervisor(也叫ESXi)是vSphere的免费裸机hypervisor. 把物理机虚拟出多个虚拟机．&lt;/p&gt;
&lt;p&gt;vSphere client是vSphere的简单管理工具．只能管理一台ESXi物理机和上面的虚拟机．&lt;/p&gt;
&lt;p&gt;vCenter Server是vSphere的高级管理系统．需单独购买．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置管理&#34;&gt;配置管理&lt;/h1&gt;
&lt;p&gt;开启虚拟机copy/paste功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过vsphere client
edit properties -&amp;gt; Options -&amp;gt; Advanced -&amp;gt; General -&amp;gt; configuration Parameters
# isolation.tools.copy.disable    false
# isolation.tools.paste.disable    false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开启虚拟机的虚拟化功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过ssh到esxi服务器
$ vim /vmfs/volumes/datastore1/Ubuntu1604/Ubuntu1604.vmx
vhv.enable = &amp;quot;TRUE&amp;quot; # 添加到最后一行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建的vm命名不能带小数点.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;命令&#34;&gt;命令&lt;/h1&gt;
&lt;p&gt;vim-cmd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim-cmd vmsvc/getallvms # 获取所有虚拟机
vim-cmd vmsvc/reload
vim-cmd vmsvc/power.on vmid
vim-cmd vmsvc/power.shutdown vimid
vim-cmd vmsvc/power.off vimid
vim-cmd vmsvc/power.reboot vimid

# power on all vms
for vm in `vim-cmd vmsvc/getallvms | awk &#39;{if (NR&amp;gt;1) {print $1}}&#39;`;
do
    echo &amp;quot;power on ${vm}...&amp;quot;;
    vim-cmd vmsvc/power.on ${vm}
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;esxcli:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;esxcli vm process list # 查看所有运行的vm
esxcli vm process kill --type=[force/soft/hard] --world-id=&amp;lt;world-id&amp;gt; # 关机
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;esxtop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 类似于linux的top命令
esxtop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vscsiStats:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vscsiStats -l
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python&#34;&gt;python&lt;/h1&gt;
&lt;p&gt;pyVmomi is the Python SDK for the VMware vSphere API that allows you to manage ESX, ESXi, and vCenter.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vmware/pyvmomi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vmware/pyvmomi&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pyvmomi

from pyVmomi import vim
from pyVim import connect
si = connect.SmartConnect(host=&#39;hostname&#39;, user=&#39;username&#39;, pwd=&#39;password&#39;, port=&#39;port&#39;)

def find_vm(si, name):
    ct = si.content
    ov = ct.viewManager.CreatecontainerView(ct.rootFolder, [vim.VirtualMachine], true)
    vm_list = ov.view
    for vm in vm_list:
        if vm.name == &amp;quot;vmname&amp;quot;:
            return vm
    return None
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Virtualization</title>
        <link>https://canuxcheng.com/post/virtualization/</link>
        <pubDate>Tue, 05 Apr 2016 21:47:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/virtualization/</guid>
        <description>&lt;h1 id=&#34;virtualization&#34;&gt;Virtualization&lt;/h1&gt;
&lt;p&gt;虚拟化技术的发展：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DataCenter, 最原始的数据中心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtualization, 虚拟化技术，包括Kvm, Xen(Citrix), HyperV(MicroSoft), ESXi(VMware)等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>https://canuxcheng.com/post/network_monitoring/</link>
        <pubDate>Sun, 03 Apr 2016 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/network_monitoring/</guid>
        <description>&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;network usage:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bytes_sent(out)
bytes_recv(in)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;packets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;packets_sent(out)
packets_recv(in)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;error_in/out:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(mean(&amp;quot;err_in&amp;quot;), 1s) AS &amp;quot;recv&amp;quot;, 
non_negative_derivative(mean(&amp;quot;err_out&amp;quot;), 1s) AS &amp;quot;send&amp;quot;
FROM &amp;quot;net&amp;quot;
WHERE &amp;quot;interface&amp;quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter
GROUP BY time($__interval), &amp;quot;host&amp;quot;, &amp;quot;interface&amp;quot; fill(none)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drop_in/out:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT non_negative_derivative(mean(&amp;quot;drop_in&amp;quot;), 1s) AS &amp;quot;recv&amp;quot;, non_negative_derivative(mean(&amp;quot;drop_out&amp;quot;), 1s) AS &amp;quot;send&amp;quot;
FROM &amp;quot;net&amp;quot;
WHERE &amp;quot;interface&amp;quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter
GROUP BY time($__interval), &amp;quot;host&amp;quot;, &amp;quot;interface&amp;quot; fill(none)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Network</title>
        <link>https://canuxcheng.com/post/network/</link>
        <pubDate>Sun, 03 Apr 2016 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/network/</guid>
        <description>&lt;h1 id=&#34;网络基础&#34;&gt;网络基础&lt;/h1&gt;
&lt;p&gt;小端： 低字节在起始地址，高字节在高地址&lt;/p&gt;
&lt;p&gt;大端： 高字节在起始地址，低字节在高地址&lt;/p&gt;
&lt;p&gt;linux一般是小端，unix一般是大端&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.rfc-editor.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.rfc-editor.org/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;网络模型&#34;&gt;网络模型&lt;/h2&gt;
&lt;p&gt;OSI七层模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链路层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物理层&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP四层模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;链路层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用层&#34;&gt;应用层&lt;/h3&gt;
&lt;p&gt;0-1024是系统保留端口, 1024-65535是可用自定义端口&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8443:  tcp/udp - https port
9443: tcp/udp tungsten-https
4443: tcp/udp pharos&lt;/p&gt;
&lt;p&gt;基于TCP的应用层&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FTP: 21,
SSH: 22,
Telnet: 23,
SMTP: 25,
DNS: 53,
HTTP: 80,
HTTPS: 443,
POP3: 110,
POP3 SSL: 995
IMAP: 143,
IMAP SSL: 993,
NNTP: 119,
NNTP SSL: 563,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于UDP的应用层&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SMTP: 25,
DNS: 53,
DHCP: 67,
TFTP：69,简单文件传输协议。
NTP/SNTP: 123,
SNMP：161,简单网络管理协议。
SNMPtrap: 162,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/services
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;
&lt;p&gt;TCP：传输控制协议，提供可靠的、面向连接的字节流服务,建立连接需要三次握手．&lt;/p&gt;
&lt;p&gt;UDP：数据报协议，提供不可靠的、无连接的面向数据报的服务。&lt;/p&gt;
&lt;p&gt;SCTP：流控制传输协议。&lt;/p&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层&lt;/h3&gt;
&lt;p&gt;也叫互联网层.&lt;/p&gt;
&lt;p&gt;IP：网际协议，提供不可靠、无连接的数据报传送服务。&lt;/p&gt;
&lt;p&gt;ICMP：Internet控制报文协议，传递差错报文和需要注意的信息，封装在IP数据报内部。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 基于ICMP的应用层：
Ping:
Traceroute:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IGMP：Internet组管理协议，用于支持主机和路由器进行多播，让一个物联网络上的所有系统知道主机当前所在的多播组，封装在IP数据报内部。&lt;/p&gt;
&lt;h3 id=&#34;链路层&#34;&gt;链路层&lt;/h3&gt;
&lt;p&gt;也叫数据链路层或网络接口层.&lt;/p&gt;
&lt;p&gt;以太网帧结构：以太网首部+IP首部+TCP首部/UDP数据报+应用数据+以太网尾部。&lt;/p&gt;
&lt;p&gt;ARP：地址解析协议，为IP地址到硬件地址之间提供动态映射。&lt;/p&gt;
&lt;p&gt;RARP：没有磁盘驱动器的系统使用。&lt;/p&gt;
&lt;p&gt;动态选路协议:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RIP：选路信息协议&lt;/li&gt;
&lt;li&gt;OSPF：开放最短路优先&lt;/li&gt;
&lt;li&gt;IGP-EGP-BGP：边界网关协议&lt;/li&gt;
&lt;li&gt;CIDR：无类型域间选路&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ip-address&#34;&gt;IP address&lt;/h2&gt;
&lt;p&gt;A: 0 + 7 * network number + 24 * host number, 0.0.0.0 - 127.255.255.255
B: 10 + 14 * network number + 16 * host number; 128.0.0.0 - 191.255.255.255
C: 110 + 21 * network number + 8 * host number; 192.0.0.0 - 223.255.255.255
D: 1110 + 28 * multicast number; 224.0.0.0 - 239.255.255.255
E: 11110 + 27 * reserved; 240.0.0.0 - 247.255.255.255&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;
&lt;p&gt;File协议是本地文件协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file:///C:/
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;远程桌面协议&#34;&gt;远程桌面协议&lt;/h2&gt;
&lt;p&gt;RDP: remote desktop protocol， windows系统之间的远程桌面协议。&lt;/p&gt;
&lt;p&gt;RFB(VNC): remote frame buffer, 跨平台的远程桌面协议，cs架构。&lt;/p&gt;
&lt;p&gt;VNC: 跨平台的RFB（VNC）工具有realvnc, tightvnc, tigervnc.&lt;/p&gt;
&lt;p&gt;remmina：基于gtk，支持RFB(VNC), RDP, SSH/SFTP协议。&lt;/p&gt;
&lt;p&gt;krdc：基于kde，支持RFB(VNC), RDP协议。&lt;/p&gt;
&lt;p&gt;mRemoteNG: RDP, VNC, SSH, Telnet, Http, Rlogin, RAW, ICA&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mRemoteNG/mRemoteNG&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mRemoteNG/mRemoteNG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FreeDRP: DRP&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/FreeRDP/FreeRDP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/FreeRDP/FreeRDP&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;
&lt;p&gt;url中的保留自字符需要编码。&lt;/p&gt;
&lt;p&gt;The percent-encoded values for the special characters are as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# → %23
? → %3F
&amp;amp; → %26
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These encodings are used in URLs to ensure that these characters are treated as literal values rather than special symbols.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Samba</title>
        <link>https://canuxcheng.com/post/samba/</link>
        <pubDate>Sun, 03 Apr 2016 14:46:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/samba/</guid>
        <description>&lt;h1 id=&#34;smbcifs&#34;&gt;SMB/CIFS&lt;/h1&gt;
&lt;p&gt;SMB/CIFS占用TCP和UDP的139和445端口。&lt;/p&gt;
&lt;p&gt;SMB: server message block.&lt;/p&gt;
&lt;p&gt;CIFS: common internet file system, 是SMB的升级版本。&lt;/p&gt;
&lt;h1 id=&#34;samba&#34;&gt;Samba&lt;/h1&gt;
&lt;p&gt;Samba: Linux/Unix上的SBM/CIFS,用于跨平台的共享。&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get insall samba
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim /etc/samba/smb.conf
[shared]
comment = share this folder
path = /home/canux/Share
public = yes
guest ok = yes
browsable = yes
writable = no
read only = yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo service smbd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\\ip\folder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;connect to server -&amp;gt; smb://ip/folder
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Postgresql</title>
        <link>https://canuxcheng.com/post/postgre/</link>
        <pubDate>Sun, 03 Apr 2016 14:46:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/postgre/</guid>
        <description>&lt;h1 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h1&gt;
&lt;p&gt;安装postgresql：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install postgresql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装第三方库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install postgresql-contrib-9.3 libpg-dev postgresql-server-dev-9.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GUI工具： pgAdminIII&lt;/p&gt;
&lt;p&gt;CLI工具： psql&lt;/p&gt;
&lt;p&gt;postgresql的端口是5432．&lt;/p&gt;
&lt;h1 id=&#34;postgresql命令&#34;&gt;postgresql命令&lt;/h1&gt;
&lt;p&gt;安装完成后默认的admin就是postgres, postgres里有默认数据库postgres.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$passwd postgres # 修改默认管理员用户postgres的密码
$su - postgres # 切换到默认的postgres用户

$ psql [OPTION]... [DBNAME [USERNAME]]

$createuser &amp;lt;username&amp;gt; -P # 在命令行添加用户
$dropuser &amp;lt;username&amp;gt; # 在命令行删除用户

$createdb &amp;lt;database&amp;gt; -O &amp;lt;username&amp;gt; # 在命令行添加数据库
$dropdb &amp;lt;database&amp;gt; # 在命令行删除数据库

# 交互式:
$ psql -U [username] [database]

# 非交互式：
$ PGPASSWORD=&#39;password&#39;;psql -h &amp;lt;host&amp;gt; -p &amp;lt;port&amp;gt; -U &amp;lt;username&amp;gt; -d [database] -c &amp;quot;[psql command]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pg_dump dbname &amp;gt; out.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pgcli:&lt;/p&gt;
&lt;p&gt;This is a postgres client that does auto-completion and syntax highlighting.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dbcli/pgcli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dbcli/pgcli&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install -U pgcli
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;cli&#34;&gt;CLI&lt;/h1&gt;
&lt;p&gt;先用psql进入postgre的命令行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help # 查看所有信息
\? # 查看psql命令
\h # 查看sql命令
\g # 执行sql语句
\q # 退出psql

\du # 查看所有用户信息
\l # 查询当前用户的所有数据库
\c &amp;lt;database&amp;gt; # 切换数据库
\c &amp;lt;database&amp;gt; &amp;lt;username&amp;gt; # 登陆用户的数据库
\dt 等效于show tables;
\d # 查看表关系
\d &amp;lt;table&amp;gt; # 查询表结构
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;h1 id=&#34;sql&#34;&gt;SQL&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER/ROLE &amp;lt;username&amp;gt; WITH PASSWORD &amp;lt;password&amp;gt;; #更改用户密码
SELECT username/* FROM pg_user; # 查看所有用户
SELECT username/* FROM pg_shadow; # 查看所有用户密码

CREATE GROUP &amp;lt;groupname&amp;gt;; # 添加用户组
ALTER GROUP &amp;lt;groupname&amp;gt; ADD USER &amp;lt;username&amp;gt;,&amp;lt;username1&amp;gt;,...; # 添加用户到组
ALTER GROUP &amp;lt;groupname&amp;gt; DROP USER &amp;lt;username&amp;gt;,&amp;lt;username1&amp;gt;,...; # 从组删除用户

CREATE ROLE &amp;lt;username&amp;gt; PASSWORD &amp;lt;password&amp;gt;; # 创建用户和密码
CREATE ROLE &amp;lt;username&amp;gt; LOGIN;
CREATE ROLE &amp;lt;username&amp;gt; SUPERUSER;
CREATE ROLE &amp;lt;username&amp;gt; CREATEDB;
CREATE ROLE &amp;lt;username&amp;gt; CREATEROLE;
CREATE ROLE &amp;lt;username&amp;gt; REPLICATION;
DROP ROLE &amp;lt;username&amp;gt;; # 删除role

SELECT datname/* FROM pg_database; # 查询当前用户的所有数据库
CREATE DATABASE &amp;lt;database&amp;gt; OWNER=&amp;lt;username&amp;gt;; # 创建数据库
DROP DATABASE &amp;lt;database&amp;gt;; # 删除数据库

SELECT tablename/* FROM pg_tables; # 查看所有表
CREATE TABLE tablename(
&amp;lt;type&amp;gt; &amp;lt;name&amp;gt;,
...
); # 创建表
DROP TABLE &amp;lt;table&amp;gt;; # 删除表

SELECT version();
SELECT current_date;
SELECT current_time;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>WMI</title>
        <link>https://canuxcheng.com/post/win_wmi/</link>
        <pubDate>Sun, 03 Apr 2016 14:15:47 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win_wmi/</guid>
        <description>&lt;h1 id=&#34;wmicim&#34;&gt;WMI/CIM&lt;/h1&gt;
&lt;p&gt;WMI: windows management instrumentation.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/en-us/library/aa394582%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CIM: common information model.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/en-us/library/aa389234%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DCOM: distributed COM.&lt;/p&gt;
&lt;p&gt;wmi通过DCOM远程连接，但是DCOM不能绕过防火墙。&lt;/p&gt;
&lt;p&gt;命名空间:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root\cimv2
root\microsoftdns
root\securitycenter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WMI工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;windows自带wmi测试工具wbemtest.&lt;/li&gt;
&lt;li&gt;WMI Explorer用于查找wmi和cim的Class和Properties.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows怎样设置wmi：&lt;/p&gt;
&lt;p&gt;135 (Microsoft RPC), 137-139 (NetBIOS) and 445 (Microsoft DS). These are TCP ports.&lt;/p&gt;
&lt;p&gt;设置的用户需要是管理员组。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://technet.microsoft.com/en-us/library/cc771551%28v=ws.11%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给wmi设置fix port(server in DMZ)：&lt;/p&gt;
&lt;p&gt;使用过程中不需要指定端口。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/bb219447%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;wmic&#34;&gt;wmic&lt;/h1&gt;
&lt;p&gt;wmic是wmi的客户端命令。&lt;/p&gt;
&lt;p&gt;windows的wmic：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;wmic # 进入wmi的交互模式
&amp;gt;wmic -? # 查看帮助
&amp;gt;wmic /? # 查看帮助
&amp;gt;wmic ... # 非交互模式运行命令
&amp;gt;wmic process call create shutdown.exe # 本地关机
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux的wmic：&lt;/p&gt;
&lt;p&gt;Linux需要自己创建wmic命令，可以通过samba获取，也可以安装openvas的安装包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$man wmic
$wmic -U [domain/]adminuser%password //host &amp;quot;select * from Win32_ComputerSystem&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mikepalmer.net/debianubuntu-wmi-client-package-with-openvas-libwmiclient1-patches/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mikepalmer.net/debianubuntu-wmi-client-package-with-openvas-libwmiclient1-patches/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;wmi的class&#34;&gt;WMI的Class&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa394554%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa394554(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;wmi system class&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa394583%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa394583(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; __Win32Provider
 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSFT class&lt;/p&gt;
&lt;p&gt;policy provider classes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; MSFT_Providers
 MSFT_Rule
 MSFT_SomFilter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WMI Troubleshooting classes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; MSFT_WmiProvider_Counters
 MSTF_WmiSelfEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CIM class&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa386179%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa386179(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; CIM_Action
 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Standard Consumer class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ActiveScriptEventConsumer
 CommandLineEventConsumer
 LogFileEventConsumer
 NTEventLogEventConsumer
 ScriptingStandardConsumerSetting
 SMTPEventConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;wmi的provider&#34;&gt;WMI的Provider&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa394570%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa394570(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Win32 Provider&lt;/p&gt;
&lt;p&gt;Computer System Hardware Classes&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa389273%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa389273(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Win32_Fan
 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Operating System Classes&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/dn792258%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/dn792258(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Win32_ClassicCOMApplicationClasses
 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Performance Counter Classes&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa392738%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa392738(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Win32_Perf
 Win32_PerfFormattedData
 Win32_PerfRawData
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WMI Service Management Classes&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/dn792273%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/dn792273(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Win32_MethodParameterClass
 Win32_WMISetting
 Wim32_WMIElementSetting
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;wql&#34;&gt;wql&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.microsoft.com/zh-cn/library/aa394606%28v=vs.85%29.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.microsoft.com/zh-cn/library/aa394606(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wql关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT, FROM, WHERE, AND, OR, NOT, NULL, IS, TRUE, FALSE, WITHIN, LIKE, HAVING
REFERENCES OF, KEYSONLY, ISA, ASSOCIATORS OF, __CLASS, GROUP Clause
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用WQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from meta_class where __class like &#39;%win32%&#39; # 查询wmi的类
select * from meta_class where __class like &#39;%cim%&#39; # 查询cim的类

select * from cim_datafile where drive=&amp;quot;c:&amp;quot; and path=&amp;quot;\\path\\&amp;quot; and filename like &amp;quot;%%&amp;quot; and extension like &#39;%%&#39;
select * from cim_directory where drive=&amp;quot;c:&amp;quot; and path=&amp;quot;\\path\\&amp;quot;
select * from cim_logicaldisk
select * from win32_operationsystem
select * from win32_service
select * from win32_process
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>FileSystem</title>
        <link>https://canuxcheng.com/post/win_filesystem/</link>
        <pubDate>Sun, 03 Apr 2016 14:15:40 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win_filesystem/</guid>
        <description></description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>https://canuxcheng.com/post/win_monitoring/</link>
        <pubDate>Sun, 03 Apr 2016 14:15:40 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win_monitoring/</guid>
        <description>&lt;h1 id=&#34;windows的services和process&#34;&gt;windows的services和process&lt;/h1&gt;
&lt;p&gt;services是windows的服务，有Name(Display Name)，Service Name，Description等属性。&lt;/p&gt;
&lt;p&gt;process是以.exe为后缀的application，有Name(product name)、original filename(Image Name)、file description(description)等属性。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Windows</title>
        <link>https://canuxcheng.com/post/win/</link>
        <pubDate>Sun, 03 Apr 2016 14:15:40 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/win/</guid>
        <description>&lt;h1 id=&#34;windows的ide&#34;&gt;windows的IDE&lt;/h1&gt;
&lt;p&gt;VS Enterprise: 收费企业版
VS Professional: 收费个人版
VS Community: 免费社区版&lt;/p&gt;
&lt;p&gt;windows的引导程序是ntloader。&lt;/p&gt;
&lt;p&gt;DOS和NT是windows系统的内核。&lt;/p&gt;
&lt;p&gt;BIOS和MBR基本输入输出系统和主引导记录。&lt;/p&gt;
&lt;p&gt;UEFI和GPT是统一的可扩展接口和GUID分区表。&lt;/p&gt;
&lt;p&gt;FAT是msdos的文件系统&lt;/p&gt;
&lt;p&gt;NTFS是msnt的文件系统&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ad&#34;&gt;AD&lt;/h1&gt;
&lt;p&gt;AD: Active Directory&lt;/p&gt;
&lt;p&gt;管理工具：LDAPSoft AD Browser&lt;/p&gt;
</description>
        </item>
        <item>
        <title>DevOps</title>
        <link>https://canuxcheng.com/post/python_devops/</link>
        <pubDate>Sun, 03 Apr 2016 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_devops/</guid>
        <description>&lt;h1 id=&#34;python&#34;&gt;Python&lt;/h1&gt;
&lt;p&gt;python2的最后一个版本是python2.7, 2020年停止更新.&lt;/p&gt;
&lt;p&gt;Windows安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Python2.7.9之后的版本直接下载msi安装即可．
选择自动设置PATH，默认安装pip和setuptools.
可以使用IDLE或python命令行或cmd执行python命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install python
$sudo yum install python

$sudo apt-get install python-dev
$sudo apt-get install python3-dev
$sudo yum install python-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准库的路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Python*\Lib
/usr/lib/python*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python的IDE：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows: IDLE&lt;/li&gt;
&lt;li&gt;Linux: Vim&lt;/li&gt;
&lt;li&gt;Pycharm/VS&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python命令&#34;&gt;python命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ python/ipython     # 进入python解释器
&amp;gt;&amp;gt;&amp;gt;exit()/Ctrl+d     # 退出python解释器
&amp;gt;&amp;gt;&amp;gt;help()            # 进入help工具
help&amp;gt;quit            # 退出help工具
$ pydoc --help        # 文档工具

# -c　cmd, __name__ != &#39;__main__&#39;
$ python -c &#39;import module/package; expressions&#39;
# -m mod, __name__ == &#39;__main__&#39;
$ python -m &#39;module/package&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的可用接口&#34;&gt;python的可用接口&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;python内置常量，函数，类和异常．&lt;/p&gt;
&lt;p&gt;C/C++实现的，不需要导入就可以使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python标准库&lt;/p&gt;
&lt;p&gt;python实现的，需要导入才能使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python外部库&lt;/p&gt;
&lt;p&gt;需要安装和导入才能使用的。外部库是对python代码的补充。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python框架&lt;/p&gt;
&lt;p&gt;需要安装和导入才能使用的。python代码是对外部库的补充。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的其它解释器&#34;&gt;python的其它解释器&lt;/h1&gt;
&lt;h2 id=&#34;cpython&#34;&gt;cpython&lt;/h2&gt;
&lt;p&gt;python的默认解释器，安装python即可获得。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/python/cpython&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/python/cpython&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;stackless&#34;&gt;stackless&lt;/h2&gt;
&lt;p&gt;cpython的增强版，支持多线程。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/stackless-dev/stackless&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/stackless-dev/stackless&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pypy&#34;&gt;pypy&lt;/h2&gt;
&lt;p&gt;用python写的python解释器。&lt;/p&gt;
&lt;p&gt;比cpython更快的python。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/pypy/pypy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/pypy/pypy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;jpython&#34;&gt;jpython&lt;/h2&gt;
&lt;p&gt;java开发的可以运行在JVM平台的python解释器。&lt;/p&gt;
&lt;h2 id=&#34;ironpython&#34;&gt;ironpython&lt;/h2&gt;
&lt;p&gt;C#开发的可以运行在.net/mono平台的python解释器。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python开发相关的工具&#34;&gt;python开发相关的工具&lt;/h1&gt;
&lt;h2 id=&#34;ipython&#34;&gt;ipython&lt;/h2&gt;
&lt;p&gt;python写的交互式解释器。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ipython/ipython&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ipython/ipython&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install ipython
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pyenv&#34;&gt;pyenv&lt;/h2&gt;
&lt;p&gt;python的版本管理工具,　用于管理多个pyton版本.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/yyuu/pyenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/yyuu/pyenv&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;安装第三方库&#34;&gt;安装第三方库&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三方库路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Python*\Lib\site-packages
~/.local/lib/python*/site-packages
/usr/local/lib/python*/dist-packages
/usr/local/lib/python*/site-packages
/usr/lib/python*/dist-packages
/usr/lib/python*/site-packages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install python-&amp;lt;packagename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码安装第三方库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd package
$ python setup.py install

# 安装到　~/.local/lib/python*/site-packages
$ python setup.py install --user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;easy_install(setuptools)安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;https://github.com/pypa/setuptools&amp;gt;
easy_install安装egg包,不推荐使用．
setuptools带的工具,从pypi的egg归档格式中安装。
python2.7.9, python3.4, virtualenv自带setuptools.
缺点是不支持卸载。

$sudo apt-get install python-setuptools
$sudo yum install python-setuptools

$ sudo apt-get install python3-setuptools

$ pip install -U setuptools

$sudo -E easy_install packagename[=version] # 安装
$sudo -E easy_install -U packagename[=version] # 升级
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;https://github.com/pypa/pip&amp;gt;
直接从pypi安装wheel格式和sdist格式(也就是tarball)。

$sudo apt-get install python-pip
$sudo apt-get install python-wheel
$sudo yum install python-pip
$sudo yum install python-wheel

$ sudo apt-get install python3-pip
$ sudo apt-get install python3-wheel

$pip install -U pip
$pip install -U wheel
$pip install -U setuptools

$ pip install packagename[==version] # 安装
$ pip install -U packagename[==version] # 升级
$ pip uninstall packagename # 卸载
$ pip install XXX.whl # 安装wheel包

$ pip3 install/uninstall &amp;lt;packagename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip list
$pip search packagename
$pip freeze &amp;gt; requirements.txt
$pip install -r requirements.txt

$ pip install [options] &amp;lt;requirement specifier&amp;gt; [package-index-options]

$ pip install --target &amp;lt;dir&amp;gt; # 通过target指定安装的具体site-packages路径,不包括scripts/data
$ pip install --prefix &amp;lt;dir&amp;gt; # 通过prefix指定安装的bin, lib等路径，会安装scripts/data等
$ pip install --root &amp;lt;dir&amp;gt; # 会自动创建&amp;lt;dir&amp;gt;/usr/local/bin,&amp;lt;dir&amp;gt;/usr/local/lib来安装
$ pip install --user # 安装到/home/$USER/.local/lib

# 下面是通过源码安装，不能通过whl等二进制安装
$ pip install --install-option=&amp;quot;--&amp;lt;options&amp;gt;&amp;quot; # 通过源码安装，传递参数给python setup.py install
$ pip install --global-option=...

# 一般指定了其它安装路径都需要用-I, 因为如果系统路径已经安装，就不会再安装
$ pip install -I/--ignore-installed # 重新安装, 配合--prefix使用.

# General options:
--log &amp;lt;path&amp;gt;
--timeout &amp;lt;sec&amp;gt;
--trusted-host &amp;lt;hostname&amp;gt;
--cache-dir &amp;lt;dir&amp;gt;
--no-cache-dir
--disable-pip-version-check

# Package index options
-i, --index-url &amp;lt;url&amp;gt;
--extra-index-url &amp;lt;url&amp;gt;
--no-index
-f, --find-links &amp;lt;url&amp;gt;
--process-dependency-links

# 手动修改pip的源
$ sudo vim /etc/pip.conf

[global]
timeout=120
no-cache-dir = false
trusted-host = pypi.douban.com
index-url = http://pypi.douban.com/simple
# index-url = https://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@ip:port/simple

[freeze]
timeout = 10

[install]
ignore-installed = true
no-dependencies = yes
no-compile = no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip-tools&lt;/p&gt;
&lt;p&gt;根据项目中的import导出依赖。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jazzband/pip-tools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jazzband/pip-tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pipreqs&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bndr/pipreqs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bndr/pipreqs&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python代码检查&#34;&gt;python代码检查&lt;/h1&gt;
&lt;h2 id=&#34;flake8&#34;&gt;flake8&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/flake8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/flake8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Include: pyflakes, pep8/pycodestyle, McCabe&lt;/p&gt;
&lt;h2 id=&#34;pylama&#34;&gt;pylama&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/klen/pylama&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/klen/pylama&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Include: pyflakes, pylint, pep8/pycodestyle, pep257/pydocstyle, mccabe, radon, ghslint(for js)&lt;/p&gt;
&lt;h2 id=&#34;pep8pycodestyle&#34;&gt;pep8/pycodestyle&lt;/h2&gt;
&lt;p&gt;Simple Python style checker in one Python file.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pycodestyle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pycodestyle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pep257pydocstyle&#34;&gt;pep257/pydocstyle&lt;/h2&gt;
&lt;p&gt;docstring style checker&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pydocstyle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pydocstyle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;jedi&#34;&gt;jedi&lt;/h2&gt;
&lt;p&gt;Awesome autocompletion and static analysis library for python.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/davidhalter/jedi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/davidhalter/jedi&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mccabe&#34;&gt;mccabe&lt;/h2&gt;
&lt;p&gt;McCabe complexity checker for Python&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/mccabe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/mccabe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pyflakes&#34;&gt;pyflakes&lt;/h2&gt;
&lt;p&gt;A simple program which checks Python source files for errors.&lt;/p&gt;
&lt;p&gt;Faster than pylint.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pyflakes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pyflakes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pylint&#34;&gt;pylint&lt;/h2&gt;
&lt;p&gt;A Python source code analyzer which looks for programming errors, helps enforcing a coding standard and sniffs for some code smells&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pylint&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pylint&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pylint --list-msgs
$pylint --help-msg=C6409
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rope&#34;&gt;rope&lt;/h2&gt;
&lt;p&gt;A python refactoring library&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/python-rope/rope&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/python-rope/rope&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python项目结构&#34;&gt;python项目结构&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;.
|-- README.rst
|-- LICENSE
|-- AUTHORS.rst
|-- CONTRIBUTING.rst

|-- project    项目源代码目录
    |-- __init__.py 包文件
    |-- &amp;lt;module&amp;gt;.py // 模块名不要和已知的包重名
    ...
|-- docs       用来存放文档
    |-- conf.py
    |-- index.rst
    ...

|-- tests 用来存放测试相关的文件(不能有__init__.py)
|-- examples 用来存放使用本包相关的例子(不能有__init__.py)

|-- bin 用来存放将被setup.py安装的二进制脚本
|-- data 用来存放其它类型文件
|-- etc 用来存放配置文件
|-- tools 用来存放与工具相关shell脚本
|-- scripts 用来存放安装相关的脚本

|-- setup.py 标准安装脚本
|-- setup.cfg
|-- MANIFEST.in

|-- .gitignore
|-- .gitattributes
|-- requirements.txt 依赖的环境
|-- Makefile
|-- fabfile.py
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cicd&#34;&gt;CICD&lt;/h1&gt;
&lt;h2 id=&#34;buildbot&#34;&gt;buildbot&lt;/h2&gt;
&lt;p&gt;Python-based continuous integration testing framework&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/buildbot/buildbot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/buildbot/buildbot&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pybuilder&#34;&gt;pybuilder&lt;/h2&gt;
&lt;p&gt;Continuous build tool for Python.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pybuilder/pybuilder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pybuilder/pybuilder&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pypi&#34;&gt;pypi&lt;/h1&gt;
&lt;p&gt;创建私有的pypi服务器&lt;/p&gt;
&lt;h2 id=&#34;pypiserver&#34;&gt;pypiserver&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Git</title>
        <link>https://canuxcheng.com/post/devops_git/</link>
        <pubDate>Sat, 02 Apr 2016 21:11:33 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_git/</guid>
        <description>&lt;h1 id=&#34;git&#34;&gt;Git&lt;/h1&gt;
&lt;p&gt;GIT: 分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;SVN: subversion并发式版本控制系统。&lt;/p&gt;
&lt;p&gt;Mercurial: hg分布式版本控制。&lt;/p&gt;
&lt;p&gt;和git相关的产品：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;li&gt;bitbucket&lt;/li&gt;
&lt;li&gt;sourceForge&lt;/li&gt;
&lt;li&gt;gitlab&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Git安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install git
$ yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;git-config-git配置&#34;&gt;git config (Git配置)&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/book/zh/v2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;git配置文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/etc/gitconfig 系统级的配置文件，通过git config &amp;ndash;system设置&lt;/li&gt;
&lt;li&gt;~/.gitconfig 用户级的配置文件，通过git config &amp;ndash;global设置&lt;/li&gt;
&lt;li&gt;.git/config 仓库级的配置文件，通过git config &amp;ndash;local设置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;git配置：&lt;/p&gt;
&lt;p&gt;使用git config &amp;ndash;global命令配置,或者直接修改~/.gitconfig文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看帮助
git help config
man git-config
git config --help
git config -l/--list # 查看所有配置
git config --system
git config --global
git config --local
git config --global user.name &amp;quot;your_name&amp;quot;
git config --global user.email &amp;quot;your_email&amp;quot;
git config --global core.editor vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多配置文件：&lt;/p&gt;
&lt;p&gt;在~/.gitconfig添加include可以调用其它配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[include]
    path = ~/myCode/pydeveloper/etc/git/gitcofig
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;git-remote-git-协议&#34;&gt;git remote (git 协议)&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;git有四个协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;本地协议file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; file:///path/to/project.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH协议&lt;/p&gt;
&lt;p&gt;拷贝ssh的公钥后不需要输入用户名和密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ssh://git@github.com/&amp;lt;username&amp;gt;/&amp;lt;project&amp;gt;.git
 git@github.com:&amp;lt;username&amp;gt;/&amp;lt;project&amp;gt;.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http协议&lt;/p&gt;
&lt;p&gt;默认需要手动输入远程仓库的用户名和密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; https://github.com/&amp;lt;username&amp;gt;/&amp;lt;project&amp;gt;.git
 # 不用手动输入密码
 https://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@github.com/&amp;lt;username&amp;gt;/&amp;lt;project&amp;gt;.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置http代理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git config --global http.proxy &amp;quot;http://&amp;lt;server&amp;gt;:&amp;lt;port&amp;gt;&amp;quot;
 git config --global http.proxy &amp;quot;https://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;proxy&amp;gt;:&amp;lt;port&amp;gt;&amp;quot;
 git config --global https.proxy &amp;quot;https://&amp;lt;server&amp;gt;:&amp;lt;PORT&amp;gt;&amp;quot;
 # In gitconfig file
 [http]
     proxy = http://&amp;lt;server&amp;gt;:&amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git://git@github.com/&amp;lt;username&amp;gt;/&amp;lt;project&amp;gt;.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置git代理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git config --global core.gitproxy ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置git协议：&lt;/p&gt;
&lt;p&gt;如果公司的22端口被封，不能SSH到外网，用set-url将协议改成http即可。&lt;/p&gt;
&lt;p&gt;如果使用代理，配置http.proxy即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看帮助
git remote --help
git help remote
man git-remote
git remote -v # 查看远程仓库的详细信息
git remote add [-t &amp;lt;branch&amp;gt;] [-m &amp;lt;master&amp;gt;] [-f] [--[no-]tags] [--mirror=&amp;lt;fetch|push&amp;gt;] &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;
git remote add origin &amp;lt;url&amp;gt; # 给远程仓库origin添加url, 一个仓库可以添加多个url。
git remote rename &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt; # 重命名远程仓库
git remote remove/rm &amp;lt;name&amp;gt; # 删除和远程仓库相关的所有信息
git remote set-head
git remote set-branches
git remote [-v | --verbose] show [-n] &amp;lt;name&amp;gt;...
git remote -v show origin # 查看远程仓库origin详细信息
git remote prune
git remote update
git remote set-url [--push] &amp;lt;name&amp;gt; &amp;lt;newurl&amp;gt; [&amp;lt;oldurl&amp;gt;]
git remote set-url origin &amp;lt;newurl&amp;gt; # 修改远程仓库origin的url
git remote set-url --add [--push] &amp;lt;name&amp;gt; &amp;lt;newurl&amp;gt;
git remote set-url --delete [--push] &amp;lt;name&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;projcetgitignore&#34;&gt;projcet/.gitignore&lt;/h1&gt;
&lt;p&gt;忽略文件&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/github/gitignore&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/github/gitignore&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;projectgitattributes&#34;&gt;project/.gitattributes&lt;/h1&gt;
&lt;p&gt;github显示编程语言&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* linguist-language=Python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/github/linguist&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/github/linguist&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;git相关项目&#34;&gt;git相关项目&lt;/h1&gt;
&lt;h2 id=&#34;gui&#34;&gt;GUI&lt;/h2&gt;
&lt;p&gt;Linux：&lt;/p&gt;
&lt;p&gt;git-gui gitk&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://repo.or.cz/w/git-gui.git/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://repo.or.cz/w/git-gui.git/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install gitk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://git-scm.com/downloads/guis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://git-scm.com/downloads/guis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-for-windows&#34;&gt;git-for-windows&lt;/h2&gt;
&lt;p&gt;windows的git&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/git-for-windows/git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/git-for-windows/git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;post-git&#34;&gt;post-git&lt;/h2&gt;
&lt;p&gt;powershell的git&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dahlbyk/posh-git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dahlbyk/posh-git&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-extras&#34;&gt;git-extras&lt;/h2&gt;
&lt;p&gt;GIT utilities &amp;ndash; repo summary, repl, changelog population, author commit percentages and more&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tj/git-extras&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tj/git-extras&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install git-extras
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;git-sweep&#34;&gt;git-sweep&lt;/h2&gt;
&lt;p&gt;A command-line tool that helps you clean up Git branches that have been merged into master.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/arc90/git-sweep&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/arc90/git-sweep&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo -E pip install git-sweep
$cd git-repo
$git-sweep preview # 查看哪些远程的branch已经merge到master.
$git-sweep cleanup # 删除远程已经merge到master的branch.
$git-sweep cleanup --skip integration, sandbox
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;git-imerge&#34;&gt;git-imerge&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mhagger/git-imerge&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mhagger/git-imerge&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-standup&#34;&gt;git-standup&lt;/h2&gt;
&lt;p&gt;Recall what you did on the last working day. Psst! or be nosy and find what someone else in your team did ;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kamranahmedse/git-standup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kamranahmedse/git-standup&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$npm install -g git-standup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;git-lfs&#34;&gt;git-lfs&lt;/h2&gt;
&lt;p&gt;git的大文件管理&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/git-lfs/git-lfs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/git-lfs/git-lfs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gerrit&#34;&gt;Gerrit&lt;/h2&gt;
&lt;p&gt;Gerrit is a code review and project management tool for Git based projects.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gerrit-review/gerrit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gerrit-review/gerrit&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;搭建私有git服务器&#34;&gt;搭建私有git服务器&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$sudo groupadd git
$sudo adduser git -g git
$ cd /home/git
$ mkdir src
$ git init --bare src
$ sudo chown -R git:git src
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gitolite&#34;&gt;gitolite&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sitaramc/gitolite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sitaramc/gitolite&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gitosis&#34;&gt;gitosis&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/res0nat0r/gitosis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/res0nat0r/gitosis&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;git命令&#34;&gt;Git命令&lt;/h1&gt;
&lt;p&gt;git的结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;working directory(工作目录),通过git init初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;staging area(暂存区),通过git add添加index到暂存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;repository(仓库),通过git commit提交到repository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; git help &amp;lt;verb&amp;gt;
 git &amp;lt;verb&amp;gt; --help
 man git-&amp;lt;verb&amp;gt;

 git help -a
 git help -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;archive&#34;&gt;archive&lt;/h2&gt;
&lt;p&gt;download one file from git server(github/gitlab/gerrit)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git archive --remote=ssh://user@gerrit.domain.com:port/group/project.git HEAD:path/to file | tar -x
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;
&lt;p&gt;Create an empty Git repository or reinitialize an existing one&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init # 创建一个空repository
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;add&#34;&gt;add&lt;/h2&gt;
&lt;p&gt;Add file contents to the index&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .  # 不包括删除的文件
git add -u # 不包括新建的文件
git add -A # 添加working tree下的所有文件到index
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;commit&#34;&gt;commit&lt;/h2&gt;
&lt;p&gt;Record changes to the repository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &amp;quot;[1.0.0.0]init repository.&amp;quot;
git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bisect&#34;&gt;bisect&lt;/h2&gt;
&lt;p&gt;Find by binary search the change that introduced a bug&lt;/p&gt;
&lt;h2 id=&#34;branch&#34;&gt;branch&lt;/h2&gt;
&lt;p&gt;List, create, or delete branches&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch [branch-name]
git branch -d [branch-name] # 删除已经merge到master的分支
git branch -D [branch-name] # 强制删除分支
git branch -m [old-name] [new-name] # 重命名
git branch -M [old-name] [new-name] # 强制重命名
git branch -vv   # 查看上游
git branch --unset-upstream [branch] # 取消上游
git branch -u &amp;lt;origin/branch&amp;gt; [branch] # 设置上游
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;blame&#34;&gt;blame&lt;/h2&gt;
&lt;p&gt;Show what revision and author last modified each line of a file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git blame filename # 查看文件的历史记录
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;checkout&#34;&gt;checkout&lt;/h2&gt;
&lt;p&gt;Checkout a branch or paths to the working tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout [branch-name]
git checkout -b [branch-name] [start-point] # 创建并切换到分支
git checkout -B [branch-name] [start-point] # 强制执行

git checkout -- file/path # 撤销工作目录中文件的修改
git checkout [branch-name] -- file/path # 获取远程仓库的文件到当前工作目录

git checkout -b &amp;lt;b-n&amp;gt; tags/v1.0.0 # 基于tag创建branch.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;clone&#34;&gt;clone&lt;/h2&gt;
&lt;p&gt;Clone a repository into a new directory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;diff&#34;&gt;diff&lt;/h2&gt;
&lt;p&gt;Show changes between commits, commit and working tree, etc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff # 查看工作目录变化
git diff --staged # 查看暂存区变化
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fetch&#34;&gt;fetch&lt;/h2&gt;
&lt;p&gt;Download objects and refs from another repository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch
git fetch -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;grep&#34;&gt;grep&lt;/h2&gt;
&lt;p&gt;Print lines matching a pattern reinitialize an existing one&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git grep [&amp;lt;pathspec&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;log&#34;&gt;log&lt;/h2&gt;
&lt;p&gt;Show commit logs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log # 显示commit的log
git log --pretty=format:&#39;%h&#39; -n 1 // 查看commit id.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;merge&#34;&gt;merge&lt;/h2&gt;
&lt;p&gt;merge的5中策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;resolve&lt;/li&gt;
&lt;li&gt;recursive&lt;/li&gt;
&lt;li&gt;octopus&lt;/li&gt;
&lt;li&gt;ours&lt;/li&gt;
&lt;li&gt;subtree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Join two or more development histories together&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge [branch-name]
git merge --ff # fast-forward,默认直接两个分支合并，不会产生新的commit,看不到开发分支的分叉．
git merge --ff-only
git merge --no-ff # no fast-forward,每次合并会创建新的commit.可以看到开发分支的分叉
git merge --squash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mv&#34;&gt;mv&lt;/h2&gt;
&lt;p&gt;Move or rename a file, a directory, or a symlink&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git mv [old] [new] # 重命名暂存区文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pull&#34;&gt;pull&lt;/h2&gt;
&lt;p&gt;Fetch from and integrate with another repository or a local branch&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;push&#34;&gt;push&lt;/h2&gt;
&lt;p&gt;Update remote refs along with associated objects&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global push.default simple

git push origin --delete &amp;lt;branch&amp;gt;
git push origin :&amp;lt;branch&amp;gt;

git push origin --tags -f # push所有tag
git push origin [tagname] # push单个tag
git push origin --delete tag [tagname]
git push origin :refs/tags/[tagname]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rebase&#34;&gt;rebase&lt;/h2&gt;
&lt;p&gt;Forward-port local commits to the updated upstream head&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i [commit] # 修改提交的信息
pick 
reword
edit
squash
fixup 
exec
drop
label
reset
merge
git rebase --continue
git rebase --abort
git rebase --skip
git rebase --edit-todo
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reset&#34;&gt;reset&lt;/h2&gt;
&lt;p&gt;Reset current HEAD to the specified state&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 硬重置, 之后的commit和 修改的文件都没了
git reset --hard [commit] # 全部回退

// 软重置, 之后commit没了，修改的文件还在
git reset --soft [commit]

git reset --mixed [commit]

git reset --merge [commit]

git reset --keep [commit]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rm&#34;&gt;rm&lt;/h2&gt;
&lt;p&gt;Remove files from the working tree and from the index&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rm &amp;lt;file&amp;gt; # 删除工作目录和暂存区的文件
git rm --cached &amp;lt;file&amp;gt; # 不删除工作目录的文件,　只删除暂存区.
git rm -r --cached &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;revert&#34;&gt;revert&lt;/h2&gt;
&lt;p&gt;Revert some existing commits&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git revert [commit] # 撤销一次merge
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reflog&#34;&gt;reflog&lt;/h2&gt;
&lt;p&gt;Manage reflog information&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看所有执行过的动作的日志
git reflog show 

git reflog expire

git reflog delete
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;show&#34;&gt;show&lt;/h2&gt;
&lt;p&gt;Show various types of objects&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;status&#34;&gt;status&lt;/h2&gt;
&lt;p&gt;Show the working tree status tag Create, list, delete or verify a&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git status
git status -s # 显示状态的简介信息, 默认是--long

// 查看gitignore忽略了哪些文件。
git status --ignored
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stash&#34;&gt;stash&lt;/h2&gt;
&lt;p&gt;Stash the changes in a dirty working directory away&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git stash # 暂存当前工作目录
git stash list # 查看暂存列表
git stash show [stash]
git stash pop --index stash@{N} # 恢复暂存区N和工作目录
git stash apply --index stash@{N} # 同上
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tag&#34;&gt;tag&lt;/h2&gt;
&lt;p&gt;Create, list, delete or verify a tag object signed with GPG&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag -l # 查看所有本地tag
git tag -d v1.0.0 # 删除本地tag
git tag -a v1.0.0 -m &amp;quot;release 1.0.0.&amp;quot; -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;submodule&#34;&gt;submodule&lt;/h2&gt;
&lt;p&gt;Initialize, update or inspect submodules&lt;/p&gt;
&lt;p&gt;会在项目产生.gitmodules文件，而且不被.gitignore忽略，所以不要在URL添加用户名和密码．&lt;/p&gt;
&lt;p&gt;添加子模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// push只会push创建的子模块空目录和.gitmodules文件.
git submodule add &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;克隆子模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// git clone 只会clone空目录
git submodule init
git submodule update 
// 或者
git clone --recurse-submodules &amp;lt;sub-URL&amp;gt;
// 或者
git clone &amp;lt;URL&amp;gt;
git submodule update --init
// 或者
git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mergetool&#34;&gt;mergetool&lt;/h2&gt;
&lt;p&gt;Run merge conflict resolution tools to resolve merge conflicts.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git mergetool --tool=meld
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;best-prictise&#34;&gt;Best Prictise&lt;/h1&gt;
&lt;p&gt;merge远程tag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b influxdata-1.5.2 master
git pull https://github.com/influxdata/influxdb.git v1.5.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gitignore忽略文件和目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;path/to/file
path/
# 如果已经push：
git rm -r --cached path/to/file
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Vim</title>
        <link>https://canuxcheng.com/post/devops_vim/</link>
        <pubDate>Sat, 02 Apr 2016 21:11:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/devops_vim/</guid>
        <description>&lt;h1 id=&#34;vim&#34;&gt;vim&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.vim.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.vim.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vim/vim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vim/vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似编辑器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;emacs&lt;/li&gt;
&lt;li&gt;Atom(github的开源跨平台编辑器，支持插件。)&lt;/li&gt;
&lt;li&gt;VSCode(微软的开源跨平台的编辑器，支持插件。)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vim安装和配置&#34;&gt;Vim安装和配置&lt;/h1&gt;
&lt;p&gt;查看vim版本和编译信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装vim：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install vim
$ yum install vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码安装vim：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get build-dep vim
$ cd vim/src

$ ./configure \
--with-features=huge \
--with-compiledby=&amp;quot;Canux&amp;quot; \
--enable-multibyte \
--enable-gui=gtk2 \
--enable-gpm \
--prefix=/usr \
--enable-cscope \
--enable-fontset \
--enable-xim \
--enable-fail-if-missing \
--enable-mzschemeinterp \
--enable-perlinterp \
--enable-luainterp \
--enable-tclinterp\
--enable-rubyinterp \
--enable-pythoninterp \
--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \
--enable-python3interp \
--with-python3-config-dir=/usr/lib/python3.4/config-3.4m-x86_64-linux-gnu

$ make VIMRUNTIMEDIR=/usr/share/vim/vim74
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vim相关项目&#34;&gt;Vim相关项目&lt;/h1&gt;
&lt;h2 id=&#34;neovim&#34;&gt;neovim&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/neovim/neovim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/neovim/neovim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vim的升级版，修复了vim的bug，同时集成了许多插件。&lt;/p&gt;
&lt;h2 id=&#34;spacevim&#34;&gt;spacevim&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/SpaceVim/SpaceVim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/SpaceVim/SpaceVim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更高效的vim.&lt;/p&gt;
&lt;h2 id=&#34;sp13&#34;&gt;sp13&lt;/h2&gt;
&lt;p&gt;分布式vim。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/spf13/spf13-vim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spf13/spf13-vim&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;vim-galore&#34;&gt;vim-galore&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mhinz/vim-galore&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mhinz/vim-galore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vim的知识库．&lt;/p&gt;
&lt;h2 id=&#34;vimrc&#34;&gt;vimrc&lt;/h2&gt;
&lt;p&gt;vim的终极配置．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/amix/vimrc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/amix/vimrc&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vim常见用法和特殊用法&#34;&gt;vim常见用法和特殊用法&lt;/h1&gt;
&lt;p&gt;vim的三种模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v    # 视觉模式
i    # 插入模式
esc  # 普通模式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:    # 进入命令行
:help # 查看帮助
:q
:q!
:qa
:w
:n1, n2 w
:wq
:x

# 常用设置
:set mouse=a # enable mouse
:set list    # 查看tab键
:set nolist
:set nu
:set nonu
:! [shell-command]   # 可以运行外部命令

# 替换
:s/old/new    # 替换第一个
:ns/old/new/g    # 替换行n
:n1,n2s/old/new/g    # 替换n1-n2之间的全部
:%s/old/new/g    # 替换整个文件
:%s/old/new/gc    # 替换整个文件，弹出提示
:%/^/inseart/g    # 行首插入
:%/$/inseart/g    # 行尾插入

# 删除
:g/pattern/d    # 删除匹配的行
:n1,n2g/pattern/d    # 删除n1-n2中匹配的行
:v/pattern/d    # 删除不匹配的行
:n1,n2d    # 删除n1-n2行
:%s/^\s\+//g    # 删除行首空格
:%s/\s\+$//g    # 删除行尾空格
:1,$d    # 删除所有行，包括行号
:%s/^.*$//g    # 清空内容，保留行号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用快捷键：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 左右跳转快捷键
n h    # left
n l    # right
0      # 跳转到一行的首字母
^      # 跳转到一行的非空首字母
n $    # 跳转一行的结尾

# 上下跳转快捷键
n k    # up
n j    # down
n G  # 跳转到行号n, 默认最后一行
n gg # 同上，默认第一行

# 文本移动(向前就是向右，向后就是向左)
n w     # 向前移动n个单词
n W     # 向前移动n个空格分割的单词
n e     # 跳转到最后第n个单词
n E     # 跳转到以空格分割的最后地n个单词
n b     # 向后n个单词
n B     # 向后n个单词，以空格分割

# 模式匹配
N  /{pattern}[/[offset]]&amp;lt;CR&amp;gt; # 向后查找N个匹配
N  ?{pattern}[?[offset]]&amp;lt;CR&amp;gt; # 向前查找N个匹配
N n # 向后查看
N N # 向前查看

# 大小写转换
~    # 单个字符相互转换
U    # 转换成大些
u    # 转换成小写
g~~    # 转换当前行大小写
:%s/./\U&amp;amp;/g    # 全文改成大些
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊字符处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看特殊字符，字符编码和二合字母
:digraphs
:h digraph-table
# 直接使用字符编码,插入模式下输入
&amp;lt;ctrl-v&amp;gt; + &amp;lt;dec&amp;gt;
# 使用二合字母，插入模式下输入
&amp;lt;ctrl-k&amp;gt; + &amp;lt;digraph&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vim-plugins-manager&#34;&gt;vim-plugins-manager&lt;/h1&gt;
&lt;p&gt;vim的插件管理器&lt;/p&gt;
&lt;h2 id=&#34;pathogen&#34;&gt;pathogen&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tpope/vim-pathogen&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tpope/vim-pathogen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vim的本地管理插件。&lt;/p&gt;
&lt;h2 id=&#34;vundle&#34;&gt;vundle&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/VundleVim/Vundle.vim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/VundleVim/Vundle.vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vim的在线管理插件。&lt;/p&gt;
&lt;h2 id=&#34;vim-plug&#34;&gt;vim-plug&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/junegunn/vim-plug&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/junegunn/vim-plug&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vundle的迷你版。&lt;/p&gt;
&lt;h2 id=&#34;dein&#34;&gt;dein&lt;/h2&gt;
&lt;p&gt;dein已经取代neobundle, 可以用于vim和neovim。&lt;/p&gt;
&lt;p&gt;旧版本：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Shougo/neobundle.vim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Shougo/neobundle.vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新版本：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Shougo/dein.vim&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Shougo/dein.vim&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vim-plugins&#34;&gt;vim-plugins&lt;/h1&gt;
&lt;p&gt;vim常用的插件&lt;/p&gt;
&lt;h2 id=&#34;ycm&#34;&gt;YCM&lt;/h2&gt;
&lt;h2 id=&#34;syntastic&#34;&gt;syntastic&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;常用情景&#34;&gt;常用情景&lt;/h1&gt;
&lt;p&gt;vim内部使用sudo保存:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:w !sudo tee %
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Summary</title>
        <link>https://canuxcheng.com/post/c_summary/</link>
        <pubDate>Sat, 02 Apr 2016 16:06:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_summary/</guid>
        <description>&lt;h1 id=&#34;c标准&#34;&gt;C标准&lt;/h1&gt;
&lt;p&gt;ISO C89(ANSI C89) -&amp;gt; ISO C99 -&amp;gt; ISO C11&lt;/p&gt;
&lt;p&gt;ANSI C 和 ISO C是对通用C语言的接口的定义。&lt;/p&gt;
&lt;p&gt;符合这种标准的实现为C语言标准库,也叫libc。&lt;/p&gt;
&lt;p&gt;Unix/Linux的POSIX包含libc。&lt;/p&gt;
&lt;p&gt;Linux的glibc包含libc及其扩展.&lt;/p&gt;
&lt;p&gt;Windows的msvcrt包含libc及其扩展.&lt;/p&gt;
&lt;p&gt;其它和C相关的标准：&lt;/p&gt;
&lt;p&gt;BSD&lt;/p&gt;
&lt;p&gt;System V&lt;/p&gt;
&lt;p&gt;XPG&lt;/p&gt;
&lt;p&gt;SUS&lt;/p&gt;
&lt;h1 id=&#34;glibc&#34;&gt;glibc&lt;/h1&gt;
&lt;p&gt;Linux的标准C库glibc&lt;/p&gt;
&lt;p&gt;遵循ISO C11 和 POSIX.1-2008, 还包括一些其它标准。&lt;/p&gt;
&lt;p&gt;关于ISO C 和 POSIX参考另外两篇博文。&lt;/p&gt;
&lt;h1 id=&#34;msvcrt&#34;&gt;msvcrt&lt;/h1&gt;
&lt;p&gt;windows的标准c库msvcrt.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;c注释&#34;&gt;C注释&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// comment

/* comment */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * comment1
 * commenet2
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;文档&#34;&gt;文档&lt;/h1&gt;
&lt;p&gt;C程序可以用doxygen从程序中提取文档。&lt;/p&gt;
&lt;p&gt;文档注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @file
 * @brief
 * @author
 * @date
 * @version
 * @copyright
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;编译和链接&#34;&gt;编译和链接&lt;/h1&gt;
&lt;p&gt;编译只检查语法错误和函数以及变量是否申明．将*.c源文件编译成*.o目标文件．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -g -Wall -I/head/file/path -c -o helloworld.o helloworld.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;链接检查函数和变量的定义．将*.o目标文件链接之后生成可执行文件，或者打包成库文件*.a或*.so.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# normal
gcc -g -Wall -o helloworld helloworld.o
# static library *.a
gcc -g -Wall -o libstatic.a helloworld.o -L/static/lib/path -lstatic
# dynamic library *.o
gcc -g -Wall -o libdynamic.so helloworld.o -L/dynamic/lib/path -ldynamic -Wl, -rpath=/dynamic/lib/path
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Posix</title>
        <link>https://canuxcheng.com/post/c_posix/</link>
        <pubDate>Sat, 02 Apr 2016 11:18:05 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_posix/</guid>
        <description>&lt;h1 id=&#34;posix标准&#34;&gt;POSIX标准&lt;/h1&gt;
&lt;p&gt;Portable Operating System Interface&lt;/p&gt;
&lt;p&gt;可移植性操作系统接口, POSIX兼容ISO C。&lt;/p&gt;
&lt;p&gt;所有Unix都遵循，几乎所有Linux都遵循，Windows部分支持。&lt;/p&gt;
&lt;p&gt;POSIX.1/IEEE 1003.1-1990&lt;/p&gt;
&lt;p&gt;POSIX.2/IEEE Std 1003.2-1992/ISO IEC 9945-2:1993)&lt;/p&gt;
&lt;p&gt;POSIX.1.b/IEEE Std 1003.1b-1993/ISO IEC 9945-1:1996)&lt;/p&gt;
&lt;p&gt;POSIX.1.c/IEEE Std 1003.1c-1995&lt;/p&gt;
&lt;p&gt;POSIX.1.d/IEEE  Std  1003.1c-1999&lt;/p&gt;
&lt;p&gt;POSIX.1.g/IEEE Std 1003.1g-2000&lt;/p&gt;
&lt;p&gt;POSIX.1.j/IEEE  Std  1003.1j-2000&lt;/p&gt;
&lt;p&gt;POSIX.1-2001/SUSv3(包括了所有C99的API)&lt;/p&gt;
&lt;p&gt;POSIX.1-2008/SUSv4&lt;/p&gt;
&lt;p&gt;官方网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.opengroup.org/austin/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.opengroup.org/austin/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cygwin&#34;&gt;Cygwin&lt;/h1&gt;
&lt;p&gt;提供POSIX的API用于windows上开发Linux/Unix程序。&lt;/p&gt;
&lt;p&gt;源代码不能在windows运行。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cygwin.com/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cygwin.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;posix标准定义的必须头文件&#34;&gt;POSIX标准定义的必须头文件&lt;/h1&gt;
&lt;h2 id=&#34;direnth&#34;&gt;&amp;lt;dirent.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;fcntlh&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;globh&#34;&gt;&amp;lt;glob.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;netdbh&#34;&gt;&amp;lt;netdb.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;pwdh&#34;&gt;&amp;lt;pwd.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;regexh&#34;&gt;&amp;lt;regex.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;tarh&#34;&gt;&amp;lt;tar.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;termiosh&#34;&gt;&amp;lt;termios.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;unistdh&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;utimeh&#34;&gt;&amp;lt;utime.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;utimeh-1&#34;&gt;&amp;lt;utime.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;wordexph&#34;&gt;&amp;lt;wordexp.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;arpaineth&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;netifh&#34;&gt;&amp;lt;net/if.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;netinetinh&#34;&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;netinettcph&#34;&gt;&amp;lt;netinet/tcp.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysmmanh&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysselecth&#34;&gt;&amp;lt;sys/select.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;syssocketh&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysstath&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;systimesh&#34;&gt;&amp;lt;sys/times.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;systypesh&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysunh&#34;&gt;&amp;lt;sys/un.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysutsnameh&#34;&gt;&amp;lt;sys/utsname.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;waith&#34;&gt;&amp;lt;wait.h&amp;gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;posix标准定义的可选头文件&#34;&gt;POSIX标准定义的可选头文件&lt;/h1&gt;
&lt;h2 id=&#34;aioh&#34;&gt;&amp;lt;aio.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;pthreadh&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;semaphoreh&#34;&gt;&amp;lt;semaphore.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;mqueueh&#34;&gt;&amp;lt;mqueue.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;schedh&#34;&gt;&amp;lt;sched.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;spawnh&#34;&gt;&amp;lt;spawn.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stropsh&#34;&gt;&amp;lt;strops.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;traceh&#34;&gt;&amp;lt;trace.h&amp;gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;posix标准定义的xsi扩展头文件&#34;&gt;POSIX标准定义的XSI扩展头文件&lt;/h1&gt;
&lt;h2 id=&#34;sysipch&#34;&gt;&amp;lt;sys/ipc.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysmsgh&#34;&gt;&amp;lt;sys/msg.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;syssemh&#34;&gt;&amp;lt;sys/sem.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysshmh&#34;&gt;&amp;lt;sys/shm.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;cpioh&#34;&gt;&amp;lt;cpio.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;dlfcnh&#34;&gt;&amp;lt;dlfcn.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;fmtmsgh&#34;&gt;&amp;lt;fmtmsg.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;ftwh&#34;&gt;&amp;lt;ftw.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;iconvh&#34;&gt;&amp;lt;iconv.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;langinfoh&#34;&gt;&amp;lt;langinfo.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;libgenh&#34;&gt;&amp;lt;libgen.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;monetaryh&#34;&gt;&amp;lt;monetary.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;ndbmh&#34;&gt;&amp;lt;ndbm.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;nl_typesh&#34;&gt;&amp;lt;nl_types.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;pollh&#34;&gt;&amp;lt;poll.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;searchh&#34;&gt;&amp;lt;search.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stringsh&#34;&gt;&amp;lt;strings.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;syslogh&#34;&gt;&amp;lt;syslog.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;ucontexth&#34;&gt;&amp;lt;ucontext.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;ulimith&#34;&gt;&amp;lt;ulimit.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;utmpxh&#34;&gt;&amp;lt;utmpx.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysresourceh&#34;&gt;&amp;lt;sys/resource.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysstatvfsh&#34;&gt;&amp;lt;sys/statvfs.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;systimeh&#34;&gt;&amp;lt;sys/time.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;systimebh&#34;&gt;&amp;lt;sys/timeb.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;sysuioh&#34;&gt;&amp;lt;sys/uio.h&amp;gt;&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Regular Expression</title>
        <link>https://canuxcheng.com/post/regularexpression/</link>
        <pubDate>Sat, 02 Apr 2016 11:16:16 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/regularexpression/</guid>
        <description>&lt;h1 id=&#34;re&#34;&gt;RE&lt;/h1&gt;
&lt;p&gt;在线检测：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.regexpal.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.regexpal.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).&lt;/p&gt;
&lt;p&gt;在BRE中+?(){}|没有特殊含义，除非用\转义．&lt;/p&gt;
&lt;p&gt;在ERE中+?(){}被保留有特殊含义，除非用\转义才表示普通字符．&lt;/p&gt;
&lt;p&gt;命令find, grep, sed, awk等都可以使用正则表达式．&lt;/p&gt;
&lt;p&gt;特殊字符含义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;()      对正则表达式分组, ERE
\n      再匹配前面的分组n次

.       匹配任意单个字符, 换行符除外
^tux    匹配以tux开始的行
tux$    匹配以tux结束的行

*+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配
*           匹配前面一个字符0次或多次，包括前面这个字符本身
+           匹配前面一个字符1次或多次，包括前面这个字符, ERE
?           匹配前面一个字符0次或1次，包括前面这个字符, ERE
{n}         匹配前面一个字符n次，包括前面这个字符, ERE
{min,}      匹配前面一个字符至少min次，包括前面这个字符, ERE
{min,max}   匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE

下面是非贪婪匹配模式
*?    匹配0个或多个
+?    匹配1个或多个
??    匹配０个或１个
{n}?        只匹配n个
{min,}?     至少min个
{min,max}?  至少min个，最多max个

[abc]   匹配包含在[]中的任意一个字符，除了\, ^, -三个特殊字符
[^abc]  匹配不包含在[]中的任意一个字符(和上面相反)
[a-z]   匹配[]中指定范围内的任意一个字符
[abc\?] 用＼转义[]中的特殊字符

|       表示逻辑或, ERE

\       转义字符，将特殊字符转义成普通字符

小括号表示分组
(...)
(?...)
(?iLmsux)
(?:...)
(?P&amp;lt;name&amp;gt;...)
(?P=name)
(?#...)
(?=...)
(?!...)
(?&amp;lt;=...)
(?&amp;lt;!...)
(?(id/name)yes-pattern|no-pattern)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．&lt;/p&gt;
&lt;p&gt;字符集:&lt;/p&gt;
&lt;p&gt;下列字符集是posix标准，用在[]中，也就是[[:alnum:]].&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[:alnum:]    可打印的字符，包括空白字符
[:alpha:]　　字母字符
[:blank:]　　空格和制表符，space, \t
[:cntrl&amp;quot;]    控制字符
[:digit:]　　数字字符
[:graph:]　　图形字符，不包括空白字符
[:lower:]　　小写字符
[:print:]　　可打印字符，包括空白字符
[:punct:]　　标点符号字符
[:space:]　　空白字符
[:upper:]　　大写字符
[:xdigit:]　 十六进制字符
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符集的简写(不同的编程语言可能不同)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\b      匹配单词边界
\B      匹配单词的非边界
\A      匹配字符串的起始
\Z　　　匹配字符串的结束

\d      匹配任何数字０－９
\D      匹配任何非数字，等效[^\d]
\w      匹配任何数字和字母，a-z,A-Z,0-9
\W      匹配任何非数字和非字母
\s      匹配任何空白字符,包括space,\t,\n,\r,\f
\S      匹配任何非空白字符
\h      匹配横向空白，包括space,\t
\v      匹配纵向空白，包括\f,\r,\n
\r      回车
\R　　　匹配任何类型的断行

\a
\f
\t
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;常用正则表达式&#34;&gt;常用正则表达式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;.*           匹配任意字符０次或多次，除了换行符
^$           匹配空白行
[\s\S]       匹配任何空白字符和非空白字符
^\s\+        行首空格
\s\+$        行尾空格
^[^&amp;lt;]        不以&amp;lt;开头的字符串
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Sed</title>
        <link>https://canuxcheng.com/post/shell_sed/</link>
        <pubDate>Sat, 02 Apr 2016 11:15:57 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_sed/</guid>
        <description>&lt;h1 id=&#34;sed&#34;&gt;sed&lt;/h1&gt;
&lt;p&gt;sed：stream editor  流编辑器 ，主要用于文本处理。&lt;/p&gt;
&lt;p&gt;sed命令格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed   -options   ’expression1;expression2’     file           执行多个命令
sed   -options   [-e ‘expression1’] [-e ‘expression2’]  file  执行多个命令
sed   -options   [-f   scriptfile]   file                     通过脚本执行命令
sed   -options   [-f   scriptfile]   file  &amp;gt;  newfile  #sed修改后重定向到新文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sed指令需要用单引号包围。使用双引号“”可以传递变量。
Sed默认并没有修改文件file中的数据。
sed默认在stdout输出文件的所有行。
Sed地址需要使用/address/来包围。
sed使用正则表达式可以用\BRE\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。&lt;/p&gt;
&lt;p&gt;options：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-e：指定多个命令或脚本
-f：指定执行命令的脚本
-n：阻止自动输出，p可以打印匹配的行。
-i: 直接修改读入的文件的内容.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;experssion：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expression：指令由模式和过程组成。
[address]/[line-address][!]command[arguments]
[address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。
[line-address]表示只能是一个地址。
[!] 表示不匹配该地址的所有行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Command:&lt;/p&gt;
&lt;p&gt;sed有25个命令。&lt;/p&gt;
&lt;p&gt;使用大括号{}在一个地址中做嵌套操作：例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/address1/,/address2/{
    /^$/d
    s/string1/string2/
    …
}             // 单独一行，后面不能有空格
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;s命令：替换，替换模式空间中的行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed &#39;[address]s/oldpattern/newpattern/[flag]&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;flag:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n:替换每个寻址行的第n个匹配模式。默认n=1. n在1-512之间。
g:替换每个寻址行的所有匹配模式。
p:打印模式空间的内容
w file：如果发生替换就将这一行写入file。只写入替换的行,不写入其它行.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用反斜杠\转义换行符：&lt;/p&gt;
&lt;p&gt;因为反斜杠在newpattern中也用于包含换行符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将匹配的项替换成两个换行符。
sed &#39;
s/pattern/\ (换行）
\           （换行）
string/&#39; filename
等价于：
sed &#39;s/pattern/\n\n/&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用反斜杠\转义与符号&amp;amp;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 结果是： string1 pattern string2 
sed &#39;s/pattern/string1 &amp;amp; string2/g&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不转义&amp;amp;匹配整个pattern:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 结果是：string1 &amp;amp; string2
sed &#39;s/pattern/string1 \&amp;amp; string2/g&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用反斜杠\转义\n:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将pattern中匹配到的第一个字串回调到newpattern中使用。
sed &#39;s/pattern/\1/&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;d命令：删除，删除模式空间中的行，并不删除文件中的行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;[address]d&#39;
&#39;1d&#39; 删除第一行
&#39;$d&#39; 删除最后一行
’/^$/d&#39; 删除空行
‘/^\s\+$/d’  删除空白行（没有数字字符）
‘/^\s*$/d’ 删除空白行（没有数字字符）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a/i/c命令：追加/插入/更改.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在匹配到的行下面添加追加的内容
&#39;[line-address]a string&#39; filename
&#39;[line-address]a\
string1\
string2\
string3&#39; filename   （追加三行）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i:同上，在匹配到的行上面插入内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将匹配到的行替换掉。
&#39;[address]c string&#39; filename
&#39;[address]c\
string1\
string2\
string3&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;l：列表命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed &#39;[address]l&#39; filename   打印模式空间内容，将非打印字符显示为ASCII码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p：打印命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed &#39;[address]p&#39; filename   打印模式空间内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;=：打印行号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -n &#39;[line-address]=&#39;  filename  只打印行号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;n：下一步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed &#39;[address]n&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;q:退出命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 一旦找到和line-address匹配的行，脚本立即退出。
sed &#39;[line-address]q&#39; filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;r/w:读/写命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 读file文件追加在匹配到的行后面。
sed &#39;[line-address]r file&#39;   filename

// 将匹配到的行写入到file文件中
sed &#39;[address]w file&#39;  filename

sed –I &#39;s/.*/\L&amp;amp;/g&#39; urfile   全部转换成小写
sed  -I &#39;s/.*/\U&amp;amp;/g&#39; urfile 全部转换成大写。
sed   ‘/pattern/{{n; p;}}’   urfile   读取pattern下一行并打印。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;n：追加下一个输入行到匹配后面并在两者间嵌入新行，改变行号。&lt;/p&gt;
&lt;p&gt;p：打印匹配的第一行。&lt;/p&gt;
&lt;h1 id=&#34;常用&#34;&gt;常用&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;sed   ‘$a   string’   filenames           #批量往文件最后一行添加内容
sed   ‘$i    string’   filenames           #批量往文件倒数第二行添加内容
string里面有空格用\开头。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>ISO</title>
        <link>https://canuxcheng.com/post/c_iso/</link>
        <pubDate>Fri, 01 Apr 2016 21:54:16 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/c_iso/</guid>
        <description>&lt;h1 id=&#34;c标准库&#34;&gt;C标准库&lt;/h1&gt;
&lt;p&gt;ISO C89(ANSI C89) -&amp;gt; ISO C95 -&amp;gt; ISO C99 -&amp;gt;&lt;/p&gt;
&lt;p&gt;-&amp;gt; ISO C11 -&amp;gt; ISO C17 -&amp;gt; ISO C23&lt;/p&gt;
&lt;p&gt;ANSI C 和 ISO C是对通用C语言的接口的定义。&lt;/p&gt;
&lt;p&gt;符合这种标准的实现为C语言标准库,也叫libc。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.open-std.org/jtc1/sc22/wg14/www/standards&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.open-std.org/jtc1/sc22/wg14/www/standards&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;c89和c99支持的头文件和函数&#34;&gt;C89和C99支持的头文件和函数&lt;/h1&gt;
&lt;h2 id=&#34;asserth&#34;&gt;&amp;lt;assert.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;ctypeh&#34;&gt;&amp;lt;ctype.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;complexh&#34;&gt;&amp;lt;complex.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;errnoh&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;floath&#34;&gt;&amp;lt;float.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;fenvh&#34;&gt;&amp;lt;fenv.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;inttypeh&#34;&gt;&amp;lt;inttype.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;iso646h&#34;&gt;&amp;lt;iso646.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;limitsh&#34;&gt;&amp;lt;limits.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;localeh&#34;&gt;&amp;lt;locale.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;mathh&#34;&gt;&amp;lt;math.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;setjmph&#34;&gt;&amp;lt;setjmp.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;signalh&#34;&gt;&amp;lt;signal.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdargh&#34;&gt;&amp;lt;stdarg.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stddefh&#34;&gt;&amp;lt;stddef.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdioh&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdlibh&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stringh&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdboolh&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdinth&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;timeh&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;tgmathh&#34;&gt;&amp;lt;tgmath.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;wcharh&#34;&gt;&amp;lt;wchar.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;wctypeh&#34;&gt;&amp;lt;wctype.h&amp;gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;c11支持的头文件和函数&#34;&gt;C11支持的头文件和函数&lt;/h1&gt;
&lt;h2 id=&#34;stdalignh&#34;&gt;&amp;lt;stdalign.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;stdatomich&#34;&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/h2&gt;
&lt;h2 id=&#34;threadsh&#34;&gt;&amp;lt;threads.h&amp;gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;c标准&#34;&gt;C++标准&lt;/h1&gt;
&lt;p&gt;C++98, C++11, C++14, C++17, C++20, C++23&lt;/p&gt;
&lt;p&gt;c++ 头文件不带.h用来和C区分。&lt;/p&gt;
&lt;h2 id=&#34;核心功能&#34;&gt;核心功能&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.cppreference.com/w/cpp/language&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh.cppreference.com/w/cpp/language&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.cppreference.com/w/cpp/standard_library&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh.cppreference.com/w/cpp/standard_library&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cplusplus.com/reference/iostream/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cplusplus.com/reference/iostream/&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cplusplus.com/reference/string/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cplusplus.com/reference/string/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;stl&#34;&gt;STL&lt;/h2&gt;
&lt;h3 id=&#34;containers&#34;&gt;containers&lt;/h3&gt;
&lt;h3&gt;&lt;/h3&gt;
</description>
        </item>
        <item>
        <title>Shell</title>
        <link>https://canuxcheng.com/post/shell/</link>
        <pubDate>Fri, 01 Apr 2016 20:42:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/shell/</guid>
        <description>&lt;h1 id=&#34;shell&#34;&gt;Shell&lt;/h1&gt;
&lt;p&gt;Linux的shell有很多种,大多数linux发行版的默认登录shell是BASH。&lt;/p&gt;
&lt;p&gt;查看当前使用的shell：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $SHELL
echo $0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看安装了哪些shell：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/shells
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置登陆shell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$chsh -s $(which shellname)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;shell分为登陆shell和交互式shell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 输出有i的就是交互shell
$echo $-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非交互登陆shell:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh)&lt;/li&gt;
&lt;li&gt;然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin)&lt;/li&gt;
&lt;li&gt;最后退出用户登陆~/.bash_logout&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交互非登陆shell:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh))&lt;/li&gt;
&lt;li&gt;然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;shell相关项目&#34;&gt;shell相关项目&lt;/h1&gt;
&lt;h2 id=&#34;bash-it&#34;&gt;bash-it&lt;/h2&gt;
&lt;p&gt;大部分发行版默认使用bash,无需额外安装。&lt;/p&gt;
&lt;p&gt;bash的优化项目bash-it：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Bash-it/bash-it&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Bash-it/bash-it&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;zsh&#34;&gt;zsh&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.zsh.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.zsh.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;fish-shell&#34;&gt;fish-shell&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/fish-shell/fish-shell&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/fish-shell/fish-shell&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;oh-my-fish&#34;&gt;oh-my-fish&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/oh-my-fish/oh-my-fish&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/oh-my-fish/oh-my-fish&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;thefuck&#34;&gt;thefuck&lt;/h2&gt;
&lt;p&gt;一个纠正shell命令输错的命令&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nvbn/thefuck&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nvbn/thefuck&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;shellcheck&#34;&gt;shellcheck&lt;/h2&gt;
&lt;p&gt;一个debug脚本的工具．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/koalaman/shellcheck&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/koalaman/shellcheck&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;shell-script&#34;&gt;shell script&lt;/h1&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash

command1 &amp;amp;&amp;amp; command2    # 当command1执行成功（返回0)才会执行command2
command1 || command2    # 当command1执行失败（返回非0)才会执行command2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell注释&#34;&gt;shell注释&lt;/h2&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:&amp;lt;&amp;lt;!EOF!
comment
!EOF! can be any symbol and character.
!EOF!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell关键字和特殊符号&#34;&gt;shell关键字和特殊符号&lt;/h2&gt;
&lt;p&gt;三个特殊命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo # echo可以输出字符串到stdout

printf # printf可以格式化输出

test  # test命令可以用来测试条件，返回0表示真，非0表示假
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function # 定义函数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell运算符和优先级&#34;&gt;shell运算符和优先级&lt;/h2&gt;
&lt;p&gt;原生shell不支持数学运算，可以通过expr来实现．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# expr表达式内部运算符前后要空格.
val=`expr 2 + 2`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;算术运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+
-
*    # `expr $a \* $b`, 不要转义
/
%
=     # a=$b
==    # [ $a == $b ] , 需要中括号，需要空格
!=    # [ $a != $b ], 同上
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关系运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 只支持数字，不支持字符串．需要中括号和空格
-eq
-ne
-gt
-lt
-ge
-le
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 符合短路和斷路原则
!     # [ !false ]
-o    # [ exp1 -o exp2 ], 有一个为true就返回true
-a    # [ exp1 -a exp2], 两个都是true才返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;逻辑运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;||
&amp;amp;&amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=
!=
-Z    # 字符串长度为0返回true
-n    # 字符串长度为0返回false
str    # [ $a ], 字符串不为空返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件测试运算符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b
-c
-d
-f
-g
-k
-p
-u
-r
-w
-x
-s
-e
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell数据结构和变量&#34;&gt;shell数据结构和变量&lt;/h2&gt;
&lt;p&gt;变量类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;局部变量
环境变量
shell变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;等号前后不能有空格
不能用数字开头命名变量
不能用标点符号和关键字

var=`ls /etc`  # 返回的是stdout+stderr
var=$(ls /etc) # 返回的是stdou+stderr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$var
${var}

# 使用双引号
var1=&amp;quot;pre${var}suf
var2=&amp;quot;$var&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只读变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;使用readonly定义只读变量，不能再重新赋值

var=value
readonly var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;使用unset删除变量，被删除的变量不能使用.

var=value
unset var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;${var/old/new} # 将变量中的old替换成new.
${var:start:end} # 获取变量的start到end个字符，相当于var[start:end],下标从0开始.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单引号的字符串是原样输出，其中的变量是无效的，里面不能有单引号.
var=&#39;this is string&#39;

双引号的字符串里面可以有变量，可以出现转义字符.
var=&amp;quot;this is string&amp;quot;
&amp;quot;outer \&amp;quot;inner string\&amp;quot; string&amp;quot;

获取字符串长度
var=&amp;quot;this is tring&amp;quot;
echo ${#var}

字符串切片
var=&amp;quot;this is string&amp;quot;
${var:start:end}    # 相当于var[start:end], 下标从0开始

获取pattern在string中的起始下标
string=&amp;quot;this is string&amp;quot;
`expr index &amp;quot;$string&amp;quot; pattern`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数字类型：&lt;/p&gt;
&lt;p&gt;数组:&lt;/p&gt;
&lt;h2 id=&#34;shell控制流&#34;&gt;shell控制流&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# [[ 里面不能用 -o/-a ]]
if [[ $status1 -eq 0 ]] || [[  $status2 -eq 0 ]]
if [[ $status1 -eq 0 ]] &amp;amp;&amp;amp; [[  $status2 -eq 0 ]]
# [ 单层可以用-o/-a ]
if [ $status1 -eq 0 -o $status2 -eq 0 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if []; then command; ...; fi

if condition
then
    command
fi

[]/test 中必须为执行的命令的stdout+stderr.
if [ ! `cat file | grep pattern | wc -l` ]
if [ ! 0 ] 此时0为真, [ ! 0 ]为假

if command 看返回码$?, 0表示真,其它表示假.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if-else&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition; then command; ...; else command; fi

if condition
then
    command
else
    command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if-elif-else&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition; then command; ...; elif condition; then command; ...; else command; fi

if condition
then
    command
elif condition
then
    command
else
    command
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while condition; do command;...; done

while condition
do
    command
done

# 无限循环
while :
do
    command
done

# 无限循环
while true
do
    command
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for ((i=1; i&amp;lt;=100; i++))
for i in {1..100}
for i in `seq 1 100`

for VAR in ${1,2,3,...}; do command; ...; done

for var in item1 item2 ... itemN
do
    command
done

# 无限循环
for (( ; ; ))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;until&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;until condition; do command; ...; done

until condition
do
    command
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;case&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case $VAR in
val1)
    command
    ...
    ;;
val2)
    command
    ...
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break&lt;/p&gt;
&lt;p&gt;continue&lt;/p&gt;
&lt;h2 id=&#34;shell函数&#34;&gt;shell函数&lt;/h2&gt;
&lt;p&gt;return只是返回当前函数，不退出主程序&lt;/p&gt;
&lt;p&gt;exit直接退出主程序&lt;/p&gt;
&lt;p&gt;通过关键字function定义函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Name {    // ()可省略
function Name() {
    ...
    # 如果不显示调用return返回，则函数返回最后一条命令的结果
    return $?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以直接定义函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数返回码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$?  # 获取函数的返回码, 0表示成功, 非0表示失败.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$1 - $9 可以在函数内部获取调用函数时候传递进来的９个参数
${10} - ${100} 获取第十个参数和后面的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$#       表示传递到脚本的参数个数,不包括程序本身
$*       传入所有参数
$@     传入所有参数
$$      当前脚本的进程ID
$!        上一个后台运行的进程ID
$-       当前shell的选项
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输入输出和重定向&#34;&gt;输入输出和重定向&lt;/h2&gt;
&lt;p&gt;stdout和stdin重定向到一个地方:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt; 只重定向stdout
2&amp;gt; 只重定向stderr
2&amp;gt;&amp;amp;1 同时重定向stdout+stderr

main &amp;gt; 2&amp;gt;&amp;amp;1 log1.log | tee log2.log # 同时重定向到两个文件
main 2&amp;gt;&amp;amp;1 | tee ${LOG} # 同时将stdout和stderr输出到终端和日志文件.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;debug&#34;&gt;debug&lt;/h2&gt;
&lt;p&gt;用set&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set -e 命令失败立即退出
set -x 执行前打印每行命令
set -u 未定义的变量会报错
set -o pipefail 对于有管道的操作，返回最后一个非零返回值的命令的返回码.

set +e 取消前面设置的-e
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Coreutils</title>
        <link>https://canuxcheng.com/post/shell_coreutils/</link>
        <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_coreutils/</guid>
        <description>&lt;h1 id=&#34;linux的外部命令&#34;&gt;Linux的外部命令&lt;/h1&gt;
&lt;p&gt;Linux外部命令的项目是coreutils。&lt;/p&gt;
&lt;p&gt;外部命令在coreutils目录中&lt;/p&gt;
&lt;p&gt;查看外部命令所在目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;外部命令在下列目录中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~/bin # 用户自定义

/sbin

/bin

/usr/sbin

/usr/bin

/usr/local/sbin

/usr/local/bin

/usr/games

/usr/local/games
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看外部命令手册的在线手册：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man [command]
info [command]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义外部命令：&lt;/p&gt;
&lt;p&gt;添加$PATH变量，然后放到该目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;系统管理&#34;&gt;系统管理&lt;/h1&gt;
&lt;p&gt;cpu/mem/load&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看cpu/mem/swap/system信息
vmstat
vmstat 1

# 查看进程消耗的cpu/mem/swap/system等系统信息
top
top -H  # 查看线程
%cpu = cputime/realtime * 100%
cpu_usage = %cpu/cpu-number
%mem = RES/physicalMem * 100%

htop
$ sudo apt-get install htop

$ sudo apt-get install sysstat (包括pidstat)
pidstat -u -p pid // cpu
pidstat -r -p pid //mem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cpu/load:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install sysstat (包括mpstat)
mpstat -P ALL 1 5 // cpu

uptime

lscpu # 显示cpu架构的信息

cat /proc/cpuinfo # 查看cpu信息
cat /proc/cpuinfo | grep &amp;quot;processor&amp;quot; | wc -l # 逻辑cpu总数
cat /proc/cpuinfo | grep &amp;quot;physical id&amp;quot; | sort | uniq | wc -l # 物理cpu个数
cat /proc/cpuinfo | grep &amp;quot;cpu cores&amp;quot; | uniq # 物理cpu核数
cat /proc/cpuinfo | grep -e &amp;quot;cpu cores&amp;quot;  -e &amp;quot;siblings&amp;quot; | sort | uniq # 和cpu cores一样说明没有启用超线程.
processor: 逻辑cpu总数=物理cpu个数*物理cpu核数（非超线程），  物理cpu个数*物理cpu核数*2（超线程cpu).
physical id :物理cpu个数(每个socket/插槽可以放一个物理cpu).
cpu cores: 物理cpu有几个核(如果是超线程技术的cpu,每个核可以运行两个线程，或者说每个核对应两个逻辑cpu）。
siblings： 每个物理cpu单个核心上的逻辑cpu个数

strace
strace -c -p pid
strace -T -e epoll_wait -p pid

dmesg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mem:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;free
free -m

cat /proc/meminfo # 查看内存信息

pmap
pmap -d pid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uname # 打印linux系统信息
$ uname -a
cat /etc/issue
cat /proc/version

lsb_release # 查看发行版本信息
$ lsb_release -a

getconf # 查询系统配置的变量，LONG_BIT表示系统位数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;process:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps
# 格式化输出，逗号后面不能有空格
ps -eo/-Ao %cpu/pcpu,%mem/pmem,stat,start/start_time/lstart,pid,ppid,cmd/args/command
ps --ppid 1 -o pid,command | grep -v grep | grep daemon # 获取多进程程序主进程的pid

pstree -a

pkill
pkill -f &amp;lt;pattern&amp;gt; # 杀死args匹配的进程

pgrep -P pid

# 内核也有一个kill命令
kill

killall
killall -e &amp;lt;deamon&amp;gt; # 杀死匹配的守护进程.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;crontab:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install cron
# /etc/crontab 设置了环境变量
crontab
crontab -l # 列出
crontab -e # 编辑
crontab -u &amp;lt;user&amp;gt; file # 导入配置/etc/cron.d/my-cron-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;editor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改默认编辑器nano
select-editor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时区管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl list-timezones # 查看所有时区
sudo timedatectl set-timezone Asia/Shanghai # 设置时区
ls -l /etc/localtime # 应该是一个链接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;update-alternatives:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update-alternatives --display python // 查看候选项
update-alternatives --config python // 选择候选项
update-alternatives --set python /usr/bin/python // 添加候选项
update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1 // 设置候选项的link
update-alternatives --remove python /usr/bin/python3.5 // 删除候选项的link
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;用户和权限管理&#34;&gt;用户和权限管理&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;id
id -u 打印当前用户uid(root uid=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chmod:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 当文件的owner的x位置为s,表示设置了SUID, 仅对二进制可执行文件有效.
# 如果执行者对该文件有可执行权限，那么执行者在执行该文件期间，就拥有了该文件的owner的权限.
-rwsr-xr-x file
chmod u+s &amp;lt;file&amp;gt; # 加SUID
chmod 4777 &amp;lt;file&amp;gt;

-rwxr-sr-x file/dir
chmod g+s &amp;lt;file&amp;gt;/&amp;lt;dir&amp;gt; # 加SGID
chmod 2777 &amp;lt;dir&amp;gt;

drwxrwxrwt dir
chmod o+t &amp;lt;dir&amp;gt; # 加SBIT
chmod 1777 &amp;lt;dir&amp;gt;

chown
chgrp
chattr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;usermod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 禁止root登录
usermod --shell /sbin/nologin root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;adduser:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adduser 

addgroup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;useradd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd
useradd -r -m -U -G sudo -s /bin/bash &amp;lt;user&amp;gt;
-U, --user-group      create a group with the same name as the user
-m, --create-home     create the user&#39;s home directory
-s, --shell SHELL     login shell of the new account
-r, --system          create a system account
-G, --groups GROUPS   list of supplementary groups of the new account

userdel

usermod
usermod -G g1,g2 -a user // 将用户追加到组

users # 查看当前登陆的用户

groupadd
groupdel
groupmod

groups # 查看指定用户所属的组，默认当前用户的组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gpasswd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gpasswd -d &amp;lt;user&amp;gt; &amp;lt;group&amp;gt; // 从组里删除用户
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chpasswd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;username:password&amp;quot; | chpasswd # 修改username的密码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;su:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;su &amp;lt;user&amp;gt; -c &amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sudo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo -i
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;文件和目录管理&#34;&gt;文件和目录管理&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;mkdir
tree
cat
col
colrm
comm
csplit
ed
ex
fmt
fold
join
look
mtype
pico
sort
tr
expr
uniq
wc

cksum
cmp
diff
diffstat
file
cut
less
more
locate
lsattr
mattrib
mdel
mdir
mktemp
mmove
mren
mtools
mtoolstest
mv
od
paste
patch
rcp
rm
split

touch
umask
which
cp
whereis
mcopy
mshowfat
lprm
lpr
lpq
rev
toilet
aafire
xeyes
pv
yes
cal
factor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;typeset&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeset -u VAR // 变量大写
VAR=&#39;test&#39;
echo $VAR # TEST

typeset -l VAR // 变量小写
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tee&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main &amp;gt; 2&amp;gt;&amp;amp;1 log1.log | tee log2.log # 同时重定向到两个文件
main 2&amp;gt;&amp;amp;1 | tee ${LOG} # 同时将stdout和stderr输出到终端和日志文件.
$ echo &amp;quot;content&amp;quot; | sudo tee filename # 写入到root权限的文件
$ echo &amp;quot;text&amp;quot; | sudo tee -a filename # append
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lsof查看打开的文件资源:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsof #
lsof -i # 查看
sudo lsof -i :port # 查看端口是否被使用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;readlink:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;readlink 获取符号连接信息
sudo readlink /proc/1/exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ln:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln TARGET LINK_NAME # 创建文件的硬链接,目录不能创建硬链接
-s, --symbolic
ln -s TARGET LINK_NAME # 创建文件或目录的软链接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dirname:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dirname
dirname $0   # 获取当前文件所在目录的相对路径, 也就是.
$(cd $(dirname $0) &amp;amp;&amp;amp; pwd)    # 获取当前文件所在目录的绝对路径
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rsync:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rsync
rsync [OPTION]... SRC [SRC]... DEST
rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
rsync [OPTION]... [USER@]HOST:SRC [DEST]
rsync -rtvzuOPH --delete
-e &amp;quot;ssh -o StrictHostKeyChecking=no&amp;quot;
-v verbose
-a archive == -rlptgoD
-u --update # 跳过目的地址上modification time更新的文件
--inplace
--append
--append-verify
-r --recursive
-z --compress
--progress
--partial
-P == --partial --progress
--devices
--specials
-D == --devices --specials
-H --hard-links  preserve hard-link
-l --links  copy symlinks as symlinks 保留软链接
-L          copy symlinks to dest 复制原始文件
--delete  从dest删除src没有的文件
-h --human-readable
-g --group  preserve group
-o --owner  preserve owner
-p --perms  preserve permissions
-t --times  preserve modification times
-O, --omit-dir-times    忽略目录的modification times.
--exclude 排除文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;计算文件空间使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;du
$ du -sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四个用到正则表达式的重要命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed
awk
grep/ack/ag
find
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;压缩备份&#34;&gt;压缩备份&lt;/h1&gt;
&lt;p&gt;tar(.tar)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar
-c, --create   # 创建归档
-u, --update    # 更新归档文件
-x, --extract, --get    # 提取归档

tar cvf name.tar folder
tar xvf name.tar

compression options:
-j, --bzip2
-J, --xz
-z, --gzip, --gunzip, --ungzip
-Z, --compress, --uncompress

device selection and switching:
-f, --file=ARCHIVE

informative output:
-v, --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gzip(.gz)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gzip
gunzip
tar zxvf file.tar.gz
tar zcvf file.tar.gz dir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bzip2(.bz2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bzip2
bunzip2
tar jxvf file.tar.bz2
tar jcvf file.tar.bz2 dir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;compress(.z)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compress
uncompress
tar Zxvf file.tar.z
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;xz(.xz)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xz
unxz
tar Jxvf file.tar.xz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gzip/gunzip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gunzip name.gz
gzip -d name.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;zip(.zip)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zip
unzip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7z(.7z)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install p7zip/p7zip-full/p7zip-rar
7z
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数据处理&#34;&gt;数据处理&lt;/h1&gt;
&lt;p&gt;base64&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 生成basic authentication.
echo -n &amp;quot;user:pw&amp;quot; | base64
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Utils</title>
        <link>https://canuxcheng.com/post/shell_utils/</link>
        <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_utils/</guid>
        <description>&lt;h1 id=&#34;linux的第三方命令&#34;&gt;Linux的第三方命令&lt;/h1&gt;
&lt;p&gt;Linux外部命令的项目是coreutils.&lt;/p&gt;
&lt;p&gt;外部命令在coreutils目录中.&lt;/p&gt;
&lt;p&gt;第三方命令(相当于外部命令)．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;文件和目录管理&#34;&gt;文件和目录管理&lt;/h1&gt;
&lt;p&gt;autojump:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wting/autojump&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wting/autojump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;fasd:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/clvv/fasd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/clvv/fasd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;fzf:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/junegunn/fzf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;压缩备份&#34;&gt;压缩备份&lt;/h1&gt;
&lt;h1 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h1&gt;
&lt;h1 id=&#34;设备管理&#34;&gt;设备管理&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Builtins</title>
        <link>https://canuxcheng.com/post/shell_builtins/</link>
        <pubDate>Thu, 31 Mar 2016 21:51:03 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/shell_builtins/</guid>
        <description>&lt;h1 id=&#34;linux内置命令&#34;&gt;Linux内置命令&lt;/h1&gt;
&lt;p&gt;内置命令在bash/builtins目录中&lt;/p&gt;
&lt;p&gt;shell命令分为内置命令和外部命令.&lt;/p&gt;
&lt;p&gt;查看一个命令是内置命令还是外部命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type -a [command]

提示&amp;quot;[command] is a shell builtin&amp;quot;就表示是内置命令，否则就是外部命令。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有内置命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help
enable -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看内置命令的帮助：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help [command]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;type
enable
help

caller
alias
bg
bind
break
builtin
command
compgen
complete
compopt
continue
declare
disown
let
local
logout
mapfile
popd
printf
pushd
read
readarray
readonly
return
shift
shopt
source
suspend
times
trap
true
typeset
ulimit
umask
unalias
unset
wait
eval
exec
exit
export
false
fc
fg
getopts
hash
history
jobs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;路径相关:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd
dirs
pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set
set -e 命令失败立即退出
set -x 执行前打印每行命令
set -u 未定义的变量会报错
set -o pipefail 对于有管道的操作，返回最后一个非零返回值的命令的返回码.

set +e 取消前面设置的-e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;echo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo
echo &#39;origin&#39;  # 不打印变量
echo &amp;quot;_${VAR}_&amp;quot; # 查看变量前后是否有空格.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kill:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill

# 查看所有信号
kill -l 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>FileSystem</title>
        <link>https://canuxcheng.com/post/linux_filesystem/</link>
        <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_filesystem/</guid>
        <description>&lt;h1 id=&#34;vfs&#34;&gt;VFS&lt;/h1&gt;
&lt;p&gt;Linux采用虚拟文件系统，支持多个文件系统协议．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;extext2ext3ext4&#34;&gt;ext/ext2/ext3/ext4&lt;/h1&gt;
&lt;h1 id=&#34;jfs2&#34;&gt;JFS2&lt;/h1&gt;
&lt;h1 id=&#34;ramfs&#34;&gt;ramfs&lt;/h1&gt;
&lt;p&gt;linux的VM(虚拟内存)包括ramfs和swap.&lt;/p&gt;
&lt;p&gt;对内存的支持&lt;/p&gt;
&lt;h1 id=&#34;swap&#34;&gt;swap&lt;/h1&gt;
&lt;p&gt;交换分区，当内存不足，会把内存上暂时不运行的程序保存到swap，获取部分内存空间运行．&lt;/p&gt;
&lt;h1 id=&#34;tmpfs&#34;&gt;tmpfs&lt;/h1&gt;
&lt;p&gt;临时文件系统, 优先使用ramfs,　其次使用swap.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 挂载tmpfs
mount -t tmpfs -o size=1024m tmpfs /path/to/mount
# /etc/fstab　
tmpfs /dev/shm tmpfs,defaults,size=512m 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;vfatfatntfs&#34;&gt;vfat/fat/ntfs&lt;/h1&gt;
&lt;p&gt;windows文件系统&lt;/p&gt;
&lt;h1 id=&#34;cifssmbfs&#34;&gt;cifs/smbfs&lt;/h1&gt;
&lt;h1 id=&#34;nfs&#34;&gt;nfs&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Firewall</title>
        <link>https://canuxcheng.com/post/linux_firewall/</link>
        <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_firewall/</guid>
        <description>&lt;h1 id=&#34;firewall&#34;&gt;Firewall&lt;/h1&gt;
&lt;p&gt;UFW: linux防火墙配置工具，底层还是调用iptables.&lt;/p&gt;
&lt;p&gt;filewall: centos的防火墙命令, 底层还是调用iptables.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;selinux&#34;&gt;SELinux&lt;/h1&gt;
&lt;p&gt;Security-Enhanced-Linux&lt;/p&gt;
&lt;p&gt;本地安全&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netfilter&#34;&gt;Netfilter&lt;/h1&gt;
&lt;p&gt;网络安全&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;iptables&#34;&gt;iptables&lt;/h1&gt;
&lt;p&gt;通过iptables操作Netfilter实现应用层安全.&lt;/p&gt;
&lt;p&gt;table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filter 默认表
nat
mangle
raw
security
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;filter&#34;&gt;filter&lt;/h2&gt;
&lt;p&gt;chain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INPUT
FORWARD
OUTPUT
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nat&#34;&gt;nat&lt;/h2&gt;
&lt;p&gt;chain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INPUT
OUTPUT
PREROUTING
POSTROUTING
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;postrouting:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;snat: 内网主机访问外网经过路由时，源ip会发生变化。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;prerouting:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dnat:  外网访问内网经过路由时，目的ip会发生变化。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;iptables命令&#34;&gt;iptables命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;-L/--list  [chain [ rulenum]]
-S/--list-rules [chain [rulenum]]
-Z/--zero [chain [rulenum]]

-A/--append chain
-C/--check chain
-N/--new chain

-F/--flush [chain] // 删除chain中的rules.
-X/--delete-chain [chain] // 删除自定义chain.

-R/--replace chain rulenum
-D/--delete chain [rulenum]
-I/--insert chain [rulenum]

-P/--policy chain target

-E/--rename-chain old-chain new-chain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-t/--table   filter/nat/mangle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;options:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[!] -p/--protocol
[!] -s/--source
[!] -d/--destination
[!] -o/--out-interface
[!] -i/--in-interface
[!] -f/--fragment
--dport    destination-port
--sport    source-port
-m, --match
-j, --jump
-g, --goto
-c, --set-counters

--line-number  # 显示rulenum
-v/--verbose
-n/--numeric
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;others:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 保存规则
iptables-save &amp;gt; firewall.txt
# 加载规则
iptables-restore firewall.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开机启动:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iptables-save &amp;gt; /etc/iptables.rules
vim /etc/network/if-pre-up.d/iptables
#!/bin/bash
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables-restore /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Grub</title>
        <link>https://canuxcheng.com/post/linux_grub/</link>
        <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_grub/</guid>
        <description>&lt;h1 id=&#34;grub&#34;&gt;Grub&lt;/h1&gt;
&lt;p&gt;引导程序。&lt;/p&gt;
&lt;p&gt;linux/unix的引导程序有lilo和grub。&lt;/p&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;p&gt;修改grub:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo vim /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Linux</title>
        <link>https://canuxcheng.com/post/linux/</link>
        <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux/</guid>
        <description>&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;
&lt;p&gt;Linux严格讲指的是Linux这一类操作系统的内核。&lt;/p&gt;
&lt;p&gt;Linux内核的github：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/torvalds/linux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux内核的站点：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kernel.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.kernel.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;商业化的linux系统：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redhat enterprise linux&lt;/li&gt;
&lt;li&gt;suse enterprise linux&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;免费的服务器版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;centos (rhel的免费版服务器版)&lt;/li&gt;
&lt;li&gt;open suse&lt;/li&gt;
&lt;li&gt;debian/ubuntu&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;免费的桌面版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fedora (原来的redhat desktop linux)&lt;/li&gt;
&lt;li&gt;open suse&lt;/li&gt;
&lt;li&gt;debian/ubuntu&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;linux桌面环境&#34;&gt;Linux桌面环境&lt;/h1&gt;
&lt;p&gt;X windows&lt;/p&gt;
&lt;p&gt;KDE&lt;/p&gt;
&lt;p&gt;GNOME2(Mate)&lt;/p&gt;
&lt;p&gt;GNOME3(Mate/Cinnamon)&lt;/p&gt;
&lt;p&gt;Unity&lt;/p&gt;
&lt;p&gt;xface&lt;/p&gt;
&lt;p&gt;lxde&lt;/p&gt;
&lt;p&gt;enlightenment(&lt;a class=&#34;link&#34; href=&#34;https://www.enlightenment.org/start&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.enlightenment.org/start&lt;/a&gt;)&lt;/p&gt;
&lt;h1 id=&#34;linux桌面管理器&#34;&gt;Linux桌面管理器：&lt;/h1&gt;
&lt;p&gt;xDM&lt;/p&gt;
&lt;p&gt;gDM(gnome)&lt;/p&gt;
&lt;p&gt;kDM(kde)&lt;/p&gt;
&lt;p&gt;lightDM&lt;/p&gt;
&lt;h1 id=&#34;linux编程&#34;&gt;Linux编程&lt;/h1&gt;
&lt;h2 id=&#34;linux程序调用结构&#34;&gt;Linux程序调用结构：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;应用程序(包括shell外部命令)/Shell命令(也就是shell内部命令)&lt;/li&gt;
&lt;li&gt;C标准库glibc(包括ISO C和POSIC封装的系统系统调用)&lt;/li&gt;
&lt;li&gt;Linux系统调用&lt;/li&gt;
&lt;li&gt;Linux内核&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;查看手册&#34;&gt;查看手册：&lt;/h2&gt;
&lt;p&gt;查看man帮助:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ man man
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手册章节:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Executable programs or shell commands&lt;/li&gt;
&lt;li&gt;System calls (functions provided by the kernel)&lt;/li&gt;
&lt;li&gt;Library calls (functions within program libraries)&lt;/li&gt;
&lt;li&gt;Special files (usually found in /dev)&lt;/li&gt;
&lt;li&gt;File formats and conventions eg /etc/passwd&lt;/li&gt;
&lt;li&gt;Games&lt;/li&gt;
&lt;li&gt;Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)&lt;/li&gt;
&lt;li&gt;System administration commands (usually only for root)&lt;/li&gt;
&lt;li&gt;Kernel routines [Non standard]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看shell命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man 1 &amp;lt;cmd&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查到的是系统调用（实际上也是POSIX封装的同名函数）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man 2 &amp;lt;name&amp;gt;

// 查看系统调用所有函数宏
man 2 syscalls
// 查看未实现的系统调用
man 2 unimplemented
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查到的glibc（包括ISO C，POSIX的部分函数，其它库）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man 3 &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看标准：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man 7 &amp;lt;name&amp;gt;

// 查看glibc标准
man 7 libc
// 查看C和Linux的标准
man 7 standards
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;grub&#34;&gt;Grub&lt;/h1&gt;
&lt;p&gt;引导程序。&lt;/p&gt;
&lt;p&gt;windows的引导程序是NTloader。&lt;/p&gt;
&lt;p&gt;linux/unix的引导程序有lilo和grub。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Monitoring</title>
        <link>https://canuxcheng.com/post/linux_monitoring/</link>
        <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/linux_monitoring/</guid>
        <description>&lt;h1 id=&#34;inode&#34;&gt;inode&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Markdown</title>
        <link>https://canuxcheng.com/post/markdown/</link>
        <pubDate>Mon, 28 Mar 2016 22:03:15 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/markdown/</guid>
        <description>&lt;h1 id=&#34;markdown&#34;&gt;Markdown&lt;/h1&gt;
&lt;h2 id=&#34;markdown简介&#34;&gt;Markdown简介&lt;/h2&gt;
&lt;p&gt;Markdown是一种轻量级文本标记语言, Markdown的目标是实现易读易写。
Markdown和html有很大区别，html是一种发布格式，markdown是一种书写格式。&lt;/p&gt;
&lt;p&gt;Markdown 中文手册：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://wowubuntu.com/markdown/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://wowubuntu.com/markdown/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Markdown 英文手册：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://daringfireball.net/projects/markdown/syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://daringfireball.net/projects/markdown/syntax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Markdown文件的扩展名是md。&lt;/p&gt;
&lt;h2 id=&#34;两个需要特殊处理的字符&#34;&gt;两个需要特殊处理的字符&lt;/h2&gt;
&lt;p&gt;&amp;lt; 的表示方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;amp; l t ;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;amp; 的表示方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;amp; a m p ;&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;区块元素&#34;&gt;区块元素&lt;/h1&gt;
&lt;h2 id=&#34;段落和换行&#34;&gt;段落和换行&lt;/h2&gt;
&lt;p&gt;段落前后要有一个或以上的空行（空格或制表符都可以）。&lt;/p&gt;
&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;
&lt;p&gt;markdown支持两个语法格式的标题&lt;/p&gt;
&lt;h3 id=&#34;setext格式&#34;&gt;setext格式&lt;/h3&gt;
&lt;p&gt;任意个数下等号=表示大标题:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title
======
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;任意个数下减号表示副标题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Subtitle
--------
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;atx格式&#34;&gt;atx格式&lt;/h3&gt;
&lt;p&gt;一到六个#表示一到六阶标题,#后面有空格&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一阶标题

## 二阶标题

### 三阶标题

#### 四阶标题

##### 五阶标题

###### 六阶标题
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;区块引用&#34;&gt;区块引用&lt;/h2&gt;
&lt;p&gt;使用&amp;gt;表示单层区块引用：&lt;/p&gt;
&lt;p&gt;&amp;gt; block&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;block&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;使用多个&amp;gt;嵌套使用：&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; block&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;block&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;区块内也可以用标题，列表和代码区块等。&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;
&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记,符号和字符之间有空格：&lt;/p&gt;
&lt;p&gt;* shopping list&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;shopping list&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;+ shoppint list&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;shopping list&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;- shopping list&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;shopping list&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;有序列表使用数字和一个英文句点,符号和字符之间有空格：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;numbered list&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;numbered list&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;代码区块&#34;&gt;代码区块&lt;/h2&gt;
&lt;p&gt;简单地缩进 4 个空格或是 1 个制表符,一个代码区块会一直持续到没有缩进的那一行或是文件结尾。&lt;/p&gt;
&lt;p&gt;这是一个普通段落：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是一个代码区块。
    缩进
代码区块结束。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分割线&#34;&gt;分割线&lt;/h2&gt;
&lt;p&gt;三个以上的*-_都可以产生分割线:&lt;/p&gt;
&lt;p&gt;***&lt;/p&gt;
&lt;blockquote&gt;
&lt;hr&gt;&lt;/blockquote&gt;
&lt;p&gt;---&lt;/p&gt;
&lt;blockquote&gt;
&lt;hr&gt;&lt;/blockquote&gt;
&lt;p&gt;___&lt;/p&gt;
&lt;blockquote&gt;
&lt;hr&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;区段元素&#34;&gt;区段元素&lt;/h1&gt;
&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;h3 id=&#34;行内式链接&#34;&gt;行内式链接&lt;/h3&gt;
&lt;p&gt;[Link](&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;参考式链接&#34;&gt;参考式链接&lt;/h3&gt;
&lt;p&gt;[Link][id]&lt;/p&gt;
&lt;p&gt;[id]:https://github.com/crazy-canux&lt;/p&gt;
&lt;h3 id=&#34;自动链接&#34;&gt;自动链接&lt;/h3&gt;
&lt;p&gt;网址:&lt;/p&gt;
&lt;p&gt;&amp;lt;https://github.com/crazy-canux&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;邮箱：&lt;/p&gt;
&lt;p&gt;&amp;lt;canuxcheng@gmail.com&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:canuxcheng@gmail.com&#34; &gt;canuxcheng@gmail.com&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;强调&#34;&gt;强调&lt;/h2&gt;
&lt;p&gt;用一个*或_表示强调，符号和字符中间没有空格&lt;/p&gt;
&lt;p&gt;斜体：*italic*&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;italic&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;斜体： _italic_&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;italic&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;粗体： **bold**&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;粗体： __bold__&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;用反引号标记一小段代码：&lt;/p&gt;
&lt;p&gt;`monospace`&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;monospace&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;
&lt;h3 id=&#34;行内式图片&#34;&gt;行内式图片&lt;/h3&gt;
&lt;p&gt;![pic](/path/to/img.jpg)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/path/to/img.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pic&#34;
	
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;参考式图片&#34;&gt;参考式图片&lt;/h3&gt;
&lt;p&gt;![pic][id]&lt;/p&gt;
&lt;p&gt;[id]: /path/to/img.jpg&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;反斜线&#34;&gt;反斜线&lt;/h1&gt;
&lt;p&gt;用反斜线\来转移字符&lt;/p&gt;
&lt;p&gt;\   反斜线&lt;/p&gt;
&lt;p&gt;`   反引号&lt;/p&gt;
&lt;p&gt;*   星号&lt;/p&gt;
&lt;p&gt;_   底线&lt;/p&gt;
&lt;p&gt;{}  花括号&lt;/p&gt;
&lt;p&gt;[]  方括号&lt;/p&gt;
&lt;p&gt;()  括弧&lt;/p&gt;
&lt;p&gt;#   井字号&lt;/p&gt;
&lt;p&gt;+   加号&lt;/p&gt;
&lt;p&gt;-   减号&lt;/p&gt;
&lt;p&gt;.   英文句点&lt;/p&gt;
&lt;p&gt;!   惊叹号&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Nagios</title>
        <link>https://canuxcheng.com/post/metrics_nagios/</link>
        <pubDate>Fri, 25 Mar 2016 11:15:48 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_nagios/</guid>
        <description>&lt;h1 id=&#34;nagios&#34;&gt;Nagios&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Nagios is the industry standard in IT infrastructure monitoring&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nagios offers complete monitoring and alerting for servers, switches, applications, and services.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios官方宣称nagios是IT基础监控的工业标准。&lt;/p&gt;
&lt;p&gt;Nagios提供对服务器，交换机，应用和服务的完整的监控和警报。&lt;/p&gt;
&lt;p&gt;Nagios是无agent的，nagios的plugin通过协议远程获取信息。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://exchange.nagios.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://exchange.nagios.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nagios-plugins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nagios-plugins&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios安装配置&#34;&gt;Nagios安装配置&lt;/h1&gt;
&lt;h2 id=&#34;nagios发展&#34;&gt;Nagios发展&lt;/h2&gt;
&lt;p&gt;Nagios core 1.0&lt;/p&gt;
&lt;p&gt;Nagios core 2.0&lt;/p&gt;
&lt;p&gt;Nagios core 3.0&lt;/p&gt;
&lt;p&gt;Nagios XI&lt;/p&gt;
&lt;p&gt;Nagios core 4.0&lt;/p&gt;
&lt;p&gt;目前nagios有两大阵营：&lt;/p&gt;
&lt;p&gt;开源解决方案： Nagios core&lt;/p&gt;
&lt;p&gt;商业解决方案： Nagios XI&lt;/p&gt;
&lt;h2 id=&#34;nagios安装配置-1&#34;&gt;Nagios安装配置&lt;/h2&gt;
&lt;p&gt;安装和配置nagios core,plugins,addons参考&lt;/p&gt;
&lt;p&gt;官方文档:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文文档：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://nagios-cn.sourceforge.net/nagios-cn/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://nagios-cn.sourceforge.net/nagios-cn/index.html&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios开源解决方案&#34;&gt;Nagios开源解决方案&lt;/h1&gt;
&lt;h2 id=&#34;nagios-core&#34;&gt;Nagios core:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Nagios Core is the monitoring and alerting engine that serves as the primary application around which hundreds of Nagios projects are built.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios core是监控和警报的主引擎，围绕它建立了成千上万的项目。
技术栈是c，只能安装在linux/unix系统。
Nagios core只是一个监控套件，本身没有监控功能，需要插件来完成监控。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/projects/nagios-core/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/projects/nagios-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises/nagioscore&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises/nagioscore&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagios-plugins&#34;&gt;Nagios plugins:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Efficient, standalone extensions that provide low-level intelligence for monitoring anything and everything with Nagios Core.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios core的监控插件,也就是官方插件,主要是c、shell和perl。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/projects/nagios-plugins/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/projects/nagios-plugins/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nagios-plugins/nagios-plugins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nagios-plugins/nagios-plugins&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagios-frontends&#34;&gt;Nagios frontends:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Web interfaces, themes, Windows and Linux interfaces, and mobile apps for Nagios. Change the look and style of Nagios to suite your needs.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios frontends包括了 主题,web接口,移动设备接口。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/downloads/nagios-core-frontends/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/downloads/nagios-core-frontends/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagios-config-toolsnagios-addons-projects&#34;&gt;Nagios config tools(Nagios addons projects):&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Tools and GUIs for simplifying Nagios Core configuration.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;nagios core的组件。&lt;/p&gt;
&lt;p&gt;包括Lilac,NagiosQL,NConf,OneCMDB,ignoramus&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/projects/nagios-config-tools/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/projects/nagios-config-tools/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/downloads/nagios-core-addons/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/downloads/nagios-core-addons/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagios-exchange&#34;&gt;Nagios exchange:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Nagios® Exchange is the central place where you&amp;rsquo;ll find all types of Nagios projects - plugins, addons, documentation, extensions, and more. This site is designed for the Nagios Community to share its Nagios creations.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios exchange是nagios的开源宝库。&lt;/p&gt;
&lt;p&gt;包括第三方plugins、addons和docs。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://exchange.nagios.org/https://exchange.nagios.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://exchange.nagios.org/https://exchange.nagios.org/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios商业解决方案&#34;&gt;Nagios商业解决方案&lt;/h1&gt;
&lt;h2 id=&#34;nagios-xi&#34;&gt;Nagios XI:&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Our most powerful IT infrastructure monitoring and IT monitoring software alerting solution for today’s demanding organizational requirements.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Nagios XI 是现代化的商业监控解决套件。&lt;/p&gt;
&lt;p&gt;Nagios XI 使用nagios core 4.0。&lt;/p&gt;
&lt;p&gt;Nagios XI 架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/nagiosxi.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagios-network-analyzer&#34;&gt;Nagios network analyzer&lt;/h2&gt;
&lt;h2 id=&#34;nagios-log-server&#34;&gt;Nagios log server&lt;/h2&gt;
&lt;h2 id=&#34;nagios-fusion&#34;&gt;Nagios fusion&lt;/h2&gt;
&lt;h2 id=&#34;nagios-incident-manager&#34;&gt;Nagios incident manager&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios命令&#34;&gt;Nagios命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nagios/bin/nagios --help
-v 验证配置文件
-d daemon mode
-W worker mode.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios-集中监控&#34;&gt;Nagios 集中监控&lt;/h1&gt;
&lt;h2 id=&#34;本地监控&#34;&gt;本地监控&lt;/h2&gt;
&lt;p&gt;使用nagios core + plugins只能监控本地的linux/unix机器。&lt;/p&gt;
&lt;h2 id=&#34;远程监控&#34;&gt;远程监控&lt;/h2&gt;
&lt;p&gt;使用nagios core + plugins + addons可以监控远程的linux/unix/windows机器。&lt;/p&gt;
&lt;p&gt;NRPE(for linux)/NRPE_NT(for windows)和check_nrpe, 运行远程机器上的插件, 支持windows/unix/linux:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core + check_nrpe &amp;lt;=&amp;gt; NRPE/NRPE_NT + plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NSCP和check_nt, 只能使用固定的几个命令查基本属性, 支持windows/linux/unix：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core + check_nt -H &amp;lt;NSCP IP&amp;gt; [-v &amp;lt;command&amp;gt;] &amp;lt;=&amp;gt; NSCP(NSClient++)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NSCP和check_nrpe，可以传自己的命令或插件, 支持windows/linux/unix：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core + check_nrpe -H &amp;lt;NSCP IP&amp;gt; [-c &amp;lt;command/plugins&amp;gt;] [-a &amp;lt;argument list&amp;gt;] &amp;lt;=&amp;gt; NSCP(NSClient++) + plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NSCP和NSCA/NRDP,NSCP主动check,然后将结果发送给NSCA/NRDP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core + NSCA &amp;lt;=&amp;gt; NSCP(NSClient++)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NCPA是python写的跨平台代理, 支持linux/windows/unix：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core + check_ncpa.py &amp;lt;=&amp;gt; NCPA
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios-分布式监控&#34;&gt;Nagios 分布式监控&lt;/h1&gt;
&lt;h2 id=&#34;nrdpnscansca-ng&#34;&gt;NRDP/NSCA/NSCA-ng&lt;/h2&gt;
&lt;p&gt;官方推荐，NRDP是NSCA的升级版,提供被动检测,这种方式效率低，稳定性差。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nagios core &amp;lt;- plugins &amp;lt;- NSCA &amp;lt;= send_nsca &amp;lt;- ocsp &amp;lt;- Nagios core &amp;lt;=&amp;gt; Hosts
                               ^
                              ||
                              send_nsca &amp;lt;- ocsp &amp;lt;- Nagios core &amp;lt;=&amp;gt; Hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nagios的组件&#34;&gt;Nagios的组件&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nagios.org/downloads/nagios-core-addons/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nagios.org/downloads/nagios-core-addons/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ndoutilsndoidoutilsido&#34;&gt;NDOUtils(NDO)/IDOUtils(IDO)&lt;/h2&gt;
&lt;p&gt;从nagios导出当前和历史数据到mysql数据库,需要安装数据库。&lt;/p&gt;
&lt;p&gt;相似功能有mk livestatus。&lt;/p&gt;
&lt;p&gt;N * (Nagios core + NDO module) -&amp;gt; TCP/Socket -&amp;gt; NDO2DB daemon -&amp;gt; DB&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises/ndoutils&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises/ndoutils&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nsti&#34;&gt;NSTI&lt;/h2&gt;
&lt;p&gt;Nagios SNMP Trap Interface.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises/nsti&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises/nsti&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;bpi&#34;&gt;BPI&lt;/h2&gt;
&lt;p&gt;Nagios Business Process Intelligence.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagiosEnterprises/nagiosbpi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagiosEnterprises/nagiosbpi&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;其它组件介绍&#34;&gt;其它组件介绍&lt;/h1&gt;
&lt;h2 id=&#34;nconf&#34;&gt;NCONF&lt;/h2&gt;
&lt;p&gt;nagios的基于web的配置工具。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.nconf.org/dokuwiki/doku.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.nconf.org/dokuwiki/doku.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nconf/nconf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nconf/nconf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;dnx&#34;&gt;DNX&lt;/h2&gt;
&lt;p&gt;分布式组件。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://dnx.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://dnx.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourceforge.net/projects/dnx/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sourceforge.net/projects/dnx/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nagiosgraph&#34;&gt;Nagiosgraph&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;nagiosgraph parses output and performance data from Nagios plugins and stores
the data in RRD files. nagiosgraph creates graphs and generates HTML pages with
graphic reports from the data.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;基于RRD，绘制nagios的性能图。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://nagiosgraph.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://nagiosgraph.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourceforge.net/projects/nagiosgraph/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sourceforge.net/projects/nagiosgraph/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;consol的分布式监控方案&#34;&gt;consol的分布式监控方案&lt;/h1&gt;
&lt;p&gt;一家德国的咨询和解决方案软件公司。&lt;/p&gt;
&lt;p&gt;可以通过 check_MK 的omd来安装。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.consol.de/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.consol.de/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://labs.consol.de/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://labs.consol.de/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ConSol&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ConSol&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要贡献组件：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sni&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sni&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要贡献插件：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/lausser&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lausser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://canuxcheng.com/images/nagios.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pic&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;mod-gearman&#34;&gt;Mod gearman&lt;/h2&gt;
&lt;p&gt;labs consol的分布式监控组件, gearman的worker。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.mod-gearman.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.mod-gearman.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sni/mod_gearman&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sni/mod_gearman&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ndoutilslivestatus&#34;&gt;NDOUtils/livestatus&lt;/h2&gt;
&lt;p&gt;Event broker.&lt;/p&gt;
&lt;h2 id=&#34;thruk&#34;&gt;Thruk&lt;/h2&gt;
&lt;p&gt;基于perl的web框架catalyst的dashbord。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.thruk.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.thruk.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sni/Thruk&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sni/Thruk&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;op5的分布式监控方案&#34;&gt;Op5的分布式监控方案&lt;/h1&gt;
&lt;p&gt;一家瑞典的监控和解决方案公司。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.op5.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.op5.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kb.op5.com/dashboard.action&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kb.op5.com/dashboard.action&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/op5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/op5&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;merlin&#34;&gt;merlin&lt;/h2&gt;
&lt;p&gt;分布式组件。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kb.op5.com/display/MERLIN/Distributed&amp;#43;%28Merlin%29&amp;#43;Home&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kb.op5.com/display/MERLIN/Distributed+%28Merlin%29+Home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/op5/merlin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/op5/merlin&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ndoutilsmk-livestatus&#34;&gt;NDOUtils/MK livestatus&lt;/h2&gt;
&lt;p&gt;Eevent broker&lt;/p&gt;
&lt;h2 id=&#34;ninja&#34;&gt;Ninja&lt;/h2&gt;
&lt;p&gt;Dashboard.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kb.op5.com/display/GUI/GUI&amp;#43;%28Ninja%29&amp;#43;Home&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kb.op5.com/display/GUI/GUI+%28Ninja%29+Home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/op5/ninja&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/op5/ninja&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;介绍Addons.&lt;/p&gt;
&lt;h1 id=&#34;omd&#34;&gt;OMD&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;OMD implements a completely new concept of how to install, maintain and update a monitoring system built on Nagios.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://omdistro.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://omdistro.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://git.mathias-kettner.de/git/?p=omd.git;a=tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://git.mathias-kettner.de/git/?p=omd.git;a=tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The Open Monitoring Distribution&lt;/p&gt;
&lt;p&gt;用于快速部署基于nagios的分布式监控，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Icinga/Shinken/check_MK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monitoring-Plugins和其它插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mod-gearman/MK Livestatus/thruk/multisite&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nsca/check_nrpe。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NagVis/Pnp4nagios/rrdtool/dokuwiki&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;gearman&#34;&gt;Gearman&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Gearman provides a generic application framework to farm out work to other machines or processes that are better suited to do the work.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Gearman用来做任务分发的.&lt;/p&gt;
&lt;p&gt;一个C++实现的Gearman Job Server:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://gearman.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://gearman.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gearman/gearmand&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gearman/gearmand&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个C实现的Gearman worker:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.mod-gearman.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.mod-gearman.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sni/mod_gearman&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sni/mod_gearman&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;rrdtools&#34;&gt;rrdtools&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;RRDtool is a little program for easily maintaining a database of time-series data. It comes with a charting program for drawing pretty graphs based on the data stored.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;存储性能数据。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://oss.oetiker.ch/rrdtool/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://oss.oetiker.ch/rrdtool/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/oetiker/rrdtool-1.x&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/oetiker/rrdtool-1.x&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;pnp4nagios&#34;&gt;pnp4nagios&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;PNP is an addon to Nagios which analyzes performance data provided by plugins and stores them automatically into RRD-databases.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;基于RRD，绘制nagios的性能图。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://docs.pnp4nagios.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://docs.pnp4nagios.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/lingej/pnp4nagios&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lingej/pnp4nagios&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以在nagios的service配置中添加“ostpl_enable-graph&amp;quot;启用图形。&lt;/p&gt;
&lt;p&gt;templates.dist是自带模板&lt;/p&gt;
&lt;p&gt;templates是用户自定义模板&lt;/p&gt;
&lt;p&gt;XXX.php需要和nagios的service的command_name同名，默认查找这个同名的模板.&lt;/p&gt;
&lt;p&gt;测试就是scp XXX.php nagios-server:/usr/share/pnp4nagios/html/templates/然后去nagios查看结果&lt;/p&gt;
&lt;p&gt;pnp4nagios查找顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;templates/check_XXX.php&lt;/li&gt;
&lt;li&gt;templates.dist/check_XXX.php&lt;/li&gt;
&lt;li&gt;templates/default.php&lt;/li&gt;
&lt;li&gt;templates.dist/default.php&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;nagvis&#34;&gt;Nagvis&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;NagVis is a program for visualizing the data the monitoring core of your choice, for example Nagios, Naemon, Icinga or Shinken, in a human friendly way.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;绘制监控地图。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.nagvis.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.nagvis.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/NagVis/nagvis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NagVis/nagvis&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;dokuwiki&#34;&gt;dokuwiki&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;DokuWiki is a simple to use and highly versatile Open Source wiki software that doesn&amp;rsquo;t require a database.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;创建监控的procedure。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dokuwiki.org/dokuwiki/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dokuwiki.org/dokuwiki/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/splitbrain/dokuwiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/splitbrain/dokuwiki&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;graphite&#34;&gt;graphite&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/graphite-project&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/graphite-project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://graphite.readthedocs.io/en/latest/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://graphite.readthedocs.io/en/latest/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zabbix,Sensu,Ganglia,Nagios/Naemon/Icinga/Shinken都可以配合使用。&lt;/p&gt;
&lt;p&gt;绘制性能图。&lt;/p&gt;
&lt;p&gt;graphite-web&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A highly scalable real-time graphing system&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;carbon&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Carbon is responsible for receiving metrics over the network, caching them in memory for &amp;ldquo;hot queries&amp;rdquo; from the Graphite-Web application, and persisting them to disk using the Whisper time-series library.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;whisper/ceres&lt;/p&gt;
&lt;p&gt;ceres会替代whisper。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Whisper is a fixed-size database, similar in design and purpose to RRD (round-robin-database). It provides fast, reliable storage of numeric data over time. Whisper allows for higher resolution (seconds per point) of recent data to degrade into lower resolutions for long-term retention of historical data.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;grafana&#34;&gt;grafana&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Grafana is an open source, feature rich metrics dashboard and graph editor for Graphite, Elasticsearch, OpenTSDB, Prometheus and InfluxDB.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;为graphite提供更好的可视化图形。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grafana/grafana&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://grafana.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://grafana.org/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;graphios&#34;&gt;graphios&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;A program to send nagios perf data to graphite(carbon)/statsd/librato/influxdb&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;发送nagios性能数据到Graphite。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/shawn-sterling/graphios&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/shawn-sterling/graphios&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;ledbetter&#34;&gt;Ledbetter&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;A simple script for gathering Nagios problem statistics and submitting them to Graphite. It focuses on summary (overall, servicegroup and hostgroup) statistics and writes them to the nagios.problems metrics namespace within Graphite.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;发送nagios性能数据到Graphite。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/github/ledbetter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/github/ledbetter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;nscp&#34;&gt;NSCP&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;NSClient is an agent designed originally to work with Nagios but has since evolved into a fully fledged monitoring agent which can be used with numerous monitoring tools (like Icinga, Naemon, OP5, NetEye Opsview etc).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;又叫NSClient++,现在同时支持windows和linux,主要用来安装到windows服务器,用于监控windows系统.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nsclient.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nsclient.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mickem/nscp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mickem/nscp&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;介绍Plugins&lt;/p&gt;
&lt;h1 id=&#34;monitoring-plugins&#34;&gt;Monitoring Plugins&lt;/h1&gt;
&lt;p&gt;Nagios/naemon/icinga/shinken/centreon/opsview/sensu&lt;/p&gt;
&lt;p&gt;Office project:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/monitoring-plugins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/monitoring-plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.monitoring-plugins.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.monitoring-plugins.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;My plugin project:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/pymonitoringplugins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/pymonitoringplugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Open source project:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/awesome-monitoring&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/awesome-monitoring&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;monitoring-plugins-1&#34;&gt;monitoring-plugins&lt;/h1&gt;
&lt;h2 id=&#34;negate&#34;&gt;negate&lt;/h2&gt;
&lt;p&gt;设置相反状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-o 设置ok对应状态
-w
-c
-u
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;check_http&#34;&gt;check_http&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[-f &amp;lt;ok|warning|critcal|follow|sticky|stickyport&amp;gt;] # 跳转
-p PORT # http:80, https:443
-a &amp;quot;USERNAME&amp;quot;:&amp;quot;PASSWORD&amp;quot;
-u PATH
--ssl=1/-S # https需要ssl
-s SEARCH
-e SEARCH,SEARCH...
-l # 用在-r或-R前面,表示可以在多行进行正则匹配
-r # 正则匹配
-R # 大小写不敏感的正则匹配
-C # 检查证书, 不检查URL
-t # timeout.
-w # warning response time
-c # critical response time
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;windows-monitoring&#34;&gt;Windows monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_wmi_plus.pl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  IgnoreMyOutDatedPerlModuleVersions
  -m checkfolderfileage -a &#39;C:&#39; -o &#39;/tmp&#39; -inc _FileAge=@0:1000 -c 10
  -m check_file_count -a &#39;F:&#39; -o &#39;/folder&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_snmp_win_services.pl&lt;/p&gt;
&lt;p&gt;查windows的service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  -n &amp;lt;name&amp;gt;[,&amp;lt;name2&amp;gt;]... # 指定service名字，默认大小写不敏感,正则匹配，逗号分隔多个service，用display name。
  -N=&amp;lt;n&amp;gt; # 匹配到service数量大于n就报错
  -r # 精确匹配
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_smb_shares.pl&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;linuxunix-monitoring&#34;&gt;Linux/Unix monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;check_hpasm.pl&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;os-x-monitoring&#34;&gt;OS X monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;OSX-Monitoring-Tools&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vitual-machine-monitoring&#34;&gt;Vitual Machine monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_wmware_api.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_vmware_esx.pl&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;db-monitoring&#34;&gt;DB monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_mysql_health.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_oracle_health.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_db2_health.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_mssql_health.pl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  --name database/sql
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;network-monitoring&#34;&gt;Network monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;check_nwc_health.pl&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;storage-monitoring&#34;&gt;Storage monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_snmp_storage.pl&lt;/p&gt;
&lt;p&gt;返回用了多少空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_disk&lt;/p&gt;
&lt;p&gt;返回剩余多少空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;log-monitoring&#34;&gt;Log monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_logfiles.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_events.pl&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;process-monitoring&#34;&gt;Process monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_snmp_process.pl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  -n &amp;lt;name&amp;gt; # process名字，大小写敏感，正则匹配，windows需要用processname.exe
  -r # 精确匹配
  -w minW, maxW
  -c minC, maxC # minC &amp;lt;= minW &amp;lt; maxW &amp;lt; maxC
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;application-monitoring&#34;&gt;Application monitoring&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;check_sap_health.pl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check_mailbox_health.pl&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;monitoring插件开发&#34;&gt;Monitoring插件开发&lt;/h1&gt;
&lt;p&gt;Nagios Plugin API:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/pluginapi.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/pluginapi.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Developing Plugins For Use With Embedded Perl:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/epnplugins.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/epnplugins.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nagios plugin development guidelines:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nagios-plugins.org/doc/guidelines.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nagios-plugins.org/doc/guidelines.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Monitoring Plugin Development Guidelines:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.monitoring-plugins.org/doc/guidelines.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.monitoring-plugins.org/doc/guidelines.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nagios不是基于agent的，所以插件都是通过协议来获取监控信息。&lt;/p&gt;
&lt;p&gt;plugin需要遵守下面规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;至少输出一行文本到STDOUT&lt;/li&gt;
&lt;li&gt;事件状态由插件的返回码决定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;just support 4kb data
shortoutput - $SERVICEOUTPUT$
perfdata - $SERVICEPERFDATA$
longoutput - $LONGSERVICEOUTPUT$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0： OK（绿色）
1： Warning（黄色）
2： Critical（红色）
3： Unknown（深黄色）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;阀值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10     | 0:10   | &amp;lt;0 or &amp;gt;10 alert
10:    | 10:æ  | &amp;lt;10 alert
~:10   | -æ:10 | &amp;gt;10 alert
10:20  |        | &amp;lt;10 or &amp;gt;20 alert
@10:20 |        | &amp;gt;=10 and &amp;lt;=20 alert
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Zabbix</title>
        <link>https://canuxcheng.com/post/metrics_zabbix/</link>
        <pubDate>Fri, 25 Mar 2016 11:15:48 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/metrics_zabbix/</guid>
        <description>&lt;h1 id=&#34;zabbix&#34;&gt;Zabbix&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Hexo</title>
        <link>https://canuxcheng.com/post/hexo/</link>
        <pubDate>Tue, 22 Mar 2016 12:59:10 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hexo/</guid>
        <description>&lt;h1 id=&#34;hexo&#34;&gt;Hexo&lt;/h1&gt;
&lt;h2 id=&#34;什么是hexo&#34;&gt;什么是hexo&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Hexo是用nodejs开发的快速、简洁且高效的博客框架，
Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;hexo有大量的插件和主题。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/plugins/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/themes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;themes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装hexo&#34;&gt;安装hexo&lt;/h2&gt;
&lt;p&gt;需要安装依赖nodejs(包括npm)和git。&lt;/p&gt;
&lt;p&gt;安装hexo命令行插件hexo-cli：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo npm install hexo-cli -g
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;next&#34;&gt;Next&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Next是一种文雅的Hexo主题。
一个主题，三种外观，选您所好。
通过主题中的主题（亦称Scheme），您可以方便地改变您博客的外观，同时几乎所有配置同样适用。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iissnan/hexo-theme-next&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;原生的Next&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/hexo-theme-next&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作者的Next&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;快速使用&#34;&gt;快速使用&lt;/h1&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;初始化一个hexo的目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$hexo init &amp;lt;folder&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h2&gt;
&lt;p&gt;进入hexo目录安装依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd &amp;lt;folder&amp;gt;
$sudo npm install &amp;lt;package-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认安装下列依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo
hexo-server
hexo-generator-index
hexo-generator-archive
hexo-generator-category
hexo-generator-tag
hexo-renderer-ejs
hexo-renderer-marked
hexo-renderer-stylus
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看文件和目录&#34;&gt;查看文件和目录&lt;/h2&gt;
&lt;p&gt;安装完成后有下列&lt;/p&gt;
&lt;p&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_config.yml
db.json
package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node_modules
scaffolds
source
themes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;生成静态文件&#34;&gt;生成静态文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$hexo g
$hexo generate
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;启动本地服务器&#34;&gt;启动本地服务器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$hexo s
$hexo server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用浏览器打开链接即可本地查看默认博客。&lt;/p&gt;
&lt;h2 id=&#34;写博文&#34;&gt;写博文&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$hexo new post &amp;lt;article-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑这篇文章。&lt;/p&gt;
&lt;h2 id=&#34;清理生成文件和缓存&#34;&gt;清理生成文件和缓存&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$hexo clean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次运行hexo g和hexo s查看。&lt;/p&gt;
&lt;h2 id=&#34;安装部署插件&#34;&gt;安装部署插件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$sudo npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改全局配置文件，参考插件的&lt;a class=&#34;link&#34; href=&#34;https://github.com/hexojs/hexo-deployer-git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github&lt;/a&gt;
针对github需要新建一个名字为&amp;lt;your-github-name&amp;gt;.github.io的仓库。&lt;/p&gt;
&lt;h2 id=&#34;部署到github&#34;&gt;部署到github&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$hexo d
$hexo deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在浏览器打开http://&amp;lt;your-github-name&amp;gt;.github.io/查看博客。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;h2 id=&#34;全局配置&#34;&gt;全局配置&lt;/h2&gt;
&lt;p&gt;全局配置文件是&amp;lt;folder&amp;gt;/_config.yml&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Hexo Configuration&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Docs: &lt;a class=&#34;link&#34; href=&#34;https://hexo.io/docs/configuration.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/docs/configuration.html&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Source: &lt;a class=&#34;link&#34; href=&#34;https://github.com/hexojs/hexo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hexojs/hexo/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Site&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   title:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   subtitle:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   description:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   author:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   language: zh-Hans
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   timezone: Asia/Shanghai
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# URL&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## If your site is put in a subdirectory, set url as &amp;lsquo;&lt;a class=&#34;link&#34; href=&#34;http://yoursite.com/child%27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://yoursite.com/child&#39;&lt;/a&gt; and root as &amp;lsquo;/child/&amp;rsquo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   url: http://&amp;lt;your-github-name&amp;gt;.github.io/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   root: /
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   permalink: :year/:month/:day/:title/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   permalink_defaults:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Directory&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   source_dir: source
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   public_dir: public
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   tag_dir: tags
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   archive_dir: archives
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   category_dir: categories
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   code_dir: downloads/code
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   i18n_dir: :lang
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   skip_render:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Writing&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   new_post_name: :title.md # File name of new posts
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   default_layout: post # post | page | draft
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   titlecase: false # Transform title into titlecase
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   external_link: true # Open external links in new tab
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   filename_case: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   render_drafts: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   post_asset_folder: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   relative_link: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   future: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   highlight:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   line_number: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   auto_detect: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   tab_replace: &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Category &amp;amp; Tag&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   default_category: uncategorized
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   category_map:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   tag_map:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Date / Time format&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Hexo uses Moment.js to parse and display date&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## You can customize the date format as defined in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## &lt;a class=&#34;link&#34; href=&#34;http://momentjs.com/docs/#/displaying/format/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://momentjs.com/docs/#/displaying/format/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   date_format: YYYY-MM-DD
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   time_format: HH:mm:ss
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Pagination&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Set per_page to 0 to disable pagination&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   per_page: 10
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   pagination_dir: page
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Extensions&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Plugins: &lt;a class=&#34;link&#34; href=&#34;https://hexo.io/plugins/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/plugins/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Themes: &lt;a class=&#34;link&#34; href=&#34;https://hexo.io/themes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/themes/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   theme: hexo-theme-canux
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   Plugins:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   - hexo-deployer-git
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Extend plugins&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## deploy&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   deploy:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     type: git
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     repo:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;        github: https://github.com/crazy-canux/crazy-canux.github.io.git,master
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;        coding: https://git.coding.net/Canux/Canux.git,master
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;主题配置&#34;&gt;主题配置&lt;/h2&gt;
&lt;p&gt;hexo官方默认主题是&amp;lt;folder&amp;gt;/themes/landscape。&lt;/p&gt;
&lt;p&gt;主题配置文件是&amp;lt;folder&amp;gt;/themes/landscape/_config.yml&lt;/p&gt;
&lt;p&gt;现在将默认主题替换成自己喜欢的主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd &amp;lt;folder&amp;gt;/themes
git clone &amp;lt;github-url-of-your-favourite-theme&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将全局配置的 theme: landscape 改为 theme: &amp;lt;your-favourite-theme-name&amp;gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;部署&#34;&gt;部署&lt;/h1&gt;
&lt;p&gt;部署到github和coding(gitcafe)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$hexo clean
$hexo g
$hexo d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;github访问http://&lt;!-- raw HTML omitted --&gt;.github.io即可。&lt;/p&gt;
&lt;p&gt;coding访问http://&lt;!-- raw HTML omitted --&gt;.coding.me/&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;绑定自己的域名：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在域名供应商购买域名后添加解析，记录类型A或者CNAME，主机类型@或者www，记录值可以是http://&lt;!-- raw HTML omitted --&gt;.github.io或者通过ping获取的ip地址。&lt;/li&gt;
&lt;li&gt;在&lt;!-- raw HTML omitted --&gt;/source/新建文件CNAME，添加你购买的域名&lt;!-- raw HTML omitted --&gt;.com。&lt;/li&gt;
&lt;li&gt;正常部署到github。&lt;/li&gt;
&lt;li&gt;访问http://&lt;!-- raw HTML omitted --&gt;.com即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;安装hexo插件&#34;&gt;安装hexo插件&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/plugins/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;plugins&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo npm install &amp;lt;plugin-name&amp;gt; --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;配置hexo插件&#34;&gt;配置hexo插件&lt;/h1&gt;
&lt;p&gt;全局配置文件是&amp;lt;folder&amp;gt;/_config.yml&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Extensions&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Plugins: &lt;a class=&#34;link&#34; href=&#34;https://hexo.io/plugins/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/plugins/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## Themes: &lt;a class=&#34;link&#34; href=&#34;https://hexo.io/themes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/themes/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   theme: next
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   Plugins:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   - hexo-deployer-git
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Extend plugins&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;## deploy&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   deploy:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   type: git

   repo: git@github.com:&amp;lt;your-github-name&amp;gt;/&amp;lt;your-github-name&amp;gt;.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   message:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;站点地图&#34;&gt;站点地图&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$npm install hexo-generator-sitemap --save
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;## sitemap&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   sitemap:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;       path: sitemap.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hexojs/hexo-generator-sitemap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hexojs/hexo-generator-sitemap&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;rss&#34;&gt;RSS&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$npm install hexo-generator-feed --save
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;## feed&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   feed:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     type: atom
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     path: atom.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     limit: 20
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;     hub:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/hexojs/hexo-generator-feed&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/hexojs/hexo-generator-feed&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;seo优化&#34;&gt;SEO优化&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$npm install hexo-generator-seo-friendly-sitemap --save
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   sitemap:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;       path: sitemap.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;next-1&#34;&gt;Next&lt;/h1&gt;
&lt;p&gt;以hexo主题next为例&lt;/p&gt;
&lt;p&gt;中文文档：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://theme-next.iissnan.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://theme-next.iissnan.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文文档：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/iissnan/hexo-theme-next/blob/master/README.en.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/iissnan/hexo-theme-next/blob/master/README.en.md&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;主题配置文件&#34;&gt;主题配置文件&lt;/h1&gt;
&lt;p&gt;主题配置文件在：&lt;/p&gt;
&lt;p&gt;&amp;lt;folder&amp;gt;/themes/next/_config.yml&lt;/p&gt;
&lt;h1 id=&#34;主题配置-1&#34;&gt;主题配置&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 站点信息设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 将制作好的favicon图标放到/source里面。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;favicon: /favicon.ico
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# SEO优化的关键字。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;keywords: &amp;quot;Canux, CHENG, blog&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 指定站点的起始日期。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;since: 2013
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 菜单设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 顶部菜单栏&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;menu:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  home: /
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  about: /about
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  categories: /categories
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  tags: /tags
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  archives: /archives
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #commonweal: /404.html
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 菜单栏图标,使用fontawsome&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;menu_icons:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  home: home
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  about: user
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  categories: th
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  tags: tags
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  archives: archive
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #commonweal: heartbeat
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 主题方案设计: Must | Mist | Pisces&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;scheme: Muse
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 捐赠设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;reward_comment: 您的支持是我创作的动力!
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;wechatpay: /images/myimages/wechatpay.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;alipay: /images/myimages/alipay.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 侧边栏设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 社交信息&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;social:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  GitHub: https://github.com/crazy-canux
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  Stackoverflow: http://stackoverflow.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  LinkedIn: http://www.linkedin.com/profile/preview?locale=zh_CN&amp;amp;trk=prof-0-sb-preview-primary-button
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  E-mail: mailto:canuxcheng@gmail.com
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 社交信息图标，使用fontawsome。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;social_icons:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  GitHub: github
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  LinkedIn: linkedin
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  Stackoverflow: stack-overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  E-mail: envelope
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 友情链接&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;links_title: Links
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;links:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  CSDN: http://bbs.csdn.net/home
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  51CTO: http://bbs.51cto.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  ChinaUnix: http://bbs.chinaunix.net/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  ITPUB: http://www.itpub.net/forum.php
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 侧边栏图像&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;avatar: /images/myimages/avatar.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# TOC(table of contents)设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;toc:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  number: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;#  设置 4.0 International 许可证: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;creative_commons: zero
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 侧边栏位置: left | right&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;sidebar:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  position: left
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 侧边栏显示方式： post | always | hide | remove&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;display: post
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 其它设置&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 使用Custom Logo.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;custom_logo:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enabled: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  image:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 代码高亮主题: normal | night | night eighties | night blue | night bright&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;highlight_theme: night eighties
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 自动滚动页面&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;scroll_to_more: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 自动摘录&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;auto_excerpt:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  length: 150
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 使用Lato font&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;use_font_lato: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 第三方插件: 一般都需要去插件的官网注册使用。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# MathJax Support&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;mathjax: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Google Analytics - US&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#google_analytics:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Facebook sdk Analytics - US&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;facebook_sdk:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  app_id: #&amp;lt;app_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  fb_admin: #&amp;lt;user_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  like_button: #true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  webmaster: #true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# CNZZ Analytics - CN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;cnzz_siteid: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# leancloud Analytics - CN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;leancloud_visitors:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  enable: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  app_id: #&amp;lt;app_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  app_key: #&amp;lt;app_key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Baidu Analytics&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#baidu_analytics: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Tencent Analytics&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#tencent_analytics: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Disqus - US&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#disqus_shortname: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Duoshuo - CN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;duoshuo_shortname: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Make duoshuo show UA&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;duoshuo_info:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  ua_enable: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  admin_enable: false
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  user_id:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  #admin_nickname: ROOT
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Make duoshuo show hot artical&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;duoshuo_hotartical: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# AddThis - US&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#add_this_id:
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# JiaThis - CN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;jiathis: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Baidu Share&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#baidushare: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Duoshuo Share&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#duoshuo_share: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Swiftype - US&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;swiftype_key: ******
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Tinysou - CN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#tinysou_Key
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;#! &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;#! 谨慎编辑的主题信息&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;#! &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 侧边栏移动插件 Motion&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;use_motion: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# 图片弹出插件 Fancybox&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;fancybox: true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Static files&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;vendors: vendors
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;css: css
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;js: js
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;images: images
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;# Theme version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;version: 0.5.0
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Hugo</title>
        <link>https://canuxcheng.com/post/hugo/</link>
        <pubDate>Mon, 01 Apr 2013 12:49:49 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/hugo/</guid>
        <description>&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;
&lt;p&gt;go开发的静态站点生成器.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gohugoio/hugo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gohugoio/hugo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;搭建博客&#34;&gt;搭建博客&lt;/h1&gt;
&lt;p&gt;创建环境:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# linux, ubuntu18.04默认是非extended, 19.04 默认extended。
$ sudo apt-get install hugo

# extended支持Sass/scss
$ sudo snap install hugo --channel=extended

# windows
PATH:   C:\Hugo\bin\hugo.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hugo help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建hugo项目:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /home/canux/sites
&amp;gt; cd C:\hugo\sites
$ hugo new site canuxcheng.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成下列文件和目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config.toml
archetypes
content    # md 文件
data
layouts
static
themes
bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;theme&#34;&gt;Theme&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gohugoio/hugoThemes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gohugoio/hugoThemes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载所有主题:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd blog
git clone --depth 1 --recursive https://github.com/gohugoio/hugoThemes.git themes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载单个主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd themes
git clone url
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在config.toml添加主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;theme = &#39;name&#39;
themesDir = &amp;quot;/path/to/themes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建主题:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hugo new theme [name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加自己的主题:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git submodule add https://github.com/crazy-canux/hugo-theme-canux.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;克隆主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git submodule init
$ git submodule update
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;创建页面&#34;&gt;创建页面&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;## content/about.md
$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;创建文章&#34;&gt;创建文章&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;## content/post/page.md
$ hugo new post/Shell.md
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;本地测试&#34;&gt;本地测试&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt; $ hugo server --theme=hyde --buildDrafts
 $ firefox http://localhost:1313
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;部署到github&#34;&gt;部署到github&lt;/h1&gt;
&lt;p&gt;先在github创建repo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hugo --theme=&amp;lt;theme&amp;gt; --baseUrl=&amp;quot;https://&amp;lt;user&amp;gt;.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;push到github:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd public
$ git init
$ git remote add origin https://github.com/&amp;lt;user&amp;gt;/&amp;lt;user&amp;gt;.github.io.git
$ git add -A
$ git commit -m &amp;quot;first push.&amp;quot;
$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Pelican</title>
        <link>https://canuxcheng.com/post/pelican/</link>
        <pubDate>Mon, 01 Apr 2013 12:49:49 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/pelican/</guid>
        <description>&lt;h1 id=&#34;pelican&#34;&gt;Pelican&lt;/h1&gt;
&lt;p&gt;python开发的静态站点生成器.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://blog.getpelican.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.getpelican.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/getpelican/pelican&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/getpelican/pelican&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://pelican-zh.readthedocs.io/en/latest/zh-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://pelican-zh.readthedocs.io/en/latest/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;搭建博客&#34;&gt;搭建博客&lt;/h1&gt;
&lt;p&gt;创建环境:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mkdir blog_pelican
$cd blog_pelican
$virtualenv .venv
$source .venv/bin/activate
$pip install pelican
$pip install markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建pelican项目:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pelican-quickstart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成下列文件和目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;publishconf.py # 主配置文件
pelicanconf.py # 发布的配置文件
fabfile.py # fabric配置文件
Makefile   # make配置文件
develop_server.sh # 用于开启测试服务器
content # 用于存放所有文章
output # 静态生成文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;发布站点&#34;&gt;发布站点&lt;/h1&gt;
&lt;p&gt;pelican部署博客:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将rst或md格式转换成html,默认导入到output.
$pelican content
$pelican content -s pelicanconf.py

# 启动web服务器预览
$cd output
$python -m pelican.server
$python2.7 -m SimpleHTTPServer
$python3 -m http.server
$firefox http://localhost:8000/

# 部署站点
# 一般publishconf.py导入pelicanconf.py即可，配置一样．
$pelican content -s publishconf.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fabric部署博客:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$fab github # 一键部署到github/coding.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;make部署博客:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$make github # 一键部署到github/coding.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;p&gt;pelicanconf.py&lt;/p&gt;
&lt;p&gt;publishconf.py&lt;/p&gt;
&lt;p&gt;参考pelican和hexo的配置：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/blog_hexo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/blog_hexo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/blog_pelican&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/blog_pelican&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;theme&#34;&gt;Theme&lt;/h1&gt;
&lt;p&gt;添加主题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd blog_pelican
$git submodule add https://github.com/getpelican/pelican-themes.git themes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd pelican-themes
$pelican-themes -i bootstrap2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在pelicanconf.py添加主题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;THEME = &#39;bootstrap2&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;plugin&#34;&gt;Plugin&lt;/h1&gt;
&lt;p&gt;添加插件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd blog_pelican
$git submodule add https://github.com/getpelican/pelican-plugins.git plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;部署到github&#34;&gt;部署到github&lt;/h1&gt;
&lt;p&gt;在makefile添加三个变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GITHUB_BRANCH=master
GITHUB_URL=https://github.com/crazy-canux/crazy-canux.github.io.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改makefile:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;github: publish
    cd $(OUTPUTDIR); git init; git remote add origin $(GITHUB_URL); git add -A; git commit -m &amp;quot;[$(shell date +%Y%m%d)]update&amp;quot;; git push -f -u origin $(GITHUB_BRANCH)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一键部署：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$make github
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
