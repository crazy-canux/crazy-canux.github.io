<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posts - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="section-page">
    <h1>Posts</h1>
    
    
    <ul class="post-list">
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_metrics/">DevOps Metrics</a></h2>
                <div class="post-meta">
                    <time>January 10, 2025</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="devops-metrics">DevOps Metrics</h1>
<p>从业务角度来看，公司希望更准确地度量其开发人员的生产力，原因如下:</p>
<ul>
<li>Monitoring progress over time</li>
<li>Creation of benchmarks</li>
<li>Rewarding top performers</li>
<li>Determining resource allocation</li>
<li>Identification of more productive development processes</li>
</ul>
<p>框架是想法、概念和关系的简单总结，因此基于您的上下文、环境和团队，您可以选择一组您可以解释的指标，以确定团队是否在它应该在的地方。</p>
<h2 id="dora">DORA</h2>
<p>DevOps Research and Assessment.</p>
<p><a href="https://getdx.com/">https://getdx.com/</a></p>
<h3 id="speed-metrics">Speed metrics</h3>
<p>Deployment frequency: This measures how often a team deploys code to production.</p>
<ul>
<li>Low performance: once per month - once per semester. (inadequate integration, lack of automation.)</li>
<li>Medium performance: once per month - once per week.</li>
<li>High performance: daily for multiple times per day.</li>
</ul>
<p>Lead time for change: This measures the time it takes from the moment a code change is made until it is successfully deployed to production.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_secret/">Secret</a></h2>
                <div class="post-meta">
                    <time>July 28, 2024</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="secret">Secret</h1>
<p>secret scan tools</p>
<h2 id="trufflehog">trufflehog</h2>
<p><a href="https://github.com/trufflesecurity/trufflehog">https://github.com/trufflesecurity/trufflehog</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_react/">React</a></h2>
                <div class="post-meta">
                    <time>January 27, 2024</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="react">React</h1>
<p><a href="https://react.dev/">https://react.dev/</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_development/">AWS Development</a></h2>
                <div class="post-meta">
                    <time>January 23, 2024</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="development">Development</h1>
<h2 id="tools">Tools</h2>
<h3 id="cloud9">Cloud9</h3>
<h3 id="codeartifact">CodeArtifact</h3>
<h3 id="codebuild">CodeBuild</h3>
<h3 id="codecommit">CodeCommit</h3>
<h3 id="codedeploy">CodeDeploy</h3>
<h3 id="codeguru">CodeGuru</h3>
<h3 id="codepipeline">CodePipeline</h3>
<h3 id="codestar">CodeStar</h3>
<h3 id="x-ray">X-Ray</h3>
<hr>
<h2 id="blockchain">Blockchain</h2>
<hr>
<h2 id="multimedia">Multimedia</h2>
<h3 id="elastic-transcoder">Elastic Transcoder</h3>
<h3 id="kinesis-video-streams">Kinesis Video Streams</h3>
<hr>
<h2 id="webmobile">Web&amp;Mobile</h2>
<h3 id="amplify">Amplify</h3>
<h3 id="api-gateway">API Gateway</h3>
<h3 id="device-farm">Device Farm</h3>
<h3 id="pinpoint">Pinpoint</h3>
<hr>
<h2 id="iot">IoT</h2>
<h3 id="iot-analytics">IoT Analytics</h3>
<h3 id="iot-core">IoT Core</h3>
<h3 id="iot-events">IoT Events</h3>
<p>&hellip;&hellip;</p>
<hr>
<h2 id="mlai">ML&amp;AI</h2>
<h3 id="comprehend">Comprehend</h3>
<h3 id="forecast">Forecast</h3>
<h3 id="fraud-detector">Fraud Detector</h3>
<h3 id="kendra">Kendra</h3>
<h3 id="lex">Lex</h3>
<p>&hellip;&hellip;</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_security/">Security</a></h2>
                <div class="post-meta">
                    <time>October 19, 2023</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="k8s-security">K8S Security</h1>
<h2 id="tetragon">Tetragon</h2>
<p><a href="https://github.com/cilium/tetragon">https://github.com/cilium/tetragon</a></p>
<h2 id="falco">Falco</h2>
<p><a href="https://github.com/falcosecurity/falco">https://github.com/falcosecurity/falco</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_apigateway/">API Gateway</a></h2>
                <div class="post-meta">
                    <time>August 4, 2023</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="api-gateway">API Gateway</h1>
<p><a href="https://github.com/kubernetes-sigs/gateway-api">https://github.com/kubernetes-sigs/gateway-api</a></p>
<p>GatewayClass没有namespace</p>
<ul>
<li>emissary ingress</li>
<li>kong</li>
<li>higress</li>
</ul></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/first_aid/">First_Aid</a></h2>
                <div class="post-meta">
                    <time>July 17, 2023</time>
                    
                        
                            <span class="category">Misc</span>
                        
                    
                </div>
                
                    <p><h1 id="first-aid">First Aid</h1>
<p><img src="/images/fa1.jpg" alt="pic0"></p>
<p><img src="/images/fa2.jpg" alt="pic1"></p>
<ol>
<li>
<p>确认现场环境安全</p>
</li>
<li>
<p>判断呼吸和意识</p>
</li>
</ol>
<p>先跪下判断意识和呼吸情况，两手拍肩膀呼叫，判断意识，看胸口起伏判断呼吸，数数1001，1002，&hellip; 1008 八秒；如果没有意识和呼吸才需要心肺复苏。否则可能是气道梗阻。</p>
<h2 id="气道梗阻">气道梗阻</h2>
<p>不完全气道梗阻：</p>
<p>有意识，能沟通，优先咳嗽排出。
其次采用背部叩击。
最后才使用腹部冲击（海姆利克法）。</p>
<p>完全气道梗阻：</p>
<p>没有意识，没有呼吸，需要心肺复苏。</p>
<h2 id="心肺复苏">心肺复苏</h2>
<p>来人啊，救命啊，有人晕倒了，我是急救员，请你拨打120，有AED一并带来，会急救的和我一起。</p>
<p>胸部按压30次01，02&hellip; 30，深度5cm左右，确保完全回弹。</p>
<p>然后清理口腔异物，吹气两次。</p>
<p>胸部按压和吹气连续做5组。</p>
<p>每做完5组检查脉搏和呼吸。一只手放头部，另一只手两个指头放劲动脉。计数1001，1002，&hellip; 1008；若有呼吸抢救成功，否则重复上述步骤。</p>
<p>如果有AED，随到随用，先打开电源，一个贴片用于病人右侧胸部上方，一个用于左侧胸部侧方，提醒旁人离开，开始分析是否需要除颤，若需要提示旁人离开，按下按钮。提示完成后继续心肺复苏。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hardware_arduino/">Arduino</a></h2>
                <div class="post-meta">
                    <time>May 15, 2023</time>
                    
                        
                            <span class="category">HW</span>
                        
                    
                </div>
                
                    <p><h1 id="arduino-uno">Arduino Uno</h1>
<p>tinogo-windows开发环境配置</p>
<p><a href="https://tinygo.org/getting-started/install/windows/">https://tinygo.org/getting-started/install/windows/</a></p>
<pre><code>scoop install go
scoop install tinygo
scoop install avrdude
</code></pre>
<p>windows烧写程序</p>
<pre><code>tinygo flash -monitor -baudrate=9600 -target arduino -port COMX /path/to/blinky1
</code></pre>
<p>macos烧写程序</p>
<pre><code>tinygo flash --target arduino -port /dev/cu.usbserial-0001 ./blinking.go
</code></pre>
<h2 id="microcontroller">Microcontroller</h2>
<p>Arduino Uno 使用的是ATmega328p 控制器</p>
<p>支持的外设接口:</p>
<ul>
<li>GPIO：general-purpose input/output，数字接口</li>
<li>UART：Universal asynchronous receiver-transmitter，异步串行接口</li>
<li>SPI：Serial Peripheral Interface，同步串行接口</li>
<li>I2C：Inter-Integrated Circuit, 同步串行接口</li>
<li>ADC：Analog-to-digital, 模拟转数字接口</li>
<li>PWM: Pulse-width modulation,</li>
<li>USB：不支持，异步串行接口</li>
</ul>
<h2 id="machine-包">machine 包</h2>
<p>machine包是tinygo中核心包</p>
<h2 id="driver">Driver</h2>
<p><a href="https://tinygo.org/docs/reference/devices/">https://tinygo.org/docs/reference/devices/</a></p>
<p>安装支持的driver</p>
<pre><code>go get tinygo.org/x/drivers
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gcp/">GCP</a></h2>
                <div class="post-meta">
                    <time>April 23, 2023</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="gcp">GCP</h1>
<p>gcp certification:</p>
<ul>
<li>Google Cloud Certified Cloud Digital Leader</li>
<li>Google Cloud Certified Associate Cloud Engineer</li>
<li>Google Cloud Certified DevOps Engineer</li>
<li>Google Cloud Certified Machine Learning Engineer</li>
<li>Google Cloud Certified Professional Cloud Architect</li>
<li>Google Cloud Certified Professional Data Engineer</li>
<li>Google Cloud Certified Professional Network Engineer</li>
<li>Google Cloud Certified Professional Security Engineer</li>
</ul>
<hr>
<h2 id="cloud-sdk">Cloud SDK</h2>
<p><a href="https://cloud.google.com/sdk/docs/install">https://cloud.google.com/sdk/docs/install</a></p>
<p>默认安装的组件:</p>
<ul>
<li>bq</li>
<li>bundled-python3-unix</li>
<li>gsutil</li>
<li>core</li>
<li>gcloud-crc32c</li>
<li>alpha</li>
<li>beta</li>
</ul>
<p>安装其它组件:</p>
<pre><code>gcloud components install app-engine-go docker-credential-gcr kustomize log-streaming terraform-tools app-engine-python app-engine-python-extras gke-gcloud-auth-plugin kubectl kubectl-oidc 
</code></pre>
<p>卸载:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_auth/">Auth</a></h2>
                <div class="post-meta">
                    <time>January 14, 2022</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="authpy">auth.py</h1>
<p>自定义authentication backend.</p>
<pre><code>from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request):
        ...
    def get_user(self, user_id):
        ...
</code></pre>
<p>配置使用自定义backend</p>
<pre><code>AUTHENTICATION_BACKENDS =  (&quot;apps.ldap_auth.auth.MyBackend&quot;,)
</code></pre>
<p><a href="https://github.com/etianen/django-python3-ldap">https://github.com/etianen/django-python3-ldap</a></p>
<h1 id="auth">auth</h1>
<p>配置</p>
<pre><code>INSTALLED_APPS = (
    'django.contrib.auth'，
    'django.contrib.contenttypes'
)
</code></pre>
<p>&lsquo;django.contrib.auth&rsquo; 包含了验证框架的内核和它的默认模型。</p>
<p>&lsquo;django.contrib.contenttypes&rsquo; 是 Django content type system ，允许你创建的模型和权限相关联。</p>
<pre><code>MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)
</code></pre>
<p>用户登录:</p>
<pre><code>from django.contrib.auth import authenticate, login
user = authenticate(username='name', password='pw')
login(request, user)
</code></pre>
<p>登陆时的默认验证后端:</p>
<pre><code>AUTHENTICATION_BACKENDS = ['django.contrib.auth.backends.ModelBackend']
</code></pre>
<p>用户登出:</p>
<pre><code>from django.contrib.auth import logout
logout(request)
</code></pre>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_application/">Application</a></h2>
                <div class="post-meta">
                    <time>December 4, 2021</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="application-definition--image-build">Application Definition &amp; Image Build</h1>
<p>application choreography.</p>
<ul>
<li>helm</li>
<li>backstage</li>
<li>buildpack.io</li>
<li>operatorframework</li>
<li>dapr</li>
<li>kubevela</li>
<li>kubevirt</li>
</ul>
<hr>
<h2 id="backstage">backstage</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_clf/">AWS CLF</a></h2>
                <div class="post-meta">
                    <time>October 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="clf">CLF</h1>
<p>Foundational: 6个月经验. Cloud Practitioner Foundational(CLF).</p>
<ul>
<li>Fundamental cloud concepts for AWS</li>
<li>Understanding AWS core services</li>
<li>Introduction to security &amp; architecture on AWS</li>
<li>AWS certified cloud practitioner exam prep</li>
</ul></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_management/">AWS Management</a></h2>
                <div class="post-meta">
                    <time>September 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-monitor">AWS Monitor</h1>
<h2 id="cli">CLI</h2>
<h2 id="management-console">Management Console</h2>
<h2 id="quotas">Quotas</h2>
<h2 id="service-catalog">Service Catalog</h2>
<h2 id="cloudwatch">CloudWatch</h2>
<p>监控和管理服务，收集logs, metrics 和 events，支持基于metrics的alert。</p>
<p>MTTR
TCO</p>
<h2 id="cloudwatch-logs">CloudWatch Logs</h2>
<h2 id="cloudtrail">CloudTrail</h2>
<p>可以用来记录，持续监控和保留与AWS基础设施中的操作相关的账户活动。</p>
<p>将审计记录插入S3或者cloudwatch log， 记录突发事件。</p>
<h2 id="aws-config">AWS Config</h2>
<p>提供基础设施的历史配置。基于规则持续评估基础设施。</p>
<h2 id="aws-trusted-advisor">AWS Trusted Advisor</h2>
<p>优化性能和安全性</p>
<h2 id="amazon-grafana">Amazon Grafana</h2>
<h2 id="amazon-prometheus">Amazon Prometheus</h2>
<h2 id="cloudformation">CloudFormation</h2>
<p>提供基于模板(yaml/json)的基础设施服务(IaaS).</p>
<h2 id="compute-optimizer">Compute Optimizer</h2>
<h2 id="control-tower">Control Tower</h2>
<h2 id="health-dashboard">Health Dashboard</h2>
<h2 id="aws-systems-manager">AWS Systems Manager</h2>
<p>提供运维数据，并且在跨基础设施中进行自动化操作。</p>
<h2 id="aws-organizations">AWS Organizations</h2>
<p>账号集中管理。</p>
<h2 id="aws-license-manager">AWS License Manager</h2>
<h2 id="proton">Proton</h2>
<h2 id="aws-well-architected-tool">AWS Well-Architected Tool</h2>
<hr>
<h1 id="financial-management">Financial Management</h1>
<h2 id="budgets">Budgets</h2>
<h2 id="cost-explorer">Cost Explorer</h2>
<h2 id="savings-plans">Savings Plans</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_cors/">CORS</a></h2>
                <div class="post-meta">
                    <time>July 28, 2021</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="cors">CORS</h1>
<p>CORS: Cross-Origin resource sharing, 跨域资源共享.</p>
<p>是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</a></p>
<h2 id="same-origin-policy">same-origin policy</h2>
<p>同源策略，是一种关键的安全机制，它限制由一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy</a></p>
<p>同源包括：</p>
<ul>
<li>protocal (http, https, &hellip;&hellip;)</li>
<li>host</li>
<li>port(80, 443, &hellip;&hellip;)</li>
</ul>
<h2 id="简单请求">简单请求</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82</a></p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain.</li>
</ul>
<p>简单请求在header添加Origin字段说明请求的源(协议，域名，端口):</p>
<pre><code>Origin: https://domain.com:port
</code></pre>
<h2 id="预检请求">预检请求</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82</a></p>
<p>针对其它方法或字段类型.</p>
<h2 id="http-headers">http headers</h2>
<p>响应header中可以带以下字段：</p>
<p>Access-Control-Allow-Origin</p>
<p>Access-Control-Max-Age</p>
<p>Access-Control-Allow-Credentials</p>
<p>Access-Control-Allow-Methods</p>
<p>Access-Control-Expose-Headers
Access-Control-Allow-Headers</p>
<p>请求header中的字段：</p>
<p>Origin</p>
<p>Access-Control-Request-Method</p>
<p>Access-Control-Request-Headers</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_letsencrypt/">Let&#39;s Encrypt</a></h2>
                <div class="post-meta">
                    <time>July 28, 2021</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="lets-encrypt">Let&rsquo;s Encrypt</h1>
<p><a href="https://letsencrypt.org/">https://letsencrypt.org/</a></p>
<p><a href="https://github.com/letsencrypt">https://github.com/letsencrypt</a></p>
<p>是非盈利组织ISRG提供的免费的证书颁发机构。</p>
<p>let&rsquo;s encrypt生成证书的工具很多certbot, acme.sh等.</p>
<h1 id="certbot">certbot</h1>
<p><a href="https://github.com/certbot/certbot">https://github.com/certbot/certbot</a></p>
<h1 id="acmesh">acme.sh</h1>
<p><a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hardware_bsp/">BSP</a></h2>
                <div class="post-meta">
                    <time>May 15, 2021</time>
                    
                        
                            <span class="category">HW</span>
                        
                    
                </div>
                
                    <p><h1 id="bsp">BSP</h1>
<p>BSP，Board Support Package，板级支持包.</p>
<p>熟悉常见的接口协议，如I2C, SPI, UART, USB等。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hardware_fpga/">FPGA</a></h2>
                <div class="post-meta">
                    <time>May 15, 2021</time>
                    
                        
                            <span class="category">HW</span>
                        
                    
                </div>
                
                    <p><h1 id="fpga">FPGA</h1>
<p>FPGA: Field Programmable Gate Array, 现场可编程逻辑门阵列.</p>
<p>下面介绍各家厂商和对应的产品系列.</p>
<hr>
<h1 id="xilinx赛灵思">xilinx/赛灵思</h1>
<p>Spartan</p>
<p>Artix</p>
<p>Kintex</p>
<p>Virtex</p>
<p>SoC/MPSoC</p>
<hr>
<h1 id="altera阿尔特拉">Altera/阿尔特拉</h1>
<p>被Intel英特尔收购</p>
<p>MAXII</p>
<p>Cyclone</p>
<p>Stratix</p>
<p>Arria</p>
<hr>
<h1 id="lattice莱迪思">Lattice/莱迪思</h1>
<p>ECP</p>
<p>ICE</p>
<p>Mach</p>
<hr>
<h1 id="synplicity">Synplicity</h1>
<p>被Synopsys新思科技收购</p>
<h2 id="haps">HAPS</h2>
<p>HAPS系列产品是专为ASIC/SOC设计者提供的高性能、高容量的基于FPGA的原型验证板.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hardware/">Hardware</a></h2>
                <div class="post-meta">
                    <time>May 15, 2021</time>
                    
                        
                            <span class="category">HW</span>
                        
                    
                </div>
                
                    <p><h1 id="hardware">Hardware</h1>
<p><a href="https://github.com/micropython/micropython">https://github.com/micropython/micropython</a></p>
<p><a href="https://github.com/tinygo-org/tinygo">https://github.com/tinygo-org/tinygo</a></p>
<h1 id="soc">SoC</h1>
<p>SOC：（System-On-Chip)片上系统。可以简单的理解为把系统做在一块芯片上。</p>
<p>AP: application processor, CPU, GPU, NPU, ISP, DSP, ROM/RAM.</p>
<p>BP: base-band processor, BBU.</p>
<p><img src="/images/chip.png" alt="pic"></p>
<p><img src="/images/ISP.png" alt="pic"></p>
<p>EUV: Extreme Ultraviolet Lithography，极紫外光刻</p>
<p>DSP: Digital Signal Processing.</p>
<p>ISP: image signal process.</p>
<p>厂商：紫光展锐，华为海思，全志科技，瑞芯微。</p>
<h1 id="rfic">RFIC</h1>
<p>射频芯片</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_kubevirt/">KubeVirt</a></h2>
                <div class="post-meta">
                    <time>May 10, 2021</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="kubevirt">KubeVirt</h1>
<p><a href="https://kubevirt.io/quickstart_cloud/">https://kubevirt.io/quickstart_cloud/</a></p>
<p><a href="https://quay.io/organization/kubevirt">https://quay.io/organization/kubevirt</a></p>
<p><a href="https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html">https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html</a></p>
<h2 id="virtctl">virtctl</h2>
<h2 id="vm">VM</h2>
<p>创建vm</p>
<pre><code>apiVersion: kubevirt.io/v1
kind: VirtualMachine
metadata:
name: testvm
spec:
running: false
template:
    metadata:
    labels:
        kubevirt.io/size: small
        kubevirt.io/domain: testvm
    spec:
    domain:
        devices:
        disks:
            - name: containerdisk
            disk:
                bus: virtio
            - name: cloudinitdisk
            disk:
                bus: virtio
        interfaces:
        - name: default
            masquerade: {}
        resources:
        requests:
            memory: 64M
    networks:
    - name: default
        pod: {}
    volumes:
        - name: containerdisk
        containerDisk:
            image: quay.io/kubevirt/cirros-container-disk-demo
        - name: cloudinitdisk
        cloudInitNoCloud:
            userDataBase64: SGkuXG4=
    nodeSelector:
        kubernetes.io/arch: arm64
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_cache/">Cache</a></h2>
                <div class="post-meta">
                    <time>May 4, 2021</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="cache">cache</h1>
<p>缓存的backend可以是django内置的，也可以是第三方的。</p>
<ul>
<li>
<p>缓存整个站点</p>
<p>MIDDLEWARE = [
&lsquo;django.middleware.cache.UpdateCacheMiddleware&rsquo;,
&lsquo;django.middleware.common.CommonMiddleware&rsquo;,
&lsquo;django.middleware.cache.FetchFromCacheMiddleware&rsquo;,
]</p>
</li>
<li>
<p>视图缓存</p>
<p>from django.views.decorators.cache import cache_page</p>
<p>@cache_page(60 * 2)
def my_view(request):
&hellip;</p>
<p>或者在URLconf中指定
urlpatterns = [
path(&lsquo;foo/<a href="int:code">int:code</a>/&rsquo;, cache_page(60 * 2)(my_view)),
]</p>
</li>
<li>
<p>模板片段缓存</p>
<p>{% load cache %}
{% cache &hellip; %}
&hellip;
{% endcache %}</p>
</li>
</ul>
<hr>
<h2 id="redis">redis</h2>
<pre><code>CACHES = {
    &quot;default&quot;: {
        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,
        &quot;LOCATION&quot;: os.environ.get(&quot;REDIS_URL&quot;, ''),
        &quot;OPTIONS&quot;: {
            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,
        },
        &quot;TIMEOUT&quot;: 60,
    }
}
</code></pre>
<h2 id="memcached">memcached</h2>
<pre><code>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
</code></pre>
<h2 id="database">database</h2>
<pre><code>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws/">AWS</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="aws">AWS</h1>
<p><a href="https://github.com/donnemartin/awesome-aws">https://github.com/donnemartin/awesome-aws</a></p>
<p>aws certification:</p>
<ul>
<li>Foundational: 6个月经验. Cloud Practitioner Foundational(CLF).</li>
<li>Associate: 一年经验. Solutions Architect Associate(SAA); Developer, SysOps Administrator</li>
<li>Professional: 两年经验. Solutions Architect Professional(SAP), Devops Engineer.</li>
<li>Specialty: 特殊领域.</li>
</ul>
<hr>
<h2 id="sdk">SDK</h2>
<p>python</p>
<p><a href="https://github.com/boto/boto3">https://github.com/boto/boto3</a></p>
<p>golang</p>
<p><a href="https://github.com/aws/aws-sdk-go">https://github.com/aws/aws-sdk-go</a></p>
<hr>
<h2 id="aws-management-console">AWS Management Console</h2>
<p>通过webUI管理资源.
kkkkjjkijijijkkjddkkkkjj</p>
<hr>
<h2 id="aws-command-line-interface">AWS Command Line Interface</h2>
<p><a href="https://github.com/aws/aws-cli">https://github.com/aws/aws-cli</a></p>
<p><a href="https://github.com/awslabs/aws-shell">https://github.com/awslabs/aws-shell</a></p>
<p>推荐使用awscli-V2:</p>
<p><a href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html">https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html</a></p>
<p>使用:</p>
<pre><code>aws [-h] [--profile PROFILE] [--debug]
</code></pre>
<p>option:</p>
<pre><code>-h, --help
--profile PROFILE
--debug
</code></pre>
<p>comand option:</p>
<pre><code>aws &lt;service&gt; &lt;subcommand&gt; help 
</code></pre>
<h3 id="cli-credentials">CLI credentials</h3>
<p>优先级：</p>
<ol>
<li>命令行选项</li>
<li>credentials文件</li>
<li>config文件</li>
<li>容器凭证</li>
<li>实例配置文件凭证</li>
</ol>
<ul>
<li>CLI</li>
</ul>
<p>配置default profile</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_cs/">AWS Compute Services</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-compute-service">AWS Compute Service</h1>
<h2 id="ec2">EC2</h2>
<p>Elastic Compute.</p>
<p>AMI: Amazon Machine Image.</p>
<p>EC2实例类型:</p>
<ul>
<li>通用型实例</li>
<li>计算优化型实例</li>
<li>内存优化型实例</li>
<li>加速计算型实例</li>
<li>存储优化型实例</li>
</ul>
<p>EC2付费类型:</p>
<ul>
<li>按需(on-demand)</li>
<li>预留实例(reserved)</li>
<li>储蓄计划(savings plans)</li>
<li>Spot实例</li>
<li>专用主机(dedicated)</li>
</ul>
<h2 id="elastic-beanstalk">Elastic Beanstalk</h2>
<p>features:</p>
<ul>
<li>monitoring</li>
<li>deployment</li>
<li>scaling</li>
<li>EC2 customization</li>
</ul>
<h2 id="lambda">Lambda</h2>
<h2 id="lightsail">Lightsail</h2>
<h2 id="batch">Batch</h2>
<h2 id="app-runner">App Runner</h2>
<h2 id="auto-scaling">Auto Scaling</h2>
<h2 id="fargate">Fargate</h2>
<h2 id="outposts">Outposts</h2>
<h2 id="wavelength">Wavelength</h2>
<hr>
<h1 id="app-integration">App Integration</h1>
<h2 id="appflow">AppFlow</h2>
<h2 id="appsync">AppSync</h2>
<h2 id="eventbridge">EventBridge</h2>
<h2 id="step-functions">Step Functions</h2>
<p>无服务架构.</p>
<h2 id="sns">SNS</h2>
<p>Simple Notification Service是消息发布订阅服务.</p>
<h2 id="sqs">SQS</h2>
<p>Simple Queue Service是消息队列服务.</p>
<p>支持256KB的payload.</p>
<p>提供两种类型的queues:</p>
<ul>
<li>standard queue</li>
<li>FIFO queue</li>
</ul>
<h2 id="mq">MQ</h2>
<p>activeMQ 和 rabbitmq 托管服务。</p>
<hr>
<h1 id="business-app-integration">Business app integration</h1>
<h2 id="simple-email-service">Simple Email Service</h2>
<p>SES</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_containers/">AWS Containers</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-containers">AWS Containers</h1>
<h2 id="ecr">ECR</h2>
<p>Elastic Container Registry.</p>
<h2 id="ecs-anywhere">ECS Anywhere</h2>
<h2 id="ecs">ECS</h2>
<p>Elastic Container Service.</p>
<h2 id="eks-distro">EKS Distro</h2>
<h2 id="eks-anywhere">EKS Anywhere</h2>
<h2 id="eks">EKS</h2>
<p>Elastic Kubernetes Service.</p>
<h3 id="通过aws-cli创建eks">通过AWS CLI创建EKS</h3>
<p>通过MC创建的资源都可以通过CLI(aws)创建.</p>
<p>创建具有公有和私有子网且符合 Amazon EKS 要求的 Amazon VPC</p>
<pre><code>$ aws cloudformation create-stack \
--stack-name my-eks-vpc-stack \
--region region-code \
--template-url https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml 
</code></pre>
<p>创建集群 IAM 角色并向其附加所需的 Amazon EKS IAM 托管策略</p>
<pre><code>// 创建EKS IAM role
aws iam create-role \
--role-name my-EKSClusterRole \
--assume-role-policy-document file://cluster-role-trust-policy.json&quot; \
--permissions-boundary arn:aws:iam::&lt;Your AWS ID&gt;:policy/ProjAdminsPermBoundaryv2

{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Principal&quot;: {
                &quot;Service&quot;: &quot;eks.amazonaws.com&quot;
            },
            &quot;Action&quot;: &quot;sts:AssumeRole&quot;,
            &quot;Condition&quot;: {}
        }
    ]
}

// 绑定role和eks策略
aws iam attach-role-policy \
--policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy \
--role-name my-EKSClusterRole
</code></pre>
<p>创建EKS cluster:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_data/">AWS Data</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="data-processing">Data Processing</h1>
<h2 id="athena">Athena</h2>
<p>serverless交互式分析</p>
<h2 id="data-exchange">Data Exchange</h2>
<h2 id="glue">Glue</h2>
<p>AWS上的ETL(extract, transform and load)服务，提供数据的提取，转换，加载服务。</p>
<h2 id="data-pipeline">Data pipeline</h2>
<p>也是ETL服务。</p>
<h2 id="emr">EMR</h2>
<p>EMR: Elastic MapReduce.</p>
<p>AWS的大数据平台。支持spark, hive, hbase, flink, hudi 和presto.</p>
<h2 id="kinesis">Kinesis</h2>
<ul>
<li>Data Analytics</li>
<li>Data Firehose</li>
<li>Data Streams</li>
</ul>
<h2 id="lake-formation">Lake Formation</h2>
<h2 id="quicksight">QuickSight</h2>
<h2 id="opensearch">OpenSearch</h2>
<h2 id="msk">MSK</h2>
<hr>
<h1 id="data-analysis">Data Analysis</h1>
<h2 id="athena-1">Athena</h2>
<p>serverless服务</p>
<h2 id="quicksight-1">Quicksight</h2>
<h2 id="aws-cloudsearch">AWS CloudSearch</h2>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_database/">AWS Database</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-database">AWS Database</h1>
<h2 id="rds">RDS</h2>
<p>Relational Database Service， 关系型数据库服务.</p>
<p>支持的数据库引擎：</p>
<ul>
<li>Amazon Aurora</li>
<li>PostgreSQL</li>
<li>MySQL</li>
<li>MariaDB</li>
<li>Oracle Database</li>
<li>Microsoft SQL Server</li>
</ul>
<h2 id="aurora-serverless">Aurora Serverless</h2>
<h2 id="aurora">Aurora</h2>
<p>兼容mysql和postgresql.</p>
<h2 id="dynamodb">DynamoDB</h2>
<p>非关系数据库(NoSQL).</p>
<p>DynamoDB是一项键值数据库服务. 无服务器，自动扩展。</p>
<p>具有Key-Value数据库和Document数据库的功能。</p>
<h2 id="documentdb">DocumentDB</h2>
<p>兼容MongoDB.</p>
<h2 id="elasticcache">ElasticCache</h2>
<p>内存数据库(in-memory). 兼容redis和memcached.</p>
<h2 id="keyspaces">Keyspaces</h2>
<p>兼容cassandra的无服务器数据库。</p>
<h2 id="redshift">Redshift</h2>
<p>Amazon Redshift 是一项数据仓库服务，可用于进行大数据分析。</p>
<h2 id="neptune">Neptune</h2>
<p>图形数据库</p>
<h2 id="timesteam">Timesteam</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_network/">AWS Network</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-network">AWS Network</h1>
<h2 id="vpc">VPC</h2>
<p>Virtual Private Cloud.</p>
<p>EC2的私有内部网络.</p>
<ul>
<li>subnets</li>
<li>route tables</li>
<li>internet gateways</li>
<li>nat gateways</li>
</ul>
<p>ENI: Elastic network interfaces.</p>
<p><a href="/images/vpc.png">pic</a></p>
<h2 id="elb">ELB</h2>
<p>ELB: Elastic Load Balancing</p>
<p>弹性负载均衡，可以和EC2,ECS和lambda集成.</p>
<p><a href="https://aws.amazon.com/cn/elasticloadbalancing/features/">https://aws.amazon.com/cn/elasticloadbalancing/features/</a></p>
<p>支持四种负载均衡器：</p>
<ul>
<li>Classic Load Balancer(默认)</li>
<li>Gateway Load Balancer</li>
<li>Application Load Balancer(ALB)</li>
<li>Network Load Balancer(NLB)</li>
</ul>
<p><a href="https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html">https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html</a></p>
<p>可以使用aws默认自带的NLB controller.也可以通过安装aws-load-balancer-controller。推荐后者。</p>
<p><a href="https://github.com/kubernetes-sigs/aws-load-balancer-controller">https://github.com/kubernetes-sigs/aws-load-balancer-controller</a></p>
<p>需要给vpc上的node的subnet打tag:</p>
<pre><code>kubernetes.io/role/elb: 1
kubernetes.io/role/internal-elb: 1
kubernetes.io/cluster/${cluster-name}: owned/shared
</code></pre>
<h2 id="route-53">Route 53</h2>
<p>DNS服务.</p>
<p>在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。</p>
<p>申请好了证书，需要在route 53创建记录.</p>
<p>可以通过external-DNS 自动同步eks上的service和ingress到dns。</p>
<pre><code>aws route53 list-hosted-zones
</code></pre>
<h2 id="cloudfront">CloudFront</h2>
<p>CDN服务.</p>
<hr>
<h2 id="direct-connect">Direct Connect</h2>
<p>提供数据中心和AWS直连。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_security/">AWS Security</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="security">Security</h1>
<p>Acceptable Use Policy.</p>
<h2 id="iam">IAM</h2>
<p>IAM: Identity and Access Management.</p>
<p>STS: Security Token Service.</p>
<p>ACL: Access control list.</p>
<p>SG: Security Group.</p>
<p><a href="https://aws.amazon.com/cn/iam/">https://aws.amazon.com/cn/iam/</a></p>
<pre><code>$aws iam list-users
</code></pre>
<p>IAM的三种身份类型:</p>
<ul>
<li>Users</li>
<li>Groups</li>
<li>Roles</li>
</ul>
<p>IAM通过Policy(json)分配权限。</p>
<hr>
<h2 id="sso">SSO</h2>
<p>sso登陆:</p>
<pre><code>aws configure sso
aws sso login --no-browser 
aws sso logout
</code></pre>
<hr>
<h2 id="secrets-manager">Secrets Manager</h2>
<hr>
<h2 id="acm">ACM</h2>
<p>AWS Certificate Manager.</p>
<p>在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。</p>
<p>申请好了证书，需要在route 53创建记录.</p>
<pre><code>aws acm list-certificates --region eu-west-1
</code></pre>
<p>aws-load-balancer-controller可以自动关联ACM的证书和ingress.</p>
<hr>
<h2 id="artifact">Artifact</h2>
<p>自助的合规报告。</p>
<hr>
<h2 id="waf">WAF</h2>
<h2 id="shield">Shield</h2>
<hr>
<h2 id="kms">KMS</h2>
<p>Key Management Service.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/aws_storage/">AWS Storage</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="aws-storage">AWS Storage</h1>
<h2 id="s3">S3</h2>
<p>Simple Storage Service.</p>
<p>S3分类：</p>
<ul>
<li>S3标准</li>
<li>S3标准-IA</li>
<li>S3单区-IA</li>
<li>S3智能分层</li>
<li>S3 Glacier</li>
<li>S3 Glacire Deep Archive</li>
</ul>
<p>特点:</p>
<ul>
<li>无限存储</li>
<li>单个对象达到5Tb</li>
<li>一次写入，多次读取</li>
<li>99%持久性</li>
</ul>
<h2 id="s3-glacier">S3 Glacier</h2>
<p>用于存放归档文件，按照访问量收费。</p>
<h2 id="ebs">EBS</h2>
<p>Elastic Block Store.</p>
<p><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">https://github.com/kubernetes-sigs/aws-ebs-csi-driver</a></p>
<p>EBS可以连接到EC2实例，可用区级资源，需要位于同一可用区中才能连接到EC2实例，卷不会自动扩展。</p>
<p>EBS只能被单个EC2实例访问。</p>
<p>特点:</p>
<ul>
<li>大小高达16Tb</li>
<li>EC2实例终止后仍然存在</li>
<li>默认情况下为固态(SSD)</li>
<li>提供IOPS SSD和HDD选项</li>
</ul>
<h2 id="efs">EFS</h2>
<p><a href="https://github.com/kubernetes-sigs/aws-efs-csi-driver">https://github.com/kubernetes-sigs/aws-efs-csi-driver</a></p>
<p>Elastic File System 是linux的NFS服务.</p>
<p>EFS是区域性服务，将数据存储在多个可用区中。可以被上千个EC2实例同时访问。</p>
<ul>
<li>完全托管的NFS文件系统</li>
<li>为linux负载而设计</li>
<li>支持PB级别数据</li>
<li>可以跨多个区域存储数据</li>
</ul>
<p>EFS提供两种存储类型(StorageClass): Standard, Infrequent access.</p>
<h2 id="fsx">FSx</h2>
<p>FSx是windows File Server服务.</p>
<h2 id="storage-gateway">Storage Gateway</h2>
<p>支持三种类型:</p>
<ul>
<li>Tape gateway</li>
<li>Volume gateway</li>
<li>File Gateway</li>
</ul>
<h2 id="aws-backup">AWS Backup</h2>
<h2 id="aws-edr">AWS EDR</h2>
<p>Elastic Disaster Recovery.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cloud_cdk/">CDK</a></h2>
                <div class="post-meta">
                    <time>April 23, 2021</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="cdk">CDK</h1>
<p>Cloud Development Kit</p>
<p>SDK一般是和service交互的。
CDK用来和基础设施交互的。</p>
<h2 id="aws-cdk">AWS CDK</h2>
<p>The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation.</p>
<p><a href="https://github.com/aws/aws-cdk">https://github.com/aws/aws-cdk</a></p>
<h2 id="cdk8s">CDK8S</h2>
<p>cdk8s is an open-source software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s apps synthesize into standard Kubernetes manifests which can be applied to any Kubernetes cluster.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_ts/">TypeScript</a></h2>
                <div class="post-meta">
                    <time>March 5, 2021</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="typescript">TypeScript</h1>
<p><a href="https://github.com/microsoft/TypeScript">https://github.com/microsoft/TypeScript</a></p>
<p><a href="https://www.typescriptlang.org/zh/">https://www.typescriptlang.org/zh/</a></p>
<p><a href="https://github.com/microsoft/tsdoc">https://github.com/microsoft/tsdoc</a></p>
<hr>
<h2 id="tsx">TSX</h2>
<p>&ldquo;*.tsx&rdquo; 是js的扩展，允许使用xml语法。</p>
<p>typescript支持interface。</p>
<hr>
<h2 id="jsc">jsc</h2>
<p>将TS编译成JS, tsconfig.json是配置文件。</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_bitbake/">BitBake</a></h2>
                <div class="post-meta">
                    <time>July 12, 2020</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="bitbake">BitBake</h1>
<p>bitbake是类似于make的构建工具，主要用于OpenEmbedded和yocto构建linux发行版.</p>
<p><a href="https://github.com/openembedded/bitbake">https://github.com/openembedded/bitbake</a></p>
<p>bitbake:</p>
<pre><code>$ bitbake python -c devshell/devpyshell
$ bitbake python -c clean/cleanall/cleanstate
$ bitbake python -c compile
$ bitbake python -c fetch/fetchall

# 查找下载地址
$ bitbake -e python | grep ^SRC_URI

# 根据文件查找包名
bitbake&gt; oe-pkgdata-util find-path /usr/bin/python3

# 包名查找recipe
bitbake&gt; oe-pkgdata-util lookup-recipe python3-core
</code></pre>
<h1 id="openembedded">openembedded</h1>
<p><a href="https://github.com/openembedded/openembedded-core">https://github.com/openembedded/openembedded-core</a></p>
<h1 id="yoctopoky">yocto(poky)</h1>
<p>poky是一个开源的最小构建示例，内置bitbake，可直接编译.</p>
<p><a href="http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/">http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/</a></p>
<p><a href="http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers">http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers</a></p>
<p><a href="https://github.com/crazy-canux/poky">https://github.com/crazy-canux/poky</a></p>
<h1 id="toaster">toaster</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_kernel/">kernel</a></h2>
                <div class="post-meta">
                    <time>May 27, 2020</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="kernel">Kernel</h1>
<h1 id="command">command</h1>
<pre><code>lsmod 查看已加载的模块    # /proc/modules
rmmod &lt;name&gt; 删除模块

modprobe -c 查看已编译可加载的内核模块
modprobe &lt;name&gt; 加载模块 # /etc/modules
modprobe -r &lt;name&gt; 删除模块

// modprobe 重启就没了
echo &quot;ipmi_devintf&quot; &gt;&gt; /etc/modules
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_security/">Linux Security</a></h2>
                <div class="post-meta">
                    <time>May 24, 2020</time>
                    
                        
                            <span class="category">Linux</span>
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="selinux">SeLinux</h1>
<p>Security-Enhanced Linux</p>
<h1 id="seccomp">SecComp</h1>
<p>Secure computing mode (seccomp) is a Linux kernel feature.</p>
<h1 id="apparmor">AppArmor</h1>
<p>AppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_cni/">K8S CNI</a></h2>
                <div class="post-meta">
                    <time>March 26, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="network-add-ons">Network add-ons</h1>
<p><a href="https://github.com/containernetworking">https://github.com/containernetworking</a></p>
<ul>
<li>flannel</li>
<li>cilium</li>
<li>calico</li>
<li>vpc-cni (aws)</li>
<li>kube-router</li>
<li>weavenet</li>
<li>antrea</li>
<li>romana</li>
</ul>
<hr>
<h2 id="cilium">cilium</h2>
<p><a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a></p>
<hr>
<h2 id="flannel">Flannel</h2>
<p>flannel是k8s最常用的网络插件.</p>
<p><a href="https://github.com/coreos/flannel">https://github.com/coreos/flannel</a></p>
<p>在所有node上部署cni-plugin:</p>
<p><a href="https://github.com/containernetworking/plugins/releases">https://github.com/containernetworking/plugins/releases</a></p>
<pre><code>$ sudo mkdir -p /opt/cni/bin
// 下载并解压所有插件命令到该目录.
</code></pre>
<p>network-addon(master上操作即可):</p>
<pre><code>$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<p>veryfy:</p>
<pre><code>$ kubectl get nodes
$ kubectl get pod --all-namespaces
</code></pre>
<p>删除插件:</p>
<p>删除插件会影响已经部署的pod.</p>
<pre><code>// 删除flannel 
$ kubectl delete -f X.yml  
$ sudo systemctl stop kubelet docker

// 第二步，在node节点清理flannel网络留下的文件
ifconfig cni0 down
ip link delete cni0 
ifconfig flannel.1 down
ip link delete flannel.1 
rm -rf /var/lib/cni /etc/cni /run/flannel
$ sudo rm -rf /var/lib/kubelet /var/lib/etcd

// 重启kubelet
$ sudo systemctl start kubelet docker
</code></pre>
<p>修改配置:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_csi/">K8S CSI</a></h2>
                <div class="post-meta">
                    <time>March 25, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="csi">CSI</h1>
<p><a href="https://github.com/container-storage-interface/spec">https://github.com/container-storage-interface/spec</a></p>
<ul>
<li>rook</li>
<li>cubefs</li>
<li>longhorn</li>
<li>ceph</li>
<li>minio</li>
</ul>
<hr>
<h2 id="卷volume">卷Volume</h2>
<p>和docker中的一样。</p>
<p>volume支持的卷类型有: awsEBS, azureDisk, azureFile, gcePD, secret, configMap, emptyDir, hostPath, local, nfs等.</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: test-ebs
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-ebs
      name: test-volume
  volumes:
  - name: test-volume
    # 此 AWS EBS 卷必须已经存在
    awsElasticBlockStore:
      volumeID: &quot;&lt;volume-id&gt;&quot;
      fsType: ext4
</code></pre>
<p>AWS的EBS和EFS需要安装驱动:</p>
<p><a href="https://github.com/kubernetes-sigs/aws-ebs-csi-driver">https://github.com/kubernetes-sigs/aws-ebs-csi-driver</a>
<a href="https://github.com/kubernetes-sigs/aws-efs-csi-driver">https://github.com/kubernetes-sigs/aws-efs-csi-driver</a></p>
<hr>
<h2 id="存储类storageclass">存储类StorageClass</h2>
<p>storageclass没有namespace.</p>
<p>每个存储类包含provisioner, parameters和reclaimPolicy.</p>
<p>内置provisioner的卷插件:</p>
<ul>
<li>awsEBS</li>
<li>azureFile</li>
<li>azureDisk</li>
<li>gcePD</li>
<li>openstack cinder</li>
</ul>
<p>没有provisioner的卷类型可以使用外部插件或者自己开发.</p>
<p><a href="https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner">https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_kubectl/">Kubectl</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="kubectl">kubectl</h1>
<p>kubectl是kubernetes的管理工具.</p>
<p><a href="https://kubernetes.io/docs/tasks/tools/#kubectl">https://kubernetes.io/docs/tasks/tools/#kubectl</a></p>
<p><a href="https://github.com/cloudnativelabs/kube-shell">https://github.com/cloudnativelabs/kube-shell</a></p>
<p><a href="https://github.com/jonmosco/kube-ps1">https://github.com/jonmosco/kube-ps1</a></p>
<p><a href="https://github.com/ahmetb/kubectx">https://github.com/ahmetb/kubectx</a></p>
<p>在master上通过kubectl命令管理集群.</p>
<p>kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.24 版本的客户端能与 v1.23、 v1.24 和 v1.25 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。</p>
<h2 id="options">Options</h2>
<pre><code>kubectl options # 查看所有命令可用选项

--kubeconfig
kubectl --kubeconfig=$HOME/.kube.config (default)

-n/--namespace
</code></pre>
<h2 id="basic-command">basic command</h2>
<p>create:</p>
<pre><code># 通过yaml或json文件创建资源
$ kubectl create -f FILENAME [options]

options:
-f/--filename

kubectl create secret tls kubernetes-dashboard-tls --key ca.key --cert ca.crt -n kubernetes-dashboard

// 输出一个资源的yaml格式.
kubectl create deployment &lt;name&gt; --image=&lt;img-name&gt; --dry-run=client --output=yaml
</code></pre>
<p>delete:</p>
<pre><code>// 删除资源
$ kubectl delete (-f FILENAME | -k DICT | TYPE [(NAME|-l label|--all)]) [optiions]

options:
-f/--filename
--all  
--all-namespaces
--force

$ kubectl delete pods --all
$ kubectl delete pod &lt;name&gt;
// 删除指定ns下所有资源.
$ kubectl delete all --all -n {namespace}
</code></pre>
<p>删除带有finalizers字段的对象，对象实际被更新了，没有真的被删除。可以通过patch来删除。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_cicd/">CI/CD</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="continuous-integration--delivery">Continuous Integration &amp; Delivery</h1>
<h2 id="argo-cd">argo-cd</h2>
<p><a href="https://github.com/argoproj/argo-cd">https://github.com/argoproj/argo-cd</a></p>
<h2 id="flux-cd">flux-cd</h2>
<p><a href="https://github.com/fluxcd/flux">https://github.com/fluxcd/flux</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_oss/">Contribution</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="kubernetes-contribution">Kubernetes Contribution</h1>
<p><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md">https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md</a></p>
<h2 id="创建google账号">创建google账号</h2>
<p>推荐申请一个google邮箱。</p>
<p>在开发机配置git</p>
<pre><code>$ git config --global user.email name@gmail.com   
$ git config user.email name@gmail.com            
</code></pre>
<h2 id="签cla并阅读coc">签CLA并阅读CoC</h2>
<p>个人开发者需要签署CLA, 选择individual contributors并用github账号登陆，然后去邮箱授权；之后重新进入，再去邮箱签字。</p>
<p><a href="https://identity.linuxfoundation.org/projects/cncf">https://identity.linuxfoundation.org/projects/cncf</a></p>
<p>读一下CoC和CV</p>
<p><a href="https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md">https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md</a></p>
<p><a href="https://github.com/kubernetes/community/blob/master/values.md">https://github.com/kubernetes/community/blob/master/values.md</a></p>
<h2 id="配置开发环境">配置开发环境</h2>
<p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging">https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging</a></p>
<p>可以在docker里面编译，也可以直接在操作系统上编译。</p>
<p>在docker里面编译</p>
<p><a href="https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md">https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md</a></p>
<pre><code>build/run.sh make 只编译linux平台
build/run.sh make cross 编译所有平台
build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64 编译指定平台的指定组件

build/run.sh make test 单元测试
build/run.sh make test-integration 集成测试
build/run.sh make test-cmd  命令行测试

build/copy-output.sh 将编译的binary从_output/dockerized/bin拷贝到本地

build/make-clean.sh 清空_output

build.shell.sh 交互模式进入编译的container

build/release.sh 编译，测试，打包，kubernetes.tar.gz
...
</code></pre>
<p>在操作系统上编译</p>
<p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment">https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment</a></p>
<p>安装依赖</p>
<pre><code>sudo apt-get update
sudo apt-get install build-essential
// apt: docker, rsync, jq, go, 
// python: pyyaml,

// 安装etcd用于集成测试
./hack/install-etcd.sh
export PATH=&quot;$GOPATH/src/k8s.io/kubernetes/third_party/etcd:${PATH}&quot;
</code></pre>
<p>编译和测试</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_api/">K8S API</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="api">API</h1>
<p>api-server统一的操作入口.</p>
<p>kubectl, UI, 等都是通过api-server操作资源.</p>
<p>payload可以是json，也可以是yaml.</p>
<p>yaml文件中#表示行注释。</p>
<hr>
<h1 id="yaml">yaml</h1>
<p>部署k8s可以通过yaml文件来配置资源.</p>
<p>资源对象组成部分:</p>
<pre><code>apiVersion: 
kind: 
metadata: 元数据
spec: 期望的状态
status: 观测到的状态
</code></pre>
<p>查看apiVersion:</p>
<pre><code>kubectl api-versions
</code></pre>
<p>查看Kind:</p>
<pre><code>kubectl api-resources

# In a namespace
kubectl api-resources --namespaced=true

# Not in a namespace
kubectl api-resources --namespaced=false
</code></pre>
<p>metadata:</p>
<pre><code>metadata:

  name:
  namespace:

  labels/标签: 用户筛选资源，唯一的资源组合方法, 可以使用selector来查询.

  annotations/注解: 存储资源的非标识性信息，扩展资源的spec/status.

  ownerReference/关系: 方便反向查找创建资源的对象，方便进行级联删除。
</code></pre>
<p>spec:</p>
<p>status:</p>
<hr>
<h1 id="调度抢占驱逐">调度，抢占，驱逐</h1>
<p>taints: 污点，使节点排斥特定pod。应用于node。</p>
<pre><code>taints:
- effect: NoSchedule
  key: kubernetes.io/arch
  value: arm64
</code></pre>
<p>tolerations: 容忍度，使pod被吸引到特定节点。应用于pod。
这个只能让pod能部署到加了污点的node，pod也能部署到其它没有加污点的node。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_operator/">Operator</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="operator">Operator</h1>
<p>TPR(Third Party Resource) 在k8s 1.7 被集成，并命名为CRD(Custom Resource Definition).</p>
<p>通过CRD，K8S可以动态的添加和管理资源，controller跟踪这些资源。</p>
<p>CRD+custom Controller = decalartive API(声明式API),一般分为通用性controller和operator.</p>
<p>通用型controller一般用于平台需求，operator一般用于部署特定应用.</p>
<p>用于开发operator的工具有kubebuilder和operator-sdk, 他们都是基于controller-runtime开发.</p>
<p><a href="https://github.com/operator-framework/awesome-operators">https://github.com/operator-framework/awesome-operators</a></p>
<p><a href="https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index">https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index</a></p>
<p><a href="https://operatorhub.io/">https://operatorhub.io/</a></p>
<p>开发示例:</p>
<p><a href="https://github.com/kubernetes/sample-controller">https://github.com/kubernetes/sample-controller</a></p>
<p>operator的build三种模式:</p>
<ul>
<li>go</li>
<li>ansible</li>
<li>helm</li>
</ul>
<p>operator的run三种模式:</p>
<ul>
<li>在集群外部本地运行（开发测试).</li>
<li>作为deployment在集群内部运行.</li>
<li>通过OLM部署.</li>
</ul>
<hr>
<h1 id="operator-sdk">operator-sdk</h1>
<p>redhat的operator-sdk可以方便的开发opeartor.</p>
<p><a href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a>
<a href="https://sdk.operatorframework.io/docs/installation/">https://sdk.operatorframework.io/docs/installation/</a></p>
<hr>
<h1 id="kubebuilder">kubebuilder</h1>
<p>sig维护的kubebuilder也能方便的开发operator.</p>
<p><a href="https://github.com/kubernetes-sigs/kubebuilder">https://github.com/kubernetes-sigs/kubebuilder</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_servicediscovery/">Service Discovery</a></h2>
                <div class="post-meta">
                    <time>January 10, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="coordination--service-discovery">Coordination &amp; Service Discovery</h1>
<p>微服务的服务注册和服务发现.</p>
<ul>
<li>coredns</li>
<li>etcd</li>
<li>zookeeper</li>
</ul>
<hr>
<h2 id="etcd">Etcd</h2>
<p><a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>
<p>类似的有consul和zoomkeeper.</p>
<h3 id="etcdctl">etcdctl</h3>
<p>使用证书访问:</p>
<pre><code>$ etcdctl \
--cacert=/etc/kubernetes/pki/etcd/ca.crt \
--cert=/etc/kubernetes/pki/etcd/server.crt  \
--key=/etc/kubernetes/pki/etcd/server.key \
--insecure-skip-tls-verify=true \
&lt;command&gt;
</code></pre>
<p>查看所有key</p>
<pre><code>$ etcdctl get / --prefix --keys-only
</code></pre>
<hr>
<h2 id="zookeeper">zookeeper</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_compose/">Compose</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="docker-compose">docker-compose</h1>
<p><a href="https://github.com/docker/compose">https://github.com/docker/compose</a></p>
<p>通过一个yaml文件来管理容器中的服务，包括网络和存储。</p>
<p>安装:</p>
<pre><code>https://docs.docker.com/compose/install/
$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
<h1 id="docker-compose命令">docker-compose命令</h1>
<pre><code>docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]
-f/--file
-p/--project-name # 默认目录名
-H/--host

# 拉取compose文件中指定的镜像
$ docker-compose -f service.yml pull

# 根据docker-compose.yml把stack打包成一个Distributed Application Bundles文件.
$ docker-compose bundle -o &lt;project name&gt;.dab

$ docker-compose start [servoce...]
$ docker-compose stop [service...]
$ docker-compose restart [service...]
$ docker-compose up -d [service...]
$ docker-compose down -v

$ docker-compose logs -f
</code></pre>
<h1 id="docker-composeyml">docker-compose.yml</h1>
<p>compose中的变量：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_accesscontrol/">API Access Control</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="api-access-control">API Access Control</h1>
<h2 id="admission-controllers">Admission Controllers</h2>
<h3 id="mutatingadmissionwebhook">MutatingAdmissionWebhook</h3>
<h3 id="validatingadmissionwebhook">ValidatingAdmissionWebhook</h3>
<h3 id="validatingwebhookconfiguration">ValidatingWebhookConfiguration</h3>
<pre><code>apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  annotations:
    meta.helm.sh/release-name: ingress-nginx-internal
    meta.helm.sh/release-namespace: ingress-nginx
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx-internal
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.9.1
    helm.sh/chart: ingress-nginx-4.8.1
  name: ingress-nginx-internal-admission
webhooks:
- admissionReviewVersions:
  - v1
  clientConfig:
    caBundle: 
    service:
      name: ingress-nginx-internal-controller-admission
      namespace: ingress-nginx
      path: /networking/v1/ingresses
      port: 443
  failurePolicy: Fail
  matchPolicy: Equivalent
  name: validate.nginx.ingress.kubernetes.io
  namespaceSelector: {}
  objectSelector: {}
  rules:
  - apiGroups:
    - networking.k8s.io
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - ingresses
    scope: '*'
  sideEffects: None
  timeoutSeconds: 10
</code></pre>
<h3 id="mutatingwebhookconfiguration">MutatingWebhookConfiguration</h3>
<pre><code>apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  annotations:
    meta.helm.sh/release-name: vault-secrets-webhook
    meta.helm.sh/release-namespace: vault-secrets-webhook
  labels:
    app.kubernetes.io/managed-by: Helm
  name: vault-secrets-webhook
webhooks:
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /pods
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: pods.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    resources:
    - pods
    scope: '*'
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /secrets
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: secrets.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: owner
      operator: NotIn
      values:
      - helm
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    resources:
    - secrets
    scope: '*'
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle:
    service:
      name: vault-secrets-webhook
      namespace: vault-secrets-webhook
      path: /configmaps
      port: 443
  failurePolicy: Ignore
  matchPolicy: Equivalent
  name: configmaps.vault-secrets-webhook.admission.banzaicloud.com
  namespaceSelector:
    matchExpressions:
    - key: name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - kube-system
    - key: kubernetes.io/metadata.name
      operator: NotIn
      values:
      - vault-secrets-webhook
  objectSelector:
    matchExpressions:
    - key: owner
      operator: NotIn
      values:
      - helm
    - key: security.banzaicloud.io/mutate
      operator: NotIn
      values:
      - skip
  reinvocationPolicy: Never
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    resources:
    - configmaps
    scope: '*'
  sideEffects: NoneOnDryRun
  timeoutSeconds: 10
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_platform/">Automation &amp; Configuration</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="automation--configuration">Automation &amp; Configuration</h1>
<ul>
<li>Cloud Custodian</li>
<li>kubeedge</li>
<li>pulumi</li>
<li>terraform</li>
<li>opentofu</li>
<li>kratix</li>
</ul>
<p>platform orchestration.</p>
<h2 id="kratix">kratix</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_dashboard/">Dashboard</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="dashboard-add-ons">dashboard add-ons</h1>
<ul>
<li>kubernetes-dashboard</li>
<li>lens</li>
<li>octant</li>
<li>weave scope</li>
</ul>
<hr>
<h2 id="kubernetes-dashboard">kubernetes-dashboard</h2>
<p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p>
<pre><code>// 部署dashboard
$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml

// check
$ kubectl -n kubernetes-dashboard get pods --watch
</code></pre>
<p>1</p>
<pre><code>// 删除已安装的dashboard
$ kubectl delete ns kubernetes-dashboard
</code></pre>
<h3 id="dashboard-arguments">dashboard arguments</h3>
<p>使用basic auth:</p>
<pre><code>--enable-skip-login
--enable-insecure-login
--system-banner=&quot;Welcome to Kubernetes&quot;
--authentication-mode=&quot;basic&quot; // 默认是 token 登陆.
</code></pre>
<h3 id="access-control">access control</h3>
<ul>
<li>
<p>kubeconfig</p>
</li>
<li>
<p>authorization header</p>
</li>
<li>
<p>token</p>
</li>
<li>
<p>basic</p>
</li>
</ul>
<p>username/password login</p>
<h3 id="access-dashboard">access dashboard</h3>
<p>本机访问</p>
<pre><code>$ kubectl proxy
#&gt; http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
</code></pre>
<p>远程访问</p>
<p>port-forward:</p>
<pre><code>$ kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 --address 0.0.0.0
</code></pre>
<p>nodePort:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_km/">Key Management</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="key-management">Key Management</h1>
<ul>
<li>spiffe</li>
<li>spire</li>
</ul></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_microservice/">Microservivce</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="microservivce">Microservivce</h1>
<p>微服务是一种架构。</p>
<p>常见的架构:</p>
<ul>
<li>Monolithic application 单体应用.</li>
<li>SOA(service-oriented architecture) 面向服务的体系结构.</li>
<li>MicroServices 微服务.</li>
</ul>
<p>微服务架构的服务治理包括:</p>
<ul>
<li>service registry 服务注册</li>
<li>service discovery 服务发现</li>
<li>observability 可观测性(metrics,logging,trace)</li>
<li>流量管理</li>
<li>安全</li>
<li>控制</li>
</ul>
<p>微服务应用可以通过容器化(docker, k8s)部署，也可以通过serverless方式部署.</p>
<p>不同的语言有不同的微服务框架.
java的dubbo, sprint boot.
golang的go-kit,  go-zero, kratos.
python的zappa, nameko.</p>
<hr>
<h2 id="dapr">Dapr</h2>
<p>Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_orchestration/">Scheduling &amp; Orchestration</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="scheduling--orchestration">Scheduling &amp; Orchestration</h1>
<ul>
<li>docker swarm.</li>
<li>KEDA</li>
<li>Crossplane</li>
<li>Knative</li>
<li>Kubeflow</li>
<li>Volcano</li>
</ul>
<h2 id="crossplane">Crossplane</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_serverless/">Serverless</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="serverless">Serverless</h1>
<hr>
<h2 id="knative">Knative</h2>
<p>Knative is a developer-focused serverless application layer which is a great complement to the existing Kubernetes application constructs. Knative consists of three components: an HTTP-triggered autoscaling container runtime called “Knative Serving”, a CloudEvents-over-HTTP asynchronous routing layer called “Knative Eventing”, and a developer-focused function framework which leverages the Serving and Eventing components, called &ldquo;Knative Functions&rdquo;.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_servicemesh/">Service Mesh</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="service-mesh">Service Mesh</h1>
<p>servivce mesh是cncf基于sidecar推出的下一代面向云原生的微服务架构，是微服务基础设施, 用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性.</p>
<p>sidecar: 边车模式，就是把业务无关的功能，日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制和服务调用可视化等独立出来。</p>
<p>特点:</p>
<ul>
<li>应用程序通信的中间层</li>
<li>轻量级网络代理</li>
<li>应用程序无感知</li>
<li>解耦应用程序的重试、超时、监控、追踪和服务发现.</li>
</ul>
<p>Service Mesh是建立在物理或者虚拟网络层之上的，基于策略的微服务的流量控制，与一般的网络协议不同的是它有以下几个特点：</p>
<ul>
<li>开发者驱动</li>
<li>可配置策略</li>
<li>服务优先的网络配置而不是协议</li>
</ul>
<hr>
<h2 id="istio">Istio</h2>
<hr>
<h2 id="linkerd">Linkerd</h2>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_proxy/">Service Proxy</a></h2>
                <div class="post-meta">
                    <time>January 4, 2020</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="service-proxy">Service Proxy</h1>
<p>ingress =&gt; gateway api</p>
<ul>
<li>envoy</li>
<li>contour</li>
<li>traefik proxy</li>
<li>haproxy</li>
<li>metaLB</li>
<li>nginx</li>
<li>openelb</li>
</ul>
<hr>
<h2 id="ingress-controller">ingress controller</h2>
<ul>
<li>Ingress-nginx(nginx)</li>
<li>aws-load-balancer-controller(alb)</li>
<li>ingress-gce</li>
<li>Traefik</li>
</ul>
<p>The kubernetes.io/ingress.class annotation is deprecated from kubernetes v1.22+.通过IngressClasses来选择ingress controller。</p>
<pre><code>ingressClassName: nginx
</code></pre>
<p>ingress 语法</p>
<pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: minimal-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx-example
  defaultBackend:
    resource:
      apiGroup: k8s.example.com
      kind: StorageBucket
      name: static-assets
  rules:
  - http:
      paths:
      - path: /testpath
        pathType: Prefix
        backend:
          service:
            name: test
            port:
              number: 80
</code></pre>
<p>ImplementationSpecific：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 pathType 处理或者与 Prefix 或 Exact 类型作相同处理。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_kubeadm/">Kubeadm</a></h2>
                <div class="post-meta">
                    <time>December 30, 2019</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="kubeadm">kubeadm</h1>
<p><a href="https://github.com/kubernetes/kubeadm">https://github.com/kubernetes/kubeadm</a></p>
<p>kubeadm是k8s自带的部署集群的工具.</p>
<h1 id="install">Install</h1>
<h2 id="准备工作">准备工作</h2>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a></p>
<h2 id="安装runtime">安装runtime</h2>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/">https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/</a></p>
<p>默认的cgroup驱动时cgroupfs,如果系统是systemd，就会有两个cgroup driver，会出问题.</p>
<p>如果修改cgroup driver需要同时修改CRI和kubelet.</p>
<p>修改containerd的cgroup driver:</p>
<pre><code>$ sudo vim /etc/containerd/config.toml
#disabled_plugins = [&quot;cri&quot;]
[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
  SystemdCgroup = true

$ sudo systemctl restart containerd
</code></pre>
<p>修改kubelet的cgroup driver(kubeadm-config.yaml):</p>
<pre><code># kubeadm-config.yaml
kind: ClusterConfiguration
apiVersion: kubeadm.k8s.io/v1beta3
kubernetesVersion: v1.21.0    // kubelet --version
---
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd
</code></pre>
<h2 id="安装kubeadm-kubelet-kubectl">安装kubeadm, kubelet, kubectl</h2>
<p>在每台机器上安装 kubeadm, kubelet, kubectl:</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install -y apt-transport-https ca-certificates curl
$ sudo curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - 
$ echo &quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list
$ sudo apt-get update
$ sudo apt-get --yes --allow-unauthenticated install kubeadm kubelet kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl
$ sudo systemctl enable kubelet
</code></pre>
<hr>
<h1 id="kubeadm-cli">Kubeadm CLI</h1>
<p>init:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_minikube/">Minikube</a></h2>
                <div class="post-meta">
                    <time>December 30, 2019</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="minikube">minikube</h1>
<p><a href="https://kubernetes.io/zh/docs/setup/learning-environment/minikube/">https://kubernetes.io/zh/docs/setup/learning-environment/minikube/</a></p>
<p>minikube 能快速创建k8s的开发集群，支持在虚拟机上创建，也支持裸机创建.</p>
<pre><code>// 在裸机上创建：
sudo minikube start --vm-driver=none
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_image/">Image</a></h2>
                <div class="post-meta">
                    <time>December 3, 2019</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="image">image</h1>
<p>容器镜像</p>
<p>docker image driver: aufs, btrfs, devicemapper, overlay.</p>
<h2 id="multi-platform-images">multi-platform images</h2>
<p><a href="https://docs.docker.com/build/building/multi-platform/">https://docs.docker.com/build/building/multi-platform/</a></p>
<h3 id="qemu">qemu</h3>
<p>使用qume:</p>
<pre><code>// 安装bitfmt
docker run --privileged --rm tonistiigi/binfmt --install all

// 查看支持的平台
ls -l /proc/sys/fs/binfmt_misc/qemu-*
</code></pre>
<h3 id="multiple-native-nodes">multiple native nodes</h3>
<p>安装</p>
<pre><code>// linux
sudo apt install docker-buildx-plugin

// mac
brew install docker-buildx
mkdir -p ~/.docker/cli-plugins
ln -sfn $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx
docker buildx install
</code></pre>
<p>查看版本</p>
<pre><code>docker buildx version
</code></pre>
<p>管理builder instance</p>
<pre><code>docker buildx create
--append 添加node到builder实例。
--leave 从builder实例删除node
--driver Driver to use(&quot;docker&quot;, &quot;docker-container&quot;, &quot;kubernetes&quot;)
--name
--use
--node
--platform 
--bootstrap 启动实例（以容器的形式启动）

// 以本地是amd64为例，创建一个实例.
docker buildx create --use --bootstrap --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --name canux-builder

// 如果没有qumu，可以把不同平台的远程机器加到builder实例.
docker buildx create \
--name local_remote_builder \
--append --node &lt;my-arm-server&gt; \
--platform linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/mips64le,linux/mips64,linux/arm/v7,linux/arm/v6 \
ssh://user@&lt;my-arm-server&gt; 

docker buildx rm

docker buildx stop

docker buildx inspect

docker buildx use

// 查看当前可用的builders
docker buildx ls
</code></pre>
<p>构建多平台镜像</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_helm/">Helm</a></h2>
                <div class="post-meta">
                    <time>September 5, 2019</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="helm">Helm</h1>
<p><a href="https://github.com/helm/helm">https://github.com/helm/helm</a></p>
<p>helm2有两个组件:</p>
<ul>
<li>helm: 客户端</li>
<li>tiller: 服务端(helm3被移除)</li>
</ul>
<p>概念:</p>
<ul>
<li>chart: helm包，包含运行一个应用所需的镜像，依赖和资源.</li>
<li>repository: 用于发布和存储chart的仓库.</li>
<li>release: 在k8s集群上运行的一个chart实例.</li>
</ul>
<p>repository有哪些:</p>
<ul>
<li>charts: OSS, public, 已经被artifacthub取代, <a href="https://github.com/helm/charts">https://github.com/helm/charts</a></li>
<li>artifacthub: OSS, public,  <a href="https://artifacthub.io/">https://artifacthub.io/</a></li>
<li>chartmuseum: OSS, private, self-host, <a href="https://github.com/helm/chartmuseum">https://github.com/helm/chartmuseum</a></li>
<li>harbor: OSS, private, self-host.</li>
<li>artifactory(jfrog): enterprise, private, self-host.</li>
</ul>
<h2 id="安装">安装</h2>
<p>helm和kubectl一样，访问指定配置的k8s集群。</p>
<p>helm2需要安装tiller并且执行helm init初始化,helm不需要tiller.</p>
<p>本地二进制安装helm3+:</p>
<pre><code>curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -
sudo apt-get install apt-transport-https --yes
echo &quot;deb https://baltocdn.com/helm/stable/debian/ all main&quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
sudo apt-get update
sudo apt-get install helm
</code></pre>
<h2 id="命令">命令</h2>
<h3 id="repo管理">repo管理</h3>
<p>查看有哪些repo,默认没有repo</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/k8s_cri/">K8S CRI</a></h2>
                <div class="post-meta">
                    <time>June 5, 2019</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="cri">CRI</h1>
<p>CRI: Container Runtime Intarface</p>
<p>定义了k8s和container runtime进行交互的接口.</p>
<p>是k8s与container交互的标准.</p>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/">https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/</a></p>
<ul>
<li>containerd</li>
<li>cri-o</li>
<li>rkt</li>
<li>kata</li>
<li>rancher</li>
</ul>
<hr>
<h2 id="docker">docker</h2>
<p>k8s_1.20 开始警告不再支持docker.</p>
<p>k8s_1.23 开始移除dockershim.</p>
<p>/var/run/dockerhsim.sock</p>
<h2 id="containerd">containerd</h2>
<p>/run/container/containerd.sock</p>
<p><a href="https://github.com/containerd/containerd">https://github.com/containerd/containerd</a></p>
<p>安装配置:</p>
<p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd">https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd</a></p>
<h2 id="cri-o">CRI-O</h2>
<p>redhat.</p>
<p>/var/run/crio/crio.sock</p>
<p><a href="https://github.com/cri-o/cri-o">https://github.com/cri-o/cri-o</a></p>
<h2 id="kata">kata</h2>
<p><a href="https://github.com/kata-containers/runtime">https://github.com/kata-containers/runtime</a></p>
<h2 id="rkt">rkt</h2>
<p>redhat(coreos)</p>
<p><a href="https://github.com/rkt/rkt">https://github.com/rkt/rkt</a></p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/virtualbox/">Virtualbox</a></h2>
                <div class="post-meta">
                    <time>June 3, 2019</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="virtualbox">Virtualbox</h1>
<p>虚拟化工具virtualbox.</p>
<h1 id="vboxmanage">vboxmanage</h1>
<p>vm</p>
<pre><code>// 导入ova
$ vboxmanage import win7.ova 

// 添加host网络
$ vboxmanage modifyvm &quot;win764&quot; --nic1 hostonly --hostonlyadapter1 vboxnet0
// 添加bridge网络
$ vboxmanage modifyvm &quot;Win732&quot; --nic2 bridged --bridgeadapter2 docker_gwbridge
// 重命名vm
$ vboxmanage modifyvm &lt;vm&gt; --name &lt;new-name&gt; 
// 修改参数
$ vboxmanage modifyvm &lt;vm&gt; --memory 4096 --cpus 4 --hwvirtex on --ioapic on

// 启动虚拟机
$ vboxmanage startvm &quot;Win732&quot;
$ vboxmanage startvm &lt;vm&gt; --type headless 
$ VBoxHeadless --startvm &lt;uuid|name&gt; --vrde on

// 控制虚拟机
$ vboxmanage controlvm &lt;vm&gt; pause/resume/reset/poweroff/savestate

// 查看所有/运行虚拟机
$ vboxmanage list vms/runningvms 

// 删除vm
$ vboxmanage unregistervm &lt;vm&gt; --delete

// linux上执行命令
$ vboxmanage guestcontrol {} --username {} --password {} run --exe /bin/bash -- -l -c 'pwd'

// windows上执行命令
$ vboxmanage guestcontrol {} --username 'Administrator' run --exe 'C:\\Program Files\\Oracle\\VirtualBox Guest Additions\\uninst.exe' -- uninst.exe /S
</code></pre>
<p>media</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_package/">Package</a></h2>
                <div class="post-meta">
                    <time>April 23, 2019</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/network_command/">Command</a></h2>
                <div class="post-meta">
                    <time>March 31, 2019</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="network-command">network command</h1>
<p>network related command</p>
<hr>
<h2 id="net-tools">net-tools</h2>
<p><a href="https://github.com/ecki/net-tools">https://github.com/ecki/net-tools</a></p>
<pre><code>$ sudo apt-get install net-tools
</code></pre>
<h3 id="ifconfig">ifconfig</h3>
<pre><code>ifconfig # 查看up的interface
ifconfig -a  # 查看所有的interface
ifconfig &lt;bridge&gt;/&lt;interface&gt; up/down
</code></pre>
<h3 id="netstat">netstat</h3>
<pre><code>netstat
-a, --all, --listening # 显示所有socket, 默认只显示connected
-l, --listening  # 显示listening
-n, --numeric
-p, --programs # 显示pid或程序名称
# socket选项:
-t, --tcp
-u, --udp
-w, --raw
-x, --unix
--ax25
--ipx
--netrom

# 常用
netstat -anp    # 查看哪些端口是打开的．
sudo netstat -anp | grep port # 查看端口是否被使用
sudo netstat -tulnp # 查看tcp&amp;udp端口是否被监听
</code></pre>
<h3 id="arp">arp</h3>
<pre><code>arp # 用于确定IP地址的网卡物理地址
</code></pre>
<h3 id="rarp">rarp</h3>
<h3 id="hostname">hostname</h3>
<h3 id="domainname">domainname</h3>
<h3 id="dnsdomainname">dnsdomainname</h3>
<h3 id="route">route</h3>
<p>Flags:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/storage_command/">Command</a></h2>
                <div class="post-meta">
                    <time>March 31, 2019</time>
                    
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="sysstat">sysstat:</h1>
<pre><code># &lt;https://github.com/sysstat/sysstat&gt;
$ sudo apt-get install sysstat
# 包括 iostat/mpstat/pidstat/tapestat/cifsiostat

iostat -d -x -k 1 10

pidstat -d -p pid
</code></pre>
<h1 id="iotop">iotop</h1>
<pre><code># 查看进程的diskio
$ sudo apt-get install iotop
$ sudo iotop
</code></pre>
<h1 id="df">df</h1>
<p>df计算文件系统磁盘空间使用:</p>
<pre><code>df
$ df -h

# 查看目录信息(读写哪个设备)
$ df /path/folder
</code></pre>
<h1 id="dd">dd</h1>
<p>dd转化并拷贝文件:</p>
<pre><code>dd
</code></pre>
<h1 id="fsck">fsck</h1>
<p>fsck检查并修复文件系统:</p>
<pre><code>fsck
</code></pre>
<h1 id="fdisk">fdisk</h1>
<p>支持msdos，支持2T以下的磁盘.</p>
<p>fdisk管理磁盘分区表:</p>
<pre><code>fdisk
fdisk -l

fdisk /dev/sda # 可以创建新的磁盘分区
&gt; n ...    创建新的分区
&gt; t (8e表示linux LVM), 修改分区类型
&gt; w 保存修改
partprobe /dev/sda # 在不重启的情况下保存分区
</code></pre>
<h1 id="parted">parted</h1>
<p>支持gpt分区表，支持2T以上的大磁盘.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_init/">Init</a></h2>
                <div class="post-meta">
                    <time>February 3, 2019</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux-init">Linux Init</h1>
<p>linux系统启动的第一个进程,pid=1的进程.</p>
<pre><code>$ ls -l /sbin/init
$ sudo readlink /sbin/init
/sbin/init -&gt; upstart
/sbin/init -&gt; /lib/systemd/systemd

/etc/init.d
The directory containing System V init scripts.
通过service命令操作

/etc/init
The directory containing upstart jobs.
通过initctl命令操作
</code></pre>
<hr>
<h1 id="systemd">systemd</h1>
<p>sytemd是upstart的替代版本．通过查看/sbin/init指向systemd还是upstart.</p>
<p>service文件位置:</p>
<pre><code>/etc/systemd/system/***.service
/lib/systemd/system/*.service
/usr/lib/systemd/system/*.service
</code></pre>
<p>service文件编写:</p>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html#">https://www.freedesktop.org/software/systemd/man/systemd.unit.html#</a></p>
<pre><code>[Unit]
Description=details
After=containerd.service # 之前启动
Before= # 之后运行
Bindsto= #
Wants=containerd.service # 弱依赖
Requires= # 强依赖
StartLimitInterval=10s
StartLimitBurst=5
</code></pre>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html#">https://www.freedesktop.org/software/systemd/man/systemd.service.html#</a></p>
<pre><code>[Service]
Type=simple/notify/dbus/forking/idle/oneshot
ExecStartPre=
ExecStart=
ExecStartPost=
ExecStop=
ExecStopPost=
ExecReload=
KillMode=node/mixed/process/control-group
Restart=no/on-success/on-failure/on-abnormal/on-abort/on-watchdog/always # always总是开机启动，即使systemctl enable.
RestartSec=3s # 重启之前等待的时间.
TimeoutSec=  # TimeoutStartSec+TimeoutStopSec
LimitNOFILE=49152 # 限制单个service的fd

[Install]
WantedBy=multi-user.target
</code></pre>
<p>systemctl命令:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/nginx/">Nginx</a></h2>
                <div class="post-meta">
                    <time>September 27, 2018</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="nginx">Nginx</h1>
<p>安装</p>
<p>配置</p>
<p>命令：</p>
<pre><code>nginx -s stop/quit/reload/reopen
nginx -V 详细信息
nginx -v 版本号
nginx -t 检查配置文件
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_ast/">AST</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="ast">AST</h1>
<p>AST: Application Security Testing, 静态应用程序安全测试, 对应用程序源代码执行直接的白盒分析.</p>
<hr>
<h2 id="sast">SAST</h2>
<p>SAST: Static Application Security Testing</p>
<p>Tools: SonarQube, Trivy, Coverity.</p>
<p>gitlab SAST report.
gitlab secret detection report.</p>
<p><a href="https://github.com/aquasecurity/trivy">https://github.com/aquasecurity/trivy</a></p>
<p><a href="https://scan.coverity.com/">https://scan.coverity.com/</a></p>
<hr>
<h2 id="dast">DAST</h2>
<p>DAST: Dynamic Application Security Testing，动态应用程序安全测试, 对应用程序进行黑盒分析.</p>
<p>Tools:</p>
<p>ZAP Scan(OWASP ZAP)</p>
<p>synopsys WhiteHat Sentinel.</p>
<p>gitlab DAST report.</p>
<hr>
<h2 id="iast">IAST</h2>
<p>IAST: Interactive Application Security Testing，交互式应用程序安全测试, 结合了SAST和DAST的优点.</p>
<hr>
<h2 id="sca">SCA</h2>
<p>SCA: Software Composition Analysis.</p>
<p>SBOM (software Bill of Materials),开源组件安全扫描</p>
<p>Tools： BlackDuck, Jfrog Xray.</p>
<p>gitlab dependency scanning report.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_ca/">CA</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="ca">CA</h1>
<p>SSL: secure sockets layer</p>
<p>TLS: transport layer security</p>
<p>CA: Certificate Authority.</p>
<p>SNI: server name indication</p>
<p>证书类型</p>
<ul>
<li>x509: 只有公钥没有私钥匙</li>
</ul>
<p>编码方式</p>
<ul>
<li>pem: base64编码</li>
<li>der: 二进制</li>
</ul>
<p>证书文件:</p>
<ul>
<li>crt: 证书文件（可以是pem或der编码）</li>
<li>cer: 证书文件（可以是pem或der编码）</li>
<li>csr: 申请签名的文件</li>
<li>key: 私钥文件</li>
</ul>
<hr>
<h1 id="创建自签名证书">创建自签名证书</h1>
<p>创建x509证书:</p>
<pre><code>$ openssl genrsa -out server.key 2048   // 创建key
$ openssl req -new -key server.key -sha256 -out server.csr // 创建csr
$ openssl x509 -req -days 365 -in server.csr -signkey server.key -sha256 -out server.crt // 创建证书
</code></pre>
<p>查看证书信息:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_capture/">Capture</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="packet-capture">Packet Capture</h1>
<p>网络抓包</p>
<h1 id="fiddler">Fiddler</h1>
<p><a href="http://www.telerik.com/fiddler">http://www.telerik.com/fiddler</a></p>
<h1 id="wireshark">Wireshark</h1>
<p><a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_csrf/">Csrf</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="csrf">CSRF</h1>
<p>Cross-site request forgery, 跨站请求伪造．</p>
<p>发生条件：</p>
<ul>
<li>登陆受信任网站A, 并在本地生成cookie</li>
<li>在不退出A的情况下，访问危险网站B</li>
</ul>
<p>预防方法:</p>
<ul>
<li>正确使用get,post和cookie</li>
<li>在非get请求中增加伪随机数</li>
</ul></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ha/">HA</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="haproxy">HAProxy</h1>
<p><a href="https://www.haproxy.com/">https://www.haproxy.com/</a></p>
<p>安装:</p>
<pre><code>$ sudo apt-get install haproxy
</code></pre>
<p>配置:</p>
<pre><code>$ sudo vim /etc/haproxy/haproxy.cfg
</code></pre>
<p>global:</p>
<pre><code>    log /dev/log    local0
    log /dev/log    local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

    # Default SSL material locations
    ca-base /etc/ssl/certs
    crt-base /etc/ssl/private

    # Default ciphers to use on SSL-enabled listening sockets.
    # For more information, see ciphers(1SSL). This list is from:
    #  https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
    # An alternative list with additional directives can be obtained from
    #  https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy
    ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS
    ssl-default-bind-options no-sslv3
</code></pre>
<p>defaults:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_sqlinjection/">Sql Injection</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="sql-injection">SQL Injection</h1>
<p>什么是sql injection:从数据库获取敏感信息,或者利用数据库的特性执行添加用户,导出文件等一系列恶意操作,甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>原因:造成SQL注入的原因是因为程序没有有效过滤用户的输入.</p>
<p>预防：</p>
<ul>
<li>严格限制数据库的操作权限</li>
<li>检查输入的数据格式是否符合要求</li>
<li>对进入数据库的特殊字符进行转义</li>
<li>数据库查询语句使用数据库提供的参数化查询接口</li>
<li>在发布之前使用专业的sql注入检测工具进行检测</li>
<li>避免网站打印sql错误信息</li>
</ul>
<p>通过表单注入：</p>
<pre><code>username =&gt; myuser' or 'foo' = 'foo' --
SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx'
</code></pre>
<p>mssql的sql语句可以执行dos命令:</p>
<pre><code>exec xp_cmdshell 'net user username 2546 /add' # 新建系统用户
exec xp_cmdshell 'net localgroup administrator username /add' # 授权
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_xss/">Xss</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="xss">XSS</h1>
<p>XSS: Cross Site Scripting, 跨站脚本攻击</p>
<p>XSS攻击涉及到攻击者，客户端，和web应用三者.</p>
<p>XSS原理:</p>
<ul>
<li>Web应用未对用户提交请求的数据做充分的检查过滤,允许用户在提交的数据中掺入HTML代码(最主要的是“&gt;”、“&lt;”),并将未经转义的恶意代码输出到第三方用户的浏览器解释执行,是导致XSS漏洞的产生原因。</li>
</ul>
<p>XSS目前主要手段和目的:</p>
<ul>
<li>盗用cookie,获取敏感信息</li>
<li>利用植入flash，通过crossdomain权限设置获取更高权限．</li>
<li>利用iframe, frame, XMLHttpRequests等方式以用户身份执行一些管理操作．</li>
</ul>
<p>XSS预防:</p>
<ul>
<li>过滤特殊字符</li>
<li>使用http头指定类型</li>
</ul></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_cfssl/">Cfssl</a></h2>
                <div class="post-meta">
                    <time>July 28, 2018</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="cfssl">cfssl</h1>
<p><a href="https://github.com/cloudflare/cfssl">https://github.com/cloudflare/cfssl</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gin/">Gin</a></h2>
                <div class="post-meta">
                    <time>July 20, 2018</time>
                    
                        
                            <span class="category">Gin</span>
                        
                    
                </div>
                
                    <p><h1 id="gin">Gin</h1>
<p><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p>
<p>install</p>
<pre><code>$ go get -u github.com/gin-gonic/gin
</code></pre>
<p>import</p>
<pre><code>import &quot;github.com/gin-gonic/gin&quot;
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/rest/">Restful</a></h2>
                <div class="post-meta">
                    <time>July 7, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="rest">REST</h1>
<p>REST: REpresentational State Transfer．</p>
<hr>
<h1 id="restclient">restclient</h1>
<p>一个是firefox的插件．</p>
<p><a href="https://github.com/chao/RESTClient">https://github.com/chao/RESTClient</a></p>
<p>另一个是java开发的application.</p>
<p><a href="https://github.com/wiztools/rest-client">https://github.com/wiztools/rest-client</a></p>
<h1 id="postman">postman</h1>
<p>postman是一个application,同时也可以从chrome启动.</p>
<p><a href="https://github.com/postmanlabs">https://github.com/postmanlabs</a></p>
<h1 id="soupui">soupui</h1>
<p>一个用于SOAP和REST的application.</p>
<p><a href="https://github.com/SmartBear/soapui">https://github.com/SmartBear/soapui</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/webhook/">Webhook</a></h2>
                <div class="post-meta">
                    <time>July 7, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="webhook">WebHook</h1>
<p>用于server和server之间通讯．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/webservice/">WebService</a></h2>
                <div class="post-meta">
                    <time>July 7, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="webservice">webservice</h1>
<p>webservice用于server和browser之间通讯．</p>
<p>webservice是基于http的，无状态的．</p>
<p>webservice一般分为soap webservice和http webservice.</p>
<hr>
<h1 id="soap">SOAP</h1>
<p>Simple Object Access Protocol, 简单对象访问协议，是一个基于XML的协议．</p>
<p>简单来说SOAP的思想就是通过http + XML来在server和browser之间交换信息．</p>
<hr>
<h1 id="soupui">soupui</h1>
<p>一个用于SOAP和REST的application.</p>
<p><a href="https://github.com/SmartBear/soapui">https://github.com/SmartBear/soapui</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/logging_elk/">ELK</a></h2>
                <div class="post-meta">
                    <time>June 8, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="elk">ELK</h1>
<p>kibana: 数据可视化</p>
<p>elasticsearch: 搜索，分析，存储数据</p>
<p>x-pack: 具有监控和报警功能的工具包.</p>
<p>logstash: 动态数据收集管道，支持可扩展的插件．</p>
<p>beats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/logging_grok/">Grok</a></h2>
                <div class="post-meta">
                    <time>June 8, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="grok">grok</h1>
<p>logstash和telegraf都是用grok来解析log</p>
<p>在线检测</p>
<p><a href="http://grokdebug.herokuapp.com/">http://grokdebug.herokuapp.com/</a></p>
<p>grok的正则表达式</p>
<p><a href="https://github.com/kkos/oniguruma/blob/master/doc/RE">https://github.com/kkos/oniguruma/blob/master/doc/RE</a></p>
<p>可用的pattern(logstash &amp; telegraf-logparser/tail)</p>
<p><a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns">https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns</a></p>
<p><a href="https://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns">https://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns</a></p>
<hr>
<h1 id="elastic-stack">Elastic stack</h1>
<p>beats/filebeats: 通过filebeats agent获取log．</p>
<p>logstash: 使用filebeats解析log并写入stash(elasticsearch).</p>
<hr>
<h1 id="tick-stack">TICK stack</h1>
<p>telegraf(agent): 通过logparser/tail插件解析log并写入influxdb.</p>
<p>pattern:</p>
<pre><code># 通过已经定义的变量来定义filter
patterns = ['''${&lt;capture_syntax&gt;[:&lt;semantic_name&gt;][:&lt;modifier&gt;]}''']
patterns = ['''%{TIMESTAMP_ISO8601:asctime:string} \[%{DATA:name:string}\] %{LOGLEVEL:levelname:string}: %{GREEDYDATA:message:string}''']

capture_syntax是已经定义好的pattern.
semantic_name是field/tag的名字, 默认都是string类型的field
modifier 是string/int/float/tag/drop/ts-&quot;CUSTOM&quot;/...类型

timestamp有特殊的modifier:
timestamp 有特殊的modifier：
Timestamp modifiers:ts (This will auto-learn the timestamp format)
ts-ansic (&quot;Mon Jan _2 15:04:05 2006&quot;)
ts-unix (&quot;Mon Jan _2 15:04:05 MST 2006&quot;)
ts-ruby (&quot;Mon Jan 02 15:04:05 -0700 2006&quot;)
ts-rfc822 (&quot;02 Jan 06 15:04 MST&quot;)
ts-rfc822z (&quot;02 Jan 06 15:04 -0700&quot;)
ts-rfc850 (&quot;Monday, 02-Jan-06 15:04:05 MST&quot;)
ts-rfc1123 (&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;)
ts-rfc1123z (&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;)
ts-rfc3339 (&quot;2006-01-02T15:04:05Z07:00&quot;)
ts-rfc3339nano (&quot;2006-01-02T15:04:05.999999999Z07:00&quot;)
ts-httpd (&quot;02/Jan/2006:15:04:05 -0700&quot;)
ts-epoch (seconds since unix epoch, may contain decimal)
ts-epochnano (nanoseconds since unix epoch)
ts-syslog (&quot;Jan 02 15:04:05&quot;, parsed time is set to the current year)
ts-&quot;CUSTOM&quot;
</code></pre>
<p>custom_patterns:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/logging/">Logging</a></h2>
                <div class="post-meta">
                    <time>June 8, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="logging">Logging</h1>
<p>日志采集，存储，可视化.</p>
<p>主要有Elastic stack, splunk, loki.</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/logging_loki/">Loki</a></h2>
                <div class="post-meta">
                    <time>June 8, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="elk">ELK</h1>
<p>kibana: 数据可视化</p>
<p>elasticsearch: 搜索，分析，存储数据</p>
<p>x-pack: 具有监控和报警功能的工具包.</p>
<p>logstash: 动态数据收集管道，支持可扩展的插件．</p>
<p>beats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/dns/">Dns</a></h2>
                <div class="post-meta">
                    <time>May 3, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="dns">DNS</h1>
<p>Domain Name System: 域名系统</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_container/">Container</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="container">Container</h1>
<p>OCI: Open Container Initiative.</p>
<p>CRI: Container Runtime Interface.</p>
<p>CNI: Container Network Interface.</p>
<p>CSI: Container Storage Interface.</p>
<h1 id="oci">OCI</h1>
<p>Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作.</p>
<p>是container的标准.</p>
<p>目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）</p>
<p><a href="https://www.opencontainers.org/">https://www.opencontainers.org/</a></p>
<h2 id="runc">runc</h2>
<p>docker(libcontainer)</p>
<p>runc支持OCI.</p>
<p><a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></p>
<h2 id="rkt">rkt</h2>
<p>redhat(coreos)</p>
<p><a href="https://github.com/rkt/rkt">https://github.com/rkt/rkt</a></p>
<hr>
<h1 id="tools">tools</h1>
<h2 id="dumb-init">dumb-init</h2>
<p>管理pid=1的进程的子进程:</p>
<p><a href="https://github.com/Yelp/dumb-init">https://github.com/Yelp/dumb-init</a></p>
<h2 id="baseimage-docker">baseimage-docker</h2>
<p>处理container中运行多个进程的问题:</p>
<p><a href="https://github.com/phusion/baseimage-docker">https://github.com/phusion/baseimage-docker</a></p>
<h2 id="watchtower">watchtower</h2>
<p>根据registry中的更新自动更新 container:</p>
<p><a href="https://github.com/containrrr/watchtower/">https://github.com/containrrr/watchtower/</a></p>
<h2 id="hadolint">hadolint</h2>
<p>dockerfile 语法检查:</p>
<p><a href="https://github.com/hadolint/hadolint">https://github.com/hadolint/hadolint</a></p>
<h2 id="gosu">gosu</h2>
<p>权限管理</p>
<p><a href="https://github.com/tianon/gosu">https://github.com/tianon/gosu</a></p>
<h2 id="swarm-cronjob">swarm-cronjob</h2>
<p><a href="https://github.com/crazy-max/swarm-cronjob">https://github.com/crazy-max/swarm-cronjob</a></p>
<hr>
<h1 id="misc">misc</h1>
<p>get host ip(docker/docker_gwbridge) from container:</p>
<pre><code>ip route | awk '/default/ { print $3 }'
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_docker/">Docker</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="docker">Docker</h1>
<p><a href="https://store.docker.com/">https://store.docker.com/</a></p>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p><a href="https://github.com/docker">https://github.com/docker</a></p>
<p><a href="https://github.com/moby/moby">https://github.com/moby/moby</a></p>
<p>Docker是一个容器引擎, 分为社区版CE, 和企业版EE, Docker不是虚拟机, 也不依赖虚拟化技术．</p>
<p>docker-cli -&gt; dockerd -&gt; containerd -&gt; shim -&gt; runc</p>
<p>containerd是容器运行时管理引擎.</p>
<p>shim用于管理容器生命周期.</p>
<p>Docker包括三个基本概念:</p>
<ul>
<li>仓库repository,集中存放镜像文件的场所,docker hub/store是最大的公开仓库．</li>
<li>镜像image, 镜像是一个文件系统.</li>
<li>容器container, 容器是镜像的运行的实例．</li>
</ul>
<p>修改docker存储路径:</p>
<pre><code>$ service docker stop
$ mv /var/lib/docker /opt/ssd/docker
$ ln -s /opt/ssd/docker /var/lib/docker
$ service docker start
</code></pre>
<p>Install:</p>
<pre><code>windows:
&lt;https://docs.docker.com/docker-for-windows/install/&gt;

linux:
&lt;https://docs.docker.com/engine/install/ubuntu/&gt;

mac:
&lt;https://github.com/abiosoft/colima/blob/main/docs/FAQ.md#docker&gt;
</code></pre>
<h2 id="config">config</h2>
<p><a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file">https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file</a></p>
<p>docker配置文件:</p>
<pre><code>/etc/docker/daemon.json
/lib/systemd/system/docker.service

{
    // debug
    &quot;debug&quot;: true,
    
    &quot;data-root&quot;： &quot;/var/lib/docker&quot;,
    
    &quot;features&quot;: {
        &quot;buildkit&quot;: true
    },

    //容器访问外网:
    ip-forward=true 会设置 net.ipv4.ip_forward=1, 才能访问外网
    // 容器之间访问:
    icc=true, 
    iptables=true  会修改iptables的forward策略为accept,

    // 修改默认docker0
    &quot;bridge&quot;:
    &quot;bip&quot;: &quot;10.0.0.1/16&quot;  // subnet + gateway
    &quot;fixed-cidr&quot;: &quot;10.41.0.0/24&quot; // iprange
    &quot;fixed-cidr-v6&quot;: &quot;&quot;,
    &quot;mtu&quot;: 1500
    &quot;default-gateway&quot;:
	&quot;default-gateway-v6&quot;: &quot;&quot;,

    // 修改默认dns
    &quot;dns&quot; : [
        &quot;114.114.114.114&quot;,
        &quot;8.8.8.8&quot;
    ]
    &quot;dns-opts&quot;: [],
    &quot;dns-search&quot;: [],

    // ipv6
    &quot;ipv6&quot;: true

    // private registry
  	&quot;insecure-registries&quot;: [],

    // 修改registry
    &quot;registry-mirrors&quot;: [
        &quot;https://registry.docker-cn.com&quot;,
        &quot;https://z4yd270h.mirror.aliyuncs.com&quot;,
        &quot;http://f1361db2.m.daocloud.io&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;
    ]

    &quot;hosts&quot;: [],
    &quot;log-level&quot;: &quot;&quot;,
    &quot;tls&quot;: true,
    &quot;tlsverify&quot;: true,
    &quot;tlscacert&quot;: &quot;&quot;,
    &quot;tlscert&quot;: &quot;&quot;,
    &quot;tlskey&quot;: &quot;&quot;,
}
</code></pre>
<p>proxy for pull image from google(gcr):</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/kubernetes/">Kubernetes</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="kubernetes">Kubernetes</h1>
<p><a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p>
<p><a href="https://github.com/kubernetes/kubeadm">https://github.com/kubernetes/kubeadm</a></p>
<p><a href="https://github.com/kubernetes/kops">https://github.com/kubernetes/kops</a></p>
<p><a href="https://github.com/kubernetes-sigs/kubespray">https://github.com/kubernetes-sigs/kubespray</a></p>
<p>kubernetes简称k8s, 是开源的容器编排工具。</p>
<p>安装单机版k8s:</p>
<ul>
<li>minikube</li>
</ul>
<p>安装k8s集群:</p>
<ul>
<li>kubeadm (k8s内置的，类似于docker swarm mode, 没有HA)</li>
<li>kops (目前主要支持aws等云平台, 国内不友好)</li>
<li>kubespray (通过ansible部署, 国内不友好)</li>
</ul>
<p>k8s发行版：</p>
<ul>
<li>openshift-okd(redhat)</li>
<li>rancher</li>
</ul>
<h1 id="k8s集群组成">k8s集群组成</h1>
<h2 id="master">master</h2>
<ul>
<li>aip-server, 提供资源操作唯一入口</li>
<li>scheduler, 负责资源调度</li>
<li>controller-manager, 负责维护集群状态</li>
<li>etcd(可以部署单独集群), 保存整个集群的状态</li>
</ul>
<h2 id="node">node</h2>
<ul>
<li>kubelet, 负责维护容器生命周期, 还包括CNI CVI</li>
<li>kube-proxy, 为service提供cluster内部的服务发现和负载均衡</li>
<li>CRI(containerd), 创建pod</li>
</ul>
<h2 id="addons">addons</h2>
<ul>
<li>coredns</li>
<li>flannel/cilium/calico</li>
<li>dashboard, web-gui</li>
<li>metrics-server, 取代heapster，用于cpu/memory监控</li>
<li>ingress-nginx, 为服务提供外网入口</li>
<li>federation, 提供跨可用区的集群</li>
</ul>
<hr>
<h1 id="概念">概念</h1>
<p>k8s包含的重要概念:</p>
<p>-: nodes, 运行pod的物理机或虚拟机.
-: namespace, 对资源和对象的抽象集合．pods/deployments/services都属于某个ns.
-: pods,一组紧密关联的容器集合，共享pid,ipc,network,uts,namespace.</p>
<p>k8s业务类型:</p>
<p>-: long-running 长期伺服型 -&gt; RC, RS, Deployment
-: batch 批处理型-&gt; Job
-: node-daemon 节点后台支撑型-&gt; DaemonSet
-: stateful application 有状态应用型-&gt; StatefulSet</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_ns/">Namespace</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="ns">NS</h1>
<p>namespace 是 Linux 内核用来隔离内核资源的方式</p>
<p>Linux namespace资源：</p>
<ul>
<li>Mount: 挂载点</li>
<li>Network: 网络设备/协议栈/端口</li>
<li>IPC: 进程间通信</li>
<li>USR: 用户和用户组</li>
<li>PID: 进程</li>
<li>UTS: 主机名和域名</li>
<li>Cgroup: 控制组</li>
<li>Time</li>
</ul>
<h1 id="cgroup">Cgroup</h1>
<p>Cgroup: Control Groups.是linux下用于对一个或一组进程资源控制和监控的机制.可以管理cpu, memory,diskIO 等资源.不同资源的具体管理工作由相应的cgrouup子系统来实现.</p>
<p>cgroup在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理, 每个cgroup可以包含其它子cgroup.</p>
<pre><code>ls -l /sys/fs/cgroup
</code></pre>
<p>cgroup子系统:</p>
<ul>
<li>cpu</li>
<li>cpuacct</li>
<li>cpuset</li>
<li>memory</li>
<li>blkio</li>
<li>devices</li>
<li>freezer</li>
<li>ns</li>
<li>pid</li>
<li>net_cls</li>
<li>net_prio</li>
</ul>
<hr>
<h1 id="lsns">lsns</h1>
<p>查看系统的namespace</p>
<p>ns类型: mnt, net, ipc, user, pid, uts, cgroup</p>
<pre><code>$lsns -l
$lsns -t net
</code></pre>
<h1 id="unshare">unshare</h1>
<p>使用非共享的NS运行程序</p>
<pre><code>// 创建unshare 的 ns类型.
$unshare -f -m/-n/-i/-U/-p/-u/-C ... 

// 在net类型的namespace执行sleep命令
$unshare -fn sleep 10
</code></pre>
<h1 id="nsenter">nsenter</h1>
<p>ns enter: Namespace enter.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cncf_registry/">Registry</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="container-registry">Container Registry</h1>
<ul>
<li>Docker Hub Registry</li>
<li>Google Container Registry (gcr.io)</li>
<li>RedHat Quay Registry (quay.io)</li>
<li>GitHub Docker Packages (docker.pkg.github.com)(Deprecated)</li>
<li>GitHub Container Registry (ghcr.io)</li>
<li>Kubernetes Registry(registry.k8s.io =&gt; k8s.gcr.io)</li>
</ul>
<h2 id="harbor">Harbor</h2>
<p><a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>Habor是由VMWare中国团队开源的容器镜像仓库, 用于存储和分发docker镜像的registry服务器.</p>
<p>安装步骤:</p>
<ol>
<li>下载并解压安装包, <a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></li>
<li>配置harbor.cfg;</li>
</ol>
<p>修改配置:</p>
<pre><code>vim harbor.yml
</code></pre>
<p>运行安装程序:</p>
<pre><code>./install.sh --with-notary --with-clair --with-chartmuseum
</code></pre>
<p>修改web的port:</p>
<pre><code>$ vim /data/harbor/docker-compose.yml
proxy:
  ports:
    - 8080:80 # 默认http是80
    - 4433:443 # 默认https是443
$ vim /data/harbor/harbor.yml
hostname = ip
</code></pre>
<p>管理harbor:</p>
<pre><code># cd /data/harbor
# docker-compose down -v 　停止并删除container

&gt; 更新配置
# ./prepare --with-notary --with-clair --with-chartmuseum

&gt; 启动
# docker-compose up -d
</code></pre>
<h2 id="docker使用harbor">docker使用harbor</h2>
<p>Deploy a plain HTTP registry:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/swarm/">Swarm</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                    
                </div>
                
                    <p><h1 id="swarm">Swarm</h1>
<p>docker swarm 是 docker内置的容器编排工具。</p>
<p>从docker1.12开始swarm内置于docker engine.</p>
<p>swarm mode具有内置kv存储，服务发现，负载均衡，路由网格，动态伸缩，滚动更新，安全传输等功能。</p>
<p>swarm: 老版本的swarm, 需要kv store, 可以作为独立的container运行, 已废弃, 已经被docker swarm mode 代替.</p>
<p><a href="https://github.com/docker/swarm">https://github.com/docker/swarm</a></p>
<p>swarmkit:</p>
<p><a href="https://github.com/docker/swarmkit">https://github.com/docker/swarmkit</a></p>
<h1 id="swarm命令">swarm命令</h1>
<p>创建集群</p>
<pre><code>docker swarm init
--advertise-addr &lt;ip&gt; 多网卡情况下指定manager的ip

docker swarm join --token &lt;token&gt; &lt;host:port&gt;

# 查看token
docker swarm join-token manager   获取添加manager命令
docker swarm join-token worker   获取添加worker命令
docker swarm join-token -q worker

docker swarm leave -f/--force

docker swarm update
</code></pre>
<p>管理节点</p>
<pre><code>docker node ls
docker node ls --format &quot;{{.Hostname}}&quot;
​
docker node rm
​
docker node inspect
​
# 查看node上运行的tasks/container
docker node ps -f/--filter NODE
​
# 添加label, node.labels.role=api
docker node update --label-add role=api node1
# 删除label
docker node update --label-rm role node1
​
# 活跃节点
docker node update --availability active node1
# 指定该节点满载,不再分派任务,关闭已有任务并重新分派.
docker node update --availability drain node1
# 已有任务继续运行,不分配新任务.
docker node update --availability pause node1

# 查看所有node和label
docker node ls -q | xargs docker node inspect -f '{{ .ID }} [{{ .Description.Hostname }}]: {{ .Spec.Labels }}'
</code></pre>
<p>service</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/swarm_cni/">Swarm CNI</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="cni">CNI</h1>
<p>CNI: Container Network Intarface</p>
<h2 id="单台host上的container通信">单台host上的container通信</h2>
<ul>
<li>none</li>
<li>host</li>
<li>bridge</li>
</ul>
<h2 id="多台host之间的container通信">多台host之间的container通信</h2>
<ul>
<li>overlay</li>
<li>macvlan</li>
</ul>
<h3 id="提供overlaymacvlan的网络服务">提供overlay/macvlan的网络服务</h3>
<p>vxlan encapsulated:</p>
<ul>
<li>canal</li>
<li>flannel</li>
<li>weave</li>
</ul>
<p>bgp unencapsulated:</p>
<ul>
<li>calico</li>
<li>romana</li>
<li>cilium</li>
<li>kube-router</li>
</ul>
<hr>
<h1 id="docker网络管理">Docker网络管理</h1>
<p>查看:</p>
<pre><code>$ docker network ls # 查看所有网络
</code></pre>
<p>默认支持的三种模式:</p>
<pre><code># 默认启动的容器都是桥接(docker0)，重启后容器的ip就变了。
docker run --network bridge  ...
docker run --network host ... # 容器和主机使用相同的ip
docker run --network none ... # 容器不会分配局域网的ip
</code></pre>
<p>创建:</p>
<pre><code>docker network create -d &lt;driver&gt; ... [name]
-d/--driver # 默认是bridge, 可选overlay/macvlan
--subnet  # CIDR格式
--gateway
--ip-range
</code></pre>
<p>使用:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/swarm_csi/">Swarm CSI</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">CNCF</span>
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="csi">CSI</h1>
<p>CSI: Container Storage Interface</p>
<p>CSI提供容器的数据持久化服务.</p>
<p>容器管理数据的两种方式：</p>
<p>数据卷(Volumes)</p>
<p>挂载主机目录(bind mounts)</p>
<p>临时文件系统(tmpfs)</p>
<h2 id="数据存储原理">数据存储原理</h2>
<p>如果container上目录不存在，docker会自动创建</p>
<p>如果container目录存在且有内容，会被host上的目录覆盖掉，但不会被删除.</p>
<h2 id="volumes">Volumes</h2>
<p>如果host上目录不存在，docker会自动创建</p>
<p>volumes是被设计用来持久化数据的，它的生命周期独立于容器.数据卷通过docker volume命令管理的，位于/var/lib/docker/volumes/下面.</p>
<p>Docker不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。</p>
<p>创建:</p>
<pre><code>$ docker volume create &lt;volume-name&gt;
$ docker volume rm &lt;volume-name&gt;
</code></pre>
<p>使用：</p>
<pre><code>$ docker run -v/--volume myvolume:/var/lib/app ...
$ docker run --mount source=myvolume,target=/var/lib/app ...
</code></pre>
<h2 id="bind-mount">Bind mount</h2>
<p>如果host上目录不存在会报错，需要提前创建.</p>
<p>bind mount就是直接将host路径挂在到docker．</p>
<p>source和target都是文件，即可挂载单个文件.</p>
<p>使用:</p>
<pre><code>$ docker run -v/--volume /opt/app:/var/lib/app:ro ...
$ docker run --mount type=bind,source=/opt/app,target=/var/lib/app,readonly ...
</code></pre>
<h2 id="tmpfs">tmpfs</h2>
<p>tmpfs是临时文件系统，也叫内存文件系统，就是将数据存在内存上。</p>
<p>tmpfs只能用于linux, 多个容器也不能共享，容器停止数据就销毁。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/storage_monitoring/">Monitoring</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="monitoring">Monitoring</h1>
<h2 id="diskio">diskio</h2>
<p>IOPS: Input/Output Per Second. 每秒输入输出量，也叫TPS.</p>
<pre><code>SELECT non_negative_derivative(mean(reads),1s) as &quot;read&quot; FROM &quot;diskio&quot;
SELECT non_negative_derivative(mean(writes),1s) as &quot;write&quot; FROM &quot;diskio&quot;
</code></pre>
<p>throughput:</p>
<pre><code>SELECT non_negative_derivative(mean(read_bytes),1s) as &quot;read&quot; FROM &quot;diskio&quot;
SELECT non_negative_derivative(mean(write_bytes),1s) as &quot;write&quot; FROM &quot;diskio&quot;
</code></pre>
<p>Utilization:</p>
<pre><code>SELECT non_negative_derivative(last(&quot;io_time&quot;),1ms)
FROM &quot;diskio&quot;
WHERE &quot;name&quot; =~ /^(v|s|)d(a|b|c|d)$/
GROUP BY &quot;host&quot;,&quot;name&quot;,time(_interval)
</code></pre>
<p>Queue length:</p>
<pre><code>SELECT non_negative_derivative(last(&quot;weighted_io_time&quot;,1ms))
FROM &quot;diskio&quot;
WHERE &quot;name&quot; =~ /^(v|s|)d(a|b|c|d)$/
GROUP BY &quot;host&quot;,&quot;name&quot;,time(_interval)
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/storage/">Storage</a></h2>
                <div class="post-meta">
                    <time>April 5, 2018</time>
                    
                        
                            <span class="category">Storage</span>
                        
                    
                </div>
                
                    <p><h1 id="storage">Storage</h1>
<h1 id="raid">RAID</h1>
<p>RAID: redundant array of independent disks, 独立磁盘冗余数组．</p>
<h1 id="存储方式">存储方式</h1>
<p>DAS: direct attached storage, 直连式存储，通过SCSI或FC连接服务器．</p>
<p>NAS: network attached storage，网络接入存储，通过IP(NFS/CIFS/..).</p>
<p>SAN: storage area network, 存储区域网络，有IP或FC两种方式．</p>
<h1 id="存储接口">存储接口</h1>
<p>SCSI</p>
<p>iSCSI</p>
<p>SAS</p>
<p>SATA</p>
<p>FC</p>
<p>FCoE</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/websocket/">Websocket</a></h2>
                <div class="post-meta">
                    <time>April 3, 2018</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="websocket">WebSocket</h1>
<p>websocket用于server和browser之间通讯．</p>
<p>websocket采用特殊报头，使得浏览器和服务器只需要做一个握手的动作．</p>
<p>通讯数据以\x00开头，以\xFF结尾．</p>
<p>url:</p>
<pre><code>ws://
wss://
</code></pre>
<p>一个客户端只建立一个tcp连接</p>
<p>服务端可以推送/push数据到web客户端</p>
<p>有更加亲量级的头，减少数据传送．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_bom/">JS BOM</a></h2>
                <div class="post-meta">
                    <time>March 15, 2018</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="bom">BOM</h1>
<p>Browser Object Model</p>
<p>介绍浏览器对象，不过缺乏规范.</p>
<h1 id="window">window</h1>
<p>window对象是最顶层对象，有6大属性,属性本身也是对象.</p>
<p>window对象的document属性也是对象，document对象有5大属性.</p>
<p>引用当前窗口时，可以省略window对象.</p>
<p>eg:</p>
<pre><code>window.document
document

window.alert()
alert()
</code></pre>
<p>对象集合:</p>
<pre><code>frames[]
</code></pre>
<p>attribution:</p>
<pre><code>document # DOM的Document对象
history # History对象
location # Location对象
Navigator # Navigator对象
Screen # Screen对象
window # 等价于self

closed
defaultStatus
status
innerheight
innerwidth
outerheight
outerwidth
</code></pre>
<p>method:</p>
<pre><code>alert() // 弹出警告框
confirm() // 和alert差不多，带确定和取消按钮，确定返回true
prompt() // 输入提示框,返回输入内容
find() // 查找

// 子窗口的opener属性反过来引用打开她的那个窗口(父窗口)
subwin = open() // 打开一个新窗口, _parent在当前窗口打开, 返回子窗口的window对象.
subwin.opener // 表示window

moveTo()
moveBy()
resizeTo()
resizeBy()

setTimeout()
clearTimeout()

setInterval()
clearInterval()

close()
</code></pre>
<h1 id="location">location</h1>
<p>attribution:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/travel_brazil/">Brazil</a></h2>
                <div class="post-meta">
                    <time>March 8, 2018</time>
                    
                        
                            <span class="category">Misc</span>
                        
                    
                </div>
                
                    <p><h1 id="巴西之旅">巴西之旅</h1>
<p>看照片：</p>
<h1 id="库里提巴">库里提巴</h1>
<p>库里提巴（Curitiba）</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_alertmanager/">AlertManager</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="alert-manager">alert-manager</h1>
<p>在Prometheus中支持基于PromQL创建告警规则, prometheus通过push触发alertmanager.</p>
<p><a href="https://github.com/prometheus/alertmanager">https://github.com/prometheus/alertmanager</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_exporter/">Exporter</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="exporter">exporter</h1>
<p>广义上讲所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:</p>
<p>prometheus通过pull从exporter拉取数据.</p>
<p>直接采集:cAdvisor, kubernetes, etcd, gokit等直接内置了用于向prometheus暴露监控数据的端点.</p>
<p>间接采集: 通过promethesu的client api编写exporter，例如mysql-exporter, consul-exporter.</p>
<hr>
<h1 id="host">host</h1>
<p><a href="https://github.com/prometheus/node_exporter">https://github.com/prometheus/node_exporter</a></p>
<hr>
<h1 id="k8s">k8s</h1>
<p>k8s metrics api包括 resource metrics api 和 customer metrics api.</p>
<p>cadvisor, metrics-server, kube-state-metrics 等实现了 核心api.</p>
<p>一些adapter实现了自定义api.</p>
<p>k8s-prometheus-adapter实现了metrics-server的核心api，同时实现了自定义api.</p>
<h2 id="metrics-server">metrics-server </h2>
<p>提供了整个集群的资源监控数据</p>
<p><a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p>
<h2 id="cadvisor">cAdvisor</h2>
<p>负责单节点内部的容器和节点资源使用统计，会自动收集本机容器 CPU、内存、网络和文件系统的资源占用情况</p>
<p><a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></p>
<h2 id="kube-state-metrics">kube-state-metrics </h2>
<p>提供了 Kubernetes 资源对象（如 DaemonSet、Deployments 等）的度量。</p>
<p><a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a></p>
<h2 id="adapter">adapter</h2>
<p>同时支持核心api和自定义api.</p>
<p><a href="https://github.com/DirectXMan12/k8s-prometheus-adapter">https://github.com/DirectXMan12/k8s-prometheus-adapter</a></p>
<hr>
<h1 id="blackbox">blackbox</h1>
<p><a href="https://github.com/prometheus/blackbox_exporter">https://github.com/prometheus/blackbox_exporter</a></p>
<h1 id="wmi">wmi</h1>
<p><a href="https://github.com/martinlindhe/wmi_exporter">https://github.com/martinlindhe/wmi_exporter</a></p>
<h1 id="snmp">snmp</h1>
<p><a href="https://github.com/prometheus/snmp_exporter">https://github.com/prometheus/snmp_exporter</a></p>
<h1 id="mysql">mysql</h1>
<p><a href="https://github.com/prometheus/mysqld_exporter">https://github.com/prometheus/mysqld_exporter</a></p>
<h1 id="rabbitmq">rabbitmq</h1>
<p><a href="https://github.com/deadtrickster/prometheus_rabbitmq_exporter">https://github.com/deadtrickster/prometheus_rabbitmq_exporter</a></p>
<h1 id="mongo">mongo</h1>
<p><a href="https://github.com/percona/mongodb_exporter">https://github.com/percona/mongodb_exporter</a></p>
<h1 id="redis">redis</h1>
<p><a href="https://github.com/oliver006/redis_exporter">https://github.com/oliver006/redis_exporter</a></p>
<h1 id="haproxy">haproxy</h1>
<p><a href="https://github.com/prometheus/haproxy_exporter">https://github.com/prometheus/haproxy_exporter</a></p>
<h1 id="consul">consul</h1>
<p><a href="https://github.com/prometheus/consul_exporter">https://github.com/prometheus/consul_exporter</a></p>
<hr>
<h1 id="pushgateway">pushgateway</h1>
<p><a href="https://github.com/prometheus/pushgateway">https://github.com/prometheus/pushgateway</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_influxdb/">Influxdb</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="influxdb">Influxdb</h1>
<p><a href="https://github.com/influxdata/influxdb">https://github.com/influxdata/influxdb</a></p>
<p>Scalable datastore for metrics, events, and real-time analytics.</p>
<p>支持从opentsdb, graphite, collectd等获取数据</p>
<p>默认数据库_internal 用于存储内部运行数据</p>
<p>安装配置参考官方文档</p>
<p>log</p>
<pre><code>$ sudo journalctl -u influxdb.service
</code></pre>
<p>config:</p>
<pre><code># 开通kapacitor的subscription功能
[[subscriber]]
enable = true
</code></pre>
<hr>
<h1 id="数据结构">数据结构</h1>
<p>influxdb每条记录是一个point.</p>
<p>points包括下面部分：</p>
<pre><code>measurement: a measurement, like cpu_load, 相当于表名
tags: zero or more tag, key=value, eg: host=ip
fields: zero or more field, key=value, eg: value=0.18
time: a timestamp

&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]
</code></pre>
<p>series: 在一个database中,相同的retention policy, measurement, tag set的数据集，叫一个序列．</p>
<p>RP: retention policy, autogen是默认的存储策略, 用于设置数据保留时间.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_kapacitor/">Kapacitor</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="kapacitor">Kapacitor</h1>
<p><a href="https://github.com/influxdata/Kapacitor">https://github.com/influxdata/Kapacitor</a></p>
<p>Open source framework for processing, monitoring, and alerting on time series data</p>
<p>可以通过chrongraf创建tickscript/task, 然后通过api/cli导入到kapacitor.</p>
<p>配置:</p>
<pre><code>hostname = &quot;kapcitor-service&quot;

# 如果从influxdb读取数据需要配置该选项．
[[influxdb]]
enabled = true

# 如果从该路径加载tickscript
[[load]]
enabled = true
dir=&quot;/etc/kapacitor/load&quot;
# tasks, 放到/etc/kapacitor/load/tasks/*.tick,重启kapacitor会自动加载task,并默认enable.
## 要求，ID和tick文件同名，tickscript开头需要指定dbrp, tickscript里面需要指定batch/stream.
# templates...
# handlers...
</code></pre>
<hr>
<h1 id="cli">CLI</h1>
<pre><code>$ kapacitor help

# 创建template(也就是变量可以单独赋值的tickscript)
$ kapacitor define-template &lt;name&gt; -tick /path/template.tick
$ kapacitor show-template &lt;name&gt;

# 创建/更新 task, 创建的默认是disable状态.
# 从tickscript创建task
$ kapacitor define &lt;name&gt; -tick task.tick -type [stream|batch] -dbrp [database.retentionPolicy]
# 从template创建task(如果yaml/json中没有指定template需要用-template指定)
$ kapacitor define &lt;name&gt; -file task.yaml
$ kapacitor define &lt;name&gt; -file task.json

# 删除task
$ kapacitor delete [task id/name]

$ kapacitor list tasks/templates
$ kapacitor reload [task id/name] # 相当于disable &amp; enable.
$ kapacitor enable [task id/name]
$ kapaciror disable [task id/name]
$ kapacitor show [id/name]
$ kapacitor watch [task id/name]

$ kapacitor list topics
$ kapacitor delete topics [topic id]
</code></pre>
<hr>
<h1 id="http-api">Http API</h1>
<pre><code>port = 9092
</code></pre>
<h2 id="configuration">configuration</h2>
<p>获取所有可以overwrite的参数</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_prometheus/">Prometheus</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="prometheus">Prometheus</h1>
<p>Prometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询</p>
<p>swarm部署:</p>
<p><a href="https://github.com/vegasbrianc/prometheus">https://github.com/vegasbrianc/prometheus</a></p>
<p>k8s部署:</p>
<p><a href="https://github.com/coreos/kube-prometheus">https://github.com/coreos/kube-prometheus</a></p>
<p><a href="https://github.com/coreos/prometheus-operator">https://github.com/coreos/prometheus-operator</a></p>
<p><a href="https://github.com/helm/charts/tree/master/stable/prometheus-operator">https://github.com/helm/charts/tree/master/stable/prometheus-operator</a></p>
<p>高可用:</p>
<p><a href="https://github.com/thanos-io/thanos">https://github.com/thanos-io/thanos</a></p>
<p>prometheus grafana dashboard:</p>
<p><a href="https://github.com/kubernetes-monitoring/kubernetes-mixin">https://github.com/kubernetes-monitoring/kubernetes-mixin</a></p>
<p><a href="https://github.com/grafana/kubernetes-app">https://github.com/grafana/kubernetes-app</a></p>
<hr>
<h1 id="promql">PromQL</h1>
<p>metrics类型:</p>
<ol>
<li>counter计数器</li>
<li>gauge仪表盘</li>
<li>histogram直方图</li>
<li>summary摘要</li>
</ol></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_telegraf/">Telegraf</a></h2>
                <div class="post-meta">
                    <time>January 18, 2018</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="telegraf">Telegraf</h1>
<p><a href="https://github.com/influxdata/telegraf">https://github.com/influxdata/telegraf</a></p>
<p>The plugin-driven server agent for collecting &amp; reporting metrics.</p>
<hr>
<h1 id="configuartion">Configuartion</h1>
<p>agent configuration:</p>
<pre><code>interval    所有inputs的默认运行间隔
round_interval
collection_jitter
precision    ns/us/ms/s
flush_interval
flush_jitter
</code></pre>
<p>input configuration:</p>
<pre><code>interval
name_override # 默认measurements是插件名,修改默认measurements.
name_prefix
name_suffix
tags
</code></pre>
<hr>
<h1 id="go-api">Go API</h1>
<p><a href="https://godoc.org/github.com/influxdata/telegraf#Input">https://godoc.org/github.com/influxdata/telegraf#Input</a></p>
<p>测试插件：</p>
<pre><code># 需要配置文件
$ telegraf --input-filter &lt;plugin-name&gt; --test
</code></pre>
<hr>
<h1 id="build">Build</h1>
<p>安装依赖：</p>
<pre><code>sudo apt-get install ruby-dev
sudo gem install fpm
sudo apt-get install rpm
</code></pre>
<p>编译telegraf:</p>
<pre><code>make telegraf
</code></pre>
<p>生成配置文件：</p>
<pre><code>./telegraf config &gt; ./etc/telegraf.conf
</code></pre>
<p>构建deb:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_oss/">Contribution</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="golang-contribution">Golang Contribution</h1>
<p><a href="https://go.dev/doc/contribute">https://go.dev/doc/contribute</a></p>
<h2 id="创建google账号">创建google账号</h2>
<p>推荐申请一个google邮箱。</p>
<p>在开发机配置git</p>
<pre><code>$ git config --global user.email name@example.com   
$ git config user.email name@example.com            
</code></pre>
<h2 id="签cla">签CLA</h2>
<p>个人开发者需要签署CLA。</p>
<p><a href="https://cla.developers.google.com/about/google-individual">https://cla.developers.google.com/about/google-individual</a></p>
<h2 id="配置git认证">配置git认证</h2>
<p>点击“Generate Password”， 用google邮箱登陆，根据提示配置git。</p>
<p><a href="https://go.googlesource.com/">https://go.googlesource.com/</a></p>
<h2 id="创建gerrit账号">创建gerrit账号</h2>
<p>用google邮箱登陆即可。</p>
<p><a href="https://go-review.googlesource.com/dashboard/self">https://go-review.googlesource.com/dashboard/self</a></p>
<h2 id="安装git-codereview">安装git-codereview</h2>
<p>windows:</p>
<pre><code>$ go get golang.org/x/review/git-codereview@latest
$ git --exec-path

&gt; copy git-codereview.exe from GOBIN to Git\mingw64\libexec\git-core

$ git codereview help
</code></pre>
<p>linux/mac:</p>
<pre><code>$ go install golang.org/x/review/git-codereview@latest
$ git codereview help
</code></pre>
<h2 id="选取修改的cl">选取修改的CL</h2>
<p>从github选取一个还没有人提交CL(change log/list)的Issue进行修改。</p>
<p>issue三种类型：</p>
<ul>
<li>NeedsInvestigation</li>
<li>NeedsDecision</li>
<li>NeedsFix    选这个里面还没有CL的做</li>
</ul>
<p><a href="https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22">https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22</a></p>
<h2 id="提交patch">提交patch</h2>
<p>支持github或者gerrit提交patch。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_debug/">Debug</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="gdb">gdb</h1>
<h1 id="delve">delve</h1>
<p><a href="https://github.com/derekparker/delve">https://github.com/derekparker/delve</a></p>
<hr>
<h1 id="debug">debug</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_devops/">Devops</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="go">Go</h1>
<p>go有三种安装方式：</p>
<ol>
<li>源码安装</li>
<li>标准包安装</li>
<li>第三方工具安装</li>
</ol>
<p>GOROOT:</p>
<pre><code>GOROOT 就是go的安装目录
</code></pre>
<p>windows标准包安装go:</p>
<pre><code>msi指定安装路径，自动添加%GOROOT%/bin到环境变量
</code></pre>
<p>linux标准包安装go:</p>
<pre><code>下载.tar.gz包解压到/usr/local/go
GOROOT=/usr/local/go
export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p>验证安装：</p>
<pre><code>$ go --help
$ go version
</code></pre>
<p>第三方工具gvm安装go:</p>
<p><a href="http://github.com/moovweb/gvm">http://github.com/moovweb/gvm</a></p>
<pre><code>$ gvm install go1.9.2
$ gvm use go1.9.2
</code></pre>
<hr>
<h1 id="gopath">GOPATH</h1>
<p>gopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．</p>
<p>GOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:</p>
<pre><code>GOPATH=$USERPROFILE%go
GOPATH=$HOME/go
</code></pre>
<p>gopath结构：</p>
<pre><code>src    存放源码
pkg    编译后的库文件
bin    编译后生成的可执行文件
</code></pre>
<p>gopath有多个值时用冒号分开即可.</p>
<h1 id="gobin">GOBIN</h1>
<p>默认值</p>
<pre><code>GOBIN=$HOME/go/bin
export PATH=$PATH:$HOME/go/bin
</code></pre>
<p>go get 和 go install 安装的二进制到GOBIN。</p>
<hr>
<h1 id="go命令">go命令</h1>
<pre><code>$ go help [command]
</code></pre>
<p>get</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_document/">Document</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="document">Document</h1>
<p>go文档相关</p>
<p><a href="https://godoc.org/">https://godoc.org/</a></p>
<p>go文档的两种方式:</p>
<ul>
<li>go doc</li>
<li>godoc</li>
</ul>
<h1 id="go-doc">go doc</h1>
<p>直接在命令行查看文档</p>
<pre><code>$ go doc [package/symbol]
</code></pre>
<h1 id="godoc">godoc</h1>
<p>go自带的文档命令行接口,在浏览器查看文档</p>
<pre><code>godoc package [name ...]
godoc -http=:6060
</code></pre>
<p>通过github的项目文档在:</p>
<pre><code>https://godoc.org
</code></pre>
<hr>
<h1 id="godev">go.dev</h1>
<p><a href="https://pkg.go.dev">https://pkg.go.dev</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go/">Go</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="go概述">Go概述</h1>
<p><a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a></p>
<p>go语言表达能力强，简洁，清晰，高效．</p>
<p>go是一个快速的，静态的，强类型的，编译型语言．</p>
<p>go具有高并发和垃圾回收功能.</p>
<hr>
<h1 id="go基本语法">Go基本语法</h1>
<p>go源程序叫*.go</p>
<p>go大小写敏感</p>
<p>go程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．</p>
<p>go中只有首字母大写的名称才能从包中导出．</p>
<p>go的类型在变量名后面．</p>
<p>go函数外的每个语句都必须以关键字开始.</p>
<p>go标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.</p>
<p>go使用大括号{}表示一个代码块.</p>
<p>go使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．</p>
<p>go的包名一般是小写的单个单词(文件所在的最后一层目录名).</p>
<p>go一般使用驼峰命名法.</p>
<p>go没有逗号操作符.</p>
<p>go中++/&ndash;是语句不是表达式．</p>
<p>go中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.</p>
<hr>
<h1 id="go注释">Go注释</h1>
<p>单行注释：</p>
<pre><code>// comment
</code></pre>
<p>多行注释：</p>
<pre><code>/* comment */
</code></pre>
<hr>
<h1 id="go关键字">Go关键字</h1>
<pre><code>var const 
break continue for if else switch case default goto fallthrough
func return defer
package import
range type struct map
interface
select go chan
</code></pre>
<hr>
<h1 id="go运算符和优先级">Go运算符和优先级</h1>
<p>go中的运算都是从左到右结合．</p>
<pre><code>^    #
!    # 逻辑非

*
/    # 结果取整数
%
&lt;&lt;   # 位运算，左移
&gt;&gt;   # 位运算，右移
&amp;    # 位运算，　按位与
&amp;^   #

+
-
|    # 位运算,按位或
^    # 位运算,按位异或

==
!=
&lt;
&lt;=
&gt;
&gt;=

&lt;- # chan运算符

&amp;&amp;   # 逻辑与
||   # 逻辑或
</code></pre>
<hr>
<h1 id="go数据类型">Go数据类型</h1>
<h2 id="变量">变量</h2>
<p>定义/申明变量:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_concurrency/">Go_Concurrency</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="并发concurrency">并发/concurrency</h1>
<p>CSP: communicating sequential processes, 通信顺序进程。</p>
<p>go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.</p>
<p>concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。</p>
<p>所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.</p>
<p>parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。</p>
<p>process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。</p>
<p>thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。</p>
<p>co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。</p>
<p>goroutine: go语言的协程，是并行的，通过channel来通信.</p>
<p>GMP: goroutine的实现模型。</p>
<p>G: goroutine。</p>
<p>M: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。</p>
<p>P: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。</p>
<p>不要通过共享内存通信，通过通信来共享内存。</p>
<h2 id="goroutines">goroutines</h2>
<p>go关键字会启动一个新的goroutine并执行.</p>
<p>每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。</p>
<p>当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.</p>
<p>当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.</p>
<pre><code>go FuncName(...)
</code></pre>
<p>主进程main结束了，goroutine也结束．</p>
<h2 id="竟态">竟态</h2>
<p>race condition: 竞争状态，多个goroutine同时操作同一资源.</p>
<pre><code># 检测竞争状态
$ go build -race
</code></pre>
<p>所以要解决goroutine间的消息传递和同步的问题.</p>
<p>通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。</p>
<p>channel还是mutex,选择的依据是他们的能力/特性.</p>
<p>channel的能力是让数据流动起来，擅长的是数据流动的场景:</p>
<ul>
<li>传递数据的所有权，即把某个数据发送给其他协程</li>
<li>分发任务，每个任务都是一个数据</li>
<li>交流异步结果，结果是一个数据</li>
</ul>
<p>sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:</p>
<ul>
<li>缓存</li>
<li>状态</li>
</ul>
<hr>
<h2 id="channel">channel</h2>
<p>goroutine通过channel来传递消息.</p>
<p>channels是引用类型,chan是线程安全的，并且不会有数据冲突。</p>
<p>channel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.</p>
<p>chan通过make来创建，通过close来关闭．</p>
<p>chan是先进先出的.</p>
<p>如果chan指定了容量(有缓存), 就是异步，非阻塞模式．</p>
<p>默认是无缓存的，同步的,　阻塞模式.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_builtin/">GSL_builtin</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="builtin">builtin</h1>
<p><a href="https://golang.org/pkg/builtin/">https://golang.org/pkg/builtin/</a></p>
<p>go的builtin package.</p>
<h2 id="constants">constants</h2>
<pre><code>true
false
iota
</code></pre>
<h2 id="variables">variables</h2>
<p>pointer, slice, map, channel, func, interface的零值：</p>
<pre><code>nil
</code></pre>
<h2 id="functions">functions</h2>
<pre><code># 分配并初始化各种类型的对象, 返回一个指针．
new(Type) *Type

# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.
make(t Type, size ...IntegerType) Type

# 返回容量，　Array/ArrayPointer/Slice/Channel
cap(v Type) int

# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel
len(v Type) int

print(args ...Type)

println(args ...Type)
</code></pre>
<p>complex:</p>
<pre><code># 把两个浮点数构造成一个复数
complex(r, i FloatType) ComplexType

# 返回复数c的实部
real(c ComplexType) FloatType

# 返回复数c的虚部
imag(c ComplexType) FloatType
</code></pre>
<p>slice:</p>
<pre><code># 向切片末尾追加元素，返回新的切片．切片长度增加.
# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．
# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.
append(slice []Type, elems ...Type) []Type

# 复制一个切片, 返回复制的元素的个数
copy(dst, src []Type) int
</code></pre>
<p>map:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_concurrency/">GSL_concurrency</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="sync">sync</h1>
<p>sync用于goroutine同步.</p>
<pre><code>import &quot;sync&quot;
</code></pre>
<h2 id="constants">constants</h2>
<h2 id="variables">variables</h2>
<h2 id="functions">functions</h2>
<h2 id="locker">Locker</h2>
<p>一个可以加锁和解锁的接口</p>
<pre><code>type Locker interface {
    Lock()
    Unlock()
}
</code></pre>
<h2 id="pool">Pool</h2>
<p>Pool是一个可以分别存取的临时对象的集合。</p>
<h2 id="once">Once</h2>
<p>只执行一次动作的对象(单例模式)</p>
<pre><code>type Once struct {}
</code></pre>
<p>method:</p>
<pre><code>// 只有第一次调用才执行
func (o *Once) Do(f func())
</code></pre>
<h2 id="mutex">Mutex</h2>
<p>互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.</p>
<p>Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。</p>
<p>同一时刻只能有一个线程进入临界区.</p>
<pre><code>type Mutex struct {}

Mutex
</code></pre>
<p>method:</p>
<pre><code>// 加锁，如果已经加锁，阻塞至m解锁．
func (m *Mutex) Lock()

// 解锁，如果没有加锁，导致panic
func (m *Mutex) Unlock()
</code></pre>
<h2 id="rwmutex">RWMutex</h2>
<p>读写互斥锁,可以由不同的线程加锁和解锁.</p>
<pre><code>type RWMutex struct {}
</code></pre>
<p>method:</p>
<pre><code>// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。
func (rw *RWMutex) Lock()

// 解除写入锁定，如果没有加锁，导致panic
func (rw *RWMutex) Unlock()

// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。
func (rw *RWMutex) RLock()

// 解除读取锁，如果没有加锁，导致panic.
func (rw *RWMutex) RUnlock()
</code></pre>
<h2 id="cond">Cond</h2>
<p>条件变量.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_cryptographic/">GSL_cryptographic</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="crypto">crypto</h1>
<p>收集了常用的密码常量</p>
<h2 id="functions">functions</h2>
<pre><code>RegisterHash(h Hash, f func() hash.Hash)
</code></pre>
<h2 id="publickey">PublicKey</h2>
<p>interface:</p>
<pre><code>type PublicKey interface{}
</code></pre>
<h2 id="privatekey">PrivateKey</h2>
<p>interface:</p>
<pre><code>type PrivateKey interface{}
</code></pre>
<h2 id="hash">Hash</h2>
<pre><code>type Hash uint
</code></pre>
<p>method:</p>
<pre><code>func (h Hash) Avaliable() bool
func (h Hash) Size() int
func (h Hash) New() hash.Hash
</code></pre>
<hr>
<h1 id="cryptocipher">crypto/cipher</h1>
<p>用于包装底层块加密算法的实现.</p>
<h2 id="block">Block</h2>
<p>代表一个使用特定密钥的底层　加／解密器．</p>
<pre><code>type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}
</code></pre>
<h2 id="blockmode">BlockMode</h2>
<p>代表一个工作在块模式(CBC, ECB等)的加／解密器</p>
<pre><code>type BlockMode interface {
    BlockSize() int
    CryptBlocks(dst, src []byte)
}
</code></pre>
<p>function:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_data/">GSL_data</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="time">time</h1>
<h2 id="constants">constants</h2>
<p>const:</p>
<pre><code>const (
    ANSIC       = &quot;Mon Jan _2 15:04:05 2006&quot;
    Unixdate    = &quot;Mon Jan _2 15:04:05 MST 2006&quot;
    RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;
    ...
)
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>// 阻塞go程d代表的时间段
func Sleep(d Duration)

func After(d Duration) &lt;- chan Time

func Tick(d Duration) &lt;- chan Time
</code></pre>
<h2 id="time-1">Time</h2>
<p>代表一个纳秒精度的时间点.</p>
<p>零值是January 1, year 1, 00:00:00.000000000 UTC.</p>
<p>struct:</p>
<pre><code>type  Time struct {}
</code></pre>
<p>functions:</p>
<pre><code>// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST
func date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time

// 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301
func Now() Time

func Parse(layout, value s tring) (Time, error)

func ParseInLocation(layout, value string, loc *Location) (Time, error)

func Unix(sec int64, nsec int64) Time
</code></pre>
<p>methods:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_database/">GSL_database</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="databasesql">database/sql</h1>
<p>使用该包，必须提供一个数据库驱动</p>
<p><a href="https://github.com/golang/go/wiki/SQLDrivers">https://github.com/golang/go/wiki/SQLDrivers</a></p>
<p>mssql driver:</p>
<p><a href="https://github.com/denisenkom/go-mssqldb">https://github.com/denisenkom/go-mssqldb</a></p>
<p>mysql driver:</p>
<p><a href="https://github.com/go-sql-driver/mysql">https://github.com/go-sql-driver/mysql</a></p>
<p>postgresql driver:</p>
<p><a href="https://github.com/lib/pq">https://github.com/lib/pq</a></p>
<p><a href="https://github.com/jackc/pgx">https://github.com/jackc/pgx</a></p>
<h2 id="variables">variables</h2>
<pre><code>// QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量
var ErrNoRows = errors.New(&quot;sql: no rows in result set&quot;)
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>// 注册并命名一个数据库，在Open中使用该命名启用该驱动
// 如果注册同一名称两次或者driver参数为nil, 会导致panic.
Register(name string, driver driver.Driver)
</code></pre>
<h2 id="db">DB</h2>
<p>DB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．</p>
<p>可以安全的被多个go程同时使用．</p>
<p>struct:</p>
<pre><code>type DB struct {}
</code></pre>
<p>functions:</p>
<pre><code>// 验证数据库驱动和参数,并不创建和数据库的连接．
// driverName: mssql, mysql, postgres
// mssql dataSourceName: &quot;server=%s;port=%d;database=%s;user id=%s;password=%s&quot;
// mysql dataSourceName: &quot;user:password@tcp(server:port)/database&quot;
Open(driverName, dataSourceName string) (*DB, error)
</code></pre>
<p>methods:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_file/">GSL_file</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="path">path</h1>
<h2 id="function">function</h2>
<pre><code>func IsAbs(path string) bool
func Join(elem ...string) string
func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string 
...
</code></pre>
<hr>
<h1 id="pathfilepath">path/filepath</h1>
<h2 id="constants">Constants</h2>
<pre><code>const (
    Separator = os.PathSeparator
    ListSeparator = os.PathListSeparator
)
</code></pre>
<h2 id="variable">Variable</h2>
<pre><code>var ErrBadPattern = errors.New(&quot;Syntax error in pattern&quot;)

var SkipDir = errors.New(&quot;skip this diractory&quot;)
</code></pre>
<h2 id="function-1">function</h2>
<pre><code>func IsAbs(path string) bool
func Abs(path string) (string, error)

// 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名.
func Rel(basepath, targpath string) (string, error)

func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string) // 包括小数点
func Walk(root string, walkFn WalkFunc) error
</code></pre>
<h2 id="walkfunc">WalkFunc</h2>
<p>调用Walk时会对每个目录和文件调用该函数.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_golang/">GSL_golang</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="runtime">runtime</h1>
<h2 id="constants">constants</h2>
<pre><code>// 指定编译器
const Compiler = &quot;gc&quot;/&quot;gccgo&quot;

// 处理器架构: 386/amd64/arm
const GOARCH string = theGoarch

// 操作系统: linux/freebsd/darwin/win
const GOOS string = theGoos
</code></pre>
<h2 id="variables">variables</h2>
<pre><code>var MemProfileRate int = 512 * 1024
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>func GOROOT() string
func Version() string

// 返回本地机器的逻辑cpu个数
func NumCPU() int

//更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu.
func GOMAXPROCS(n int) int

// 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行.
// 当前goroutine放回队列等待继续执行.
func Gosched()

// 终止当前goroutine,终止前执行所有defer.
func Goexit()
</code></pre>
<hr>
<h1 id="runtimedebug">runtime/debug</h1>
<h2 id="function">function</h2>
<pre><code>// 设置最大线程数，默认1000.
func SetMaxThreads(threads int) int
</code></pre>
<hr>
<h1 id="runtimecgo">runtime/cgo</h1>
<hr>
<h1 id="runtimepprof">runtime/pprof</h1>
<hr>
<h1 id="runtimerace">runtime/race</h1>
<hr>
<h1 id="runtimetrace">runtime/trace</h1>
<hr>
<h1 id="go">go</h1>
<hr>
<h1 id="expvar">expvar</h1>
<hr>
<h1 id="context">context</h1>
<hr>
<h1 id="unsafe">unsafe</h1>
<hr>
<h1 id="errors">errors</h1>
<h2 id="function-1">function</h2>
<pre><code>// 使用字符串创建一个错误, 返回一个error
func New(text string) error
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_math/">GSL_math</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="math">math</h1>
<h2 id="constants">constants</h2>
<h2 id="variables">variables</h2>
<h2 id="functions">functions</h2>
<hr>
<h1 id="mathbig">math/big</h1>
<hr>
<h1 id="mathcmplx">math/cmplx</h1>
<hr>
<h1 id="mathrand">math/rand</h1>
<hr>
<h1 id="sort">sort</h1>
<h2 id="functions-1">functions</h2>
<pre><code>func Ints(a []int)
func IntAreSorted(a []int) bool
func SearchInts(a []int, x int) int

func Float64s(a []float64)
func Float64sArerSorted(a []float64) bool
func SearchFloat64s(a []float64, x float64) int

func Strings(a []string)
func StringsAreSorted(a []string) bool
func SearchStrings(a []string, x string) int

func Sort(data Interface)
func Stable(data Interface)
func IsSorted(data Interface) bool
func Reverse(data Interface) Interface
// 二分查找
func Search(n int, f func(int) bool) int
</code></pre>
<h2 id="interface">Interface</h2>
<pre><code>type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
</code></pre>
<h2 id="initslice">InitSlice</h2>
<pre><code>type InitSlice []int
</code></pre>
<h2 id="float64slice">Float64Slice</h2>
<pre><code>type Float64Slice []float64
</code></pre>
<h2 id="stringslice">StringSlice</h2>
<pre><code>type StringSlice []string
</code></pre>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_multimedia/">GSL_multimedia</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="image">image</h1>
<hr>
<h1 id="mime">mime</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_network/">GSL_network</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="net">net</h1>
<p>网络IO接口，包括TCP/IP, UDP, SOCKET, DNS</p>
<pre><code>import &quot;net&quot;
</code></pre>
<h2 id="constants">constants</h2>
<pre><code>const (
    IPv4len = 4
    IPv6len = 16
)
</code></pre>
<h2 id="variables">variables</h2>
<h2 id="functions">functions</h2>
<h2 id="addr">Addr</h2>
<p>代表一个网络终端地址．</p>
<p>TCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口</p>
<pre><code>type Addr interface {
    Network() string
    String() string
}
</code></pre>
<h2 id="tcpaddr">TCPAddr</h2>
<p>function:</p>
<pre><code>func ResolveTCPAddr(net, addr string) (*TCPAddr, error)
</code></pre>
<h2 id="udpaddr">UDPAddr</h2>
<p>function:</p>
<pre><code>func ResolveUDPAddr(net, addr string) (*UDPAddr, error)
</code></pre>
<h2 id="ipaddr">IPAddr</h2>
<p>function:</p>
<pre><code>func ResolveIPAddr(net, addr string) (*IPAddr, error)
</code></pre>
<h2 id="unixaddr">UnixAddr</h2>
<p>function:</p>
<pre><code>func ResolveUnixAddr(net, addr string) (*UnixAddr, error)
</code></pre>
<h2 id="conn">Conn</h2>
<p>该接口代表通用的面向流的网络连接．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_oop/">GSL_oop</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="reflect">reflect</h1>
<h2 id="constants">constants</h2>
<p>const:</p>
<pre><code>const (
    SelectSend
    SelectRecv
    SelectDefault
)
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>// 将src拷贝到dst, 直到src被耗尽或dst被装满.
func Copy(dst, src Value) int

// 判断两个值是否深度一致
func DeepEqual(a1, a2 interface{}) bool
</code></pre>
<h2 id="kind">Kind</h2>
<p>表示Type类型值表示的具体分类.</p>
<pre><code>type Kind uint

const (
    Invalid Kind = iota
    Bool
    Int
    ...
    Uint
    ...
    Float...
    Complex...
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
</code></pre>
<p>method:</p>
<pre><code>func (k Kind) String() string
</code></pre>
<h2 id="stringheader">StringHeader</h2>
<h2 id="sliceheader">SliceHeader</h2>
<h2 id="structfield">StructField</h2>
<h2 id="structtag">StructTag</h2>
<h2 id="chandir">ChanDir</h2>
<h2 id="selectdir">SelectDir</h2>
<h2 id="selectcase">SelectCase</h2>
<h2 id="method">Method</h2>
<h2 id="type">Type</h2>
<p>用来表示一个go类型.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_string/">GSL_string</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="strings">strings</h1>
<p>实现了用于操作字符的函数.</p>
<h2 id="functions">functions</h2>
<pre><code>func EqualFold(s, t string) bool

func HasPrefix(s, prefix string) bool
func HasSuffix(s, suffix string) bool

func Count(s, sep string) int

func Contains(s, substr string) bool
...

func Index(s, sep string) int
...

func LastIndex(s, sep string) int
...

func title(s string) string

func ToLower(s string) string
...

// 返回count个string
func Repeat(s string, count int) string

func Replace(s, old, new string, n int) string

func Map(mapping func(rune) rune, s string) string

func Trim(s string, cutset string) string
...

// 返回将字符串按照空白分割的多个字符串
func Fields(s string) []string
// 按照f作为分隔符来分割字符串，返回切片
func FieldsFunc(s string, f func(rune) bool) []string

func Split(s, sep string) []string
...

// 将一系列字符串连接为一个字符串，之间用sep来分割.
func Join(a []string, sep string) string
</code></pre>
<h2 id="reader">Reader</h2>
<h2 id="replacer">Replacer</h2>
<hr>
<h1 id="bytes">bytes</h1>
<p>实现了操作[]bytes的常用函数.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_system/">GSL_system</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="os">os</h1>
<p>提供了操作系统的不依赖平台的接口</p>
<pre><code>import &quot;os&quot;
</code></pre>
<h2 id="constants">constants</h2>
<pre><code># flag 参数
const (
    O_RDONLY int = syscall.O_RDONLY
    O_WRONLY int = syscall.O_WRONLY
    O_RDWR int = syscall.O_RDWR
    O_CREATE int = syscall.O_CREATE # 不存在就创建
    O_APPEND int = syscall.O_APPEND # 追加写入
    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件
    O_EXCL int = syscall.O_EXCL
    O_SYNC int = syscall.O_SYNC
)

const (
    SEEK_SET int = 0
    SEEK_CUR int = 1
    SEEK_END int = 2
)

const (
    // 操作系统指定的路径分隔符
    PathSeperator = '/'
    // 操作系统指定的表分隔符
    PathListSeparator = ':'
)

// 操作系统空设备的名字
const DevNull = &quot;/dev/null&quot;
</code></pre>
<h2 id="variables">variables</h2>
<pre><code>var (
    ErrInvalid = errors.New(&quot;invalid argument&quot;)
    ...
)

// 指向标准输入／输出／错误的文件描述符
var (
    Stdin = NewFile(uintptr(syscall.Stdin), &quot;/dev/stdin&quot;)
    Stdout = NewFile(uintptr(syscall.Stdout), &quot;/dev/stdout&quot;)
    Stderr = NewFile(uintptr(syscall.Stderr), &quot;/dev/stderr&quot;)
)

// 保存了命令行参数，第一个是程序名
var Args []string
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>// 返回内核提供的主机名
func Hostname() (name string, err error)

// 当前程序以给出的状态码马上退出，defer不会执行
func Exit(code int)

// 返回key=value格式的环境变量的字符串的切片拷贝
func Environ() []string
</code></pre>
<p>文件相关的操作</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/gsl_test/">GSL_test</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="testing">testing</h1>
<p>go的测试由go test命令和testing包组成．</p>
<p>测试程序命名：</p>
<pre><code>XXX.go # 测试文件和源码放在一个包中
XXX_test.go
</code></pre>
<p>测试程序结构：</p>
<pre><code>import &quot;testing&quot;

# 单元测试
# go test 会自动执行
func TestXXX(t *testing.T) {}

# 性能测试
# go test XXX_test.go -test.bench=&quot;.*&quot;  压力测试需要指定才能执行
func BenchmarkXXX(b *testing.B) {}
</code></pre>
<h2 id="constants">constants</h2>
<h2 id="variables">variables</h2>
<h2 id="functions">functions</h2>
<h2 id="t">T</h2>
<p>管理测试状态并支持格式化测试的日志．</p>
<p>struct:</p>
<pre><code>type T struct {}
</code></pre>
<p>methods:</p>
<pre><code>// 将当前测试标识为失败，但继续执行该文件剩下的测试
func (c *T) Fail()

// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.
func (c *T) FailNow()

// 用于报告测试函数是否失败
func (c *T) Failed() bool

func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})

# 相当于Log/Logf之后调用Fail.(当前case失败)
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})

# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})

func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
</code></pre>
<h2 id="b">B</h2>
<p>管理基准测试的计时行为，并指示应该迭代的运行测试多少次.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/go_oop/">OOP</a></h2>
                <div class="post-meta">
                    <time>January 1, 2018</time>
                    
                        
                            <span class="category">Golang</span>
                        
                    
                </div>
                
                    <p><h1 id="go面向对象">Go面向对象</h1>
<p>golang通过方法和接口实现面向对象.</p>
<hr>
<h1 id="方法method">方法/method</h1>
<p>go中没有类，但是可以为结构体定义方法．</p>
<p>方法就是一类带有特殊的　接收者参数　的函数．</p>
<p>只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．</p>
<p>除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．</p>
<p>方法有两种接收者,值接收者和指针接收者.</p>
<pre><code>type Vertex struct {
    ...
}
</code></pre>
<p>值接收者:</p>
<p>值接收者操作的是值的副本.</p>
<pre><code>func (v Vertex) MethodName() rType {
    ...
}

var v Vertex
v.MethodName() // 操作值的副本

# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换
vp := new(Vertex)
vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.
</code></pre>
<p>指针接收者：</p>
<p>指针接收者，调用方法的时候操作的是该指针指向的值.</p>
<pre><code># 指针接收者的方法可以修改接收者指向的值
func (v *Vertex) MethodName() rType {
    ...
}

vp := new(Vertex)
vp.MethodName() // 操作实际的值

# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.
var v Vertex
v.MethodName() // (&amp;v).MethodName() , 操作的是实际的值
</code></pre>
<hr>
<h1 id="接口interface">接口/Interface</h1>
<p>接口是引用类型.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/rabbitmq/">Rabbitmq</a></h2>
                <div class="post-meta">
                    <time>September 25, 2017</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="amqp">AMQP</h1>
<p>AMQP: Advanced Message Queuing Protocol,高级消息队列协议</p>
<p>常用的开源AMQP框架：</p>
<p><a href="https://github.com/rabbitmq">https://github.com/rabbitmq</a></p>
<p><a href="https://github.com/apache/kafka">https://github.com/apache/kafka</a></p>
<p><a href="https://github.com/apache/activemq">https://github.com/apache/activemq</a></p>
<h1 id="mqtt">MQTT</h1>
<p>MQTT: Message Queuing Telemetry Transport,消息队列遥测传输协议</p>
<hr>
<h1 id="rabbitmq">Rabbitmq</h1>
<p><a href="https://github.com/rabbitmq">https://github.com/rabbitmq</a></p>
<p>RabbitMQ是一个erlang开发的符合AMQP和MQTT的开源项目．</p>
<p>rabbitmq-server也叫broker server</p>
<p>rabbitmq的三个组件：</p>
<ul>
<li>exchange,　交换器，发送消息的实体</li>
<li>binding, 绑定器，连接交换器和队列，并且封装消息的路由信息</li>
<li>queue,　队列，接受消息的实体</li>
</ul>
<p>workflow:</p>
<pre><code>producer(publish-message) =&gt;

rabbitmq-server =&gt; exchange -&gt; binding -&gt; queue =&gt;

=&gt; comsumer
</code></pre>
<p>producer: 生产message并且publish到rabbitmq-server.</p>
<p>consumer: 连接到rabbitmq-server并且subscribe一些queue.</p>
<p>connection: producer和consumer都是通过tcp连接到rabbitmq-server.</p>
<p>channels: 建立在tcp连接中的虚拟连接，用于处理数据流动.</p>
<p>queue:　生产者和消费者都应该创建queue.(只能通过exchange接收message)</p>
<p>exchanges类型:</p>
<ul>
<li>fanout: 所有绑定到此exchange的queue都可以接收消息</li>
<li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息</li>
<li>topic：所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息</li>
</ul>
<p>message类型:</p>
<ul>
<li>messages: 生产者产生的总消息数．</li>
<li>messages_ready: 等待deliver给消费者的消息．</li>
<li>messages_unack: 已经被consumer处理，但是没有被ack的消息．</li>
</ul>
<p>virtual hosts: 本质就是一个rabbitmq server,拥有独立的exchange,queue.默认是/(%2F).</p>
<p>round-robin dispatch: 循环分发，按顺序分发message到consumer,如果message被consumer正确接收，就会从queue中移除．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/rpc/">Rpc</a></h2>
                <div class="post-meta">
                    <time>September 3, 2017</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="rpc">RPC</h1>
<p>Remote Procedure Call Protocol: 远程过程调用.</p>
<p>google的rpc框架，支持多语言:</p>
<p><a href="https://github.com/grpc/grpc">https://github.com/grpc/grpc</a></p>
<p>facebook的rpc框架，贡献给了apache, 支持多语言:</p>
<p><a href="https://github.com/apache/thrift">https://github.com/apache/thrift</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/travel_germany/">Germany</a></h2>
                <div class="post-meta">
                    <time>May 8, 2017</time>
                    
                        
                            <span class="category">Misc</span>
                        
                    
                </div>
                
                    <p><h1 id="德国之旅">德国之旅</h1>
<p>看照片：</p>
<p><a href="http://user.qzone.qq.com/1085694641/4">http://user.qzone.qq.com/1085694641/4</a></p>
<p>德国是汽车之都。</p>
<p>德国有16个州。</p>
<h1 id="城市州">城市州</h1>
<p>德国16个州中的三个城市州</p>
<h2 id="柏林">柏林</h2>
<p>德国首都。</p>
<p>德国第一大城市。</p>
<h2 id="汉堡">汉堡</h2>
<p>德国第二大城市。</p>
<h2 id="不来梅">不来梅</h2>
<h1 id="巴伐利亚州拜仁洲">巴伐利亚州(拜仁洲)</h1>
<p>慕尼黑是首府。</p>
<h2 id="慕尼黑">慕尼黑</h2>
<p>慕尼黑的奥特莱斯位于Ingolstadt Village。</p>
<p>奥迪的总部位于慕尼黑的Ingolstadt。</p>
<p>宝马总部位于慕尼黑。</p>
<p>德国第三大城市。</p>
<h2 id="纽伦堡">纽伦堡</h2>
<h2 id="奥格斯堡">奥格斯堡</h2>
<h2 id="非森">非森</h2>
<p>天鹅堡的所在地Fussen。</p>
<h1 id="巴登符腾堡州">巴登符腾堡州</h1>
<p>斯图加特是首府。</p>
<h2 id="斯图加特">斯图加特</h2>
<p>斯图加特的奥特莱斯位于Metzingen Village。</p>
<p>保时捷的总部。</p>
<p>奔驰的总部。</p>
<h1 id="黑森州">黑森州</h1>
<p>威斯巴登是首府。</p>
<h2 id="威斯巴登">威斯巴登</h2>
<h2 id="法兰克福">法兰克福</h2>
<p>该州最大城市,法国第五大城市。</p>
<p>法兰克福的奥特莱斯位于Wertheim Village。</p>
<h1 id="北莱茵-威斯特法伦州">北莱茵-威斯特法伦州</h1>
<p>杜塞尔多夫是首府。</p>
<h2 id="杜塞尔多夫">杜塞尔多夫</h2>
<h2 id="科隆">科隆</h2>
<p>该州最大城市，德国第四大城市。</p>
<h1 id="下萨克森州">下萨克森州</h1>
<p>汉诺威是首府。</p>
<h2 id="汉诺威">汉诺威</h2>
<h2 id="沃尔夫斯堡">沃尔夫斯堡</h2>
<p>大众总部。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hadoop_mapreduce/">Hadoop MapReduce</a></h2>
                <div class="post-meta">
                    <time>May 3, 2017</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="map-reduce">Map-Reduce</h1>
<p>一种基于YARN的大型数据并行处理系统．主要处理离线数据．</p>
<hr>
<h1 id="mapreduce-commands">mapreduce commands</h1>
<pre><code>mapred [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]
</code></pre>
<p>user commands:</p>
<pre><code>$ mapred archive
...
</code></pre>
<p>admin commands:</p>
<pre><code>$ mapred historyserver

$ mapred hsadmin
</code></pre>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/redis/">Redis</a></h2>
                <div class="post-meta">
                    <time>May 3, 2017</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="redis">Redis</h1>
<p><a href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<p>redis在key-value存储上性能比memcached更好．</p>
<p>安装：</p>
<pre><code># redis-cli, redis-sentinel, redis-server
$ sudo apt-get install redis-server
</code></pre>
<p>只安装redis-cli:</p>
<pre><code>$ sudo apt-get install redis-tools
</code></pre>
<p>redis-server监听端口6379.</p>
<p>redis-sentinel端口26379.</p>
<p>redis gui:</p>
<p><a href="https://github.com/qishibo/AnotherRedisDesktopManager">https://github.com/qishibo/AnotherRedisDesktopManager</a></p>
<p><a href="https://github.com/luin/medis">https://github.com/luin/medis</a></p>
<p>redis HA:</p>
<p><a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p>
<hr>
<h1 id="redis的命令">redis的命令</h1>
<p>server:</p>
<pre><code>redis-server
</code></pre>
<p>client:</p>
<pre><code>redis-client
</code></pre>
<p>test:</p>
<pre><code>redis-benchmark
</code></pre>
<p>sentinel:</p>
<pre><code>redis-sentinel
</code></pre>
<hr>
<h1 id="cli">CLI</h1>
<p>redis-cli 进入命令行模式</p>
<pre><code>&gt; command    # 查看所有可用命令

&gt; info    # 查看redis服务器信息

&gt; monitor

&gt; select 1 # 选中数据库1
&gt; keys *  # 显示所有key
</code></pre>
<hr>
<h1 id="数据类型">数据类型</h1>
<p>string</p>
<pre><code>&gt; set &lt;key&gt; &lt;value&gt;
&gt; get &lt;key&gt;
</code></pre>
<p>list</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/smtp/">Smtp</a></h2>
                <div class="post-meta">
                    <time>April 26, 2017</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="email">Email</h1>
<p>MTA: Mail Transfer Agent</p>
<p>MUA: Mail User Agent</p>
<p>python邮件服务器MTA：smtp协议</p>
<p>python客户端MUA：本地协议pop3, 远程协议imap</p>
<h2 id="mailutils">mailutils:</h2>
<p>mailutils默认安装postfix,如果已经安装其它MTA就使用已经安装的．</p>
<pre><code>$ sudo apt-get install mailutils
</code></pre>
<p>非交互安装mailutils:</p>
<pre><code># 这里不用配置任何参数．
$ sudo debconf-set-selections &lt;&lt;&lt; &quot;postfix postfix/mailname string &quot;
$ sudo debconf-set-selections &lt;&lt;&lt; &quot;postfix postfix/main_mailer_type string 'Internet Site'&quot;
$ sudo apt-get install -y mailutils
</code></pre>
<p>测试：</p>
<pre><code>$ echo &quot;test mail body&quot; | mail -s &quot;test mail title&quot; canuxcheng@gmail.com
</code></pre>
<hr>
<h1 id="sendmail">sendmail</h1>
<p>开源的smtp服务器．</p>
<p>安装sendmail:</p>
<pre><code>$ sudo apt-get install sendmail
$ sudo apt-get install sendmail-cf
</code></pre>
<p>配置：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hawq/">HAWQ</a></h2>
                <div class="post-meta">
                    <time>April 24, 2017</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="hawq">HAWQ</h1>
<p><a href="http://hawq.incubator.apache.org/">http://hawq.incubator.apache.org/</a></p>
<p><a href="https://github.com/apache/incubator-hawq">https://github.com/apache/incubator-hawq</a></p>
<p>HAWQ是在Pivotal Greenplum和PostgreSQL基础上开发而来．</p>
<p>HAWQ也就是Pivotal HDB.</p>
<p>HAWQ和Pivotal　HDB是一个项目．</p>
<p>Hortonworks公司的HDP集成了HAWQ.</p>
<p>HAWQ可以通过HDFS在本机快速，交互查询hadoop数据．</p>
<p>hawq的交互式命令行接口, 类似于postgresql, 参考postgresql.</p>
<p>hawq的client: psql (参考postgresql)</p>
<hr>
<h1 id="psql">psql</h1>
<pre><code>$ psql
$ PGPASSWORD='password';psql -h &lt;host&gt; -p &lt;port&gt; -U &lt;username&gt; -d [database] -c &quot;[psql command]&quot;
$ psql -l # 查看所有database

# jdbc
$ jdbc:pivotal:greenplum://hdm1:5432;DatabaseName=getstartdb;User=hdbuser;Password=hdbpass
</code></pre>
<hr>
<h1 id="sql">sql</h1>
<p>AO(append only) table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type1);
</code></pre>
<p>parquet table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type2) WITH (appendonly=true, orientation=parquet);
</code></pre>
<p>AO table distributed by specified column and partitioned by range:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hive/">Hive</a></h2>
                <div class="post-meta">
                    <time>April 24, 2017</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="hive">Hive</h1>
<p><a href="https://github.com/apache/hive">https://github.com/apache/hive</a></p>
<p><a href="http://hive.apache.org/">http://hive.apache.org/</a></p>
<p>Hive2数据仓库用于读取，写入和管理使用SQL的大型分布式数据集．</p>
<p>hive2的client: beeline(hive命令的升级版)</p>
<hr>
<h1 id="hivebeeline">hive/beeline</h1>
<p>hive</p>
<pre><code>$ hive --help
</code></pre>
<p>beeline</p>
<pre><code>$ beeline --silent=true
beeline&gt; !connect jdbc:hive2://[ip]:[port]/[database] [username] [password]

$ beeline -u &quot;jdbc:hive2://[ip]:10000[/database]&quot; -n [username] -p [password] -e &quot;USE [database]; ...&quot;
</code></pre>
<hr>
<h1 id="sql">sql</h1>
<p>normal table:</p>
<pre><code>&gt; create table tablename (var type, var1 type1);
</code></pre>
<p>parquet table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type1) STORED AS PARQUET;
</code></pre>
<p>partition table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2);
&gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values};
</code></pre>
<p>parquet partition table:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/impala/">Impala</a></h2>
                <div class="post-meta">
                    <time>April 24, 2017</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="impala">Impala</h1>
<p><a href="https://github.com/apache/incubator-impala">https://github.com/apache/incubator-impala</a></p>
<p><a href="https://impala.apache.org/">https://impala.apache.org/</a></p>
<p>impala的client: impala-shell</p>
<p>Cloudera公司的CDH集成了Impala.</p>
<hr>
<h1 id="impala-shellbeeline">impala-shell/beeline</h1>
<p>impala-shell</p>
<pre><code>$ impala-shell
</code></pre>
<p>beeline</p>
<pre><code>$ beeline --silent=true
beeline&gt; !connect jdbc:hive2://[ip]:21050[/database];auth=noSasl [username] [password]

$ beeline -u &quot;jdbc:hive2://[ip]:21050[/database];auth=noSasl&quot; -n [username] -p [password] -e &quot;USE [database]; ...&quot;
</code></pre>
<hr>
<h1 id="sql">sql</h1>
<p>normal table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type1);
</code></pre>
<p>parquet table:</p>
<pre><code>&gt; crate table {table_name} (var type, var1 type1) STORED AS PARQUET;
</code></pre>
<p>partition table:</p>
<pre><code>&gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2);
&gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1)
</code></pre>
<p>parquet partition table:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/presto/">Presto</a></h2>
                <div class="post-meta">
                    <time>April 24, 2017</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="presto">Presto</h1>
<p><a href="https://github.com/prestodb">https://github.com/prestodb</a></p>
<p><a href="https://prestodb.io/">https://prestodb.io/</a></p>
<p>presto的client: presto-cli(rename to presto)</p>
<hr>
<h1 id="presto-cli">presto-cli</h1>
<pre><code>$ presto --server localhost:8080 --catalog hive --schema default

# jdbc for presto
$ jdbc:presto://host:port/catalog/schema
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/mongodb/">MongoDB</a></h2>
                <div class="post-meta">
                    <time>April 16, 2017</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="mongodb">MongoDB</h1>
<p><a href="https://github.com/mongodb/mongo">https://github.com/mongodb/mongo</a></p>
<p>mongodb是一种开源的文档数据库，高性能，高可用性，自动裁剪．</p>
<p>mongodb的database和关系数据库中的database一样．</p>
<p>mongodb将BSON(mongo的JSON)文档存储在集合(collections)中，集合相当于关系数据库中的表table．</p>
<p>mongodb的collections中的域(field)，相当于关系数据库中的字段column.</p>
<p>mongodb的collections中的文档(document)，相当于关系数据库中的记录行row.</p>
<p>mongodb也支持index索引和primary key主键，但是不支持table joins表连接．</p>
<p>ubuntu安装:</p>
<pre><code>$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv0C49F3730359A14518585931BC711F9BA15703C6
$ echo &quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list
$ sudo apt-get update
$ sudo apt-get install -y mongodb-org
</code></pre>
<p>ubuntu启动:</p>
<pre><code>$ sudo service mongod start
</code></pre>
<p>安装完成默认的数据库是test.另外db, admin, local是保留的数据库名称．</p>
<p>mongod的默认端口是27017.</p>
<p>mongo web-gui:</p>
<p><a href="https://github.com/Studio3T/robomongo">https://github.com/Studio3T/robomongo</a></p>
<hr>
<h1 id="mongo的命令">mongo的命令</h1>
<pre><code>mongo [options] [db address] [file names (ending in .js)]
</code></pre>
<p>mongo shell进入到指定数据库:</p>
<pre><code>$ mongo [db_name]
</code></pre>
<p>本地命令行执行sql语句：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/xml/">Xml</a></h2>
                <div class="post-meta">
                    <time>April 7, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="xml">XML</h1>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/xpath/">Xpath</a></h2>
                <div class="post-meta">
                    <time>April 7, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="xpath">XPath</h1>
<p>XPath是一门在XML文档中查找信息的语言．</p>
<p>xpath定位有绝对定位和相对定位，推荐使用相对定位．</p>
<p>绝对的XPath定位包含了从HTML根节点起的所有元素，并且一些轻微的改变就会失效。</p>
<p>相对的XPath用id或者name属性来找到一个靠近的元素(比较理想的是父元素)，这样你就可以依靠他们的相对关系来确定目标元素的位置。</p>
<h1 id="firefox">firefox</h1>
<p>firebug + firepath</p>
<p>firefox通过两者结合来获取xpath</p>
<h1 id="chrome">chrome</h1>
<p>chrome的开发者工具(F12)可以直接copy xpath.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/kvm/">Kvm</a></h2>
                <div class="post-meta">
                    <time>April 5, 2017</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="kvm">KVM</h1>
<p>Kernel-based Virtual Machine.</p>
<hr>
<h1 id="qemu">Qemu</h1>
<p>安装:</p>
<pre><code>$ sudo apt-get install qemu-system qemu-kvm
</code></pre>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/libvirt/">Libvirt</a></h2>
                <div class="post-meta">
                    <time>April 5, 2017</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="libvirt">Libvirt</h1>
<p>支持多种虚拟化平台的库</p>
<p><a href="https://libvirt.org/">https://libvirt.org/</a></p>
<p>安装:</p>
<pre><code>$ sudo apt-get install libvirt-bin (包含virsh命令和libvirtd daemon)
// libvirtd在container中无法运行；在container中安装libvirt-bin可以获取virsh命令远程访问libvirt-bin server.
</code></pre>
<p>libvirt-bin拆分成了两个包：</p>
<pre><code>libvirt-daemon-system
libvirt-clients

$ sudo apt-get install libvirt-dev # 库, python/go client依赖该库

$ sudo apt-get install virt-manager # windows管理工具

$ sudo apt-get install virt-view # ...

$ sudo service libvirt-bin restart
</code></pre>
<h1 id="virsh">virsh</h1>
<p>libvirt的命令行工具</p>
<pre><code>$ virsh list --all    # 查看所有虚拟机
$ virsh list --all --name # 只看domain name.

$ virsh define /path/to/X.xml    # 从xml配置文件定义一个domain
$ virsh start     # 启动虚拟机
$ virsh reboot    # 重启虚拟机
$ virsh shutdown   # 关闭虚拟机
$ virsh destroy    # 强制关闭虚拟机
$ virsh undefine   # 移除虚拟机
$ virsh vncdisplay # 查看虚拟机的vnc信息，可以通过vnc访问.

$ virsh net-list --all # 查看所有网络
$ virsh net-define default.xml
$ virsh net-autostart default
$ virsh net-start default
$ virsh net-undefine default
$ virsh net-destroy default

# 批量操作vm
$ for vm in `virsh list --all --name`; do virsh undefine/destroy ${vm}; done
</code></pre>
<h1 id="qemu-img">qemu-img</h1>
<p>创建虚拟机的镜像文件:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_ide/">IDE</a></h2>
                <div class="post-meta">
                    <time>April 2, 2017</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="jetbrains">JetBrains</h1>
<p>IntelliJ: Java的IDE, 安装Python的插件也支持python.</p>
<h2 id="pycharm">PyCharm</h2>
<p>PyCharm: Python的IDE.</p>
<h2 id="goland">Goland</h2>
<p>Goland: golang的IDE.</p>
<hr>
<h1 id="vscode">VSCode</h1>
<h2 id="intellisense--code-navigation">IntelliSense &amp; Code Navigation</h2>
<p>Go to Definition: F12, 跳转到定义.</p>
<p>Peek Definition: Alt + F12， 速览定义，不跳转.</p>
<p>Go to references: Shift + F12, 转到引用.</p>
<h2 id="frontend">frontend</h2>
<h3 id="vs-js-debug">vs-js-debug</h3>
<p>vscode内置了js/ts/node的debugger.</p>
<p><a href="https://github.com/microsoft/vscode-js-debug">https://github.com/microsoft/vscode-js-debug</a></p>
<h3 id="live-server">live server</h3>
<p>live preview(html, svg&hellip;)</p>
<p>如果用remote-ssh开启live server就是在远程机器上开启5500端口，webroot就是vscode打开的目录.</p>
<p>如果是remote-ssh开发html，用这个preview很方便.</p>
<p><a href="https://github.com/ritwickdey/vscode-live-server">https://github.com/ritwickdey/vscode-live-server</a></p>
<h3 id="vscode-chrome-debug">vscode-chrome-debug</h3>
<p>打开的是安装vscode的机器上的chrome。</p>
<p><a href="https://github.com/microsoft/vscode-chrome-debug">https://github.com/microsoft/vscode-chrome-debug</a></p>
<p>通过live server监听remote-ssh机器上的5500，可以通过chrome远程调试静态站点。</p>
<pre><code>{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;angularjs&quot;,
            &quot;type&quot;: &quot;chrome&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;url&quot;: &quot;http://remote-ssh-server:5500/path/to/index.html&quot;,
            &quot;webRoot&quot;: &quot;${workspaceFolder}/path/to/&quot;,
        },
    ]
}
</code></pre>
<hr>
<h2 id="python">python</h2>
<p>debuging:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_cryptographic/">Cryptographic</a></h2>
                <div class="post-meta">
                    <time>March 27, 2017</time>
                    
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="pgp">PGP</h1>
<p>PGP: Pretty Good Privacy。</p>
<p>用于签名和加密解密。</p>
<h2 id="pgp-1">PGP</h2>
<p><a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">https://en.wikipedia.org/wiki/Pretty_Good_Privacy</a></p>
<h2 id="openpgp">OpenPGP</h2>
<p>OpenPGP是PGP的标准,也有很多实现。</p>
<p><a href="http://openpgp.org/">http://openpgp.org/</a></p>
<h2 id="gnupg">GnuPG</h2>
<p>GunPG: Gun Privacy Guard, 是基于openPGP的实现。</p>
<p><a href="https://gnupg.org/">https://gnupg.org/</a></p>
<pre><code>$ gpg --help

$ 快速生成签名密钥对
gpg --quick-generate-key &quot;Canux&quot;
// 查看公钥
gpg --list-keys
// 查看私钥
gpg --list-secret-keys
// 删除私钥
gpg --delete-secret-keys &quot;Canux&quot;
// 删除公钥
gpg --delete-keys &quot;Canux&quot;
</code></pre>
<p>GPGME: GPG Made Easy, 是一个让应用程序使用GPG更容易的库．</p>
<h1 id="openssl">OpenSSL</h1>
<p>网络安全和密码工具。</p>
<p><a href="https://www.openssl.org/">https://www.openssl.org/</a></p>
<pre><code>$ openssl --help
</code></pre>
<hr>
<h1 id="单向哈希加密">单向哈希加密</h1>
<p>md5和shaX都是常用的存储密码的加密方法.</p>
<p>rainbow table可以破解单向加密.</p>
<p>salt方法可以防止rainbow table破解.</p>
<p>scrypt是最难破解的加密方案.</p>
<h2 id="md5">md5</h2>
<h2 id="sha1">sha1</h2>
<h2 id="sha256">sha256</h2>
<h2 id="sha512">sha512</h2>
<h2 id="hmac">hmac</h2>
<hr>
<h1 id="symmetric-cryptography">Symmetric Cryptography</h1>
<p>对称加密就是加密和解密使用的密钥是相同的．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_dom/">JS DOM</a></h2>
                <div class="post-meta">
                    <time>March 15, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="dom">DOM</h1>
<p>DOM: document object model.</p>
<p>当网页被加载时，浏览器会创建页面的文档对象模型(DOM).</p>
<p>DOM操作需要在html加载完成后进程.</p>
<p>js可以通过DOM访问html文档的所有元素.</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件做出反应</li>
</ul>
<h2 id="查找html元素">查找html元素</h2>
<p>找到返回该元素的对象，没找到返回null.</p>
<p>通过id:</p>
<pre><code>document.getElementById(&quot;id&quot;);
</code></pre>
<p>通过标签名:</p>
<pre><code>document.getElementsByTagName(&quot;tag&quot;);
</code></pre>
<p>通过类名:</p>
<pre><code>document.getElementsByName(&quot;name&quot;)
</code></pre>
<h2 id="操作html元素或文本">操作html元素或文本</h2>
<p>操作标签或标签内的文本.</p>
<p>直接改变html内容:</p>
<pre><code># 绝不要使用在文档加载之后使用 document.write()。这会覆盖该文档
document.write(...);
</code></pre>
<p>改变元素的内容:</p>
<pre><code>document.getElementById(id).innerHTML = &quot;new text&quot;;
</code></pre>
<h2 id="操作html属性">操作html属性</h2>
<p>改变元素属性:</p>
<pre><code>document.getElementById(id).attribute = &quot;new value&quot;;
</code></pre>
<h2 id="操作css">操作css</h2>
<pre><code>document.getElementById(id).style.property = &quot;new style&quot;
</code></pre>
<h2 id="增删html元素">增删html元素</h2>
<p>增加元素:</p>
<pre><code>var para = document.createElement(&quot;p&quot;);
var node = document.createTextNode(&quot;new para&quot;);
para.appendChild(node);
</code></pre>
<p>删除元素:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_oop/">JS OOP</a></h2>
                <div class="post-meta">
                    <time>March 15, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="oop">OOP</h1>
<p>javascript中一切都是对象.</p>
<p>javacript内置了Bull/Number/String/Object/Function/Array/Date/RegExp类型.</p>
<h1 id="object">Object</h1>
<p>创建Object实例:</p>
<pre><code>var obj = new Object();

var obj = Object(); // new 可以省略

var obj = ｛
    name: &quot;value&quot;
};

var obj = {
    &quot;name&quot;: &quot;value&quot;
}
</code></pre>
<p>添加属性:</p>
<pre><code>obj.attr = &quot;value&quot;
</code></pre>
<p>添加方法:</p>
<pre><code>obj.method =  methodName;
function methodName() {};

obj.method = function() {};
</code></pre>
<p>删除属性:</p>
<pre><code>delete obj.attr
</code></pre>
<p>访问对象属性:</p>
<pre><code>obj.property
</code></pre>
<p>访问对象方法:</p>
<pre><code>obj.method()
</code></pre>
<h1 id="boolean">Boolean</h1>
<p>attribution:</p>
<pre><code>constructor
prototype
</code></pre>
<p>method:</p>
<pre><code>toSource()
valueOf()
toString()
</code></pre>
<h1 id="number">Number</h1>
<p>attribution:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_angular/">Angular</a></h2>
                <div class="post-meta">
                    <time>March 13, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="angularjs">angularjs</h1>
<p>angularjs 1.*</p>
<p><a href="https://github.com/angular/angular.js">https://github.com/angular/angular.js</a></p>
<p><a href="https://angularjs.org/">https://angularjs.org/</a></p>
<p><a href="https://github.com/rev087/ng-inspector">https://github.com/rev087/ng-inspector</a></p>
<hr>
<h1 id="angular">Angular</h1>
<p>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。</p>
<p>angular.js 的升级版</p>
<p><a href="https://github.com/angular/angular">https://github.com/angular/angular</a></p>
<p><a href="https://github.com/angular/angular-cli">https://github.com/angular/angular-cli</a></p>
<p><a href="https://angular.io">https://angular.io</a></p>
<p><a href="https://angular.cn">https://angular.cn</a></p>
<p>安装 angular-cli:</p>
<pre><code>$ npm install -g @angular/cli
</code></pre>
<p>查看版本:</p>
<pre><code>$ ng v
</code></pre>
<p>新建项目:</p>
<pre><code>$ cd &lt;project&gt;
$ ng new &lt;application&gt;

# 严格模式
$ ng new &lt;application&gt; --strict

$ ng generate &lt;schematic&gt; [options]
appShell
application
class
component
directive
enum
guard
interceptor
interface
library
module
pipe
resolver
service
serviceWorker
webWorker
</code></pre>
<p>测试项目:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_devops/">DevOps</a></h2>
                <div class="post-meta">
                    <time>March 13, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="js--ts">JS &amp; TS</h1>
<p>vscode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;version&#34;</span>: <span style="color:#e6db74">&#34;0.2.0&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;configurations&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Next.js: debug server-side&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;node-terminal&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;request&#34;</span>: <span style="color:#e6db74">&#34;launch&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;command&#34;</span>: <span style="color:#e6db74">&#34;npm run dev&#34;</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Next.js: debug client-side&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;chrome&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;request&#34;</span>: <span style="color:#e6db74">&#34;launch&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;url&#34;</span>: <span style="color:#e6db74">&#34;http://localhost:3000&#34;</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Next.js: debug client-side (Firefox)&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;firefox&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;request&#34;</span>: <span style="color:#e6db74">&#34;launch&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;url&#34;</span>: <span style="color:#e6db74">&#34;http://localhost:3000&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;reAttach&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;pathMappings&#34;</span>: [
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&#34;url&#34;</span>: <span style="color:#e6db74">&#34;webpack://_N_E&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&#34;path&#34;</span>: <span style="color:#e6db74">&#34;${workspaceFolder}&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      ]
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Next.js: debug full stack&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;node&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;request&#34;</span>: <span style="color:#e6db74">&#34;launch&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;program&#34;</span>: <span style="color:#e6db74">&#34;${workspaceFolder}/node_modules/next/dist/bin/next&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;runtimeArgs&#34;</span>: [<span style="color:#e6db74">&#34;--inspect&#34;</span>],
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;skipFiles&#34;</span>: [<span style="color:#e6db74">&#34;&lt;node_internals&gt;/**&#34;</span>],
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;serverReadyAction&#34;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;debugWithEdge&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;killOnServerStop&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;pattern&#34;</span>: <span style="color:#e6db74">&#34;- Local:.+(https?://.+)&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;uriFormat&#34;</span>: <span style="color:#e6db74">&#34;%s&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;webRoot&#34;</span>: <span style="color:#e6db74">&#34;${workspaceFolder}&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>SPA: Single page application, 单页应用，like react, vue and angular.
SSR: server side rendering. 服务端渲染, like next.js, nuxt.js</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js/">JavaScript</a></h2>
                <div class="post-meta">
                    <time>March 13, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="javascript概述">JavaScript概述</h1>
<p>Javascript包括三部分:</p>
<ol>
<li>ECMAScript核心,提供核心语言功能．</li>
<li>DOM文档对象模型, 提供访问和操作网页内容的方法和接口．</li>
<li>BOM浏览器对象模型, 提供与浏览器交互的方法和接口．</li>
</ol>
<p>ES5.0 (2009)
ES5.1 (2011, ISO/IEC)
ES6.0 (2015)</p>
<hr>
<h1 id="javascript基本语法">javascript基本语法</h1>
<p>javascript源程序叫xxx.js.</p>
<p>javascript大小写敏感．</p>
<p>javascript使用驼峰命名法．</p>
<p>javascript的标识符以字母，下划线或美元符号开头，还可以包含数字．不能是关键字．</p>
<p>JvaScript代码块以大括号{}包围,开括号写在第一行结尾处，前面空格，闭括号单独一行。</p>
<p>javascript中所有事物都是对象，都有属性和方法.</p>
<p>JavaScript使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．</p>
<p>javascript中运算符周围要有空格。</p>
<p>javascript中使用四个空格来缩进。</p>
<p>javascript不支持goto。</p>
<hr>
<h1 id="注释">注释</h1>
<p>单行注释：</p>
<pre><code>// comment
</code></pre>
<p>多行注释：</p>
<pre><code>/*
 * comment1
 * comment2
 */
</code></pre>
<hr>
<h1 id="关键字">关键字</h1>
<pre><code># 数据类型
var function return typeof new delete

# 流程控制
if else for in do while switch case default with break continue

# 修饰符
void

# 动作相关
instanceof this

# 异常处理
try catch throw

# 调试
debugger

# ECMAScript2015
let const
</code></pre>
<hr>
<h1 id="运算符和优先级">运算符和优先级</h1>
<h2 id="算数运算符">算数运算符</h2>
<pre><code>+
-
* 
**
/
%
++
--
</code></pre>
<h2 id="赋值运算符">赋值运算符</h2>
<pre><code>=
+=
-=
*=
/=
%=
&lt;&lt;=
&gt;&gt;=
&gt;&gt;&gt;=
&amp;=
^=
|=
**=
</code></pre>
<h2 id="比较运算符">比较运算符</h2>
<pre><code>// 在比较值钱进行类型转换.
==

// 强制对值和类型进行比较.
===

!=

!==

&gt;
&lt;
&gt;=
&lt;=

// 三元运算符
?
</code></pre>
<h2 id="逻辑运算符">逻辑运算符</h2>
<pre><code>// 逻辑与
&amp;&amp;

// 逻辑或
||

// 逻辑非
!
</code></pre>
<h2 id="类型运算符">类型运算符</h2>
<pre><code>typeof

instanceof
</code></pre>
<h2 id="位运算符">位运算符</h2>
<pre><code>&amp;
|
~
^
&lt;&lt;
&gt;&gt;
&gt;&gt;&gt;
</code></pre>
<hr>
<h1 id="数据类型">数据类型</h1>
<h2 id="var申明变量">var申明变量</h2>
<p>通过var申明的变量没有块作用域，在块之外也能访问.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_test/">JS Test</a></h2>
                <div class="post-meta">
                    <time>March 13, 2017</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1></h1>
<hr>
<h2 id="jest">Jest</h2>
<p>for javascript.</p>
<p><a href="https://github.com/jestjs/jest">https://github.com/jestjs/jest</a></p>
<h2 id="ts-jest">TS Jest</h2>
<p>for typescript.</p>
<p><a href="https://github.com/kulshekhar/ts-jest">https://github.com/kulshekhar/ts-jest</a></p>
<hr>
<h2 id="jasmine">jasmine</h2>
<p>A JavaScript Testing Framework</p>
<p><a href="https://github.com/jasmine/jasmine">https://github.com/jasmine/jasmine</a></p>
<p>install jasmine to devDependencies</p>
<pre><code>$ npm install --save-dev jasmineinit 
</code></pre>
<p>jasmine in project</p>
<pre><code>$ npx jasmine init
</code></pre>
<p>set jasmine as test script in package.json</p>
<pre><code>&gt; &quot;scripts&quot;: { &quot;test&quot;: &quot;jasmine&quot; } 
</code></pre>
<p>run test</p>
<pre><code>$ npm test
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/testing/">Testing</a></h2>
                <div class="post-meta">
                    <time>March 1, 2017</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="qa">QA</h1>
<p>Quality Assurance</p>
<p>QA主要就是进行软件测试相关的工作.</p>
<p>软件测试就是使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异．</p>
<p>软件测试五个要素：</p>
<ul>
<li>质量</li>
<li>人员</li>
<li>技术</li>
<li>流程</li>
<li>资源</li>
</ul>
<p>软件测试两个目标：</p>
<ul>
<li>测试覆盖率</li>
<li>测试效率</li>
</ul>
<p>软件测试阶段：</p>
<ul>
<li>单元测试(Unit Testing)</li>
<li>集成测试(Integration Testing)</li>
<li>系统测试(System Testing)</li>
<li>验收测试(Acceptance Testing)</li>
</ul>
<p>软件测试的手段：</p>
<ul>
<li>手动测试/自动化测试</li>
<li>静态测试/动态测试</li>
<li>黑盒测试/白盒测试</li>
</ul>
<p>软件测试的类型：</p>
<ul>
<li>性能测试</li>
<li>稳定性测试</li>
<li>安全测试</li>
<li>可用性测试</li>
<li>兼容性测试</li>
<li>文档测试</li>
<li>本地化测试</li>
<li>冒烟测试</li>
<li>功能测试Functional Testing</li>
<li>回归测试Regression Testing</li>
<li>用户界面测试UI Testing</li>
<li>端到端测试End-To-End Testing</li>
</ul>
<p>软件测试的模型：</p>
<ul>
<li>传统的瀑布模型</li>
<li>V模型</li>
<li>W模型</li>
<li>X模型</li>
<li>H模型</li>
<li>敏捷测试模型(金字塔模式)</li>
</ul>
<p>软件测试的模式：</p>
<ul>
<li>金字塔模式Ideal Test Automation Pyramid</li>
<li>蛋筒冰激凌模式Ice Cream Cone</li>
<li>双金字塔模式Dual Test Pyramid</li>
<li>纸杯蛋糕模式Cupcake</li>
</ul>
<h1 id="test-automation-pyramid">Test Automation Pyramid</h1>
<p>Mike Cohn的测试金字塔</p>
<p><a href="https://martinfowler.com/bliki/TestPyramid.html">https://martinfowler.com/bliki/TestPyramid.html</a></p>
<ul>
<li>Automated GUI Tests(10%)</li>
<li>Automated Service Tests(Component/Integration/API)(20%)</li>
<li>Automated Unit Tests(70%)</li>
</ul>
<hr>
<h1 id="unit-test单元测试">Unit Test/单元测试</h1>
<p>单元测试是开发者编写的测试一个单元（函数／类）的功能是否符合预期．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/testing_robotframework/">RobotFramework</a></h2>
                <div class="post-meta">
                    <time>February 25, 2017</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="robot-framework">Robot Framework</h1>
<p><a href="https://github.com/robotframework/robotframework">https://github.com/robotframework/robotframework</a></p>
<p><a href="https://github.com/robotframework/QuickStartGuide">https://github.com/robotframework/QuickStartGuide</a></p>
<p>支持python和java的API.</p>
<p>Robot Framework is a generic test automation framework for acceptance testing and acceptance test-driven development (ATDD).</p>
<p>Install:</p>
<pre><code>$ pip install robotframework
</code></pre>
<p>Modular:</p>
<ul>
<li>Test Data</li>
<li>Robot Framework(test data syntax)</li>
<li>Test Libraries(test library API) + Test Tools</li>
<li>System under Test(system interface)</li>
</ul>
<p>Use:</p>
<pre><code>$ robot --version
$ robot [options] data_sources
</code></pre>
<p>会生成三个文件：</p>
<ul>
<li>output.xml</li>
<li>log.html</li>
<li>report.html</li>
</ul>
<hr>
<h1 id="setting-table">setting table</h1>
<pre><code>*** Settings ***
# 前三个是加载外部文件
Library    Selenium2Library # 需要在sys.path路径里面
Resource    ${RESOURCES}/common.tsv
Variables    ${RESOURCES}/common.py
Documentation    Docs
Metadata    Version    2.0
Suite Setup
Suite Teardown
Force Tags
Default Tags
Test Setup
Test Teardown
Test Template
Test Timeout
</code></pre>
<h1 id="test-case-table">Test Case table</h1>
<p><a href="https://github.com/robotframework/HowToWriteGoodTestCases">https://github.com/robotframework/HowToWriteGoodTestCases</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/testing_selenium/">Selenium</a></h2>
                <div class="post-meta">
                    <time>February 25, 2017</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="selenium">Selenium</h1>
<p><a href="https://github.com/SeleniumHQ/selenium">https://github.com/SeleniumHQ/selenium</a></p>
<p>用于基于浏览器的web应用的自动化测试工具集．</p>
<pre><code>selenium1: deprecated.
selenium2: 默认支持firefox&lt;=46. 支持python2.6+, python3.2+
selenium3: 支持firefox47+, 所有浏览器都需要安装webdriver.支持python2.6+, python3.3+, 必须重启OS.
</code></pre>
<p>支持python, java, javascript等API.</p>
<p>默认安装selenium3:</p>
<pre><code>$ pip install selenium
</code></pre>
<p>selenium3需要安装相应浏览器的driver, 然后重启OS:</p>
<p>selenium, driver, browser三个版本都需要兼容才能工作．</p>
<pre><code>winfows放在C:\Python\Scripts\
linux放在/usr/local/bin/
</code></pre>
<p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p>
<p><a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<p>[Deprecated] Remote Control: 也就是selenium1.selenium2依然保留了selenium1的API.但是selenium3会彻底删除RC的API.</p>
<p>[Deprecated] IDE: selenium IDE是一个firefox的插件，用于记录浏览器上的测试步骤，能用于生成测试代码，并且转换成编程语言．但是已经被WebDriver取代．</p>
<hr>
<h1 id="webdriver">WebDriver</h1>
<p>也就是selenium2.已经取代了selenium RC和selenium IDE.</p>
<p>python的API参考python博客．</p>
<hr>
<h1 id="grid">Grid</h1>
<p>Selenium Grid用于分布式测试</p>
<hr>
<h1 id="定位元素">定位元素</h1>
<p>对应的python的API参考python博文．</p>
<p>selenium提供８种定位web页面中元素的方法：</p>
<ul>
<li>id</li>
<li>name</li>
<li>class</li>
<li>tag</li>
<li>link</li>
<li>partial_link</li>
<li>通过xpath</li>
<li>通过css</li>
</ul>
<p>在浏览器通过F12快捷键进入调试模式获取．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cloud_openstack/">OpenStack</a></h2>
                <div class="post-meta">
                    <time>February 23, 2017</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="openstack">OpenStack</h1>
<p><a href="https://github.com/openstack">https://github.com/openstack</a></p>
<p><a href="https://github.com/openstack-dev">https://github.com/openstack-dev</a></p>
<p>openstack是一个云操作系统，通过数据中心可控制大型的计算，存储，网络等资源池．</p>
<p>所有的管理通过前端的界面管理员就可以完成，同样也可以通过web接口让最终的用户部署资源．</p>
<p>openstack的设计原则：</p>
<p><a href="https://wiki.openstack.org/wiki/BasicDesignTenets">https://wiki.openstack.org/wiki/BasicDesignTenets</a></p>
<hr>
<h1 id="horizon---openstack-dashboard">horizon - OpenStack Dashboard</h1>
<p>控制面板</p>
<p><a href="https://github.com/openstack/horizon">https://github.com/openstack/horizon</a></p>
<hr>
<h1 id="keystone---openstack-identity">keystone - OpenStack Identity</h1>
<p>认证服务</p>
<p><a href="https://github.com/openstack/keystone">https://github.com/openstack/keystone</a></p>
<hr>
<h1 id="nova---openstack-compute">nova - OpenStack Compute</h1>
<p>计算服务</p>
<p><a href="https://github.com/openstack/nova">https://github.com/openstack/nova</a></p>
<hr>
<h1 id="swift---openstack-storage">swift - OpenStack Storage</h1>
<p>存储服务</p>
<p><a href="https://github.com/openstack/swift">https://github.com/openstack/swift</a></p>
<hr>
<h1 id="neutron---openstack-networking">neutron - OpenStack Networking</h1>
<p>网络服务(原名quantum)</p>
<p><a href="https://github.com/openstack/neutron">https://github.com/openstack/neutron</a></p>
<hr>
<h1 id="glance---openstack-image-management">glance - OpenStack Image Management</h1>
<p>镜像管理</p>
<p><a href="https://github.com/openstack/glance">https://github.com/openstack/glance</a></p>
<hr>
<h1 id="cinder---openstack-block-storage">cinder - OpenStack Block Storage</h1>
<p>块存储服务</p>
<p><a href="https://github.com/openstack/cinder">https://github.com/openstack/cinder</a></p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_makefile/">Makefile</a></h2>
                <div class="post-meta">
                    <time>January 12, 2017</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="make">Make</h1>
<p>make的作用：</p>
<ul>
<li>控制源代码的编译</li>
<li>手册页的编写</li>
<li>将应用程序安装到目标目录</li>
</ul>
<p>make的使用规则：</p>
<ul>
<li>如果工程没有编译过，需要编译所有源文件和链接所有目标文件．</li>
<li>如果工程里某几个目标文件被修改，只需要编译修改的源文件，并链接所有目标文件．</li>
<li>如果头文件被修改，只需要编译引用了被修改的头文件的源文件，并链接所有目标文件．</li>
</ul>
<p>makefile文件查找顺序：</p>
<ul>
<li>当前目录找makefile</li>
<li>当前目录找Makefile</li>
<li>当前目录找GNUmakefile</li>
</ul>
<h1 id="make命令">make命令</h1>
<p>make命令会执行当前目录的makefile/Makefile/GNUmakefile文件．</p>
<pre><code>make [options] [target] ...
-f FILE, --file=FILE, --makefile=FILE    # 指定makefile文件
-n, --just-print, --dry-run, --recon # 只打印，不执行
-k, --keep-going　# 忽略错误继续执行

make
make all
make install
make clean
</code></pre>
<p>make的工作顺序：</p>
<ul>
<li>读入所有makefile文件</li>
<li>读入include的其它makefile文件</li>
<li>初始化变量</li>
<li>推导隐晦规则，分析所有规则</li>
<li>为所有目标文件创建依赖关系链</li>
<li>根据依赖关系决定哪些目标需要重新生成</li>
<li>执行生成的命令</li>
</ul>
<h1 id="makefile语法">makefile语法</h1>
<p>make命令执行makefile文件时，会比较target和prerequisites的时间戳，如果后者比前者新，或者前者不存在，就会执行command,否则会跳过command.</p>
<p>其中#表示注释，\表示续行．@表示该命令的执行不会打印到stdout,-表示忽略错误继续执行．</p>
<p>makefile中的command必须以tab开头，target和prerequisites有多个时用空格分开．</p>
<pre><code># comment
target...: prerequisites...
    command
    command1 too \
    long
    @command2
    -command3
    ...
</code></pre>
<p>makefile变量赋值:</p>
<pre><code>var=val
var := val  覆盖之前的值
var ?= val  如果没有被赋值过，就赋值
var += val  添加一个值
</code></pre>
<p>通过命令定义变量：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_grafana/">Grafana</a></h2>
                <div class="post-meta">
                    <time>January 12, 2017</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="grafana">Grafana</h1>
<p>The tool for beautiful monitoring and metric analytics &amp; dashboards for Graphite, InfluxDB &amp; Prometheus &amp; More.</p>
<p><a href="https://github.com/grafana/grafana">https://github.com/grafana/grafana</a></p>
<p>支持多种data source:</p>
<p>graphite/influxdb/opentsdb/premetheus/elasticsearch/mysql/postgresql</p>
<p>安装配置参考官方文档</p>
<p>grafana配置文件是grafana.ini.</p>
<hr>
<h1 id="http-api">HTTP API</h1>
<pre><code>port = 3000
</code></pre>
<h2 id="dashboard">dashboard</h2>
<p>create/update dashboard:</p>
<p>将datasource设置成变量，然后导出的json文件就可以直接导入了．</p>
<p>dashboard.id=null才能创建新dashboard.</p>
<pre><code>post /api/dashboards/db
data = json.dumps({
    &quot;dashboard&quot;: {
        &quot;id&quot;: null,
        ...
    },
    &quot;folderId&quot;: 0,
    &quot;overwrite&quot;: True, # True for python, true for go.
    &quot;message&quot;: &quot;commit message&quot;
})
</code></pre>
<h2 id="datasource">datasource</h2>
<p>create datasource:</p>
<pre><code>post /api/datasources
data = json.dumps({
    &quot;name&quot;:
    &quot;type&quot;:
    &quot;url&quot;:
    &quot;database&quot;:
    &quot;access&quot;: &quot;proxy&quot;
})
</code></pre>
<h2 id="alert">alert</h2>
<p>create alert notification/channel:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/vagrant/">Vagrant</a></h2>
                <div class="post-meta">
                    <time>January 12, 2017</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="vagrant">Vagrant</h1>
<p>构建在虚拟化技术之上的虚拟机运行环境管理工具．</p>
<p>适合用来构建和分发开发环境．通过命令行可以批量自动化，不用一个一个安装配置图形界面的虚拟机．</p>
<p><a href="https://github.com/mitchellh/vagrant">https://github.com/mitchellh/vagrant</a></p>
<p>需要安装virtualbox或vmware等虚拟机.</p>
<p>vagrant还支持其它的providers(docker, vmware, hyper-v, aws)</p>
<p>可以在这里找到很多vagrant可用的box:</p>
<p><a href="https://atlas.hashicorp.com/boxes/search">https://atlas.hashicorp.com/boxes/search</a></p>
<hr>
<h1 id="初始化">初始化</h1>
<pre><code>$ mkdir -p /home/user/vagrant
$ cd /vagrant

# 在当前目录生成一个Vagrantfile文件, 需手动添加vm.box
$ vagrant init 

# 相当于直接添加了vm.box到Vagrantfile.
$ vagrant init [box-name]
</code></pre>
<h1 id="添加box">添加box</h1>
<pre><code># 默认从https://atlas.hashicorp.com/boxes/search下载该box.
$ vagrant box add [[--name ]box-name] hashicorp/precise64

# 也可以使用下载到本地的box
$ vagrant box add [[--name ]box-name] /path/to/your.box

# 也可以使用自己的服务器上的box
$ vagrant box add [[--name ]box-name] URL

# 添加box之后修改Vagrantfile,添加vm.box:
Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;[box-name]&quot;
end
</code></pre>
<h1 id="使用box">使用box</h1>
<pre><code>$ vagrant up [box-name]
$ vagrant up --provider docker/aws/vmware/hyperv/... [box-name]

$ vagrant ssh
# 会进入一个vagrant@precise64:~$的环境．
# /vagrant 是一个和/home/user/vagrant同步的路径．
</code></pre>
<h1 id="结束使用">结束使用</h1>
<pre><code>$ vagrant status # 查看box状态
$ vagrant halt # 关闭box
$ vagrant reload # 重启box
$ vagrant suspend
$ vagrant resume
$ vagrant provision

# 会销毁box占用的所有资源，但不删除box.
$ vagrant destroy
</code></pre>
<h1 id="管理box">管理box</h1>
<pre><code>$ vagrant box list
$ vagrant box remove
</code></pre>
<h1 id="其它">其它</h1>
<pre><code>$ vagrant global-status
$ vagrant global-status --prune
</code></pre>
<hr>
<h1 id="配置vagrantfile">配置Vagrantfile</h1>
<pre><code>config.vm.box_version = &quot;1.1.0&quot;
cfg.vm.hostname = &quot;ubuntu.labs&quot;

# 端口映射, 把主机的端口映射到vagrant的box
# 访问主机的该端口就是访问vagrant的box
cfg.vm.network :forward_port, guest: 80, host: 8080

# 私有网络，只有主机可以访问vagrant的box.
# 如果多个vagrant的box设定在同一个网段也可以互相访问．
cfg.vm.network :private_network, ip: &quot;192.168.50.10&quot;

# 公有网络，vagrant的box和主机使用一样的网络．
cfg.vm.network :public_network
cfg.vm.network :public_network, ip: &quot;192.168.1.1&quot;

cfg.vm.synced_folder &quot;/var/tmp/pkg-build&quot;, &quot;/var/tmp/pkg-build&quot;
</code></pre>
<hr>
<h1 id="打包">打包</h1>
<p>用户可以打包自己的开发环境，然后分发出去．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_misc/">Django Misc</a></h2>
                <div class="post-meta">
                    <time>January 4, 2017</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="django的国际化和本地化">Django的国际化和本地化</h1>
<p>settings.py里面和国际化和本地化相关的设置:</p>
<pre><code>USE_I18N = True
USE_L10N = True
TIME_ZONE = 'UTC'
USE_TZ = True
</code></pre>
<h2 id="国际化i18n">国际化(i18N)</h2>
<p>由开发者完成,本地化的准备工作.</p>
<p><a href="http://www.i18nguy.com/unicode/language-identifiers.html">http://www.i18nguy.com/unicode/language-identifiers.html</a></p>
<pre><code>LANGUAGE_CODE = 'en-us' # default

LANGUAGES = [
    ('en-US', _('English')),
    ('zh-CN', _('Chinese')),
]
</code></pre>
<h2 id="本地化l10n">本地化(l10N)</h2>
<p>由翻译者完成.</p>
<hr>
<h1 id="django的安全">Django的安全</h1>
<hr>
<h1 id="django的性能优化">Django的性能优化</h1>
<p><a href="https://docs.djangoproject.com/zh-hans/3.2/topics/performance/">https://docs.djangoproject.com/zh-hans/3.2/topics/performance/</a></p>
<hr>
<h1 id="django的地理框架">Django的地理框架</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/database/">TSDB</a></h2>
                <div class="post-meta">
                    <time>January 3, 2017</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="rdbms">RDBMS</h1>
<p>关系数据库管理系统。</p>
<p>SQLite</p>
<p>Oracle</p>
<p>MSSQL</p>
<p>Mysql</p>
<p>Postgre</p>
<hr>
<h1 id="nosql">NoSQL</h1>
<p>NoSQL: Not only SQL.</p>
<p>非关系型数据库。</p>
<p>memcached(cache)</p>
<p>redis(cache)</p>
<p>mongodb</p>
<p>hbase(hadoop)</p>
<p>cassandra(hadoop)</p>
<p>rethinkdb</p>
<hr>
<h1 id="tsdb">TSDB</h1>
<p>Time series database.</p>
<p>时序数据库</p>
<p>influxdb</p>
<p>rrdtool</p>
<p>graphite</p>
<p>opentsdb</p>
<p>premetheus</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_awk/">Awk</a></h2>
                <div class="post-meta">
                    <time>December 14, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="awk">awk</h1>
<p>awk 是一门编程语言</p>
<p>awk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。</p>
<p>nawk： new awk。</p>
<p>mawk： awk的解释器</p>
<p>gawk是gnu的awk，功能更全面。</p>
<p>awk命令格式：</p>
<pre><code>awk [-v var=value [-F *] [–] '/pattern/ {action}'  file
awk [-v var=value [-F *] [-f scriptfile ...] [–] file
awk [-v var=value [-F *] [-] 'BEGIN {} /pattern/ {action} END {}'  file
BEGIN { }  在读取输入之前就操作
END { }    在读物输入之后操作
</code></pre>
<p>awk的指令需要用单引号包围；
模式需要用/pattern/包围；
过程需要用{command1；command2}包围，多个过程需要用；隔开。</p>
<p>脚本中传递参数格式：</p>
<pre><code>awk [-f scriptfile]OR['/pattern/{action}'] val1=value1 val2=value2 … file1   vala=valuea valb=valueb... file2 ...
</code></pre>
<p>如果通过shell传参数，把value改成$n即可。
可以通过命令返回值作为参数value。
也可以使用环境变量作为value，也可以给awk的环境变量赋值。
可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。
只有在-v和在BEGIN中定义的变量能在BEGIN中使用。
在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。
在任何位置定义的变量在END中都可以使用。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/wordpress/">Wordpress</a></h2>
                <div class="post-meta">
                    <time>November 18, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="wordpress">WordPress</h1>
<h1 id="安装">安装</h1>
<p>安装依赖：</p>
<pre><code>$sudo apt install apache2
$sudo apt install mysql-server
$sudo apt install php5
</code></pre>
<p>下载wordpress：</p>
<pre><code>$cd /var/www/html
$git clone https://github.com/WordPress/WordPress.git
</code></pre>
<h1 id="配置">配置</h1>
<p>添加mysql数据库：</p>
<pre><code>$mysql -u root -p
mysql&gt; create user 'wordpress'@'localhost' identified by '******';
mysql&gt; create database 'wordpress';
mysql&gt; GRANT ALL PRIVILEGES ON wordpress.* TO &quot;wordpress&quot;@&quot;localhost&quot;;
mysql&gt; FLUSH PRIVILEGES;
</code></pre>
<p>编辑配置文件：</p>
<pre><code>wp-config.php
</code></pre>
<p>登陆并安装站点：</p>
<pre><code>http://localhost
</code></pre>
<p>管理界面：</p>
<pre><code>http://localhost/wp-admin
</code></pre>
<hr>
<h1 id="语言">语言</h1>
<p>下载相应的语言版本,中文下载中文版的wordpress.</p>
<p>然后将wordpress/wp-content/languages拷贝到英文版的wordpress/wp-content下</p>
<p>语言包路径:</p>
<pre><code>wordpress/wp-content/languages
</code></pre>
<hr>
<h1 id="主题">主题</h1>
<p>修改wp-config.php安装主题不用输入ftp信息：</p>
<pre><code>define(&quot;FS_METHOD&quot;, &quot;direct&quot;);
define(&quot;FS_CHMOD_DIR&quot;, 0777);
define(&quot;FS_CHMOD_FILE&quot;, 0777);
</code></pre>
<p>主题安装在：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/html_form/">Html Form</a></h2>
                <div class="post-meta">
                    <time>October 31, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="html表单">html表单</h1>
<p>html表单用于搜集不同类型的用户输入。</p>
<hr>
<h1 id="form"><strong>form</strong></h1>
<p>form元素定义html表单。支持全局属性和事件属性。</p>
<pre><code>&lt;form action=&quot;action_page.py&quot;&gt;
&lt;fieldset&gt;
&lt;legend&gt;Form information:&lt;/legend&gt;
First name:&lt;br&gt;
&lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;
&lt;br&gt;
Last name:&lt;br&gt;
&lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;
&lt;/fieldset&gt;
&lt;/form&gt;

# accept-charset属性规定服务器可处理的表单数据字符集。

# action属性规定当提交表单时向何处发送表单数据。
&lt;form action=&quot;action_page.py&quot;&gt;

# autocomplete属性规定是否启用表单的自动完成功能
on/off

# enctype属性规定在发送表单数据之前如何编码
application/x-www-form-urlencoded, 默认值，表示在发送前编码所有值．
multipart/form-data, 不编码，在使用包含文件上传控件的表单必须使用．
text/plain, 空格转换为&quot;+&quot;加号，不对特殊字符编码．

# method属性规定用于发送form-data的http方法
get/post

# name属性规定表单名称
# novalidate属性规定提交表单时不验证

# target属性规定在何处打开URL。
_blank/_self/_parent/_top
</code></pre>
<hr>
<h1 id="input"><strong>input</strong></h1>
<p>input元素是最重要的表单元素。支持全局属性和事件属性。</p>
<pre><code># type属性规定输入元素类型
button
checkbox
file
hidden
image
password
radio
reset
submit
text

# name属性定义input元素名称
# value属性定义input元素默认值
readonly
disabled
size
maxlength
alt
accept
checked
src

autocomplete
autofocus
form
formaction
formenctype
formmethod
formnovalidate
formtarget
height
width
list
max
min
multiple
pattern
placeholder
required
step
</code></pre>
<hr>
<h1 id="fieldset"><strong>fieldset</strong></h1>
<p>fieldset元素组合表单中的相关数据，支持全局属性和事件属性</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_bootstrap/">Bootstrap</a></h2>
                <div class="post-meta">
                    <time>October 27, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="bootstrap">Bootstrap</h1>
<p><a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a></p>
<p><a href="https://www.bootcss.com/">https://www.bootcss.com/</a></p>
<p>install:</p>
<pre><code>$ npm install bootstrap@next
</code></pre>
<p>HTML,CSS,JavaScript的支持响应式和移动设备的WEB框架.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_jquery/">jQuery</a></h2>
                <div class="post-meta">
                    <time>October 27, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="jquery">jQuery</h1>
<p><a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a></p>
<p><a href="https://www.jquery123.com/">https://www.jquery123.com/</a></p>
<p>jquery是一个js库，简化了js编程。</p>
<p>install:</p>
<pre><code>$ npm install jqury
</code></pre>
<p>jquery功能：</p>
<ul>
<li>HTML 元素选取</li>
<li>HTML 元素操作</li>
<li>HTML 事件函数</li>
<li>HTML DOM 遍历和修改</li>
<li>CSS 操作</li>
<li>JavaScript 特效和动画</li>
<li>AJAX</li>
<li>Utilities</li>
</ul>
<h1 id="syntax">syntax</h1>
<p>对元素操作语法：</p>
<pre><code>$(selector).action()
</code></pre>
<p>文档就绪函数:</p>
<pre><code>$(document).ready(function(){
    ......
})
</code></pre>
<p>head中:</p>
<pre><code>&lt;head&gt;
&lt;script type=&quot;text/javascript&gt;
$(document).ready(function(){
    $(&quot;button&quot;).click(function(){
        $(&quot;p&quot;).hide();
    })
})
&lt;/script&gt;
&lt;/head&gt;
</code></pre>
<p>独立js文件</p>
<pre><code>&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/path/to/my.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
</code></pre>
<h1 id="选择器">选择器</h1>
<p><a href="https://api.jquery.com/category/selectors/">https://api.jquery.com/category/selectors/</a></p>
<pre><code>$(this).hide()   this表示当前html元素
$(&quot;p.test&quot;)    class=&quot;test&quot;的&lt;p&gt;&lt;/p&gt;元素
$(&quot;p#test&quot;)    id=&quot;test&quot;的&lt;p&gt;&lt;/p&gt;元素
$(&quot;div#test .demo&quot;)  id=&quot;test&quot;的&lt;div&gt;&lt;/div&gt;中class=demo的元素
$(&quot;ul li:first&quot;)  每个&lt;ul&gt;&lt;/ul&gt;的第一个&lt;li&gt;&lt;/li&gt;
</code></pre>
<p>element选择器：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_test/">Test</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="testspy">tests.py</h1>
<p><a href="https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/">https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/</a></p>
<p><a href="https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/">https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/</a></p>
<p>单个测试文件</p>
<pre><code>vim app/tests.py
from django.test import TestCase
</code></pre>
<p>多个测试文件</p>
<pre><code>mkdir -p app/tests
vi test_case1.py
vi test_case2.py
</code></pre>
<h1 id="配置和运行">配置和运行</h1>
<p>默认情况下运行 manage.py test 会创建测试数据库运行testcase，完成后自动销毁测试数据库.</p>
<p>测试相关配置</p>
<pre><code>vim project/settings.py

DATABASES = {
    'default': {
        'NAME': 'mydb',
        'TEST': {
            // 默认测试数据库是'NAME'前加'test_' (eg: 'test_mydb')
            // 可以通过TEST.NAME指定测试数据库
            'NAME': 'mytestdb'
        }
    }
}

# 指定runner
## 默认 django.test.runner.DiscoverRunner
TEST_RUNNER = 'site_main.base_tests.TestRunner

# 指定fixture文件路径
FIXTURE_DIRS = (os.path.join(BASE_DIR, 'app', 'fixtures'), )
</code></pre>
<p>运行测试程序：</p>
<pre><code>$ python3 manage.py test // 查找test 开头的文件运行里面的 unittest.TestCase的子类.
$ python3 manage.py test &lt;package&gt; // 运行指️定应用内的测试
$ python3 manage.py test &lt;module&gt; // 运行指定模块内的测试
$ python3 manage.py test &lt;module&gt;.tests.MyTestCase // 运行一个指定的testcase
$ python3 manage.py test &lt;module&gt;.tests.MyTestCase.test_method // 运行一个指定的test method

--keepdb // 保留测试数据库
--parallel // 并行运行测试。
-v/--verbosity 0/1/2/3  测试输出信息级别，默认为1， 0表示不输出。
-d/--debug-sql 输出测试执行的sql语句.
</code></pre>
<hr>
<h1 id="client">Client</h1>
<p>测试客户端是一个 Python 类，它充当一个虚拟的 Web 浏览器，
允许你测试视图并以编程方式与 Django 驱动的应用程序交互。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_form/">Form</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="formspy">forms.py</h1>
<pre><code>from django import forms
</code></pre>
<h1 id="表单">表单</h1>
<p>用户在浏览器中输入数据提交，对数据验证以及输入框的生成等。</p>
<p>django的表单系统的核心类是django.forms.Form类,所有的构建的表单都是这个类的子类。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_admin/">Admin</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="adminpy">admin.py</h1>
<pre><code>from django.contrib import admin
</code></pre>
<p>创建一个管理员用户：</p>
<pre><code>$ python manage.py createsuperuser
</code></pre>
<p>管理员登陆界面：</p>
<pre><code>http://localhost:8000/admin/
</code></pre>
<p>在admin.py中注册模型，然后就可以在登陆界面管理模型了</p>
<pre><code>from .models import Question
admin.site.register(Question)
</code></pre>
<p>自定义管理表单：</p>
<pre><code>from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fileds = ['pub_date', 'question_date']
admin.site.register(Question, QuestionAdmin)
</code></pre>
<p>把表单分割成字段集：</p>
<pre><code>from .models import Question
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]
admin.site.register(Question, QuestionAdmin)
</code></pre>
<h1 id="后台">后台</h1>
<p>django的后台管理程序。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_url/">URL</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="urlspy">urls.py</h1>
<pre><code>from django.urls import path, include
</code></pre>
<p>django请求站点的方法：</p>
<ol>
<li>ROOT_URLCONF，在settings.py中设置。</li>
<li>寻找urlpatterns，它是django.conf.urls.url()实例的一个python列表。</li>
<li>dnango依次匹配每个URL模式，在第一个匹配停下。</li>
<li>一旦一个正则表达式匹配，django就调用对应的视图，视图获得HttpRequest实例,如果是没有命名的组返回内容作为位置参数，如果是命名的组返回内容作为关键字参数。</li>
<li>如果没有匹配到或者过程跑出异常，django调用合适的错误处理。</li>
</ol>
<h1 id="项目的url">项目的URL</h1>
<p>项目的URL主要用来包含应用的URL以及全局的URL:</p>
<pre><code>from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    # 默认的项目的admin的url
    path('admin/', admin.site.urls),
    
    # 在项目URL添加链接到应用URL：
    # 在下面添加你的所有应用的url,
    path('polls/', include('polls.urls')),
]
</code></pre>
<h1 id="应用的url">应用的URL</h1>
<p>将应用的视图映射到URL,需要在应用目录新建urls.py文件,然后在项目的url中包含应用的url。</p>
<p>urlpatterns是url()实例类型的python列表。</p>
<pre><code>from django.urls import path
from . import views

app_name = 'polls'

urlpatterns = [
    # 普通视图
    path('', views.index, name='index'),
    # 类视图
    path('', views.IndexView.as_view(), name='index'),
]
</code></pre>
<hr>
<h1 id="没有命名的组">没有命名的组</h1>
<p>视图函数只有request参数，匹配的正则表达式作为位置参数。</p>
<pre><code>url(r'^pattern1/pattern2/$', views.index, name='index'),

def index(request):
    ...
</code></pre>
<h1 id="命名组">命名组</h1>
<p>视图函数除了request参数还有关键字参数，匹配的命名表达式组作为关键字参数,覆盖默认的关键字参数。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_view/">View</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="viewspy">views.py</h1>
<pre><code>from django.shortcuts import render
</code></pre>
<p>定义自己的视图函数：</p>
<pre><code>from django.http import HttpResponse
from django.template import RequestContext, loader

# 导入模板中的类
from .models import Question

def index(request):
    ...
    t = loader.get_template('application/index.html')
    c = RequestContext(request, {'foo': 'bar'})
    return HttpResponse(t.render(c), content_type=&quot;text/html&quot;)
</code></pre>
<p>当请求一个页面时django会建立一个包含请求元数据的HttpRequest对象，当django加载对应视图时，这个对象作为视图第一个参数。</p>
<p>每个视图会返回一个HttpResponse对象。</p>
<p>每个视图函数都用HttpRequest对象（通常用request）作为第一个参数。</p>
<p>每个视图函数都返回一个HttpResponse对象，包含生成的响应。</p>
<p>HttpRquest和HttpResponse在django.http包中，参考：</p>
<p><a href="http://python.usyiyi.cn/documents/django_182/ref/request-response.html">http://python.usyiyi.cn/documents/django_182/ref/request-response.html</a></p>
<p>HttpRequest对象属性：</p>
<pre><code>request.scheme # http/https
request.body
request.path
request.path_info
request.method # GET/POST
request.encoding
request.user
request.session
request.urlconf
request.GET
request.POST
request.REQUEST
request.COOKIES
request.FILES
request.META
</code></pre>
<p>HttpRequest对象方法：</p>
<pre><code>request.get_host()
...
</code></pre>
<p>HttpResponse对象属性：</p>
<pre><code>response.content
response.charset
response.status_code
response.reason_phrase
response.streaming
response.closed
</code></pre>
<p>HttpResponse对象的方法：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_model/">Model</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="modelspy">models.py</h1>
<pre><code>from django.db import models
</code></pre>
<p>django模型是和数据库关联的，代码放在models.py，数据库信息在settings.py中统一配置即可。</p>
<p>每个模型对应数据库唯一的一张表，是django.db.models.Model的子类。</p>
<p>每个模型实例代表数据库中的一条特定记录.</p>
<p>模型的每个属性都表示为数据库中的一个字段。</p>
<ul>
<li>
<p>在项目的settings.py中激活应用，并设置数据库相关参数。</p>
</li>
<li>
<p>让django包含你的应用：</p>
<p>告诉django你对模型做了更改，并且将这些更改存储为迁移文件polls/migrations/0001_initial.py:</p>
<pre><code>  $python manage.py makemigrations polls
</code></pre>
<p>可以查看迁移文件执行了哪些sql语句,并不真的在数据库执行：</p>
<pre><code>  $python manage.py sqlmigrate polls 0001
</code></pre>
<p>可以检查项目中的模型是否存在问题：</p>
<pre><code>  $python manage.py check
</code></pre>
<p>在数据库中创建模型,查找还没有被应用的迁移文件然后和数据库同步：</p>
<pre><code>  $python manage.py migrate
</code></pre>
</li>
</ul>
<hr>
<h1 id="模型的字段类型和字段选项">模型的字段类型和字段选项</h1>
<p>模型的每个属性都表示为数据库的一个字段,是Field子类的某个实例。</p>
<p>模型的字段还有一些选项。</p>
<p>字段命名规则：</p>
<ol>
<li>不能是python的保留关键字。</li>
<li>字段名中连续的下划线不能超过一个。</li>
</ol>
<p>访问其它应用的模型,导入即可：</p>
<pre><code>from &lt;other-aplication&gt;.models import &lt;module-name&gt;
</code></pre>
<p>模型字段类型和选项参考：</p>
<p><a href="http://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options">http://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options</a></p>
<h2 id="模型字段类型">模型字段类型</h2>
<p>字段的类型都是Field类的子类：</p>
<p>每个字段都接受一个可选的位置参数(一般是第一个），叫字段的自述名,如果不指定就默认是字段名字（下划线换成空格）。</p>
<p>自增字段:</p>
<pre><code>AutoField
# 默认django会每个模型添加一个自增主键字段,如果你显示设置一个自增主键字段就不会默认再添加,每个模型只能有一个主键字段。
# id = models.AutoField(primary_key=True)
</code></pre>
<p>普通字段:</p>
<pre><code>BigIntegerField
BinaryField
BooleanField
CharField
CommaSeparatedIntegerField
DateField
DateTimeField
DecimalField
DurationField
EmailField
FileField
FilePathField
FloatField
GenericIPAddressField
IPAddressField
ImageField
IntegerField
NullBooleanField
PositiveIntegerField
PositiveSmallIntegerField
SlugField
SmallIntegerField
TextField
TimeField
URLField
UUIDField
</code></pre>
<p>关系字段:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_template/">Template</a></h2>
                <div class="post-meta">
                    <time>October 4, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="模板设置">模板设置</h1>
<p>模板引擎在settings.py设置, django有两套模板引擎：</p>
<pre><code>TEMPLATES = [
    # DjangoTemplates
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # 定义项目的通用模板, mysite/templates
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        # True 表示在所有安装应用的application/templates中查找。
        'APP_DIRS': True,
        # 模板的选项：
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ]
        },
    },

    # Jinja2
    {
        'BACKEND': 'django.template.backends.jinja2.Jinja2',
        # 定义项目的通用模板, mysite/templates
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        # True表示在所有已安装应用的application/jinja2中查找。
        'APP_DIRS': True,
        # 模板的选项：
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ]
        },
    },
]
</code></pre>
<p>BACKEND定义模板引擎,django内置的模板引擎有两个django.template.backends.django.DjangoTemplates(默认)和django.template.backends.jinja2.Jinja2</p>
<p>DIRS存放自定义的不在应用路径的模板，模板引擎按列表顺序搜索查找模板源文件,默认就是默认引擎的默认路径。</p>
<p>APP_DIRS告诉模板引擎是否进入安装应用的templates(jinja2的目录是jinja2)查找模板。</p>
<p>在视图中使用模板：</p>
<p>默认django会在项目的所有应用的templates中查找模板，所以为了防止多个应用有同名的模板，需要在templates下新建application同名的目录来存放模板</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_deploy/">Deploy</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="发布django项目">发布django项目</h1>
<p>django内置一个轻量级web开发服务器。</p>
<p>如果要发布django项目需要另外的操作。</p>
<p>也可以发布到其它的云平台。</p>
<p>一般通过wsgi或者asgi来部署.</p>
<h2 id="deploy时django的设置">deploy时django的设置</h2>
<p>settings.py中的设置：</p>
<pre><code>ALLOWED_HOSTS = ['*']
DEBUG = False
</code></pre>
<hr>
<h1 id="wsgi-部署">WSGI 部署</h1>
<h2 id="apache2--mod_wsgi">apache2 + mod_wsgi</h2>
<p><a href="https://github.com/GrahamDumpleton/mod_wsgi">https://github.com/GrahamDumpleton/mod_wsgi</a></p>
<p>mod_wsgi是C写的apache的模块，实现了兼容WSGI接口，用来部署python的web应用。</p>
<p>作为apache2的模块安装</p>
<pre><code># ubuntu/debian
sudo aptitude install apache2 # 安装apache2
sudo aptitude install libapache2-mod-wsgi # for python2
sudo aptitude install libapache2-mod-wsgi-py3 # for python3

# redhat/centos/fedora
sudo yum install httpd2
sudo yum install httpd-devel
sudo yum install mod_wsgi
</code></pre>
<p>Ubuntu创建网站的配置文件/etc/apache2/sites-available/mysite.conf:</p>
<p>Fedora创建网站的配置文件/etc/httpd/conf.d/mysite.conf:</p>
<p>一般部署到web服务器，/home/user/修改为/var/www/<project-name>/</p>
<pre><code># Include the project dir, can not inside VirtualHost section.
WSGIPythonPath /home/user/mysite
# If use virtualenv and named .venv
# WSGIPythonPath /home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages

&lt;VirtualHost *:80&gt;
    ServerName localhost
    # ServerName yoursite.domain
    ServerAdmin canuxcheng@gmail.com

    Alias /robots.txt /home/user/mysite/static/robots.txt
    Alias /favicon.ico /home/user/mysite/static/favicon.ico

    Alias /media/ /home/user/mysite/media/
    Alias /static/ /home/user/mysite/static/

    &lt;Directory /home/user/mysite/media&gt;
    Required all granted
    &lt;/Directory&gt;

    &lt;Directory /home/user/mysite/static&gt;
    Required all granted
    &lt;/Directory&gt;

    # If use daemon mode to run WSGI process.
    WSGIDaemonProcess mysite python-path=/home/user/mysite
    # If use virtualenv and named .venv
    # WSGIDaemonProcess mysite python-path=/home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages
    # WSGIProcessGroup mysite

    WSGIScriptAlias / /home/user/mysite/mysite/wsgi.py

    &lt;Directory /home/user/mysite/mysite&gt;
    &lt;Files wsgi.py&gt;
    Required all granted
    &lt;/Files&gt;
    &lt;/Directory&gt;

    # check the log in /var/log/apache2/error_mysite.log or access_mysite.log
    ErrorLog ${APACHE_LOG_DIR}/error_mysite.log
    CustomLog ${APACHE_LOG_DIR}/access_mysite.log combined
&lt;/VirtualHost&gt;
</code></pre>
<p>修改项目的wsgi.py:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_node/">Nodejs</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="nodejs">Nodejs</h1>
<p><a href="https://github.com/nodejs/node">https://github.com/nodejs/node</a></p>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p>
<p>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p>
<p>Node.js 的包管理器npm，是全球最大的开源库生态系统.</p>
<p>常说的javascript是前端语言，nodejs就是后端版本的javascript。</p>
<p>安装nodejs(npm):</p>
<pre><code>$ sudo apt-get install nodejs
$ brew install nodejs
</code></pre>
<p>查看</p>
<pre><code>$ node --version
$ npm --version
</code></pre>
<hr>
<h1 id="nvm">nvm</h1>
<p><a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p>
<p>nodejs版本管理器.</p>
<p>install:</p>
<pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
</code></pre>
<p>verify:</p>
<pre><code>command -v nvm
</code></pre>
<p>usage:</p>
<pre><code>// 查看所有可安装版本
nvm ls-remote

// 安装指定版本
nvm install v14.15.5

// 查看已安装版本
nvm ls

// 指定默认版本
nvm alias default v16.14.0

// 指定版本
nvm use v14.15.5
nvm use default

// 查看版本
nvm run node --version
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/js_npm/">NPM</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="npm">NPM</h1>
<p><a href="https://www.npmjs.cn/">https://www.npmjs.cn/</a></p>
<p>npm: node package manager.</p>
<p>npm 由三部分组成：</p>
<ul>
<li>website <a href="https://www.npmjs.com">https://www.npmjs.com</a></li>
<li>CLI</li>
<li>registry <a href="https://registry.npmjs.org">https://registry.npmjs.org</a></li>
</ul>
<p>config:</p>
<pre><code>// 修改registry
$ npm config set registry https://registry.npm.taobao.org
$ npm config get registry

// 修改默认全局安装路径
mkdir /path/npm_global
npm config set prefix /path/npm_global
echo 'export PATH=/path/npm_global/bin:$PATH' &gt;&gt; ~/.profile
source ~/.profile

// 查看配置
$ npm config ls -l
</code></pre>
<p>install:</p>
<pre><code>// 根据当前目录package.json安装到当前目录node_modules
$ npm install

// 安装pkg到当前目录的 node_modules
$ npm install &lt;pkg&gt;

// 安装到全局的node_modules
$ npm install -g &lt;name&gt;

--save-dev // 安装并自动更新到package.json的devDependencies.
--no-save // 不保存到package.json 和 package-lock.json.
--no-package-lock // 不生成package-lock.json
</code></pre>
<p>list:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/web/">Web</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="web">WEB</h1>
<p>web一般包括web server, web service, load balancing.</p>
<p>URL: Uniform Resource Locator, 统一资源定位符．</p>
<pre><code>scheme://host[:port#]/path/.../[?query-string][#anchor]
</code></pre>
<p>DNS: Domain Name System, 域名系统.</p>
<p>header: header中用来保存session，cookie等头部信息．</p>
<p>session: 服务端的数据存储机制．</p>
<p>cookie: 客户端的数据存储机制．分为会话cookie和持久cookie.</p>
<hr>
<h1 id="webserver">webserver</h1>
<p>LAMP: Linux+apache+mysql+php</p>
<p>LNMP: Linux+nginx+mysql+php</p>
<h1 id="blog静态站点">Blog静态站点</h1>
<p>hugo是golang开发的静态站点生成器．</p>
<p>pelican是python开发的静态站点生成器.</p>
<p>hexo是nodejs开发的静态站点生成器.</p>
<p>jekyll是ruby开发的静态站点生成器.</p>
<p>octopress是ruby开发的kekyll的升级版.</p>
<h1 id="cms系统">CMS系统</h1>
<p>wordpress是php开发的website, blog, app框架。</p>
<p>joomla是php开发的内容管理系统.</p>
<p>drupal是php开发的内容管理系统.</p>
<p>django-cms是python开发的基于django的内容管理系统.</p>
<p>wagtail是python开发的基于django的内容管理系统.</p>
<p>mezzanine是python开发的基于django的内容管理系统.</p>
<h1 id="forum系统">Forum系统</h1>
<p>vanilla是php开发的论坛系统.</p>
<p>phpbb是php开发的论坛系统.</p>
<hr>
<h1 id="webservice">webservice</h1>
<p>web service是一种标准,将应用程序转换成网络应用程序.</p>
<p>WSDL:网络服务描述语言</p>
<p>UDDI:</p>
<p>RDF:</p>
<p>RSS:</p>
<p>SOAP: 是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django_tpl/">TPL</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="django-third-party-library">Django Third Party Library.</h1>
<p><a href="https://github.com/rosarior/awesome-django">https://github.com/rosarior/awesome-django</a></p>
<p>Add this application to your django project in settings.py.</p>
<pre><code>INSTALLED_APPS = (
    'south',
    'debug_toolbar',
    'crispy_forms',
    ...
)
</code></pre>
<h1 id="django-rest-framework">django-rest-framework</h1>
<p>django的RESTful API的application。</p>
<p><a href="https://github.com/tomchristie/django-rest-framework/tree/master">https://github.com/tomchristie/django-rest-framework/tree/master</a></p>
<p><a href="https://github.com/django-json-api/django-rest-framework-json-api">https://github.com/django-json-api/django-rest-framework-json-api</a></p>
<p><a href="https://github.com/SimpleJWT/django-rest-framework-simplejwt">https://github.com/SimpleJWT/django-rest-framework-simplejwt</a></p>
<hr>
<h1 id="admin-interface">admin interface</h1>
<p><a href="https://github.com/geex-arts/django-jet">https://github.com/geex-arts/django-jet</a></p>
<p><a href="https://github.com/sehmaschine/django-grappelli">https://github.com/sehmaschine/django-grappelli</a></p>
<p><a href="https://github.com/darklow/django-suit">https://github.com/darklow/django-suit</a></p>
<p><a href="https://github.com/sshwsfc/xadmin">https://github.com/sshwsfc/xadmin</a></p>
<h1 id="authentication">authentication</h1>
<p><a href="https://github.com/etianen/django-python3-ldap">https://github.com/etianen/django-python3-ldap</a></p>
<p><a href="https://github.com/pennersr/django-allauth/">https://github.com/pennersr/django-allauth/</a></p>
<p><a href="https://github.com/django-guardian/django-guardian">https://github.com/django-guardian/django-guardian</a></p>
<h1 id="database">database</h1>
<p><a href="https://github.com/django-dbbackup/django-dbbackup">https://github.com/django-dbbackup/django-dbbackup</a></p>
<h1 id="debug">debug</h1>
<p><a href="https://github.com/jazzband/django-debug-toolbar">https://github.com/jazzband/django-debug-toolbar</a></p>
<p><a href="https://github.com/django-extensions/django-extensions/">https://github.com/django-extensions/django-extensions/</a></p>
<h1 id="form">form</h1>
<p><a href="https://github.com/django-crispy-forms/django-crispy-forms">https://github.com/django-crispy-forms/django-crispy-forms</a></p>
<h1 id="search">search</h1>
<p><a href="https://github.com/carltongibson/django-filter">https://github.com/carltongibson/django-filter</a></p>
<p><a href="https://github.com/django-haystack/django-haystack">https://github.com/django-haystack/django-haystack</a></p>
<h1 id="security">security</h1>
<p><a href="https://github.com/adamchainz/django-cors-headers">https://github.com/adamchainz/django-cors-headers</a></p>
<hr>
<h1 id="cms-project">CMS Project</h1>
<h2 id="django-cms">django-cms</h2>
<p><a href="https://github.com/divio/django-cms/">https://github.com/divio/django-cms/</a></p>
<h2 id="wagtail">wagtail</h2>
<p><a href="https://github.com/wagtail/wagtail">https://github.com/wagtail/wagtail</a></p>
<h2 id="mezzanine">mezzanine</h2>
<p><a href="https://github.com/stephenmcd/mezzanine/">https://github.com/stephenmcd/mezzanine/</a></p>
<hr>
<h1 id="e-commerce-project">e-Commerce Project</h1>
<h2 id="django-oscar">django-oscar</h2>
<p><a href="https://github.com/django-oscar/django-oscar">https://github.com/django-oscar/django-oscar</a></p>
<h2 id="django-shop">django-shop</h2>
<p><a href="https://github.com/awesto/django-shop">https://github.com/awesto/django-shop</a></p>
<hr>
<h1 id="pm-project">PM Project</h1>
<h2 id="taiga">taiga</h2>
<p><a href="https://github.com/taigaio">https://github.com/taigaio</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/apache/">Apache</a></h2>
                <div class="post-meta">
                    <time>September 27, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="apache">Apache</h1>
<p><a href="https://github.com/apache/httpd">https://github.com/apache/httpd</a></p>
<p><a href="http://httpd.apache.org/">http://httpd.apache.org/</a></p>
<p>ubuntu/debian：</p>
<pre><code>sudo aptitude install apache2
</code></pre>
<p>redhat/centos/fedora:</p>
<pre><code>$ sudo yum install httpd2
</code></pre>
<p>启动服务器：</p>
<pre><code>service apache2 start
</code></pre>
<p>启动浏览器查看：</p>
<pre><code>http://localhost:80
</code></pre>
<hr>
<h1 id="apache命令">apache命令</h1>
<p>apache2ctl:</p>
<pre><code>// 检查配置
$ apache2ctl configtest
</code></pre>
<p>a2ensite</p>
<pre><code>// 启用一个站点
$ sudo a2ensite &lt;site&gt;
</code></pre>
<p>a2dissite</p>
<pre><code>$ sudo a2dissite &lt;site&gt;
</code></pre>
<p>a2enmod</p>
<pre><code>// 启用一个模块
$ sudo a2enmod &lt;mod&gt;
</code></pre>
<p>a2dismod</p>
<pre><code>$ sudo a2dismod &lt;mod&gt;
</code></pre>
<h1 id="配置">配置</h1>
<p>配置站点site-enable/site.conf:</p>
<pre><code>&lt;VirtualHost *:8080&gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /opt

    # 适合多目录
    Alias /qa /opt/qa
    Alias /dev /opt/dev

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;
</code></pre>
<p>修改权限apache2.conf:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/django/">Django</a></h2>
                <div class="post-meta">
                    <time>September 20, 2016</time>
                    
                        
                            <span class="category">Django</span>
                        
                    
                </div>
                
                    <p><h1 id="django">Django</h1>
<p>django是python的web框架。</p>
<p><a href="https://github.com/django/django">https://github.com/django/django</a></p>
<p><a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a></p>
<p><a href="https://docs.djangoproject.com/zh-hans/3.1/contents/">https://docs.djangoproject.com/zh-hans/3.1/contents/</a></p>
<p>django遵守MVC设计模式，采用MTV框架。</p>
<p>M: model,数据存取</p>
<p>T: template，如何展现数据</p>
<p>V: view，展现哪些数据</p>
<h1 id="安装">安装</h1>
<p><a href="https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support">https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support</a></p>
<p>django1.11是最后一个支持python2.7的长期支持版(2017.4).</p>
<p>django2.0开始只支持python3(2018).</p>
<p>本文以django3.1为例创建名为next的project.</p>
<p>virtualenv中安装：</p>
<pre><code>$mkdir next
$cd next
$virtualenv .venv

# mac/linux
$source .venv/bin/activate

# windows
&gt;cd .venv/Scripts
&gt;activate

$pip install django
</code></pre>
<p>验证安装：</p>
<pre><code>$python
&gt;&gt;&gt;import django
&gt;&gt;&gt;django.VERSION
&gt;&gt;&gt;django.get_version()
</code></pre>
<p>安装使用的数据库引擎的库：</p>
<pre><code>$ sudo udo apt-get install libmysqlclient-dev
$ pip install mysqlclient

$pip install psycopg2

$pip install cx_Oracle
</code></pre>
<p>django默认是mysqlclient，可以使用pymysql替代：</p>
<pre><code># vim settings.py
import pymysql
pymysql.version_info = (1, 4, 13, &quot;final&quot;, 0)
pymysql.install_as_MySQLdb()
</code></pre>
<hr>
<h1 id="project">project</h1>
<p>创建一个名为next的项目</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/http/">Http</a></h2>
                <div class="post-meta">
                    <time>September 13, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="httphttps">HTTP/HTTPS</h1>
<p>http port: 80</p>
<p>https port: 443</p>
<p>http/https的请求方式：</p>
<pre><code>get # 从服务器取出资源
post # 在服务器新建资源
put # 在服务器更新资源，客户端提供改变后的完整资源
delete # 从服务器删除资源
patch # 在服务器更新资源，客户端提供改变的属性
head # 获取资源的源数据
options # 获取资源的哪些信息是客户端可以改变的信息
</code></pre>
<p>URL: Uniform Resource Locator</p>
<p>URI: Universal Resource Identifier</p>
<pre><code>&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;
scheme: http/https/ftp/file
netloc: username:password@host:port
path: /path/to/path
params: options arguments
query: connector&amp;key-value
fragment:
</code></pre>
<hr>
<h1 id="http命令">http命令</h1>
<h2 id="curl">curl</h2>
<pre><code>$ curl [options] [URL...]
</code></pre>
<h2 id="httpie">httpie</h2>
<p>python开发的类似于curl的命令行工具，同时还有wget的功能．</p>
<p><a href="https://github.com/jakubroztocil/httpie">https://github.com/jakubroztocil/httpie</a></p>
<pre><code>$ sudo yum/apt-get install httpie

$ http -a 'username:password' GET http://google.com
</code></pre>
<hr>
<h1 id="python的http标准库">python的http标准库</h1>
<p>python2的http标准库</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_builtins/">PSL_builtins</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="_builtins_">_<em>builtins</em>_</h1>
<p>python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。</p>
<p>包括内置类类型以及所属的内置方法，和内置函数.</p>
<blockquote>
<blockquote>
<p><strong>builtin</strong> - 包括内置类类型以及所属的内置方法，和内置函数.解释器不会自动导入．</p></blockquote></blockquote>
<blockquote>
<blockquote>
<p><strong>builtins</strong> - 仅仅是__builtin__的一个引用．解释器自动导入的．</p></blockquote></blockquote>
<p>内置常量</p>
<p>内置函数(BIF)</p>
<p>内置类型(BIT)</p>
<p>工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．</p>
<p>内置类型的内置方法(BIM)</p>
<p>内置异常</p>
<p>该模块是通过C/C++实现的．</p>
<hr>
<h1 id="内置函数">内置函数</h1>
<p>python2和python3共同的内置函数：</p>
<pre><code>__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数

compile(source, filename, mode[, flags[, dont_inherit]])
# 编译source返回一个code对象(代码对象)．
# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;
module = &quot;for i in xrange(10): print(i)&quot;
code = compile(module, '', 'exec')
type(code) # code
exec code
# mode: single, 用于单行语句, 也是用exec执行;
code = compile(&quot;print 'test'&quot;, '', single)
type(code) # code
exec code
# mode: eval, 用于表达式 可以用eval()函数执行． eg:
expression = &quot;3 * 4&quot;
code = compile(expression, '', 'eval')
type(code) # code
eval(code)

eval(source[, globals[, locals]])
# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．

format(value[, format_spec]) # 返回格式化后的字符串形式．

## 环境变量相关
globals() # 返回当前作用域的全局名称空间的字典．
locals() # 返回当前作用域的局部名称空间的字典．

## 数字类型的数学运算
abs(number) # 返回int/long的绝对值
divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组
pow(x, y[, z]) # 返回x**y或(x**y) % z
round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.
chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 &lt;= i &lt; 256.
ord(c) # 返回字符ASCII字符c对应的整数.
bin(number) # 返回int/long的二进制的字符串形式
oct(number) # 返回int/long的八进制的字符串形式．
hex(number) # 返回int/long的十六进制的字符串形式.

## 对象相关的操作
id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.
repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.
callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()
hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.
len(object) # 返回序列（str, tuple, list)或映射（dict)的长度
dir([object]) # 查看对象的信息
getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．
hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.
setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value
delattr(object, name) # 删除对象object的属性name
isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.
issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．
vars([object]) # 没有参数等于locals()，有参数等于object.__dict__.

## related to iterable
min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素
min(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素
max(iterable[, key=func]) # 和min相反
max(a, b, c, ...[, key=func]) # 和min相反
all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,''则返回True,iterable为空也返回True,否则返回False
any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,''则返回False,　否则返回True
sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．

## related to iterator
iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.
iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．
next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．

## related to input
input([prompt]) # 等于eval(raw_input(prompt))
# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.

## related to file
open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．
</code></pre>
<p>[New]python3新增的内置函数：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_concurrency/">PSL_Concurrency</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="concurrent-execution">Concurrent Execution</h1>
<p>进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。</p>
<p>线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。</p>
<p>IPC: 进程/线程之间交换信息叫进程间通信．</p>
<p>python的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.</p>
<p>IO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.</p>
<p>python的多进程可以并行,每个进程启动一个解释器进程.</p>
<p>多进程开销大，消耗内存.</p>
<p>计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.</p>
<h2 id="multiprocessing">multiprocessing</h2>
<p>多进程就是同时执行多个任务.</p>
<p>python可以通过多进程取代多线程，从而绕过多线程的GIL.</p>
<p>python是静态语言，</p>
<pre><code>import multiprocessing
</code></pre>
<p>classes:</p>
<pre><code># multiprocessing.Process
proc = Process(group=None, target=None, name=None, args=(), kwargs={})
# methods:
run(self)
start(self) # 启动一个进程
join(self, timeout=None) # 父进程等待子进程结束
is_alive()
terminate(self)
# data descriptor:
authkey
daemon # proc.daemon = True 后台运行
exitcode
ident
name
pid
</code></pre>
<p>functions:</p>
<pre><code># 普通函数
active_children()
allow_connection_pickling()
cpu_count() # 获取cpu个数
current_process()
freeze_support()
get_logger()
log_to_stderr(level=None)

Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)
pool = Pool()
# func只能是顶层函数，不能是方法和内部函数.
# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())
# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.
apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,
map_async(func, iterable, chunksize=None, callback=None) # 非阻塞
# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.
apply(func, args=(), kwargs={}) # 阻塞
map(func, itreable, chunksize=None) # 阻塞
terminate() # 终止所有任务
close() # 关闭pool,不接受新任务
join() # 等待pool中子进程结束，要在close/terminate之后调用.

# IPC: 管道
Pipe(duplex=True) # duplex=True表示默认是双向pipe.
receiver, sender = Pipe()
sender.send(obj)
receiver.recv()
close()

# IPC: 消息队列
# 来自于Queue.Queue, 具体方法参考Queue.Queue
Queue(maxsize=0) # return a queue object
q = Queue()

# IPC: 共享内存
Manager()
list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array

Array(typecode_or_type, size_or_initializer, **kwds)

RawArray(typecode_or_type, size_or_initializer)

Value(typecode_or_type, *args, **kwds)

RawValue(typecode_or_type, *args)

Event()

# 同步：　条件变量
Condition(lock=None)

# 同步：信号量
Semaphore(value=1)

# 同步：有界信号量
BoundedSemaphore(value=1)

# 同步： 锁
Lock()

# 同步: 锁
RLock()
</code></pre>
<p>data:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_python/">PSL_Python</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="python-runtime-services">Python Runtime Services</h1>
<h2 id="_builtin_">_<em>builtin</em>_</h2>
<blockquote>
<p><strong>builtin</strong>/builtins - Built-in functions, exceptions, and other objects.</p></blockquote>
<p>python2叫__builtin__</p>
<p>python3叫builtins</p>
<h2 id="_main_">_<em>main</em>_</h2>
<blockquote>
<p><strong>main</strong> - Top-level script environment.</p></blockquote>
<pre><code>if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>当作为顶层脚本运行时(<strong>main</strong>), 当作为一个模块运行时候就是模块名称．</p>
<h2 id="_future_">_<em>future</em>_</h2>
<p>把下一个版本的新特性导入到当前版本。</p>
<pre><code>from __future__ import &lt;feature_name&gt;

# feature name:
all_feature_names # 一次导入所有feature
absolute_import # 绝对导入
division
generators
nested_scopes
print_function
unicode_literals # python2中u'string'才表示unicode, 'string'表示str，python3中所有字符串都是unicode。
with_statement
</code></pre>
<p>data:</p>
<pre><code>all_feature_names
...
</code></pre>
<h2 id="sys">sys</h2>
<pre><code>import sys
</code></pre>
<p>Dynamic objects:</p>
<pre><code># 动态对象
sys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc
sys.path # 搜索的路径．import导入模块的搜索路径．
sys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来．
sys.stdin # 标准输入，用于input()
sys.stdout # 标准输出，用于print
sys.stderr # 标准出错
displayhook -- called to show results in an interactive session
excepthook --
last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback --
</code></pre>
<p>Static objects:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_system/">PSL_System</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="generic-operating-system-services">Generic Operating System Services</h1>
<h2 id="os">os</h2>
<pre><code>import os

os.path # 参考PSL_File
os.name
os.curdir
os.pardir # 表示上一级路径.., 需要用abspath解析
# os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))
os.sep
os.extsep
os.altsep
os.pathsep
os.linesep
os.defpath
os.devnull
</code></pre>
<p>classes:</p>
<p>functions:</p>
<pre><code>WCOREDUMP(...)
...

abort(...)
fork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程．
exec*
wait() # 等待子进程结束，返回(pid, status).
waitpid(pid, options) # 等待指定子进程结束.
listdir(path) # 列出目录下的文件和目录
makedirs(path [, mode=0o777], exist_ok=False)
mkdir(path [, mode=0777])
walk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器
remove(path) # 删除文件
rmdir(path) # 删除目录
removedirs(path)
symlink(src, dst)
chown(path, uid, gid)
chmod(path, mode=0o777)
...

# 使用subprocess模块代替下列函数：
system(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果．
spawn*
popen*(command [, mode='r' [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象)
</code></pre>
<p>data:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_gui/">PSL_GUI</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="gui">GUI</h1>
<h2 id="tkinter">Tkinter</h2>
<h2 id="ttk">ttk</h2>
<h2 id="tix">Tix</h2>
<h2 id="scrolledtext">ScrolledText</h2>
<h2 id="turtle">turtle</h2>
<hr>
<h1 id="tpl">TPL</h1>
<p>相关的第三方库</p>
<h2 id="wxwidgets">wxWidgets</h2>
<p>python2的库叫wxPython.</p>
<p><a href="https://www.wxpython.org/">https://www.wxpython.org/</a></p>
<pre><code># Windows下载安装包安装即可．
$ sudo apt-get install python-wxgtk2.8
</code></pre>
<p>python３启用新的项目phoneix.</p>
<p><a href="https://github.com/wxWidgets/Phoenix">https://github.com/wxWidgets/Phoenix</a></p>
<h2 id="gtk">gtk</h2>
<pre><code>PyGTK
</code></pre>
<h2 id="qt">qt</h2>
<pre><code>PyQt
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_misc/">PSL_Misc</a></h2>
                <div class="post-meta">
                    <time>August 15, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="psl">PSL</h1>
<p>Python Standard Library: Python标准库</p>
<hr>
<h1 id="internationalization">Internationalization</h1>
<h2 id="gettext">gettext</h2>
<h2 id="locale">locale</h2>
<hr>
<h1 id="program-frameworks">Program Frameworks</h1>
<h2 id="cmd">cmd</h2>
<h2 id="shlex">shlex</h2>
<p>类shell的词法分析．</p>
<p>classes:</p>
<pre><code>shlex
</code></pre>
<p>functions:</p>
<pre><code>split(s, comments=False, posix=True)
# split(&quot;command **kwargs&quot;) -&gt; ['command', 'arg1', ...]
</code></pre>
<p>data:</p>
<hr>
<h1 id="custom-python-interpreters">Custom Python Interpreters</h1>
<h2 id="code">code</h2>
<h2 id="codeop">codeop</h2>
<hr>
<h1 id="python-language-services">Python Language Services</h1>
<h2 id="keyword">keyword</h2>
<pre><code>import keyword
</code></pre>
<p>functions:</p>
<pre><code>keyword.iskeyword(keyword) # x.__contains__(y) &lt;==&gt; y in x
</code></pre>
<p>data:</p>
<pre><code>keyword.kwlist # 返回所有关键字的列表
</code></pre>
<h2 id="parser">parser</h2>
<h2 id="ast">ast</h2>
<h2 id="symtable">symtable</h2>
<h2 id="symbol">symbol</h2>
<h2 id="token">token</h2>
<h2 id="tokenize">tokenize</h2>
<h2 id="tabnanny">tabnanny</h2>
<h2 id="pyclbr">pyclbr</h2>
<h2 id="py_compile">py_compile</h2>
<h2 id="compileall">compileall</h2>
<h2 id="dis">dis</h2>
<h2 id="pickletools">pickletools</h2>
<hr>
<h1 id="importing-modules">Importing Modules</h1>
<h2 id="imp">imp</h2>
<h2 id="importlib">importlib</h2>
<h2 id="zipimport">zipimport</h2>
<h2 id="pkgutil">pkgutil</h2>
<h2 id="modulefinder">modulefinder</h2>
<h2 id="runpy">runpy</h2>
<hr>
<h1 id="miscellaneous-services">Miscellaneous Services</h1>
<h2 id="formatter">formatter</h2>
<h2 id="ihooks">ihooks</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_cryptographic/">PSL_Cryptographic</a></h2>
                <div class="post-meta">
                    <time>August 14, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="cryptographic-services">Cryptographic Services</h1>
<h2 id="hashlib">hashlib</h2>
<p>哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．</p>
<p>MD5: Message Digest Algorithm 5.</p>
<p>SHA1: Secure Hash Algorithm.</p>
<pre><code>import hashlib
</code></pre>
<p>classes:</p>
<pre><code># methods:
# 哈希对象有下列方法：
update(arg) # 更新字符串
md5.update('string or read from a file') # 放入需要转换的内容

digest() # 字符串
hexdigest() # 十六进制字符串
md5.hexdigest() # 获取md5十六进制字符串

copy() # 复制哈希对象
</code></pre>
<p>functions:</p>
<pre><code># 下类函数都返回哈希对象
new(name, string='')
md5()
md5 = hashlib.md5() # 创建一个md5的hash对象
sha1()
sha224()
sha256()
sha384()
sha512()
</code></pre>
<h2 id="hmac">hmac</h2>
<hr>
<h1 id="tpl">TPL</h1>
<p>相关的第三方库</p>
<h2 id="pycrypto">pycrypto</h2>
<p><a href="https://github.com/dlitz/pycrypto">https://github.com/dlitz/pycrypto</a></p>
<p>windows需要MS Visual C++ compiler for python2.7.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_data/">PSL_Data</a></h2>
                <div class="post-meta">
                    <time>August 14, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="data-types">Data Types</h1>
<h2 id="datetime">datetime</h2>
<pre><code>import datetime
</code></pre>
<p>classes:</p>
<pre><code># datetime.date
date(year, month, day)
# methods:
ctime(...)
...
# data descriptors:
day
month
year

# datetime.datetime(datetime.date)
datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])
# methods:
datetime.datetime.strptime(string, format)
format_datetime = datetime.datetime.strptime('20160824161431', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31)
format_datetime = datetime.datetime.strptime('24 August 2016 16:14:31', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31)

datetime.datetime.strftime(format[, tuple])
string_datetime = format_datetime.strftime(&quot;%d %B %Y %H:%M:%S&quot;) # return: '24 August 2016 16:14:31'
datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') # return: '2017-02-07 23:07:32'

str(datetime.datetime.now())
datetime.datetime.now().strftime('%Y%m%d%H%M%S') # 当前时间戳

# datetime.time

# datetime.timedelta

# datetime.tzinfo
</code></pre>
<p>data:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_file/">PSL_File</a></h2>
                <div class="post-meta">
                    <time>August 14, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="file-and-directory-access">File and Directory Access</h1>
<h2 id="ospath">os.path</h2>
<p>windows的路径要写成：</p>
<pre><code>C:\\test\\sub\\

import os
</code></pre>
<p>function:</p>
<pre><code>os.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(&quot;~/src&quot;) -&gt; /home/user/src
os.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原．
os.path.dirname(filename) # 返回filename的路径 dirname(&quot;/home/user/file.py&quot;) -&gt; /home/user
os.path.join(a, *p) # 拼结一个完整的路径　
os.path.join(a, os.pardir) # 返回上级目录的路径
os.path.realpath(filename) # 返回filename的真实路径+文件名 realpath('__file__')
os.path.abspath(path) # 返回绝对路径, os.path.abspath('__file__')
os.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -&gt; (&quot;/home/user/test&quot;, &quot;.py&quot;)
os.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -&gt; test.py
os.path.getsize(filename) # 返回文件大小
os.path.exists(path) # 判断path(文件或目录)是否存在
os.path.isfile(path) # 判断path是否是常规文件
</code></pre>
<h2 id="pathlib">pathlib</h2>
<p>new in python3.4</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_math/">PSL_Math</a></h2>
                <div class="post-meta">
                    <time>August 12, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="numeric-and-mathematical-modules">Numeric and Mathematical Modules</h1>
<h2 id="random">random</h2>
<pre><code>import random
</code></pre>
<p>classes:</p>
<pre><code># random.Random
Random()
# methods:
seed([self,], a=None)
randint(a, b) # 随机一个[a,b]中的整数．
choice(self, seq) # 从seq中随机选择一个元素
uniform(self, a, b)
sample(self, population, k)
randint(self, a, b)
randrange(self, start, stop=None, step=1, _int=&lt;type 'int'&gt;, _maxwidth=9007199254740992L)

# random.SystemRandom(Random)
SystemRandom(Random)

# random.WichmannHill(Random)
WichmannHill(Random)
</code></pre>
<p>functions:</p>
<pre><code>getrandbits(k)
random(self) # 随机一个小于１的数．
# 所有Random类的methods也可以直接使用．
</code></pre>
<h2 id="fractions">fractions</h2>
<h2 id="functools">functools</h2>
<p>函数式编程相关的模块</p>
<pre><code>import functools
</code></pre>
<p>classes:</p>
<pre><code># functools.partial
partial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型.
RED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED)
RED(&quot;show me red&quot;) == lambda content, color: Fore.RED + str(&quot;show me red&quot;) + Fore.RESET
# 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数．
</code></pre>
<p>functions:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_string/">PSL_String</a></h2>
                <div class="post-meta">
                    <time>August 12, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="text-processing-services">Text Processing Services</h1>
<h2 id="string">string</h2>
<pre><code>import string
</code></pre>
<p>classes:</p>
<p>functions:</p>
<p>data:</p>
<pre><code>ascii_letters
ascii_lowercase
ascii_uppercase
digits
...
</code></pre>
<h2 id="re">re</h2>
<pre><code>import re
</code></pre>
<p>classes:</p>
<p>functions:</p>
<pre><code>compile(pattern, flags=0)
escape(pattern)
findall(pattern, string, flags=0)
finditer(pattern, string, flags=0)
match(pattern, string, flags=0) # if not match, return None, else return object.
search(pattern, string, flags=0)
purge()
split(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表．
sub(pattern, repl, string, count=0, flags=0)
subn(pattern, repl, string, count=0, flags=0)
template(pattern, flags=0)
</code></pre>
<p>data:</p>
<pre><code># flags:
IGNORECASE # 大小写不敏感
LOCALE
MULTILINE
DOTALL
VERBOSE
UNICODE
</code></pre>
<p>modules:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_multimedia/">PSL_Multimedia</a></h2>
                <div class="post-meta">
                    <time>August 12, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="multimedia-services">Multimedia Services</h1>
<h2 id="audioop">audioop</h2>
<h2 id="aifc">aifc</h2>
<h2 id="sunau">sunau</h2>
<h2 id="wave">wave</h2>
<h2 id="chunk">chunk</h2>
<h2 id="colorsys">colorsys</h2>
<h2 id="imghdr">imghdr</h2>
<h2 id="sndhdr">sndhdr</h2>
<h2 id="ossaudiodev">ossaudiodev</h2>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_network/">PSL_Network</a></h2>
                <div class="post-meta">
                    <time>August 12, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="internet-protocols-and-support">Internet Protocols and Support</h1>
<p>socketserver/http/ftp参考<a href="https://super-devops.readthedocs.io/en/latest/">https://super-devops.readthedocs.io/en/latest/</a>.</p>
<p>pop,imap/smtp参考<a href="https://super-devops.readthedocs.io/en/latest/">https://super-devops.readthedocs.io/en/latest/</a>.</p>
<h2 id="urllib">urllib</h2>
<p>urllib.request</p>
<p>urllib.respponse</p>
<p>urllib.parse</p>
<pre><code>from urllib.parse import urlparse
from urllib.parse import urljoin
</code></pre>
<p>urllib.error</p>
<p>urllib.robotparser</p>
<h2 id="ipaddress">ipaddress</h2>
<h2 id="webbrowser">webbrowser</h2>
<h2 id="cgi">cgi</h2>
<h2 id="cgitb">cgitb</h2>
<h2 id="wsgiref">wsgiref</h2>
<h2 id="xmlrpc">xmlrpc</h2>
<h2 id="socketserver">socketserver</h2>
<h2 id="nntplib">nntplib</h2>
<p>network news transfer protocol</p>
<pre><code>import nntplib
</code></pre>
<h2 id="telnet">telnet</h2>
<pre><code>import telnetlib
</code></pre>
<hr>
<h1 id="structured-markup-processing-tools">Structured Markup Processing Tools</h1>
<h2 id="html">html</h2>
<h2 id="xml">xml</h2>
<hr>
<h1 id="internet-data-handling">Internet Data Handling</h1>
<h2 id="json">json</h2>
<p>http api(restful)一般使用json格式的数据．</p>
<p>python和json数据类型对应关系参考WEB/JSON.</p>
<p>complex和class/def不能被编码.</p>
<pre><code>import json
</code></pre>
<p>classes:</p>
<p>functions:</p>
<pre><code># 将转换后的json格式写入文件
dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)
with open(file, 'w') as f:
    json.dump(dict_data, f)

# 将dict类型转换成json格式
dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)
json_data = json.dumps(dict_data)

indent=4 # 写入自动缩进４个空格

# 将读出的文件(json格式)转换成dict
load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
with open(file, 'r') as f:
    dict_data = json.load(f)

# json类型变成dict类型
loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
response_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型
</code></pre>
<h2 id="base64">base64</h2>
<h2 id="mailcap">mailcap</h2>
<h2 id="mailbox">mailbox</h2>
<h2 id="minetypes">minetypes</h2>
<h2 id="binhex">binhex</h2>
<h2 id="binascii">binascii</h2>
<h2 id="quopri">quopri</h2>
<h2 id="uu">uu</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/restructuredtext/">ReStructuredText</a></h2>
                <div class="post-meta">
                    <time>August 8, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="restructuredtext">reStructuredText</h1>
<p><a href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></p>
<p>reST是易读所见即所得的文本标记语言，格式类似markdown。</p>
<p>python的reST参考pep12和pep287:</p>
<p><a href="https://www.python.org/dev/peps/pep-0012/">https://www.python.org/dev/peps/pep-0012/</a></p>
<p><a href="https://www.python.org/dev/peps/pep-0287/">https://www.python.org/dev/peps/pep-0287/</a></p>
<p>主标题：</p>
<pre><code>title
=====

=====
title
=====
</code></pre>
<p>副标题：</p>
<pre><code>Subtitle
-----

--------
Subtitle
--------
</code></pre>
<p>次级标题：</p>
<pre><code>Content
^^^^^^^
</code></pre>
<p>星号斜体强调：</p>
<pre><code>*text*
</code></pre>
<p>双星号加粗重点强调：</p>
<pre><code>**text**
</code></pre>
<p>四个或以上的-表示分割线：</p>
<pre><code>----
</code></pre>
<p>参考式链接：</p>
<pre><code>`hyperlink`_

.. _hyperlink: http://hyperlink.org
</code></pre>
<p>行内式链接：</p>
<pre><code>`link &lt;https://link.com&gt;`_
</code></pre>
<p>图片：</p>
<pre><code>.. image:: https://path/image.png
    :alt: HTTPie compared to cURL
    :width: 679
    :heigh: 781
    :align: center
</code></pre>
<p>原样引用块：</p>
<p>双冒号加四个空格</p>
<pre><code>source code::

    print(&quot;source&quot;)
    return 0
</code></pre>
<p>文档测试块：</p>
<pre><code>&gt;&gt;&gt; print doctest block.
</code></pre>
<p>无序列表：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_debug/">Debug</a></h2>
                <div class="post-meta">
                    <time>August 6, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="ide">IDE</h1>
<p>pycharm可以通过breakpoint和step调试.</p>
<hr>
<h1 id="debug">debug</h1>
<h2 id="bdb">bdb</h2>
<h2 id="pdb">pdb</h2>
<h2 id="hotshot">hotshot</h2>
<h2 id="timeit">timeit</h2>
<h2 id="trace">trace</h2>
<h2 id="cprofile">cProfile</h2>
<h2 id="profile">profile</h2>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_pep/">PEP</a></h2>
                <div class="post-meta">
                    <time>August 6, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="pep-8--style-guide-for-python-code">PEP 8 &ndash; Style Guide for Python Code</h1>
<p><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p>
<h1 id="pep-257--docstring-conventions">PEP 257 &ndash; Docstring Conventions</h1>
<p><a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a></p>
<h1 id="pep-20pep-20--the-zen-of-python">PEP-20PEP 20 &ndash; The Zen of Python</h1>
<p><a href="https://www.python.org/dev/peps/pep-0020/">https://www.python.org/dev/peps/pep-0020/</a></p>
<pre><code># 查看pep20
&gt;import this
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_document/">Document</a></h2>
                <div class="post-meta">
                    <time>August 3, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="document">Document</h1>
<p>python项目文档相关的工具．</p>
<h1 id="pydoc">pydoc</h1>
<p>python自带的文档命令行接口</p>
<pre><code>$ pydoc --help
$ pydoc -p &lt;port&gt;
</code></pre>
<hr>
<h1 id="tpl">TPL</h1>
<h2 id="sphinx">Sphinx</h2>
<p><a href="https://github.com/sphinx-doc/sphinx">https://github.com/sphinx-doc/sphinx</a></p>
<p><a href="https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html">https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html</a></p>
<p>Sphinx就是python处理reStructuredText格式的工具。</p>
<p>安装：</p>
<pre><code>$pip install -U Sphinx
</code></pre>
<p>使用sphinx：</p>
<pre><code>$cd your-project/docs

$sphinx-quickstart
# 以下选项需要手动设定，其它都可以用默认值：
&gt; Project name: pydeveloper
&gt; Author name(s): Canux CHENG
&gt; Project version: 1.0.0.0
&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y
&gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y
</code></pre>
<p>配置文件conf.py包含刚才的所有配置，可以在这里手动修改。</p>
<p><a href="http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs">http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs</a></p>
<p>添加包的版本：</p>
<pre><code>sys.path.insert(0, os.path.abspath(&quot;..&quot;))
from &lt;project&gt; import __version__
</code></pre>
<p>修改自己的配置：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ftp/">Ftp</a></h2>
                <div class="post-meta">
                    <time>July 28, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="ftp">FTP</h1>
<p>ftp服务器有很多：</p>
<ol>
<li>vsftpd</li>
<li>proftpd</li>
<li>pyftpdlib</li>
</ol>
<hr>
<h1 id="vsftpd">vsftpd</h1>
<p>安装vsftpd:</p>
<pre><code>$ sudo apt-get install vsftpd
</code></pre>
<p>windows开启ftp服务和建立IIS站点即可。</p>
<p>linux配置：</p>
<pre><code>$ vim /etc/vsftpd.conf
local_root=/home/canux/FTP
anon_root=/home/canux/FTP
local_enable=YES
anonymous_enable=YES
chroot_local_user=YES
$ sudo service vsftpd restart
</code></pre>
<p>ftp的网页浏览格式：</p>
<pre><code>ftp://host/path
ftp://username:password@host:port/path
</code></pre>
<hr>
<h1 id="ftp命令">ftp命令</h1>
<h2 id="ftp-1">ftp</h2>
<pre><code>$ ftp [-46pinegvd] [host [port]]
</code></pre>
<hr>
<h1 id="python的ftp标准库">python的FTP标准库</h1>
<h2 id="ftplib">ftplib</h2>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ldap/">Ldap</a></h2>
                <div class="post-meta">
                    <time>July 28, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="ldap">LDAP</h1>
<p>LDAP占用tcp和udp的389端口。</p>
<p>使用SSL的LDAP占用tcp和udp的636端口。</p>
<p>Lightweight Directory Access Protocol.</p>
<p><a href="http://www.openldap.org/">http://www.openldap.org/</a></p>
<p>LDAP的windows工具：LDAPSoft LDAP Browser</p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/nfs/">Nfs</a></h2>
                <div class="post-meta">
                    <time>July 28, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="nfs">NFS</h1>
<p>NFS: Network File System</p>
<p>安装：</p>
<pre><code># 在nfs服务器安装nfs服务
$ sudo apt-get install nfs-kernel-server
# 添加共享目录并授权
$ sudo vim /etc/exports
/home/user/share *(rw,no_root_squash)
$ sudo service nfs-kernel-server restart

# 在nfs客户端安装nfs客户端
$ sudo apt-get install nfs-common
# 自动挂载
$ sudo vim /etc/fstab
nfs-server-ip:/home/user/share /home/user1/share nfs auto 0 0
$ sudo mount -a
# 手动挂载
$ sudo mount -t nfs nfs-server-ip:/home/user/share /home/user1/share
</code></pre>
<hr>
<h1 id="nfs-server">nfs-server</h1>
<p>配置/etc/exports</p>
<pre><code>/etc/exports  文件格式
&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]
</code></pre>
<h1 id="nfs-client">nfs-client</h1>
<p>配置/etc/fstab</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ntp/">Ntp</a></h2>
                <div class="post-meta">
                    <time>July 28, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="ntp">NTP</h1>
<p>NFS: Network Time Protocol</p>
<p>UTC: Coordinated Universal Time, 世界统一时间</p>
<p>GMT: Greenwich Mean Time, 格林尼治标准时间, = UTC</p>
<p>CET: Central European Time, 欧洲中部时间, = UTC+1, 下令时=UTC+2</p>
<p>CST: Chinese Standard Time, 中国标准时间, = UTC+8</p>
<hr>
<h1 id="时区管理">时区管理</h1>
<pre><code>$ timedatectl list-timezones # 查看所有时区
$ sudo timedatectl set-timezone Asia/Shanghai # 设置时区
$ sudo timedatectl set-timezone Etc/UTC
$ ls -l /etc/localtime # 应该是一个链接
</code></pre>
<hr>
<h1 id="ntp-1">ntp</h1>
<p>安装:</p>
<pre><code>$ sudo apt-get install ntp
</code></pre>
<h2 id="ntpdate">ntpdate</h2>
<p>从目标服务器同步.</p>
<pre><code>ntpdate -u ip
</code></pre>
<h2 id="ntpstat">ntpstat</h2>
<pre><code>$ sudo apt-get install ntpstat
</code></pre>
<hr>
<h1 id="chrony">chrony</h1>
<p>ntp的升级版.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ssh/">Ssh</a></h2>
                <div class="post-meta">
                    <time>July 28, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="openssh">OpenSSH</h1>
<p><a href="http://www.openssh.com/">http://www.openssh.com/</a></p>
<p>windows上支持ssh协议的客户端：</p>
<ul>
<li>putty</li>
<li>xshell</li>
<li>MobaXterm</li>
<li>secureCRT</li>
</ul>
<p>安装：</p>
<pre><code>$ sudo apt-get install openssh-server
$ sudo apt-get install openssh-client
</code></pre>
<hr>
<h1 id="ssh命令">SSH命令</h1>
<p>ssh是openssh协议的客户端．</p>
<p>远程操作的命令包括ssh, scp, sftp.</p>
<p>ssh</p>
<pre><code>$ ssh
# 远程执行命令需要用双引号，不能用单引号
$ ssh username@host &quot;command/script&quot;
</code></pre>
<p>scp</p>
<pre><code>$ scp
</code></pre>
<p>sftp</p>
<pre><code>$ sftp
</code></pre>
<p>常用选项：</p>
<pre><code>-C   compression
# 不需要输入yes来交互, 或者修改/etc/ssh/ssh_config
-o StrictHostKeyChecking=no
-o UserKnownHostsFile /dev/null
</code></pre>
<p>ssh也包括一些密钥管理的命令.</p>
<p>ssh-keygen</p>
<pre><code>$ ssh-keygen -t rsa -C 'canuxcheng@gmail.com'

# 通过将本机的公钥拷贝到远程机器实现无密码访问．
# 将本机的public-key拷贝到远程机器的authorized_keys.
$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote
# 另外的拷贝方法
$ ssh user@host &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot; &lt; ~/.ssh/id_rsa.pub
$ sudo service ssh restart # 需要重启ssh服务

非交互式通过命令行传密码的命令：
$ sshpass -p [password]
</code></pre>
<p>ssh-add</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ps_remote/">Remote Management</a></h2>
                <div class="post-meta">
                    <time>July 18, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="windows远程管理">Windows远程管理</h1>
<ol>
<li>WinRM, 远程处理,在远程机器上执行命令</li>
<li>WMI/CIM</li>
<li>RPC, 远程连接,在发起远程连接的机器上执行命令</li>
</ol>
<hr>
<h1 id="winrm">WinRM</h1>
<p>一对一远程处理:</p>
<p>类似于linux的ssh。</p>
<pre><code>Enter-PSSession -ComputerName name
...
Exit-PSSession
</code></pre>
<p>一对多远程处理:</p>
<p>同时远程到多台机器执行命令或脚本。</p>
<p>Invoke-Command一次创建一个连接对象，返回PSComputerName属性，执行完后就关闭连接。</p>
<pre><code>Invoke-Command -ComputerName name1,name2 -ScriptBlock {command1;command2}

Invoke-Command -ComputerName name1,name2 -FilePath filepath

Invoke-Command -ComputerName (Get-Content hosts.txt) ...
</code></pre>
<p>通过argumentlist把本地的参数传给远程的命令:</p>
<pre><code>$lvar1=&quot;value1&quot;
$lvar2=&quot;value2&quot;
Invoke-Command -ComputerName name
-ScriptBlock {
Param($var1, $var2)
...
}
-ArgumentList $lvar1, $lvar2
</code></pre>
<p>通过$using:传本地参数到远程机器：</p>
<pre><code>$var1=&quot;value1&quot;
Invoke-Command -ComputerName name
-ScriptBlock {
... $using:var1
}
</code></pre>
<p>创建持久的远程处理：</p>
<pre><code>$session1=New-PSSession -ComputerName server1
Enter-PSSession -Session $session1 ...
Invoke-Command -Session $session1 ...
</code></pre>
<hr>
<h1 id="wmi">WMI</h1>
<pre><code>Get-WmiObject
Remove-WmiObject
Invoke-WmiMethod
Register-WmiEvent
Set-WmiInstance

# 用powershell跑一个wql。
Get-WmiObject -Query &quot;select * from win32_service where name='winRM'&quot; | Format-List -Property Name,status

# 远程管理
Get-WMIObject -ComputerName ...
</code></pre>
<h1 id="cim">CIM</h1>
<pre><code>Get-CimClass
Get-CimInstance
Get-CimSession
Get-CimAssociatedInstance
Invoke-CimMethod
New-CimInstance
New-CimSession
New-CimSessionOption
Register-CimIndicationEvent
Remove-CimInstance
Remove-CimSession
Set-CimInstance
</code></pre>
<hr>
<h1 id="rpc">RPC</h1>
<pre><code># 远程连接
Get-Service -ComputerName ...
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win_winrm/">WinRM</a></h2>
                <div class="post-meta">
                    <time>July 17, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="winrm">WinRM</h1>
<p>Windows Remote Management</p>
<p>WinRM是WSMAN(WS-Management Protocol)的增强版。</p>
<p>WinRM是基于SOAP的防火墙友好的远程协议。</p>
<p><a href="https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx</a></p>
<p>WinRM设置:</p>
<p><a href="https://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx</a></p>
<p>检查winrm所有配置：</p>
<pre><code>cmd&gt; winrm get winrm/config
</code></pre>
<p>快速设置winrm：</p>
<pre><code>cmd&gt; winrm quickconfig
cmd&gt; winrm quickconfig -transport:https
</code></pre>
<p>查看listener配置：</p>
<pre><code>cmd&gt; winrm enumerate winrm/config/listener
</code></pre>
<p>WinRM配置包括监听设置,协议设置,Client,Service和Winrs四部分.</p>
<p>windows的三种网络安全协议。</p>
<p>Basic是基本的明文协议, NTLM是早期的安全协议,Kerberos是最新的安全协议.</p>
<h1 id="service权限管理">service权限管理</h1>
<p>查看service的auth配置：</p>
<pre><code>cmd&gt; winrm get winrm/config/service/auth
</code></pre>
<p>service只有Negotiate和Kerberos是默认开启的:</p>
<pre><code>Basic = false
Kerberos = true
Negotiate = true
Certificate = false
CredSSP = false
</code></pre>
<p>Negotiate对domain用户选择kerberos,对local用户选择NTLM.</p>
<p>设置service的Basic和Certificate和CredSSP(默认关闭)：</p>
<pre><code>#cmd&gt; winrm set winrm/config/service/auth @{Basic=&quot;true&quot;}
#cmd&gt; winrm set winrm/config/service/auth @{Certificate=&quot;true&quot;}
#cmd&gt; winrm set winrm/config/service/auth @{CredSSP=&quot;true&quot;}
</code></pre>
<p>设置是否允许不加密：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ps_coreutils/">Coreutils</a></h2>
                <div class="post-meta">
                    <time>July 12, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="外部命令">外部命令</h1>
<p>powershell可以执行外部命令.</p>
<pre><code>C:\Windows\System32\*.exe
</code></pre>
<h1 id="cmd">cmd</h1>
<h1 id="ping">ping</h1>
<h1 id="netstat">netstat</h1>
<h1 id="ipconfig">ipconfig</h1>
<h1 id="route">route</h1>
<h1 id="arp">arp</h1>
<h1 id="nslookup">nslookup</h1>
<h1 id="ftp">ftp</h1>
<h1 id="mstsc">mstsc</h1>
<p>RDP client.</p>
<h1 id="taskmgr">taskmgr</h1>
<p>任务管理器．</p>
<h1 id="tskill">tskill</h1>
<h1 id="tree">tree</h1>
<h1 id="whoami">whoami</h1>
<hr>
<p>需要下载，然后放入环境变量的第三方命令.</p>
<h1 id="windump">WinDump</h1>
<p>Windows版本的tcpdump, 依赖WinPcap包．</p>
<p>通过windump导出的*.pcap文件可以通过wireshark打开．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/json/">Json</a></h2>
                <div class="post-meta">
                    <time>July 7, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="json">JSON</h1>
<p><a href="http://www.json.org/">http://www.json.org/</a></p>
<p>JSON: JavaScript Object Notation.</p>
<p>json有两种数据结构.</p>
<h1 id="key-value键值对">key-value/键值对</h1>
<pre><code>{
    key: value,
    key1: value1,
    ...
}
</code></pre>
<h1 id="列表数组">列表/数组</h1>
<pre><code>[value, value1, ...]
</code></pre>
<h1 id="数据类型">数据类型</h1>
<p>bool:</p>
<pre><code>python -&gt; True/False
go -&gt; true/false
</code></pre>
<p>string:</p>
<pre><code>&gt; 只能用双引号.

python -&gt; str
go -&gt; string
go -&gt; []byte -&gt; base64编码字符串
</code></pre>
<p>number:</p>
<pre><code>python -&gt; int/float
go -&gt; int64/float64
</code></pre>
<p>null:</p>
<pre><code>python -&gt; None
go -&gt; nil
</code></pre>
<p>array</p>
<pre><code>python -&gt; tuple/list
go -&gt; array/slice
</code></pre>
<p>object</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/yaml/">Yaml</a></h2>
                <div class="post-meta">
                    <time>July 7, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="yaml">YAML</h1>
<p><a href="https://yaml.org">https://yaml.org</a></p>
<p>Yaml Ain&rsquo;t Markup Language.</p>
<h2 id="yamllint">yamllint</h2>
<p><a href="https://github.com/adrienverge/yamllint">https://github.com/adrienverge/yamllint</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/css/">CSS</a></h2>
                <div class="post-meta">
                    <time>June 23, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="css"><strong>CSS</strong></h1>
<p>CSS是叠层样式表</p>
<h1 id="css3">CSS3</h1>
<p>CSS3是最新的CSS标准</p>
<h1 id="css创建">CSS创建</h1>
<p>优先级从上往下。</p>
<ol>
<li>内联样式， 在html中通过style属性定义，仅用于一个html元素。</li>
<li>内部样式表，在html中通过style标签在头部定义,针对单个页面。</li>
<li>外部样式表，在html中通过link标签在文档头部定义，方便将样式用于多个页面。</li>
<li>浏览器的默认值。</li>
</ol>
<hr>
<h1 id="css基本语法"><strong>CSS基本语法</strong></h1>
<p>CSS由两部分组成，选择器和声明，选择器是html元素，声明由属性和值组成。</p>
<pre><code>selector {
  property1: value1;
  property2: value2;
  ...;
}
</code></pre>
<p>多个声明用分号隔开，属性的值有空格要用引号。</p>
<p>CSS对大小写不敏感。</p>
<p>CSS注释:</p>
<pre><code>/* comment */
</code></pre>
<hr>
<h1 id="css选择器"><strong>CSS选择器</strong></h1>
<p>最常见的选择器是元素选择器,html元素是最基本的选择器。</p>
<h2 id="元素选择器">元素选择器</h2>
<p>html {color:black;}</p>
<h2 id="id选择器">id选择器</h2>
<p>id选择器可以为标有特定id的html元素指定特定样式。</p>
<p>id选择器用#开头定义。</p>
<pre><code>#red {color: red;}
#green {color: green;}

&lt;p id=&quot;red&quot;&gt;This is red.&lt;/p&gt;
</code></pre>
<p>id选择器常常用来建立派生选择器：</p>
<pre><code>#sidebar p {
  font-style: italic;
  text-align: right;
  margin-top: 0.5em;
}

&lt;div id=&quot;sidebar&quot;&gt;...&lt;/div&gt;
</code></pre>
<h2 id="class选择器">class选择器</h2>
<p>和id选择器功能类似，类选择器以.开头。</p>
<pre><code>.center {text-align: center}

&lt;h1 class=&quot;center&quot;&gt;...&lt;/h1&gt;
</code></pre>
<p>类选择器用于建立派生选择器：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/html/">Html</a></h2>
                <div class="post-meta">
                    <time>June 23, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="html">HTML</h1>
<p>HTML是超文本标记语言</p>
<h1 id="xhtml">XHTML</h1>
<p>XHTML是更严谨的更纯净的HTML</p>
<h1 id="html5">HTML5</h1>
<p>HTML5是下一代HTML</p>
<hr>
<h1 id="html元素和属性"><strong>html元素和属性</strong></h1>
<p>html元素指从开始标签到结束标签的所有代码,包括元素内容：</p>
<p>html元素可以嵌套。</p>
<pre><code>&lt;p&gt; This is paragrph &lt;/p&gt;
&lt;p&gt;&lt;/p&gt; # 空内容的元素
&lt;br /&gt; # 空元素，在开始标签中关闭
</code></pre>
<p>html标签可以拥有属性，属性总是以name=&lsquo;value&rsquo;的形式出现，属性总是在html元素的开始标签中规定。</p>
<pre><code>&lt;a href=&quot;http://www.test.com&quot;&gt;This is a link&lt;/a&gt;
</code></pre>
<p>html属性和值大小写不敏感，推荐使用小写,始终给属性值加引号。</p>
<h2 id="html的全局属性标准属性">html的全局属性(标准属性)</h2>
<p>参考：</p>
<p><a href="http://www.w3school.com.cn/tags/html_ref_standardattributes.asp">http://www.w3school.com.cn/tags/html_ref_standardattributes.asp</a></p>
<h2 id="html的事件属性">html的事件属性</h2>
<p>参考：</p>
<p><a href="http://www.w3school.com.cn/tags/html_ref_eventattributes.asp">http://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a></p>
<h2 id="html字符实体">html字符实体</h2>
<p>参考：</p>
<p><a href="http://www.w3school.com.cn/tags/html_ref_entities.html">http://www.w3school.com.cn/tags/html_ref_entities.html</a></p>
<hr>
<h1 id="html基本标签"><strong>html基本标签</strong></h1>
<h2 id="doctype">DOCTYPE</h2>
<pre><code># 文档类型
&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
...
&lt;/head&gt;

&lt;body&gt;
...
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="html-1">html</h2>
<pre><code># html文档,支持全局属性
&lt;html&gt;
...
&lt;/html&gt;

# mainfest属性，定义一个url，描述文档缓存信息

# xmlns属性，定义XML的namespace属性
</code></pre>
<h2 id="注释">注释</h2>
<pre><code># 注释, 浏览器会忽略注释,没有任何属性
&lt;!-- This is a comment --&gt;
</code></pre>
<h2 id="空格">空格</h2>
<pre><code>&amp;nbsp;    # 空格
</code></pre>
<hr>
<h1 id="head"><strong>head</strong></h1>
<h2 id="head-1">head</h2>
<p>可以在head标签中使用的标签： link, style, base, meta, script, title.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_package/">Package</a></h2>
                <div class="post-meta">
                    <time>June 22, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="package">Package</h1>
<p>PEP426是python最新的打包标准，定义了wheel为最新的python包。</p>
<p><a href="https://www.python.org/dev/peps/pep-0426/">https://www.python.org/dev/peps/pep-0426/</a></p>
<h2 id="ensurepip">ensurepip</h2>
<p>内置模块.提供使用pip从pypi安装模块。</p>
<h2 id="distutils">distutils</h2>
<p>内置的模块.处理简单的包安装,一般使用setuptools代替该模块。</p>
<h2 id="venv">venv</h2>
<p>python3新增了虚拟环境的包．python2中使用virtualenv.</p>
<h2 id="zipapp">zipapp</h2>
<p>python3新增管理可执行的python的zip包．</p>
<hr>
<h1 id="tpl">TPL</h1>
<p>相关的第三方库</p>
<h2 id="virtualenv">virtualenv</h2>
<p>python3.5开始并入了虚拟化标准库venv.</p>
<p>分离的虚拟的python环境,自动安装setuptools和pip和wheel</p>
<p><a href="https://github.com/pypa/virtualenv">https://github.com/pypa/virtualenv</a></p>
<pre><code>$cd project

# 默认python2.7
$virtualenv .env
# 指定python3, 会安装pip/setuptools/wheel到当前环境.
$$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env

# 激活虚拟环境
$source .env/bin/activate

# 先升级pip和setuptools
$pip install pip
$pip install setuptools
$pip install wheel

# 导出项目用的所有依赖库．
$pip freeze &gt; requirements.txt
# 在其它环境需要安装依赖：
$pip install -r requirements.txt
</code></pre>
<p>virtualenvwrapper</p>
<p><a href="https://bitbucket.org/virtualenvwrapper/virtualenvwrapper">https://bitbucket.org/virtualenvwrapper/virtualenvwrapper</a></p>
<p>封装了virtualenv的工具:</p>
<pre><code>$ pip install virtualenvwrapper

# 创建主目录
$ mkdir -p $WORKON_HOME

# 最好写入到.bashrc/.zshrc:
$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
$ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv
$ export WORKON_HOME=~/.virtualenvs
$ source /usr/local/bin/virtualenvwrapper.sh

# 为每个项目创建独立python环境：
$ mkvirtualenv -r requirementx.txt [project-name]
# 不安装setuotools/wheel/pip
$ mkvirtualenv --no-setuptools --no-wheel --no-pip [name]
# 指定查找pip/setuptools的路径
--extra-search-dir=/usr/local/lib/python2.7/dist-packages
--extra-search-dir=/usr/lib/python2.7/dist-packages
$ workon [project-name] # 切换到针对该项目的virtualenv
(pro)$ /path/to/pip install [package] # 安装第三方包
(pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装
(pro)$ lssitepackages # 查看安装的第三方包
$ deactivate # 退出virtualenv
$ rmvirtualenv [project-name] # 删除环境
</code></pre>
<p>pipenv</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_summary/">Summary</a></h2>
                <div class="post-meta">
                    <time>June 21, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="python难点总结">python难点总结</h1>
<h1 id="多线程">多线程</h1>
<ul>
<li>
<p>GIL</p>
<p>GIL: Global Interpretror Lock. 全局解释器锁．</p>
<p>python不建议使用多线程，用多进程代替．</p>
</li>
</ul>
<hr>
<h1 id="协程">协程</h1>
<ul>
<li>
<p>coroutine</p>
<p>协程就是同时开启两个任务，但一次只顺序执行一个．
如果执行的任务阻塞，就切换到下一个继续执行．节省时间．</p>
</li>
</ul>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_oop/">OOP</a></h2>
                <div class="post-meta">
                    <time>June 21, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="面向对象oop">面向对象/OOP</h1>
<p>OOD: Object Oriented Design.</p>
<p>面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．</p>
<p>OOP: Object Oriented Programming.</p>
<p>python内置OOP的结构，但是不必一定要使用类和OOP.</p>
<p>面向对象的两个主题就是类和类实例．</p>
<p>创建实例的过程叫实例化．</p>
<p>属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．</p>
<hr>
<h1 id="类class">类/Class</h1>
<p>类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．</p>
<p>类是一种数据结构的定义，实例是申明了一个这种类型的变量．</p>
<p>类的定义：</p>
<p>Python 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。</p>
<pre><code>class ClassName(object):
    &quot;&quot;&quot;Doc string.&quot;&quot;&quot;
    class_suite
</code></pre>
<p>类的初始化方法init(相当于构造器):</p>
<p>如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。</p>
<p>init方法的第一个参数必须是实例self，而且不能有return语句。</p>
<p>init方法一般用来设置实例属性(也就是数据属性)。</p>
<pre><code>class ClassName(object):
    def __init__(self, *args, **kwargs):
        pass
</code></pre>
<p>特殊方法new:</p>
<p>如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。</p>
<p>new方法的第一个参数必须是类cls。并且需要返回一个实例。</p>
<p>new方法在object中被定义为staticmethod。</p>
<p>相当于析构器的特殊方法del:</p>
<p>__del__特殊方法要在实例对象的所有引用都被清除后才会执行。</p>
<p>不要在del中做与实例没有关系的事情，一般不建议实现该方法。</p>
<pre><code>class ClassName(object):

    def __new__(cls, *args, **kwargs):
        ...
        return ...

    def __del__(self):
        ...
</code></pre>
<h2 id="类属性">类属性</h2>
<p>类属性分为数据属性和方法属性。</p>
<p>类的数据属性仅仅是定义的类的变量。</p>
<p>数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python/">Python</a></h2>
                <div class="post-meta">
                    <time>June 21, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="python概述"><strong>Python概述</strong></h1>
<p><a href="https://docs.python.org/2.7/index.html">https://docs.python.org/2.7/index.html</a></p>
<p><a href="http://python.usyiyi.cn/translate/python_278/index.html">http://python.usyiyi.cn/translate/python_278/index.html</a></p>
<p><a href="https://docs.python.org/3.5/index.html">https://docs.python.org/3.5/index.html</a></p>
<p><a href="http://python.usyiyi.cn/translate/python_352/index.html">http://python.usyiyi.cn/translate/python_352/index.html</a></p>
<p>python是一门优雅而健壮的语言.</p>
<p>继承了编译语言(静态语言)的强大性和通用性.</p>
<p>同时也借鉴了脚本语言(动态语言)的易用性．</p>
<p>python特点：</p>
<ul>
<li>高级</li>
<li>面向对象</li>
<li>可升级</li>
<li>可扩展</li>
<li>可移植性</li>
<li>易学</li>
<li>易读</li>
<li>易维护</li>
<li>健壮性</li>
<li>高效的快速原型开发工具</li>
<li>内存管理器</li>
<li>解释性和编译性</li>
</ul>
<hr>
<h1 id="python基本语法"><strong>python基本语法</strong></h1>
<p>python源程序叫xxx.py</p>
<p>python中一切皆对象．</p>
<p>python大小写敏感．</p>
<p>python通过缩进和冒号:区分语法块，而不是大括号{}.</p>
<p>python中的表达式(条件/循环表达式等)不需要用小括号()括起来．</p>
<p>python标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．</p>
<p>python不支持方法或函数重载．</p>
<p>python不支持char和type类型．</p>
<p>python没有switch语句．</p>
<p>python支持多继承．</p>
<p>python不支持++/&ndash;自增和自减运算符．</p>
<p>python支持连续比较，a&lt;b&lt;c.</p>
<h2 id="lexical-analysis">lexical analysis</h2>
<p><a href="https://docs.python.org/2/reference/lexical_analysis.html">https://docs.python.org/2/reference/lexical_analysis.html</a></p>
<p>Logical lines and physical lines：</p>
<pre><code># python通过行尾的令牌NEWLINE表示逻辑行
expression
# 以操作系统的换行符表示物理行．
\n
</code></pre>
<p>encoding declarations:</p>
<pre><code># python脚本中的第一行或第二行的
coding[=:]\s*([-\w.]+)
# 注释与正则表达式匹配将被作为编码申明处理．
</code></pre>
<p>[Deprecated] explicit line joining:</p>
<pre><code># 多个物理行通过反斜线backslash续行进行显示换行
# 推荐用隐式换行．
if a == b \
       and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释.
    print('more than one physical line.')
</code></pre>
<p>implicit line joining：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_tmux/">Tmux</a></h2>
                <div class="post-meta">
                    <time>June 19, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="tmux">tmux</h1>
<p>tmux是终端复用工具，类似于gnu screen。</p>
<p>tmux三个基本概念：</p>
<ol>
<li>
<p>会话（session）</p>
</li>
<li>
<p>窗口（window）</p>
</li>
<li>
<p>面板（pane）</p>
</li>
</ol>
<p>tmux使用c/s架构，tmux命令启动tmux服务器，一个tmux服务有多个session，
每个session就是tmux管理下的伪终端集合，一个session有多个window与之关联，
每个window就是一个伪终端，占据整个屏幕，一个window可以被分割成多个pane。</p>
<hr>
<h1 id="tmux安装和配置">tmux安装和配置</h1>
<p>tmux依赖libevent和ncurses库。</p>
<p><a href="http://libevent.org/">http://libevent.org/</a></p>
<pre><code>$ sudo yum install libevent-devel
</code></pre>
<p><a href="http://invisible-island.net/ncurses/">http://invisible-island.net/ncurses/</a></p>
<pre><code>$ sudo yum install ncurese-devel
</code></pre>
<p><a href="http://tmux.github.io/">http://tmux.github.io/</a></p>
<pre><code>sudo apt-get install tmux
sudo yum install tmux
</code></pre>
<p>用户配置文件： ~/.tmux.conf</p>
<p>系统配置文件： /etc/tmux.conf</p>
<hr>
<h1 id="tmux相关项目">tmux相关项目</h1>
<h2 id="tpm">TPM</h2>
<p>Tmux Plugins Manager.</p>
<p><a href="https://github.com/tmux-plugins/tpm">https://github.com/tmux-plugins/tpm</a></p>
<hr>
<h1 id="tmux用法">tmux用法</h1>
<pre><code>man tmux
</code></pre>
<p>开启tmux：</p>
<pre><code>tmux
</code></pre>
<p>退出tmux：</p>
<pre><code>exit
ctrl + d
</code></pre>
<p>列出tmux会话：</p>
<pre><code>tmux ls
</code></pre>
<h2 id="tmux快捷键">tmux快捷键</h2>
<p>tmux的prefix是ctrl-b</p>
<p>按下ctrl-b然后松开，通知tmux下面的按键是快捷键。</p>
<p>查看所有快捷键：</p>
<pre><code>ctrl-b + ?
</code></pre>
<p>显示时间：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/tracing_jaeger/">Jaeger</a></h2>
                <div class="post-meta">
                    <time>June 8, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="jaeger">Jaeger</h1>
<p>一款uber贡献给cncf的微服务tracing监控工具.</p>
<p><a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></p>
<p><a href="https://github.com/jaegertracing/jaeger">https://github.com/jaegertracing/jaeger</a></p>
<h1 id="deploy-jaeger-on-k8s">Deploy Jaeger on K8S</h1>
<p><a href="https://github.com/jaegertracing/jaeger-operator">https://github.com/jaegertracing/jaeger-operator</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics/">Metrics</a></h2>
                <div class="post-meta">
                    <time>June 8, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="monitoring">Monitoring</h1>
<p>Tranditional monitoring is for Datacenter, like nagios, zabbix.</p>
<p>Modern monitoring is for Cloud and Container.</p>
<p>Modern monitoring based on metrics, logs and tracing.</p>
<h1 id="tick-stack">TICK stack</h1>
<p>influxdb: tsdb.</p>
<p>kapacitor: alerting.</p>
<p>chronograf: GUI.</p>
<p>telegraf(agent): metrics collector.</p>
<h1 id="prometheus">Prometheus</h1>
<hr>
<h1 id="graphing">Graphing</h1>
<p>最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/monitoring/">Monitoring</a></h2>
                <div class="post-meta">
                    <time>June 8, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="monitoring">Monitoring</h1>
<p>Tranditional monitoring is for Datacenter, like nagios, zabbix.</p>
<p>Modern monitoring is for Cloud and Container.</p>
<p>Modern monitoring based on metrics, logs and tracing.</p>
<p>现代的监控系统在DevOps的基础上，除了传统的metrics和logging的采集，还需要tracing应用。</p>
<hr>
<h1 id="metrics">metrics</h1>
<h2 id="tick-stack">TICK stack</h2>
<p>influxdb: tsdb.</p>
<p>kapacitor: alerting.</p>
<p>chronograf: GUI.</p>
<p>telegraf(agent): metrics collector.</p>
<h2 id="prometheus">Prometheus</h2>
<h2 id="graphing">Graphing</h2>
<p>最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.</p>
<hr>
<h1 id="logging">Logging</h1>
<h2 id="elk">ELK</h2>
<h2 id="lokigrafana">Loki+Grafana</h2>
<hr>
<h1 id="tracing">Tracing</h1>
<h2 id="jeager">Jeager</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/tracing_sentry/">Sentry</a></h2>
                <div class="post-meta">
                    <time>June 8, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="sentry">Sentry</h1>
<p><a href="https://github.com/getsentry/sentry">https://github.com/getsentry/sentry</a></p>
<h1 id="deploy-sentry-on-k8s">Deploy Sentry on K8S</h1>
<p><a href="https://github.com/getsentry/onpremise">https://github.com/getsentry/onpremise</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/tracing/">Tracing</a></h2>
                <div class="post-meta">
                    <time>June 8, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="tracing">Tracing</h1>
<p>APM 监控，也叫全链路监控。</p>
<h1 id="sentry">sentry</h1>
<p><a href="https://github.com/getsentry/sentry">https://github.com/getsentry/sentry</a></p>
<h1 id="zipkin">zipkin</h1>
<p><a href="https://github.com/openzipkin/zipkin">https://github.com/openzipkin/zipkin</a></p>
<h1 id="open-telemetry">open-telemetry</h1>
<p>opentracing和opencensus 合并成open-telemetry.</p>
<p><a href="https://github.com/opentracing">https://github.com/opentracing</a></p>
<p><a href="https://github.com/census-instrumentation">https://github.com/census-instrumentation</a></p>
<p><a href="https://github.com/open-telemetry">https://github.com/open-telemetry</a></p>
<h1 id="jaeger">jaeger</h1>
<p><a href="https://github.com/jaegertracing/jaeger">https://github.com/jaegertracing/jaeger</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_package/">Package</a></h2>
                <div class="post-meta">
                    <time>June 7, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="dpkg">DPKG</h1>
<p>debian的包管理机制。</p>
<hr>
<h2 id="dpkg-1">dpkg</h2>
<p>dpkg的本地前端工具。</p>
<h3 id="deb---debian-binary-package-format">deb - Debian binary package format</h3>
<h3 id="dpkg---package-manager-for-debian">dpkg - package manager for Debian</h3>
<pre><code>dpkg
dpkg -X  ./xxx.deb  xxx  # 将deb包解压到xxx目录
dpkg -e  ./xxx.deb  xxx/DEBIAN # 将control信息解压
dpkg -l | grep pkg # 查看安装的包
</code></pre>
<h3 id="dpkg-reconfigure---reconfigure-an-already-installed-package">dpkg-reconfigure - reconfigure an already installed package</h3>
<pre><code>dpkg-reconfigure
</code></pre>
<h3 id="dpkg-deb---debian-package-archive-deb-manipulation-tool">dpkg-deb - Debian package archive (.deb) manipulation tool</h3>
<p>目录结构, DEBIAN/control是必需的</p>
<pre><code>|- debian_root
   |- DEBIAN
      |- control
      |- preinst/preinstallation # 解压deb包之前执行
      |- prerm/preremove
      |- postinst/postinstallation # 解压完成之后执行，通常用来配置
      |- postrm/postremove
      |- copyright
      |- changelog
      |- conffiles
   |- etc
      |- init.d/systemd
         |- &lt;service&gt;
      |- logrotate.d
         |- &lt;service&gt;
   |- user/local/...
   |- opt/...
</code></pre>
<p>control:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/oracle/">Oracle</a></h2>
                <div class="post-meta">
                    <time>June 1, 2016</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="oracle">Oracle</h1>
<p>oracle的GUI：</p>
<ol>
<li>oracle sql developer(officer)</li>
<li>pl/sql</li>
<li>toad</li>
</ol>
<p>oracle的CLI：</p>
<ol>
<li>sqlplus</li>
</ol>
<h1 id="oracle命令">Oracle命令</h1>
<p>sys是oracle默认管理员权限</p>
<pre><code>$ sqlplus / as sysdba
</code></pre>
<p>system是oracle的默认最高权限，默认密码是manager，需要sys授权才能登陆</p>
<pre><code>$ sqlplus / as sysdba
&gt; alter user system account unlock;
&gt; alter user system identified by manager;
&gt; conn system/manager
</code></pre>
<p>scott是oracle的默热你的普通用户，默认密码是tiger，需要sys授权才能登陆</p>
<pre><code>$ sqlplus / as sysdba
&gt; alter user scott account unlock;
&gt; alter user scott identified by tiger;
&gt; conn scott/tiger
</code></pre>
<p>本地命令行执行sql语句：</p>
<pre><code>$ &lt;sql query&gt; | &lt;sqlplus&gt; &lt;db user&gt;/&lt;db password&gt;@&lt;db sid&gt; | sudo ORACLE_HOME=&lt;oracle home&gt; -i -u &lt;oracle user&gt;
</code></pre>
<p>dbsnmp是oracle的用户智能代理用户，用来监控和管理数据库相关性能。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sql/">SQL</a></h2>
                <div class="post-meta">
                    <time>May 25, 2016</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="sql">SQL</h1>
<p>sql是结构化查询语言。</p>
<p>sql是一种标准，几乎所有关系型数据库都遵守。</p>
<p>但是不同的数据库又有自己的扩展。</p>
<p>SQL分为两部分，DML和DDL。</p>
<p>SQL大小写敏感，文本使用单引号，数值不需要引号。</p>
<h1 id="sql语法">sql语法</h1>
<p>sql注释:</p>
<pre><code># 多行注释
/*
comment multi lines
in a sql file.
*/

# 单行注释
/* comment single line */

# 单行注释还可以直接用 -- 表示
select * from table -- where condition;
-- select * from table where condition;
</code></pre>
<hr>
<h1 id="ddl">DDL</h1>
<p>DDL: 数据定义语言</p>
<h2 id="create">create</h2>
<p>创建数据库：</p>
<pre><code>CREATE DATABASE database_name;
</code></pre>
<p>建表：</p>
<pre><code>CREATE TABLE table(
    column1 type1,
    column2 type2,
    ...
);
</code></pre>
<p>create也可以用来创建索引和视图．</p>
<h2 id="drop">drop</h2>
<p>删除数据库：</p>
<pre><code>DROP DATABASE database_name;
</code></pre>
<p>删表：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/mysql/">Mysql</a></h2>
                <div class="post-meta">
                    <time>May 25, 2016</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="mysql">Mysql</h1>
<p>安装mysql服务器</p>
<pre><code>$ sudo apt-get install mysql-server
$ sudo yum install mysql-community-server

$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
# 注意mysql的/etc/mysql/my.cnf和相关文件如果设置了bind-address = 127.0.0.1就无法远程访问，需要注释掉．
</code></pre>
<p>安装mysql客户端</p>
<pre><code>$ sudo apt-get install mysql-client
$ sudo yum install mysql-community-client
</code></pre>
<p>安装开发工具：</p>
<pre><code>$ sudo apt-get install libmysqlclient-dev
</code></pre>
<p>CLI工具： mysql</p>
<p>GUI工具： mysql workbench</p>
<p>安装完成默认的数据库是 mysql。</p>
<p>mysqld的默认端口是3306.</p>
<hr>
<h1 id="mysql命令">mysql命令</h1>
<p>tips: 用户名密码有特殊字符用引号.</p>
<pre><code>$ mysql [OPTIONS] [database]
</code></pre>
<p>初始化时需要用root用户进入mysql命令行</p>
<pre><code>$ mysql -uroot -p
$ mysql -h&lt;host&gt; -P&lt;port&gt; -uroot -p&lt;password&gt;
</code></pre>
<p>创建用户后用其它用户操作：</p>
<pre><code>$ mysql -u&lt;user&gt; -p
</code></pre>
<p>本地执行sql语句或mysql客户端命令:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ps_builtins/">Builtins</a></h2>
                <div class="post-meta">
                    <time>May 24, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="get-help和help">Get-Help和Help:</h1>
<p>get-help查看帮助信息,help分页查看帮助信息，man是help的别名</p>
<p>命令说明：</p>
<pre><code>Get-Help
Help
</code></pre>
<p>查看所有命令和概念：</p>
<pre><code>Get-Help *
Help *
</code></pre>
<p>模糊查找命令和概念：</p>
<pre><code>Get-Help *&lt;name&gt;*
Help *&lt;name&gt;*
</code></pre>
<p>查看具体命令帮助：</p>
<pre><code>Get-Help {&lt;CmdletName&gt; | &lt;TopicName&gt;}
Help {&lt;CmdletName&gt; | &lt;TopicName&gt;}
&lt;CmdletName&gt; -?
</code></pre>
<p>get-help/help的选项:</p>
<pre><code>get-help get-help
-examples # 查看示例
-full # 查看所有帮助
-parameter # 查看选项的帮助
-detailed # 查看详细信息
-online # 打开文档中的link
-showwindow # 用窗口打开
</code></pre>
<h1 id="helpfile">Helpfile</h1>
<p>3.0/4.0 需要先下载帮助手册：</p>
<pre><code>update-help
</code></pre>
<p>所有helpfile：</p>
<pre><code>Get-Help/Help about_*
</code></pre>
<p>查看具体helpfile：</p>
<pre><code>Get-Help/Help about_&lt;name&gt;
</code></pre>
<hr>
<h1 id="cmdlets">Cmdlets</h1>
<p>cmdlets是powershell的内置命令,类型是System.Management.Automation.CmdletInfo</p>
<p>cmdlets的方法：</p>
<pre><code>Equals
GetHashCode
GetType
ToString
</code></pre>
<p>cmdlets的属性：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/snmp/">Snmp</a></h2>
                <div class="post-meta">
                    <time>April 26, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="snmp">SNMP</h1>
<p>Simple Network Management Protocol, 简单网络管理协议</p>
<p>MIB</p>
<p>SMI</p>
<p>安装和配置snmp:</p>
<pre><code>$sudo apt-get install snmp snmpd snmp-mibs-downloader
</code></pre>
<hr>
<h1 id="snmp命令">snmp命令</h1>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win_admin/">Admin</a></h2>
                <div class="post-meta">
                    <time>April 26, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ps/">PowerShell</a></h2>
                <div class="post-meta">
                    <time>April 26, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="powershell">PowerShell</h1>
<p>Console: command line interface</p>
<p>ISE: script editor and console combination</p>
<p>Version:</p>
<p>2.0,3.0,4.0,5.0</p>
<p>C:\Windows\System32\powershell 存放64位powershell</p>
<p>C:\Windows\SysWOW64\powershell 存放32位powershell</p>
<pre><code>&gt;$PSVersionTable
&gt;$HOST
</code></pre>
<p>Install/Update:</p>
<p><a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=40855">https://www.microsoft.com/zh-CN/download/details.aspx?id=40855</a></p>
<p>安装Windows Management Framework4.0即可。</p>
<pre><code>&gt;$PSHOME
</code></pre>
<p>多版本时切换版本:</p>
<pre><code>&gt;powershell -version 2
</code></pre>
<hr>
<h1 id="powershell相关项目">powershell相关项目</h1>
<p><a href="https://github.com/Microsoft">https://github.com/Microsoft</a></p>
<p><a href="https://github.com/PowerShell">https://github.com/PowerShell</a></p>
<p><a href="https://github.com/PowerShellOrg">https://github.com/PowerShellOrg</a></p>
<h2 id="win32-openssh">win32-openssh</h2>
<p>windows的SSH。</p>
<p><a href="https://github.com/PowerShell/Win32-OpenSSH">https://github.com/PowerShell/Win32-OpenSSH</a></p>
<hr>
<h1 id="powershell命令">powershell命令</h1>
<pre><code>&gt;powershell -?
&gt;powershell /?
&gt;powershell -help
</code></pre>
<hr>
<h1 id="powershell-script">powershell script</h1>
<p>powershell是默认大小写不敏感的。</p>
<p>同一行多个命令需要用分号;隔开。</p>
<p>powershell的安全策略：</p>
<ol>
<li>restricted(default)</li>
<li>allsigned</li>
<li>remotesigned</li>
<li>unrestricted</li>
<li>bypass</li>
</ol>
<h1 id="注释">注释</h1>
<p>单行注释：</p>
<pre><code># comment
</code></pre>
<p>多行注释(文档注释)：</p>
<pre><code>&lt;#
comment1
comment2
...
#&gt;
</code></pre>
<p>帮助文档:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/ps_utils/">Utils</a></h2>
                <div class="post-meta">
                    <time>April 26, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="windows相关项目">windows相关项目：</h1>
<h2 id="choco">choco</h2>
<p><a href="https://github.com/chocolatey">https://github.com/chocolatey</a></p>
<p>windows的apt/yum。</p>
<p><a href="https://github.com/chocolatey/choco">choco</a> is replacement of <a href="https://github.com/chocolatey/chocolatey">chocolatey</a></p>
<pre><code>choco install openssh
</code></pre>
<h2 id="cmder">cmder</h2>
<p>cmd的升级版。</p>
<p><a href="https://github.com/cmderdev/cmder">https://github.com/cmderdev/cmder</a></p>
<h2 id="babun">babun</h2>
<p>a linux-shell like on windows.</p>
<p><a href="https://github.com/babun/babun">https://github.com/babun/babun</a></p>
<h2 id="flinux">flinux</h2>
<p>run unmodified linux applications inside windows</p>
<p><a href="https://github.com/wishstudio/flinux">https://github.com/wishstudio/flinux</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_tivoli/">Tivoli</a></h2>
                <div class="post-meta">
                    <time>April 20, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="itm">ITM</h1>
<p>ITM: IBM Tivoli Monitoring</p>
<p>是IBM的Cloud &amp; Smart Infrastructure监控解决方案。</p>
<p>Architecture Overview:</p>
<p><img src="/images/tivoli.png" alt="pic"></p>
<p>ITM主要由管理组件和可选组件组成。</p>
<p>Tivoli Management Services:</p>
<ol>
<li>TEMS</li>
<li>TEPS</li>
<li>TEP client</li>
<li>Historical data collection(warehouse agent)
<ul>
<li>warehouse proxy</li>
<li>summarization and pruning agent</li>
</ul>
</li>
<li>OS agent</li>
</ol>
<p>Optional components:</p>
<ol>
<li>Dashboard Application Services Hub
<ul>
<li>Tivoli Monitoring dashboards(Infrastructure Management Dashboards for Servers)</li>
<li>Tivoli Common Reporting</li>
<li>Tivoli Enterprise Monitoring Automation Server</li>
</ul>
</li>
<li>Tivoli Event Synchronization component</li>
<li>Authorization Policy Components(tivcmd)</li>
</ol>
<p><a href="http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm">http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm</a></p>
<h2 id="安装itm">安装ITM</h2>
<p>Windows: C:\IBM\ITM</p>
<p>Linux/Unix: /opt/IBM/ITM</p>
<p>分为本地安装和分布式安装。</p>
<ol>
<li>
<p>需要先为TEPS和TDW安装DB(ODBC/JDBC)。</p>
<p>DB2</p>
<p>MSSQL</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_find/">Find</a></h2>
                <div class="post-meta">
                    <time>April 20, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="find">find</h1>
<p>Find     查找，用于在目录中查找。
find  path  options  tests  actions
path 路径
options 选项
tests 测试
actions 动作</p>
<p>optioins选项:
-follow
-depth
-maxdepth
-mindepth
find   dir  -mindepth  n     指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。
find   dir   -maxdepth  n      指定最大目录深度，不搜索n级之后的目录。</p>
<p>test选项很多：
-newer   pattern   比pattern文件要新
-user    pattern      文件属主是pattern
-name   pattern    查找和type匹配的
-iname  pattern    查找和type匹配的，会忽略大小写
-iwholename
-path   pattern     按照文件路径匹配
-type   c           c是文件类型，按照文件类型匹配文件
-size   +/-    nk/c/w/k/b/M/G    匹配大于或小于n  kb/..  的文件
-perm   XXX       基于文件权限的匹配
find dir  –atime/mtime/ctime    +/-n    根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。
-a/-and   pattern
-o/-or     pattern
！/-not    pattern
find  dir  !  test   pattern   列出所有没有按照-options  pattern模式的项
(&hellip;)    使用括号需要用引号来引用。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_grep/">Grep</a></h2>
                <div class="post-meta">
                    <time>April 20, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="grep">grep</h1>
<p>grep相关的命令：</p>
<pre><code>grep
egrep == grep -E
fgrep == grep -F
rgrep == grep -r
</code></pre>
<p>grep:</p>
<pre><code>grep [OPTIONS] PATTERN [FILE/DIR...]
grep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...]
</code></pre>
<p>options:</p>
<pre><code># Matcher Selection
-G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE
-E, --extended-regexp 选择ERE, 可以使用扩展的RE
# grep -E &quot;pattern1|pattern2&quot; 比如支持或运算
-F, --fixed-strings
-P, --perl-regexp perl RE

# Matching Control
-e PATTERN, --regexp=PATTERN    可以指定多个pattern
# grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来
-f FILE, --file=FILE    文件的每一行就是一个pattern.
-i, --ignore-case    忽略大小写
-v, --invert-match   忽略含有pattern的行
-w, --word-regexp    精确匹配一个单词
-x, --line-regexp    精确匹配一行
-y

# General Output Control
-c, --count    统计匹配到的行数
--color[=WHEN], --colour[=WHEN]    输出匹配的pattern高亮
-L, --files-without-match    列出没有匹配到的文件名
-l, --files-with-matches    列出匹配到的文件的文件名
# grep -rl pattern1 | xargs grep -r pattern2    相当于与运算，过滤同时满足两个pattern
-m NUM, --max-count=NUM
-o, --only-matching    只输出匹配的部分
# grep -o pattern filename | wc -l 统计匹配的行数
-q, --quiet, --silent    不打印查找的结果
-s, --no-messages

# Output Line Prefix Control
-b, --byte-offset    打印匹配的字符数或偏移量
-H, --with-filename
-h, --no-filename
--label=LABEL
-n, --line-number    打印匹配的行的行号
-T, --initial-tab
-u, --unix-byte-offsets
-Z, --null

# Context Line Control
-A NUM, --after-context=NUM    打印匹配到的行的后NUM行
-B NUM, --before-context=NUM    打印匹配到的行的前NUM行j
-C NUM, -NUM, --context=NUM    打印匹配到的行的前NUM行和后NUM行

# File and Directory Selection
-a, --text
--binary-files=TYPE
-D ACTION, --devices=ACTION
-d ACTION, --directories=ACTION
--exclude=GLOB    排除查找指定的文件
--exclude-from=FILE
--exclude-dir=DIR   排除查找指定的目录
-I
--include=GLOB     指定查找的文件
-r, --recursive    递归查找
-R, --dereference-recursive    递归查找
# grep -nR/-nr pattern filename    阅读源码可以递归查找并打印行号

# Other Options
--line-buffered
--mmap
-U, --binary
-z, --null-data
</code></pre>
<h1 id="ack">ack</h1>
<p>ack/ack2是grep的升级版</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_dev/">Development</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="development">Development</h1>
<p>开发相关的工具</p>
<p>传统的软件开发采用的是瀑布式开发流程．</p>
<p>现代的软件开发采用的是敏捷开发流程(Agile development).</p>
<p>Alpha: inner test version.</p>
<p>Beta: outer test version.</p>
<p>RC: release candidate. 最终版本之前的最后一个版本．也叫gamma.</p>
<p>RTM: release to manufacture, 最终版</p>
<p>GA: generally avaliable. stable/production.</p>
<hr>
<h1 id="怎样选择licenses">怎样选择Licenses</h1>
<p><a href="http://choosealicense.com/licenses/">http://choosealicense.com/licenses/</a></p>
<p><a href="https://choosealicense.com/">https://choosealicense.com/</a></p>
<p><img src="/images/license.jpeg" alt="pic"></p>
<hr>
<h1 id="semver">semver</h1>
<p>语义化版本．</p>
<p><a href="http://semver.org/lang/zh-CN/">http://semver.org/lang/zh-CN/</a></p>
<p><a href="https://github.com/mojombo/semver">https://github.com/mojombo/semver</a></p>
<pre><code>主版本号.次版本号.修订号
Major.Minor.Patch

Major: 做了不兼容的API修改
Minor: 做了向下兼容的功能性新增
Patch: 做了向下兼容的问题修正
</code></pre>
<hr>
<h1 id="文档阅读工具">文档阅读工具</h1>
<h2 id="zeal">zeal</h2>
<h2 id="dash">dash</h2>
<hr>
<h1 id="cookiecutter">cookiecutter</h1>
<p>一个快速建立工程模板的命令行工具．</p>
<p><a href="https://github.com/audreyr/cookiecutter">https://github.com/audreyr/cookiecutter</a></p>
<p><a href="https://github.com/audreyr/cookiecutter-pypackage">https://github.com/audreyr/cookiecutter-pypackage</a></p>
<pre><code>$sudo -E pip install cookiecutter
# 创建python项目
$cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git
# 创建django格式的python项目
$cookiecutter https://github.com/pydanny/cookiecutter-django
# 创建openstack格式的python项目
$cookiecutter https://git.openstack.org/openstack-dev/cookiecutter.git
$cookiecutter https://github.com/openstack-dev/cookiecutter.git
</code></pre>
<hr>
<h1 id="bumpversion">bumpversion</h1>
<p>版本管理工具</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops/">DevOps</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="devops">DevOps</h1>
<p>DevOps包括ChatOps, 敏捷开发，持续集成,持续交付,持续发布/部署，QA(自动化测试），智能监控和日志管理等内容．</p>
<p>DevOps涉及到三个部门：</p>
<ul>
<li>Development</li>
<li>Operations</li>
<li>Quality Assurance</li>
</ul>
<hr>
<h1 id="ci">CI</h1>
<p>Continuous Integration.</p>
<p>持续集成包括：</p>
<ul>
<li>编译代码.</li>
<li>静态代码分析.</li>
<li>自动化测试，例如selenium.</li>
<li>代码覆盖率分析.</li>
<li>构建，例如docker.</li>
</ul>
<h1 id="cd">CD</h1>
<p>Continuous Delivery.</p>
<p>持续交付包括：</p>
<ul>
<li>将通过测试的代码部署到Staging.</li>
</ul>
<h1 id="continuous-releasedeploy">Continuous Release/Deploy</h1>
<p>持续部署/发布包括：</p>
<ul>
<li>将通过评审的交付代码部署到Production.</li>
</ul>
<hr>
<h1 id="cicd的工具">CI/CD的工具</h1>
<p>持续集成和部署</p>
<h2 id="jenkins">Jenkins</h2>
<h2 id="travis-ci">travis CI</h2>
<p><a href="https://travis-ci.org/">https://travis-ci.org/</a></p>
<p>travis CI是基于github的CI工具, 部署代码然后运行测试代码.</p>
<p>在github项目添加.travis.yml文件：</p>
<pre><code>language: python
python:
  - &quot;2.7&quot;
install:
  - pip install -r requirements.txt
  - pip install coveralls
script:
  - coverage run --source=pymonitoringplugins setup.py test
after_success:
  - coveralls
</code></pre>
<h2 id="circleci">circleci</h2>
<p><a href="https://circleci.com/">https://circleci.com/</a></p>
<hr>
<h1 id="coverage的工具">coverage的工具</h1>
<p>统计单元测试的覆盖率</p>
<h2 id="coveralls">coveralls</h2>
<p><a href="https://coveralls.io/">https://coveralls.io/</a></p>
<h2 id="codecov">codecov</h2>
<p><a href="https://codecov.io/">https://codecov.io/</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_gitlab/">Gitlab</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="gitlab">Gitlab</h1>
<p>gitlab是开源的有web界面的git服务器．</p>
<p><a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p>
<p>安装gitlab:</p>
<pre><code>sudo apt-get install -y curl openssh-server ca-certificates
sudo apt-get install -y postfix
curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash
sudo EXTERNAL_URL=&quot;http://gitlab.example.com&quot; apt-get install gitlab-ce
</code></pre>
<p>配置:</p>
<pre><code>/etc/gitlab/gitlab.rb
</code></pre>
<p>升级gitlab:</p>
<p>需要先升级到下个major版本的最后一个稳定版.</p>
<pre><code>current:   9.4.7
patch: gitlab-ce=9.5.10
patch: gitlab-ce_10.8.7
patch: gitlab-ce=11.11.8
patch: gitlab-ce=12.0.12
target: 12.10.14
</code></pre>
<p>runner:</p>
<pre><code>#sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64
sudo chmod +x /usr/local/bin/gitlab-runner
sudo gitlab-runner install --user=canux --working-directory=/home/canux/gitlab
sudo gitlab-runner register
sudo gitlab-runner start
</code></pre>
<hr>
<h1 id="cli">CLI</h1>
<p>备份：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_jenkins/">Jenkins</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="jenkins">Jenkins</h1>
<p>Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks such as building, testing, and deploying software.</p>
<p><a href="https://github.com/jenkinsci/jenkins">https://github.com/jenkinsci/jenkins</a></p>
<p>安装好Jenkins后安装需要的插件．</p>
<p>安装jenkins:</p>
<pre><code># download jenkins.war and install java8.
$ java -jar jenkins.war --httpPort=8080
$ firefox http://localhost:8080
</code></pre>
<p>设置开机自动启动，不用每次从终端启动:</p>
<pre><code>$ vim /etc/systemd/system/jenkins.service
$ systemctl daemon-reload
$ systemctl enable jenkins.service
$ systemctl start jenkins
</code></pre>
<p>jinkens主目录:</p>
<pre><code># 默认主目录在/home/canux/.jenkins
</code></pre>
<hr>
<h1 id="nodes">nodes</h1>
<p>添加节点需要安装和master版本一样的java.</p>
<p>on jenkins agent:</p>
<ol>
<li>install java.</li>
<li>create folder and grant permission. (/home/jenkins)</li>
</ol>
<p>on jenkins:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_ops/">Operations</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="operations">Operations</h1>
<p>运维相关的工具．</p>
<hr>
<h1 id="批量配置管理">批量配置管理</h1>
<h2 id="puppet">puppet</h2>
<h2 id="chef">chef</h2>
<h2 id="salt">salt</h2>
<h2 id="ansible">ansible</h2>
<hr>
<h1 id="密码管理工具">密码管理工具</h1>
<h2 id="keepass">keepass</h2>
<p><a href="http://keepass.info/">http://keepass.info/</a></p>
<h2 id="keepassx">KeePassX</h2>
<p><a href="https://www.keepassx.org/">https://www.keepassx.org/</a></p>
<p><a href="https://github.com/keepassx/keepassx">https://github.com/keepassx/keepassx</a></p>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_admin/">Admin</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux-admin">Linux Admin</h1>
<p>dpkg: ubuntu, debian.</p>
<p>rpm: fedora, centos, redhat.</p>
<p>zypper: suse.</p>
<hr>
<h1 id="linux系统常用的安装和配置">Linux系统常用的安装和配置</h1>
<h2 id="terminalizer">terminalizer</h2>
<p>终端录制工具</p>
<p><a href="https://github.com/faressoft/terminalizer">https://github.com/faressoft/terminalizer</a></p>
<h2 id="virtualbox">virtualbox</h2>
<p>开机自动挂载共享文件夹</p>
<pre><code># 手动挂在命令, 需要安装增强功能
$ mount -t vboxsf FolderNameOnWindows /path/on/linux

# 实现开机自动挂载
$ sudo vim /etc/rc.local
mount.vboxsf -w ShareFolderNameOnWindows MountPointOnLinux
</code></pre>
<h2 id="xrdp">xrdp</h2>
<p>从windows的RDP远程连接linux.</p>
<p>use RDP on windows to connect to ubuntu16.04.</p>
<pre><code>sudo dpkg -i tigervncserver_1.6...deb # download and install tigervncserver first.
sudo apt-get install -f
sudo apt-get instal xrdp -y
echo unity &gt; ~/.xsession
</code></pre>
<p>use RDP on windows to connect to ubuntu14.04.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_agile/">Agile</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="agile-methodologies">Agile methodologies</h1>
<p>Agile的具体方法有Scrum, XP和kanban.</p>
<p>ThoughtWorks公司的Martin Fowler提出的敏捷方法．</p>
<hr>
<h1 id="scrum">Scrum</h1>
<p>Scrum方法由Ken Schwaber和Jeff Sutherland 提出.</p>
<p>scrum是一个用于开发和维护复杂产品的框架，是一个增量的，迭代的开发过程．</p>
<p>sprint: 一个短的迭代周期．一般２到４周．</p>
<p>backlog: 按商业价值排序的需求列表．</p>
<h2 id="scrum框架的三个角色">scrum框架的三个角色</h2>
<p>product owner: 产品负责人</p>
<p>scrum master: 敏捷教练和领导者</p>
<p>scrum team：developer</p>
<h2 id="scrum框架的三个工件">scrum框架的三个工件</h2>
<p>Product backlog: 整个产品待开发需求列表</p>
<p>sprint backlog: 一次迭代的待开发需求列表</p>
<p>increment: 产品增量</p>
<h2 id="scrum框架的五个事件">scrum框架的五个事件</h2>
<p>sprint planning meeting: sprint计划会议</p>
<p>Daily Scrum Meeting/DSM: 每日站立会议</p>
<p>sprint review meeting: sprint评审会议</p>
<p>sprint retrospective meeting: sprint回顾会议</p>
<p>product backlog refinement: 产品backlog梳理会议</p>
<h2 id="scrum框架的五个价值观">scrum框架的五个价值观</h2>
<p>承诺</p>
<p>专注</p>
<p>开放</p>
<p>尊重</p>
<p>勇气</p>
<h2 id="scrum框架的四大支柱">scrum框架的四大支柱</h2>
<p>迭代开发</p>
<p>增量交付</p>
<p>自组织团队</p>
<p>高优先级的需求驱动</p>
<hr>
<h1 id="xp">XP</h1>
<p>Extreme Programming</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_ansible/">Ansible</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="ansible">Ansible</h1>
<p><a href="https://github.com/ansible/ansible">https://github.com/ansible/ansible</a></p>
<p><a href="http://www.ansible.com.cn/index.html">http://www.ansible.com.cn/index.html</a></p>
<p>ansible通过SSH来远程管理Linux/Unix机器．</p>
<p>ansible通过winrm+powershell来远程管理Windows机器．</p>
<p>安装:</p>
<pre><code>$ sudo pip install ansible
$ sudo apt-get install ansible
$ sudo yum install ansible
</code></pre>
<p>配置：</p>
<p>参考Network-SSH实现从controller到所有node的无密码登陆</p>
<p>配置文件执行顺序:</p>
<pre><code>ANSIBLE_CONFIG
ansible.cfg
.ansible.cfg
/etc/ansible/ansible.cfg
</code></pre>
<p>手动配置:</p>
<pre><code>$ sudo vim /etc/ansible/ansible.cfg
[defaults]
ask_pass = False
host_key_checking = False
</code></pre>
<h1 id="ansible命令">ansible命令</h1>
<p>ansible运行命令的两种方式：</p>
<ol>
<li>Ad-hoc相当于直接运行shell命令</li>
<li>playbooks相当于运行shell脚本</li>
</ol>
<p>ansible:</p>
<pre><code>$ ansible -i inventory group1:group1:group3/all ...

$ansible --help
-m MODULE_NAME, --module-name=MODULE_NAME # 执行模块，默认是command
-M MODULE_PATH, --module-path=MODULE_PATH # 指定模块的路径
-a MODULE_ARGS, --args=MODULE_ARGS # 模块的参数
-i INVENTORY, --inventory INVENTORY # 默认/etc/ansible/hosts, 需要指定hosts分组
-f FORKS, --forks=FORKS # 指定并发进程的数量
-C, --check
-D, --diff
-l SUBSET, --limit=SUBSET
--syntax-check
--list-hosts
-v, --verbose # -v, -vvv, -vvvv

# 提权选项
-b, --become
--become-method=BECOME_METHOD # sudo(default)/su/pbrun/pfexec/runas/doas
--become-user=BECOME_USER # root(default)
-K, --ask-become-pass

# 连接选项
-u REMOTE_USER
--ssh-common-args
--ssh-extra-args
-T TIMEOUT # default 10s
-K, --ask-pass
</code></pre>
<hr>
<h1 id="inventory">inventory</h1>
<p>inventory包括主机和分组,以及主机变量和分组变量.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cloud_terraform/">Terraform</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="terraform">Terraform</h1>
<p>install:</p>
<p><a href="https://learn.hashicorp.com/tutorials/terraform/install-cli">https://learn.hashicorp.com/tutorials/terraform/install-cli</a></p>
<hr>
<h2 id="cli">CLI</h2>
<p>操作工作目录</p>
<pre><code>// 初始化目录，会根据配置下载和安装provider.
terraform init

terraform get
</code></pre>
<p>操作tf文件</p>
<pre><code>// 格式化文件
terraform fmt -recursive

// 验证文件
terraform validate 

// 可以通过终端验证函数.
terraform console
</code></pre>
<p>操作基础设施:</p>
<pre><code>terraform plan
terraform plan -out test.tfplan

terraform apply -auto-approve
terraform apply test.tfplan

terraform destroy
</code></pre>
<p>检查基础设施:</p>
<pre><code>terraform show
terraform graph
terraform output
terraform state list/show
</code></pre>
<p>认证:</p>
<pre><code>terraform login
terraform logout
</code></pre>
<hr>
<h2 id="tf">TF</h2>
<p><a href="https://www.terraform.io/language">https://www.terraform.io/language</a></p>
<p>注释:</p>
<pre><code># comment 
// comment
/* comment */
</code></pre>
<h3 id="backend-and-state">backend and state</h3>
<p><a href="https://www.terraform.io/language/settings/backends">https://www.terraform.io/language/settings/backends</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_vault/">Vault</a></h2>
                <div class="post-meta">
                    <time>April 15, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="vault">Vault</h1>
<p><a href="https://github.com/hashicorp/vault">https://github.com/hashicorp/vault</a></p>
<p>Install:</p>
<p><a href="https://learn.hashicorp.com/tutorials/vault/getting-started-install">https://learn.hashicorp.com/tutorials/vault/getting-started-install</a></p>
<h1 id="cli">CLI</h1>
<p>可以通过环境变量或者命令行参数指定server:</p>
<pre><code>-address VAULT_ADDR
-namespace VAULT_NAMESPACE
vault [subcommand] -address=&quot;https://server:8200&quot;
</code></pre>
<p>server:</p>
<pre><code>// 启动vault
$ vault server -config=/etc/vault/config.hcl
</code></pre>
<p>agent:</p>
<pre><code>$ vault agent
</code></pre>
<p>login:</p>
<pre><code>// 跟据token登陆.
$ vault login

$vault login -token-only -method=oidc
</code></pre>
<p>operator:</p>
<pre><code>// init生成keys和token.
$ vault operator init

// 通过keys  unseal
$ vault operator unseal

// 通过token seal
$ vault operator seal
</code></pre>
<p>auth:</p>
<pre><code>// 查看auth
$ vault auth list
</code></pre>
<p>secrets</p>
<pre><code>// 查看secrets engine
$ vault secrets list

// enable kv
$ vault secrets enable -path=&lt;ns&gt;/&lt;name&gt; kv
$ vault secrets enable kv

// disable kv
$ vault secrets disable kv

// 创建一个database engine
vault secrets enable -path &lt;ns&gt;/mysql database
// 创建rabbitmq engine
vault secrets enable -path &lt;ns&gt;/rabbitmq rabbitmq
</code></pre>
<p>policy</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/psl_test/">PSL_Test</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="development-tools">Development Tools</h1>
<h2 id="typing">typing</h2>
<h2 id="2to3">2to3</h2>
<pre><code>$2to3
</code></pre>
<h2 id="pydoc">pydoc</h2>
<pre><code>import pydoc
</code></pre>
<h2 id="test">test</h2>
<pre><code>import test
</code></pre>
<h2 id="doctest">doctest</h2>
<p>python内置的文档测试库．</p>
<pre><code>import doctest
</code></pre>
<h2 id="unittest">unittest</h2>
<p>python内置的单元测试库．</p>
<pre><code>import unittest
</code></pre>
<hr>
<h1 id="tpl">TPL</h1>
<p>相关的第三方库</p>
<h2 id="unittest2">unittest2</h2>
<p>unittest2是unittest的升级版．</p>
<p>python3集成了unittest2到unittest,像使用unittest一样使用即可．</p>
<pre><code># python2.7
$pip install unittest2
import unittest2

# python3
import unittest
</code></pre>
<p>unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．</p>
<p>测试结果：</p>
<p>OK 表示测试通过</p>
<p>FAIL 表示测试没有通过，并引发一个AssertionError异常．</p>
<p>ERROR 表示测试过程引发一个不是AssertionError的异常．</p>
<pre><code># Python2.7 此处用的是标准库的unittest.
import unittest
import MyClass
</code></pre>
<p>classes:</p>
<pre><code>unittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．
unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.
unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.
unittest.TestResult: 用来保存测试的结果．

unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．
fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．

unittest.TextTestRunner: 用来执行测试用例．
unittest.TextTestResult: 用来打印格式化的测试结果．

# unittest.TestCase
# methods:
assertXXX　系列方法．
failXXX 系列方法
fail(self, msg=None) # test立即失败
addCleanup(self, function, *args, **kwargs)
addTypeEqualityFunc(self, typeobj, function)
countTestCases(self)
debug(self)
defaultTestResult() # return unittest.TestResult()
doCleanups(self)
id(self)
run(self, result=None) # 可以在子类覆盖该方法．
shortDescription(self)
skipTest(self, reason)
setUp(self) # 重写之后，每个case运行之前都会调用一次．
tearDown(self) # 同上

# classmethods:
setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．
tearDownClass(cls) # 同上

# data:
failureException = AssertionError
longMessage = False
maxDiff = 640
</code></pre>
<p>functions:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_devops/">DevOps</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="ide">IDE</h1>
<ul>
<li>Visual Studio</li>
<li>VSCode</li>
</ul>
<h2 id="compilers">Compilers</h2>
<p>编译器组成：</p>
<ul>
<li>frontend</li>
<li>optimizer</li>
<li>backend</li>
</ul>
<p><a href="https://zh.cppreference.com/w/cpp/compiler_support">https://zh.cppreference.com/w/cpp/compiler_support</a></p>
<p>windows:</p>
<ul>
<li>llvm clang</li>
<li>Mingw</li>
<li>Msvc</li>
</ul>
<p>linux:</p>
<ul>
<li>llvm clang</li>
<li>gcc</li>
</ul>
<p>mac:</p>
<ul>
<li>llvm clang</li>
<li>gcc</li>
<li>apple clang</li>
</ul>
<h3 id="gcc">gcc</h3>
<p>gnu gcc,g++</p>
<h3 id="llvm-clang">llvm clang</h3>
<p>llvm: low level virtual machine. (backend)</p>
<p>clang: c language.(frontend)</p>
<hr>
<h2 id="tools">tools</h2>
<ul>
<li>CMake</li>
<li>MSBuild</li>
<li>Makefile</li>
</ul>
<hr>
<h2 id="gcc-1">GCC</h2>
<p>&ldquo;-ansi&rdquo;</p>
<p>for c: == -std=c90
for cpp: ==-std=c++98</p>
<p>&ldquo;-std&rdquo;</p>
<p>c++17, gnu++17, gnu17,c17
gnu2x: 下个ISO C标准。
c2x:下个ISO C标准。
c++2a: 下个ISO C++标准
gnu+2a:下个ISO C++标准</p>
<p>gcc8 开始支持c++20.
gcc11开始支持c++23.</p>
<h2 id="vscode">vscode</h2>
<p>for macOS:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_document/">Document</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="document">Document</h1>
<hr>
<h1 id="doxygen">Doxygen</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hadoop/">Hadoop</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="hadoop">Hadoop</h1>
<p><a href="https://github.com/apache/hadoop">https://github.com/apache/hadoop</a></p>
<p>apache hadoop是一个框架，允许使用简单的编程模型在大量计算机上对大型数据集进行分布式处理．</p>
<p>hadoop1只有HDFS和MapReduce两个模块，hadoop2开始分为HDFS, YARN, MapReduce三个模块．</p>
<p>hadoop的版本:</p>
<ul>
<li>apache hadoop</li>
<li>hortonworks hadoop (HDP)</li>
<li>cloudera hadoop (CDH)</li>
<li>mapr</li>
<li>transwarp</li>
</ul>
<h1 id="安装hadoop">安装hadoop</h1>
<p>hadoop有三种安装模式：</p>
<ul>
<li>单节点模式</li>
<li>伪分布式模式</li>
<li>分布式模式</li>
</ul>
<p>参考Linux Admin和Network SSH如何安装多台centos，并且配置局域网，让本地多台机器相互访问．</p>
<p>下载hadoop的二进制安装包，然后放到/home/hadoop/目录下并解压．</p>
<p>推荐的cluster node:</p>
<pre><code>NameNode(hdfs)
Secondary NameNode(hdfs)
DataNode(hdfs)
ResourceManager server(yarn)
NodeManager server(yarn)
WebAppProxy server(yarn)
MapReduceJobHistory server(mapreduce)
</code></pre>
<p>设置环境变量：</p>
<pre><code>$ vim ~/.bash_profile
export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-.../jre
export HADOOP_HOME=/home/hadoop/hadoop-3.0.0-alpha2
export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PATH
$ source ~/.bash_profile
</code></pre>
<p>修改hadoop的环境变量：</p>
<pre><code>$ cd hadoop-3.0.0-alpha2/etc/hadoop
$ vim hadoop-env.sh
export JAVA_HOME='/usr/lib/jvm/java-1.8.0-openjdk-.../jre

# 测试java和hadoop的环境是否可用：
$ hadoop
</code></pre>
<p>分布式环境搭建：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hadoop_hdfs/">Hadoop HDFS</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="hdfs">HDFS</h1>
<p>Hadoop Distributed File System: hadoop分布式文件系统</p>
<p>hadoop hdfs分为三部分:</p>
<p>NameNode -&gt; JobTracker</p>
<p>secondary NameNode</p>
<p>DataNode -&gt; TaskTracker</p>
<hr>
<h1 id="hdfs-commands">hdfs commands</h1>
<pre><code>hdfs [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]
</code></pre>
<p>user commands:</p>
<pre><code>$ hdfs classpath

$ hdfs dfs # 参考 hadoop fs命令
...
</code></pre>
<p>admin commands:</p>
<pre><code>$ hdfs balancer
...
</code></pre>
<p>debug commands:</p>
<pre><code>$ hdfs verify

$ hdfs recoverLease
</code></pre>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hadoop_yarn/">Hadoop YARN</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="yarn">YARN</h1>
<p>作业调度和集群资源管理的框架．</p>
<p>yarn的两个组件：</p>
<ul>
<li>resourcemanager</li>
<li>nodemanager</li>
</ul>
<hr>
<h1 id="yarn-commands">yarn commands</h1>
<pre><code>yarn [--config confdir] COMMAND [--loglevel loglevel] [GENERIC_OPTIONS] [COMMAND_OPTIONS]
</code></pre>
<p>user commands:</p>
<pre><code>$ yarn application
...
</code></pre>
<p>admin commands:</p>
<pre><code>$ yarn daemonlog
...
</code></pre>
<hr>
<h1 id="resource-manager">resource manager</h1>
<p>resource manager由两部分组成：</p>
<ul>
<li>scheduler</li>
<li>applicationmanager</li>
</ul>
<p>ResourceManager功能：</p>
<ul>
<li>处理客户请求</li>
<li>启动／监控applicationmaster</li>
<li>监控nodemanager</li>
<li>资源分配与调度</li>
</ul>
<p>ApplicationMaster功能：</p>
<ul>
<li>数据切分</li>
<li>为应用申请资源, 并分配给内部任务</li>
<li>任务监控与容错</li>
</ul>
<hr>
<h1 id="node-manager">node manager</h1>
<p>node manager功能：</p>
<ul>
<li>单个节点的资源管理</li>
<li>处理来自resourcemanager的命令</li>
</ul>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_package/">Package</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="package">Package</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/bigdata/">BigData</a></h2>
                <div class="post-meta">
                    <time>April 11, 2016</time>
                    
                        
                            <span class="category">BigData</span>
                        
                    
                </div>
                
                    <p><h1 id="bigdata">BigData</h1>
<p>大数据最流行的框架是hadoop.</p>
<p>大部分工具都属于Apache基金会的项目．</p>
<h1 id="mpp">MPP</h1>
<p>Massive Parallel Process</p>
<p>大规模并行处理数据库包括impala, hawq</p>
<hr>
<h1 id="分布式存储">分布式存储</h1>
<h2 id="hadoop-hdfs">hadoop hdfs</h2>
<hr>
<h1 id="资源调度">资源调度</h1>
<h2 id="hadoop-yarn">hadoop yarn</h2>
<hr>
<h1 id="分布式计算框架">分布式计算框架</h1>
<h2 id="hadoop-mapreduce">hadoop mapreduce</h2>
<h2 id="spark">Spark</h2>
<h1 id="流式计算框架">流式计算框架</h1>
<h2 id="storm">Storm</h2>
<h2 id="flink">Flink</h2>
<hr>
<h1 id="部署工具">部署工具</h1>
<h2 id="ambari">Ambari</h2>
<p>用于配置，管理，监控hadoop集群的web工具．</p>
<h2 id="bigtop">Bigtop</h2>
<p>对hadoop相关软件打包，分发，测试的工具．</p>
<h2 id="whirr">whirr</h2>
<h2 id="cloudera-hue">Cloudera Hue</h2>
<h2 id="hortonworks-hoya">Hortonworks hoya</h2>
<h1 id="服务编程">服务编程</h1>
<h2 id="zookeeper">Zookeeper</h2>
<p>分布式应用程序的高性能协调服务</p>
<h2 id="curator">Curator</h2>
<h2 id="avro">Avro</h2>
<h2 id="chuckwa">chuckwa</h2>
<p>用于监控大型分布式系统的数据收集系统．</p>
<hr>
<h1 id="交互式分析框架sql-on-hadoop">交互式分析框架(Sql On Hadoop)</h1>
<h2 id="facebook-presto">Facebook Presto</h2>
<h2 id="hive">Hive</h2>
<h2 id="hawqpivotal">Hawq(Pivotal)</h2>
<p>Hortonworks的HDP集成了HAWQ.</p>
<h2 id="impalacloudera">Impala(Cloudera)</h2>
<p>Cloudera的CHD集成了Impala.</p>
<h1 id="交互式分析框架nosql-on-hadoop">交互式分析框架(NoSQL On Hadoop)</h1>
<h2 id="hbase">HBase</h2>
<h2 id="cassandra">Cassandra</h2>
<hr>
<h1 id="数据管理工具">数据管理工具</h1>
<h2 id="sqoop">Sqoop</h2>
<h2 id="flume">Flume</h2>
<h1 id="消息队列">消息队列</h1>
<h2 id="kafka">Kafka</h2>
<h2 id="pivotal-rabbitmq">Pivotal RabbitMQ</h2>
<hr>
<h1 id="dsl">DSL</h1>
<h2 id="pig">Pig</h2>
<hr>
<h1 id="workflow-and-lifecycle">Workflow and Lifecycle</h1>
<h2 id="oozie">Oozie</h2>
<h2 id="aurora">aurora</h2>
<h2 id="falcon">falcon</h2>
<hr>
<h1 id="security">Security</h1>
<h2 id="sentry">Sentry</h2>
<hr>
<h1 id="data-search">Data search</h1>
<h2 id="solr">Solr</h2>
<h2 id="nutch">Nutch</h2>
<h2 id="lucene">Lucene</h2>
<hr>
<h1 id="data-analytics">Data Analytics</h1>
<h2 id="mahout">Mahout</h2>
<h2 id="kuducloudera">Kudu(Cloudera)</h2>
<hr>
<h1 id="misc">Misc</h1>
<h2 id="hama">hama</h2>
<h2 id="giraph">giraph</h2>
<h2 id="crunch">crunch</h2>
<h2 id="hcatalog">hcatalog</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/travel_france/">France</a></h2>
                <div class="post-meta">
                    <time>April 10, 2016</time>
                    
                        
                            <span class="category">Misc</span>
                        
                    
                </div>
                
                    <p><h1 id="法国之旅">法国之旅</h1>
<p>看照片：</p>
<p><a href="http://user.qzone.qq.com/1085694641">http://user.qzone.qq.com/1085694641</a></p>
<p>戴高乐机场</p>
<p>雅高集团的宜必思酒店</p>
<p>SNCF的TVG火车</p>
<p>法国有22个大区。</p>
<h1 id="法兰西岛">法兰西岛</h1>
<h2 id="巴黎省">巴黎省</h2>
<p>巴黎是法国首都，大区首府和该省省会。</p>
<p>埃菲尔铁塔</p>
<p>凯旋门</p>
<p>塞纳河</p>
<p>卢浮宫</p>
<p>巴黎圣母院</p>
<h2 id="伊夫林省">伊夫林省</h2>
<p>凡尔赛是该省省会。</p>
<p>著名景点凡尔赛宫。</p>
<h2 id="塞纳-马恩省">塞纳-马恩省</h2>
<p>著名景点枫丹白露。</p>
<h1 id="弗朗什-孔泰">弗朗什-孔泰</h1>
<h2 id="杜省">杜省</h2>
<p>贝桑松是大区首府和省会。</p>
<p>蒙贝利亚尔是杜省的一个区。</p>
<h2 id="贝尔福地区">贝尔福地区</h2>
<p>贝尔福是省会驻地,与瑞士相邻。</p>
<p>景点有贝尔福雄狮。</p>
<p>Eurockéennes法国最大的摇滚音乐节。</p>
<h1 id="阿尔萨斯">阿尔萨斯</h1>
<p>斯特拉斯堡是省会。</p>
<h2 id="下莱茵省">下莱茵省</h2>
<p>斯特拉斯堡是大区首府和省会。</p>
<h2 id="上莱茵省">上莱茵省</h2>
<p>科尔马是该省的首府,是童话小镇。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/mssql/">MSSql</a></h2>
                <div class="post-meta">
                    <time>April 6, 2016</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="mssql">MSSQL</h1>
<p>商业版：</p>
<ol>
<li>企业版</li>
<li>商业智能版</li>
<li>标准版</li>
</ol>
<p>免费版：</p>
<ol>
<li>Express</li>
<li>Developer</li>
<li>Compact</li>
<li>Web</li>
<li>SQL Azure</li>
</ol>
<p>system databases:</p>
<ol>
<li>master 主数据库</li>
<li>model  模板数据库</li>
<li>msdb   自动机数据库</li>
<li>tempdb 零时交换数据库,不需要备份,挂载到独立的子系统。</li>
<li>resource</li>
</ol>
<p>default port：1433</p>
<p>2008: max instance 16</p>
<p>2012: max instance 256</p>
<p>Client -&gt; SNAC(OLE DB/ODBC) -&gt; Network Libraries -&gt; TDS &lt;=&gt; Server -&gt; Endpoints -&gt; SQL OS(relational engine/storage engine)</p>
<h2 id="gui">GUI</h2>
<ul>
<li>
<p>SSMS</p>
<p>SQL Server Management Studio是mssql的图形化管理界面。</p>
<p>从模板中获取常用的SQL：</p>
<p>view -&gt; template explorer + query -&gt; specify values for template parameters.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/cloud_computing/">CloudComputing</a></h2>
                <div class="post-meta">
                    <time>April 5, 2016</time>
                    
                        
                            <span class="category">Cloud</span>
                        
                    
                </div>
                
                    <p><h1 id="cloudcomputing">CloudComputing</h1>
<p>IAAS: Infrastructure as a service</p>
<p>PAAS: Platform as a service</p>
<p>SAAS: Software as a service</p>
<h1 id="serverless">Serverless</h1>
<p>Faas: Function as a service.</p>
<p>Baas: Backend as a service.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/esxi/">Esxi</a></h2>
                <div class="post-meta">
                    <time>April 5, 2016</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="vmware">VMware</h1>
<p>vSphere是vmware的虚拟化平台,包括ESXi和vSphere Client.</p>
<p>vSphere Hypervisor(也叫ESXi)是vSphere的免费裸机hypervisor. 把物理机虚拟出多个虚拟机．</p>
<p>vSphere client是vSphere的简单管理工具．只能管理一台ESXi物理机和上面的虚拟机．</p>
<p>vCenter Server是vSphere的高级管理系统．需单独购买．</p>
<hr>
<h1 id="配置管理">配置管理</h1>
<p>开启虚拟机copy/paste功能：</p>
<pre><code># 通过vsphere client
edit properties -&gt; Options -&gt; Advanced -&gt; General -&gt; configuration Parameters
# isolation.tools.copy.disable    false
# isolation.tools.paste.disable    false
</code></pre>
<p>开启虚拟机的虚拟化功能：</p>
<pre><code># 通过ssh到esxi服务器
$ vim /vmfs/volumes/datastore1/Ubuntu1604/Ubuntu1604.vmx
vhv.enable = &quot;TRUE&quot; # 添加到最后一行
</code></pre>
<p>创建的vm命名不能带小数点.</p>
<hr>
<h1 id="命令">命令</h1>
<p>vim-cmd:</p>
<pre><code>vim-cmd vmsvc/getallvms # 获取所有虚拟机
vim-cmd vmsvc/reload
vim-cmd vmsvc/power.on vmid
vim-cmd vmsvc/power.shutdown vimid
vim-cmd vmsvc/power.off vimid
vim-cmd vmsvc/power.reboot vimid

# power on all vms
for vm in `vim-cmd vmsvc/getallvms | awk '{if (NR&gt;1) {print $1}}'`;
do
    echo &quot;power on ${vm}...&quot;;
    vim-cmd vmsvc/power.on ${vm}
done
</code></pre>
<p>esxcli:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/virtualization/">Virtualization</a></h2>
                <div class="post-meta">
                    <time>April 5, 2016</time>
                    
                        
                            <span class="category">Virtualization</span>
                        
                    
                </div>
                
                    <p><h1 id="virtualization">Virtualization</h1>
<p>虚拟化技术的发展：</p>
<ol>
<li>
<p>DataCenter, 最原始的数据中心</p>
</li>
<li>
<p>Virtualization, 虚拟化技术，包括Kvm, Xen(Citrix), HyperV(MicroSoft), ESXi(VMware)等</p>
</li>
</ol>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/network_monitoring/">Monitoring</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="monitoring">Monitoring</h1>
<p>network usage:</p>
<pre><code>bytes_sent(out)
bytes_recv(in)
</code></pre>
<p>packets:</p>
<pre><code>packets_sent(out)
packets_recv(in)
</code></pre>
<p>error_in/out:</p>
<pre><code>SELECT non_negative_derivative(mean(&quot;err_in&quot;), 1s) AS &quot;recv&quot;, non_negative_derivative(mean(&quot;err_out&quot;), 1s) AS &quot;send&quot;
FROM &quot;net&quot;
WHERE &quot;interface&quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter
GROUP BY time($__interval), &quot;host&quot;, &quot;interface&quot; fill(none)
</code></pre>
<p>drop_in/out:</p>
<pre><code>SELECT non_negative_derivative(mean(&quot;drop_in&quot;), 1s) AS &quot;recv&quot;, non_negative_derivative(mean(&quot;drop_out&quot;), 1s) AS &quot;send&quot;
FROM &quot;net&quot;
WHERE &quot;interface&quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter
GROUP BY time($__interval), &quot;host&quot;, &quot;interface&quot; fill(none)
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/network/">Network</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="网络基础">网络基础</h1>
<p>小端： 低字节在起始地址，高字节在高地址</p>
<p>大端： 高字节在起始地址，低字节在高地址</p>
<p>linux一般是小端，unix一般是大端</p>
<p><a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a></p>
<hr>
<h2 id="网络模型">网络模型</h2>
<p>OSI七层模型:</p>
<ul>
<li>
<p>应用层</p>
</li>
<li>
<p>表示层</p>
</li>
<li>
<p>会话层</p>
</li>
<li>
<p>传输层</p>
</li>
<li>
<p>网络层</p>
</li>
<li>
<p>链路层</p>
</li>
<li>
<p>物理层</p>
</li>
</ul>
<p>TCP/IP四层模型：</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
</ul>
<h3 id="应用层">应用层</h3>
<p>0-1024是系统保留端口, 1024-65535是可用自定义端口</p>
<p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p>
<p>8443:  tcp/udp - https port
9443: tcp/udp tungsten-https
4443: tcp/udp pharos</p>
<p>基于TCP的应用层</p>
<pre><code>FTP: 21,
SSH: 22,
Telnet: 23,
SMTP: 25,
DNS: 53,
HTTP: 80,
HTTPS: 443,
POP3: 110,
POP3 SSL: 995
IMAP: 143,
IMAP SSL: 993,
NNTP: 119,
NNTP SSL: 563,
</code></pre>
<p>基于UDP的应用层</p>
<pre><code>SMTP: 25,
DNS: 53,
DHCP: 67,
TFTP：69,简单文件传输协议。
NTP/SNTP: 123,
SNMP：161,简单网络管理协议。
SNMPtrap: 162,
</code></pre>
<p>查看端口</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/samba/">Samba</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Network</span>
                        
                    
                </div>
                
                    <p><h1 id="smbcifs">SMB/CIFS</h1>
<p>SMB/CIFS占用TCP和UDP的139和445端口。</p>
<p>SMB: server message block.</p>
<p>CIFS: common internet file system, 是SMB的升级版本。</p>
<h1 id="samba">Samba</h1>
<p>Samba: Linux/Unix上的SBM/CIFS,用于跨平台的共享。</p>
<p>安装:</p>
<pre><code>$ sudo apt-get insall samba
</code></pre>
<p>配置：</p>
<pre><code>$ vim /etc/samba/smb.conf
[shared]
comment = share this folder
path = /home/canux/Share
public = yes
guest ok = yes
browsable = yes
writable = no
read only = yes
</code></pre>
<p>重启：</p>
<pre><code>$ sudo service smbd restart
</code></pre>
<p>windows访问：</p>
<pre><code>\\ip\folder
</code></pre>
<p>linux访问：</p>
<pre><code>connect to server -&gt; smb://ip/folder
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/postgre/">Postgresql</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Database</span>
                        
                    
                </div>
                
                    <p><h1 id="postgresql">PostgreSQL</h1>
<p>安装postgresql：</p>
<pre><code>$ sudo apt-get install postgresql
</code></pre>
<p>安装第三方库：</p>
<pre><code>$ sudo apt-get install postgresql-contrib-9.3 libpg-dev postgresql-server-dev-9.3
</code></pre>
<p>GUI工具： pgAdminIII</p>
<p>CLI工具： psql</p>
<p>postgresql的端口是5432．</p>
<h1 id="postgresql命令">postgresql命令</h1>
<p>安装完成后默认的admin就是postgres, postgres里有默认数据库postgres.</p>
<pre><code>$passwd postgres # 修改默认管理员用户postgres的密码
$su - postgres # 切换到默认的postgres用户

$ psql [OPTION]... [DBNAME [USERNAME]]

$createuser &lt;username&gt; -P # 在命令行添加用户
$dropuser &lt;username&gt; # 在命令行删除用户

$createdb &lt;database&gt; -O &lt;username&gt; # 在命令行添加数据库
$dropdb &lt;database&gt; # 在命令行删除数据库

# 交互式:
$ psql -U [username] [database]

# 非交互式：
$ PGPASSWORD='password';psql -h &lt;host&gt; -p &lt;port&gt; -U &lt;username&gt; -d [database] -c &quot;[psql command]&quot;
</code></pre>
<p>导出数据：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win_wmi/">WMI</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="wmicim">WMI/CIM</h1>
<p>WMI: windows management instrumentation.</p>
<p><a href="https://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx</a></p>
<p>CIM: common information model.</p>
<p><a href="https://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx</a></p>
<p>DCOM: distributed COM.</p>
<p>wmi通过DCOM远程连接，但是DCOM不能绕过防火墙。</p>
<p>命名空间:</p>
<pre><code>root\cimv2
root\microsoftdns
root\securitycenter
</code></pre>
<p>WMI工具：</p>
<ol>
<li>windows自带wmi测试工具wbemtest.</li>
<li>WMI Explorer用于查找wmi和cim的Class和Properties.</li>
</ol>
<p><a href="http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq">http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq</a></p>
<p>windows怎样设置wmi：</p>
<p>135 (Microsoft RPC), 137-139 (NetBIOS) and 445 (Microsoft DS). These are TCP ports.</p>
<p>设置的用户需要是管理员组。</p>
<p><a href="https://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx">https://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx</a></p>
<p>给wmi设置fix port(server in DMZ)：</p>
<p>使用过程中不需要指定端口。</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx">https://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx</a></p>
<h1 id="wmic">wmic</h1>
<p>wmic是wmi的客户端命令。</p>
<p>windows的wmic：</p>
<pre><code>&gt;wmic # 进入wmi的交互模式
&gt;wmic -? # 查看帮助
&gt;wmic /? # 查看帮助
&gt;wmic ... # 非交互模式运行命令
&gt;wmic process call create shutdown.exe # 本地关机
</code></pre>
<p>linux的wmic：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win_filesystem/">FileSystem</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win_monitoring/">Monitoring</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="windows的services和process">windows的services和process</h1>
<p>services是windows的服务，有Name(Display Name)，Service Name，Description等属性。</p>
<p>process是以.exe为后缀的application，有Name(product name)、original filename(Image Name)、file description(description)等属性。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/win/">Windows</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="windows的ide">windows的IDE</h1>
<p>VS Enterprise: 收费企业版
VS Professional: 收费个人版
VS Community: 免费社区版</p>
<p>windows的引导程序是ntloader。</p>
<p>DOS和NT是windows系统的内核。</p>
<p>BIOS和MBR基本输入输出系统和主引导记录。</p>
<p>UEFI和GPT是统一的可扩展接口和GUID分区表。</p>
<p>FAT是msdos的文件系统</p>
<p>NTFS是msnt的文件系统</p>
<hr>
<h1 id="ad">AD</h1>
<p>AD: Active Directory</p>
<p>管理工具：LDAPSoft AD Browser</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/python_devops/">DevOps</a></h2>
                <div class="post-meta">
                    <time>April 3, 2016</time>
                    
                        
                            <span class="category">Python</span>
                        
                    
                </div>
                
                    <p><h1 id="python">Python</h1>
<p>python2的最后一个版本是python2.7, 2020年停止更新.</p>
<p>Windows安装：</p>
<pre><code>Python2.7.9之后的版本直接下载msi安装即可．
选择自动设置PATH，默认安装pip和setuptools.
可以使用IDLE或python命令行或cmd执行python命令
</code></pre>
<p>Linux安装：</p>
<pre><code>$sudo apt-get install python
$sudo yum install python

$sudo apt-get install python-dev
$sudo apt-get install python3-dev
$sudo yum install python-devel
</code></pre>
<p>标准库的路径：</p>
<pre><code>C:\Python*\Lib
/usr/lib/python*/
</code></pre>
<p>python的IDE：</p>
<ol>
<li>Windows: IDLE</li>
<li>Linux: Vim</li>
<li>Pycharm/VS</li>
</ol>
<hr>
<h1 id="python命令">python命令</h1>
<pre><code>$ python/ipython     # 进入python解释器
&gt;&gt;&gt;exit()/Ctrl+d     # 退出python解释器
&gt;&gt;&gt;help()            # 进入help工具
help&gt;quit            # 退出help工具
$ pydoc --help        # 文档工具

# -c　cmd, __name__ != '__main__'
$ python -c 'import module/package; expressions'
# -m mod, __name__ == '__main__'
$ python -m 'module/package'
</code></pre>
<hr>
<h1 id="python的可用接口">python的可用接口</h1>
<ol>
<li>
<p>python内置常量，函数，类和异常．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_git/">Git</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="git">Git</h1>
<p>GIT: 分布式版本控制系统。</p>
<p>SVN: subversion并发式版本控制系统。</p>
<p>Mercurial: hg分布式版本控制。</p>
<p>和git相关的产品：</p>
<ol>
<li>github</li>
<li>bitbucket</li>
<li>sourceForge</li>
<li>gitlab</li>
</ol>
<p>Git安装：</p>
<pre><code>$ sudo apt-get install git
$ yum install git
</code></pre>
<h1 id="git-config-git配置">git config (Git配置)</h1>
<p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<p>git配置文件：</p>
<ol>
<li>/etc/gitconfig 系统级的配置文件，通过git config &ndash;system设置</li>
<li>~/.gitconfig 用户级的配置文件，通过git config &ndash;global设置</li>
<li>.git/config 仓库级的配置文件，通过git config &ndash;local设置</li>
</ol>
<p>git配置：</p>
<p>使用git config &ndash;global命令配置,或者直接修改~/.gitconfig文件。</p>
<pre><code># 查看帮助
git help config
man git-config
git config --help
git config -l/--list # 查看所有配置
git config --system
git config --global
git config --local
git config --global user.name &quot;your_name&quot;
git config --global user.email &quot;your_email&quot;
git config --global core.editor vim
</code></pre>
<p>多配置文件：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/devops_vim/">Vim</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="vim">vim</h1>
<p><a href="http://www.vim.org">http://www.vim.org</a></p>
<p><a href="https://github.com/vim/vim">https://github.com/vim/vim</a></p>
<p>类似编辑器:</p>
<ul>
<li>emacs</li>
<li>Atom(github的开源跨平台编辑器，支持插件。)</li>
<li>VSCode(微软的开源跨平台的编辑器，支持插件。)</li>
</ul>
<h1 id="vim安装和配置">Vim安装和配置</h1>
<p>查看vim版本和编译信息：</p>
<pre><code>vim --version
</code></pre>
<p>安装vim：</p>
<pre><code>$ sudo apt-get install vim
$ yum install vim
</code></pre>
<p>源码安装vim：</p>
<pre><code>$ sudo apt-get build-dep vim
$ cd vim/src

$ ./configure \
--with-features=huge \
--with-compiledby=&quot;Canux&quot; \
--enable-multibyte \
--enable-gui=gtk2 \
--enable-gpm \
--prefix=/usr \
--enable-cscope \
--enable-fontset \
--enable-xim \
--enable-fail-if-missing \
--enable-mzschemeinterp \
--enable-perlinterp \
--enable-luainterp \
--enable-tclinterp\
--enable-rubyinterp \
--enable-pythoninterp \
--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \
--enable-python3interp \
--with-python3-config-dir=/usr/lib/python3.4/config-3.4m-x86_64-linux-gnu

$ make VIMRUNTIMEDIR=/usr/share/vim/vim74
$ sudo make install
</code></pre>
<hr>
<h1 id="vim相关项目">Vim相关项目</h1>
<h2 id="neovim">neovim</h2>
<p><a href="https://github.com/neovim/neovim">https://github.com/neovim/neovim</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_summary/">Summary</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="c标准">C标准</h1>
<p>ISO C89(ANSI C89) -&gt; ISO C99 -&gt; ISO C11</p>
<p>ANSI C 和 ISO C是对通用C语言的接口的定义。</p>
<p>符合这种标准的实现为C语言标准库,也叫libc。</p>
<p>Unix/Linux的POSIX包含libc。</p>
<p>Linux的glibc包含libc及其扩展.</p>
<p>Windows的msvcrt包含libc及其扩展.</p>
<p>其它和C相关的标准：</p>
<p>BSD</p>
<p>System V</p>
<p>XPG</p>
<p>SUS</p>
<h1 id="glibc">glibc</h1>
<p>Linux的标准C库glibc</p>
<p>遵循ISO C11 和 POSIX.1-2008, 还包括一些其它标准。</p>
<p>关于ISO C 和 POSIX参考另外两篇博文。</p>
<h1 id="msvcrt">msvcrt</h1>
<p>windows的标准c库msvcrt.</p>
<hr>
<h1 id="c注释">C注释</h1>
<p>单行注释：</p>
<pre><code>// comment

/* comment */
</code></pre>
<p>多行注释：</p>
<pre><code>/*
 * comment1
 * commenet2
 */
</code></pre>
<h1 id="文档">文档</h1>
<p>C程序可以用doxygen从程序中提取文档。</p>
<p>文档注释：</p>
<pre><code>/**
 * @file
 * @brief
 * @author
 * @date
 * @version
 * @copyright
 */
</code></pre>
<h1 id="编译和链接">编译和链接</h1>
<p>编译只检查语法错误和函数以及变量是否申明．将*.c源文件编译成*.o目标文件．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_posix/">Posix</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="posix标准">POSIX标准</h1>
<p>Portable Operating System Interface</p>
<p>可移植性操作系统接口, POSIX兼容ISO C。</p>
<p>所有Unix都遵循，几乎所有Linux都遵循，Windows部分支持。</p>
<p>POSIX.1/IEEE 1003.1-1990</p>
<p>POSIX.2/IEEE Std 1003.2-1992/ISO IEC 9945-2:1993)</p>
<p>POSIX.1.b/IEEE Std 1003.1b-1993/ISO IEC 9945-1:1996)</p>
<p>POSIX.1.c/IEEE Std 1003.1c-1995</p>
<p>POSIX.1.d/IEEE  Std  1003.1c-1999</p>
<p>POSIX.1.g/IEEE Std 1003.1g-2000</p>
<p>POSIX.1.j/IEEE  Std  1003.1j-2000</p>
<p>POSIX.1-2001/SUSv3(包括了所有C99的API)</p>
<p>POSIX.1-2008/SUSv4</p>
<p>官方网站：</p>
<p><a href="http://www.opengroup.org/austin/">http://www.opengroup.org/austin/</a></p>
<h1 id="cygwin">Cygwin</h1>
<p>提供POSIX的API用于windows上开发Linux/Unix程序。</p>
<p>源代码不能在windows运行。</p>
<p><a href="https://cygwin.com/index.html">https://cygwin.com/index.html</a></p>
<hr>
<h1 id="posix标准定义的必须头文件">POSIX标准定义的必须头文件</h1>
<h2 id="direnth">&lt;dirent.h&gt;</h2>
<h2 id="fcntlh">&lt;fcntl.h&gt;</h2>
<h2 id="globh">&lt;glob.h&gt;</h2>
<h2 id="netdbh">&lt;netdb.h&gt;</h2>
<h2 id="pwdh">&lt;pwd.h&gt;</h2>
<h2 id="regexh">&lt;regex.h&gt;</h2>
<h2 id="tarh">&lt;tar.h&gt;</h2>
<h2 id="termiosh">&lt;termios.h&gt;</h2>
<h2 id="unistdh">&lt;unistd.h&gt;</h2>
<h2 id="utimeh">&lt;utime.h&gt;</h2>
<h2 id="utimeh-1">&lt;utime.h&gt;</h2>
<h2 id="wordexph">&lt;wordexp.h&gt;</h2>
<h2 id="arpaineth">&lt;arpa/inet.h&gt;</h2>
<h2 id="netifh">&lt;net/if.h&gt;</h2>
<h2 id="netinetinh">&lt;netinet/in.h&gt;</h2>
<h2 id="netinettcph">&lt;netinet/tcp.h&gt;</h2>
<h2 id="sysmmanh">&lt;sys/mman.h&gt;</h2>
<h2 id="sysselecth">&lt;sys/select.h&gt;</h2>
<h2 id="syssocketh">&lt;sys/socket.h&gt;</h2>
<h2 id="sysstath">&lt;sys/stat.h&gt;</h2>
<h2 id="systimesh">&lt;sys/times.h&gt;</h2>
<h2 id="systypesh">&lt;sys/types.h&gt;</h2>
<h2 id="sysunh">&lt;sys/un.h&gt;</h2>
<h2 id="sysutsnameh">&lt;sys/utsname.h&gt;</h2>
<h2 id="waith">&lt;wait.h&gt;</h2>
<hr>
<h1 id="posix标准定义的可选头文件">POSIX标准定义的可选头文件</h1>
<h2 id="aioh">&lt;aio.h&gt;</h2>
<h2 id="pthreadh">&lt;pthread.h&gt;</h2>
<h2 id="semaphoreh">&lt;semaphore.h&gt;</h2>
<h2 id="mqueueh">&lt;mqueue.h&gt;</h2>
<h2 id="schedh">&lt;sched.h&gt;</h2>
<h2 id="spawnh">&lt;spawn.h&gt;</h2>
<h2 id="stropsh">&lt;strops.h&gt;</h2>
<h2 id="traceh">&lt;trace.h&gt;</h2>
<hr>
<h1 id="posix标准定义的xsi扩展头文件">POSIX标准定义的XSI扩展头文件</h1>
<h2 id="sysipch">&lt;sys/ipc.h&gt;</h2>
<h2 id="sysmsgh">&lt;sys/msg.h&gt;</h2>
<h2 id="syssemh">&lt;sys/sem.h&gt;</h2>
<h2 id="sysshmh">&lt;sys/shm.h&gt;</h2>
<h2 id="cpioh">&lt;cpio.h&gt;</h2>
<h2 id="dlfcnh">&lt;dlfcn.h&gt;</h2>
<h2 id="fmtmsgh">&lt;fmtmsg.h&gt;</h2>
<h2 id="ftwh">&lt;ftw.h&gt;</h2>
<h2 id="iconvh">&lt;iconv.h&gt;</h2>
<h2 id="langinfoh">&lt;langinfo.h&gt;</h2>
<h2 id="libgenh">&lt;libgen.h&gt;</h2>
<h2 id="monetaryh">&lt;monetary.h&gt;</h2>
<h2 id="ndbmh">&lt;ndbm.h&gt;</h2>
<h2 id="nl_typesh">&lt;nl_types.h&gt;</h2>
<h2 id="pollh">&lt;poll.h&gt;</h2>
<h2 id="searchh">&lt;search.h&gt;</h2>
<h2 id="stringsh">&lt;strings.h&gt;</h2>
<h2 id="syslogh">&lt;syslog.h&gt;</h2>
<h2 id="ucontexth">&lt;ucontext.h&gt;</h2>
<h2 id="ulimith">&lt;ulimit.h&gt;</h2>
<h2 id="utmpxh">&lt;utmpx.h&gt;</h2>
<h2 id="sysresourceh">&lt;sys/resource.h&gt;</h2>
<h2 id="sysstatvfsh">&lt;sys/statvfs.h&gt;</h2>
<h2 id="systimeh">&lt;sys/time.h&gt;</h2>
<h2 id="systimebh">&lt;sys/timeb.h&gt;</h2>
<h2 id="sysuioh">&lt;sys/uio.h&gt;</h2></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/regularexpression/">Regular Expression</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                            <span class="category">Windows</span>
                        
                    
                </div>
                
                    <p><h1 id="re">RE</h1>
<p>在线检测：</p>
<p><a href="https://www.regexpal.com/">https://www.regexpal.com/</a></p>
<p>RE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).</p>
<p>在BRE中+?(){}|没有特殊含义，除非用\转义．</p>
<p>在ERE中+?(){}被保留有特殊含义，除非用\转义才表示普通字符．</p>
<p>命令find, grep, sed, awk等都可以使用正则表达式．</p>
<p>特殊字符含义：</p>
<pre><code>()      对正则表达式分组, ERE
\n      再匹配前面的分组n次

.       匹配任意单个字符, 换行符除外
^tux    匹配以tux开始的行
tux$    匹配以tux结束的行

*+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配
*           匹配前面一个字符0次或多次，包括前面这个字符本身
+           匹配前面一个字符1次或多次，包括前面这个字符, ERE
?           匹配前面一个字符0次或1次，包括前面这个字符, ERE
{n}         匹配前面一个字符n次，包括前面这个字符, ERE
{min,}      匹配前面一个字符至少min次，包括前面这个字符, ERE
{min,max}   匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE

下面是非贪婪匹配模式
*?    匹配0个或多个
+?    匹配1个或多个
??    匹配０个或１个
{n}?        只匹配n个
{min,}?     至少min个
{min,max}?  至少min个，最多max个

[abc]   匹配包含在[]中的任意一个字符，除了\, ^, -三个特殊字符
[^abc]  匹配不包含在[]中的任意一个字符(和上面相反)
[a-z]   匹配[]中指定范围内的任意一个字符
[abc\?] 用＼转义[]中的特殊字符

|       表示逻辑或, ERE

\       转义字符，将特殊字符转义成普通字符

小括号表示分组
(...)
(?...)
(?iLmsux)
(?:...)
(?P&lt;name&gt;...)
(?P=name)
(?#...)
(?=...)
(?!...)
(?&lt;=...)
(?&lt;!...)
(?(id/name)yes-pattern|no-pattern)
</code></pre>
<p>匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_sed/">Sed</a></h2>
                <div class="post-meta">
                    <time>April 2, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="sed">sed</h1>
<p>sed：stream editor  流编辑器 ，主要用于文本处理。</p>
<p>sed命令格式：</p>
<pre><code>sed   -options   ’expression1;expression2’     file           执行多个命令
sed   -options   [-e ‘expression1’] [-e ‘expression2’]  file  执行多个命令
sed   -options   [-f   scriptfile]   file                     通过脚本执行命令
sed   -options   [-f   scriptfile]   file  &gt;  newfile  #sed修改后重定向到新文件。
</code></pre>
<p>sed指令需要用单引号包围。使用双引号“”可以传递变量。
Sed默认并没有修改文件file中的数据。
sed默认在stdout输出文件的所有行。
Sed地址需要使用/address/来包围。
sed使用正则表达式可以用\BRE\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。</p>
<p>options：</p>
<pre><code>-e：指定多个命令或脚本
-f：指定执行命令的脚本
-n：阻止自动输出，p可以打印匹配的行。
-i: 直接修改读入的文件的内容.
</code></pre>
<p>experssion：</p>
<pre><code>expression：指令由模式和过程组成。
[address]/[line-address][!]command[arguments]
[address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。
[line-address]表示只能是一个地址。
[!] 表示不匹配该地址的所有行
</code></pre>
<p>Command:</p>
<p>sed有25个命令。</p>
<p>使用大括号{}在一个地址中做嵌套操作：例如：</p>
<pre><code>/address1/,/address2/{
    /^$/d
    s/string1/string2/
    …
}             // 单独一行，后面不能有空格
</code></pre>
<p>s命令：替换，替换模式空间中的行。</p>
<pre><code>sed '[address]s/oldpattern/newpattern/[flag]' filename
</code></pre>
<p>flag:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/c_iso/">ISO</a></h2>
                <div class="post-meta">
                    <time>April 1, 2016</time>
                    
                        
                            <span class="category">C</span>
                        
                    
                </div>
                
                    <p><h1 id="c标准库">C标准库</h1>
<p>ISO C89(ANSI C89) -&gt; ISO C95 -&gt; ISO C99 -&gt;</p>
<p>-&gt; ISO C11 -&gt; ISO C17 -&gt; ISO C23</p>
<p>ANSI C 和 ISO C是对通用C语言的接口的定义。</p>
<p>符合这种标准的实现为C语言标准库,也叫libc。</p>
<p>官方网站：</p>
<p><a href="http://www.open-std.org/jtc1/sc22/wg14/www/standards">http://www.open-std.org/jtc1/sc22/wg14/www/standards</a></p>
<hr>
<h1 id="c89和c99支持的头文件和函数">C89和C99支持的头文件和函数</h1>
<h2 id="asserth">&lt;assert.h&gt;</h2>
<h2 id="ctypeh">&lt;ctype.h&gt;</h2>
<h2 id="complexh">&lt;complex.h&gt;</h2>
<h2 id="errnoh">&lt;errno.h&gt;</h2>
<h2 id="floath">&lt;float.h&gt;</h2>
<h2 id="fenvh">&lt;fenv.h&gt;</h2>
<h2 id="inttypeh">&lt;inttype.h&gt;</h2>
<h2 id="iso646h">&lt;iso646.h&gt;</h2>
<h2 id="limitsh">&lt;limits.h&gt;</h2>
<h2 id="localeh">&lt;locale.h&gt;</h2>
<h2 id="mathh">&lt;math.h&gt;</h2>
<h2 id="setjmph">&lt;setjmp.h&gt;</h2>
<h2 id="signalh">&lt;signal.h&gt;</h2>
<h2 id="stdargh">&lt;stdarg.h&gt;</h2>
<h2 id="stddefh">&lt;stddef.h&gt;</h2>
<h2 id="stdioh">&lt;stdio.h&gt;</h2>
<h2 id="stdlibh">&lt;stdlib.h&gt;</h2>
<h2 id="stringh">&lt;string.h&gt;</h2>
<h2 id="stdboolh">&lt;stdbool.h&gt;</h2>
<h2 id="stdinth">&lt;stdint.h&gt;</h2>
<h2 id="timeh">&lt;time.h&gt;</h2>
<h2 id="tgmathh">&lt;tgmath.h&gt;</h2>
<h2 id="wcharh">&lt;wchar.h&gt;</h2>
<h2 id="wctypeh">&lt;wctype.h&gt;</h2>
<hr>
<h1 id="c11支持的头文件和函数">C11支持的头文件和函数</h1>
<h2 id="stdalignh">&lt;stdalign.h&gt;</h2>
<h2 id="stdatomich">&lt;stdatomic.h&gt;</h2>
<h2 id="threadsh">&lt;threads.h&gt;</h2>
<hr>
<h1 id="c标准">C++标准</h1>
<p>C++98, C++11, C++14, C++17, C++20, C++23</p>
<p>c++ 头文件不带.h用来和C区分。</p>
<h2 id="核心功能">核心功能</h2>
<p><a href="https://zh.cppreference.com/w/cpp/language">https://zh.cppreference.com/w/cpp/language</a></p>
<h2 id="标准库">标准库</h2>
<p><a href="https://zh.cppreference.com/w/cpp/standard_library">https://zh.cppreference.com/w/cpp/standard_library</a></p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell/">Shell</a></h2>
                <div class="post-meta">
                    <time>April 1, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="shell">Shell</h1>
<p>Linux的shell有很多种,大多数linux发行版的默认登录shell是BASH。</p>
<p>查看当前使用的shell：</p>
<pre><code>echo $SHELL
echo $0
</code></pre>
<p>查看安装了哪些shell：</p>
<pre><code>cat /etc/shells
</code></pre>
<p>设置登陆shell:</p>
<pre><code>$chsh -s $(which shellname)
</code></pre>
<p>shell分为登陆shell和交互式shell:</p>
<pre><code># 输出有i的就是交互shell
$echo $-
</code></pre>
<p>非交互登陆shell:</p>
<ul>
<li>先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh)</li>
<li>然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin)</li>
<li>最后退出用户登陆~/.bash_logout</li>
</ul>
<p>交互非登陆shell:</p>
<ul>
<li>先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh))</li>
<li>然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin)</li>
</ul>
<hr>
<h1 id="shell相关项目">shell相关项目</h1>
<h2 id="bash-it">bash-it</h2>
<p>大部分发行版默认使用bash,无需额外安装。</p>
<p>bash的优化项目bash-it：</p>
<p><a href="https://github.com/Bash-it/bash-it">https://github.com/Bash-it/bash-it</a></p>
<h2 id="zsh">zsh</h2>
<p><a href="http://www.zsh.org/">http://www.zsh.org/</a></p>
<h2 id="oh-my-zsh">oh-my-zsh</h2>
<p><a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p>
<h2 id="fish-shell">fish-shell</h2>
<p><a href="https://github.com/fish-shell/fish-shell">https://github.com/fish-shell/fish-shell</a></p>
<h2 id="oh-my-fish">oh-my-fish</h2>
<p><a href="https://github.com/oh-my-fish/oh-my-fish">https://github.com/oh-my-fish/oh-my-fish</a></p>
<h2 id="thefuck">thefuck</h2>
<p>一个纠正shell命令输错的命令</p>
<p><a href="https://github.com/nvbn/thefuck">https://github.com/nvbn/thefuck</a></p>
<h2 id="shellcheck">shellcheck</h2>
<p>一个debug脚本的工具．</p>
<p><a href="https://github.com/koalaman/shellcheck">https://github.com/koalaman/shellcheck</a></p>
<hr>
<h1 id="shell-script">shell script</h1>
<p>基本语法</p>
<pre><code>#!/usr/bin/env bash

command1 &amp;&amp; command2    # 当command1执行成功（返回0)才会执行command2
command1 || command2    # 当command1执行失败（返回非0)才会执行command2
</code></pre>
<h2 id="shell注释">shell注释</h2>
<p>单行注释：</p>
<pre><code># comment
</code></pre>
<p>多行注释：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_coreutils/">Coreutils</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux的外部命令">Linux的外部命令</h1>
<p>Linux外部命令的项目是coreutils。</p>
<p>外部命令在coreutils目录中</p>
<p>查看外部命令所在目录：</p>
<pre><code>echo $PATH
</code></pre>
<p>外部命令在下列目录中：</p>
<pre><code>~/bin # 用户自定义

/sbin

/bin

/usr/sbin

/usr/bin

/usr/local/sbin

/usr/local/bin

/usr/games

/usr/local/games
</code></pre>
<p>查看外部命令手册的在线手册：</p>
<pre><code>man [command]
info [command]
</code></pre>
<p>自定义外部命令：</p>
<p>添加$PATH变量，然后放到该目录。</p>
<hr>
<h1 id="系统管理">系统管理</h1>
<p>cpu/mem/load</p>
<pre><code># 查看cpu/mem/swap/system信息
vmstat
vmstat 1

# 查看进程消耗的cpu/mem/swap/system等系统信息
top
top -H  # 查看线程
%cpu = cputime/realtime * 100%
cpu_usage = %cpu/cpu-number
%mem = RES/physicalMem * 100%

htop
$ sudo apt-get install htop

$ sudo apt-get install sysstat (包括pidstat)
pidstat -u -p pid // cpu
pidstat -r -p pid //mem
</code></pre>
<p>cpu/load:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_utils/">Utils</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux的第三方命令">Linux的第三方命令</h1>
<p>Linux外部命令的项目是coreutils.</p>
<p>外部命令在coreutils目录中.</p>
<p>第三方命令(相当于外部命令)．</p>
<hr>
<h1 id="文件和目录管理">文件和目录管理</h1>
<p>autojump:</p>
<p><a href="https://github.com/wting/autojump">https://github.com/wting/autojump</a></p>
<p>fasd:</p>
<p><a href="https://github.com/clvv/fasd">https://github.com/clvv/fasd</a></p>
<p>fzf:</p>
<p><a href="https://github.com/junegunn/fzf">https://github.com/junegunn/fzf</a></p>
<h1 id="压缩备份">压缩备份</h1>
<h1 id="磁盘管理">磁盘管理</h1>
<h1 id="设备管理">设备管理</h1>
<hr></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/shell_builtins/">Builtins</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux内置命令">Linux内置命令</h1>
<p>内置命令在bash/builtins目录中</p>
<p>shell命令分为内置命令和外部命令.</p>
<p>查看一个命令是内置命令还是外部命令：</p>
<pre><code>type -a [command]

提示&quot;[command] is a shell builtin&quot;就表示是内置命令，否则就是外部命令。
</code></pre>
<p>查看所有内置命令：</p>
<pre><code>help
enable -a
</code></pre>
<p>查看内置命令的帮助：</p>
<pre><code>help [command]
</code></pre>
<hr>
<pre><code>type
enable
help

caller
alias
bg
bind
break
builtin
command
compgen
complete
compopt
continue
declare
disown
let
local
logout
mapfile
popd
printf
pushd
read
readarray
readonly
return
shift
shopt
source
suspend
times
trap
true
typeset
ulimit
umask
unalias
unset
wait
eval
exec
exit
export
false
fc
fg
getopts
hash
history
jobs
</code></pre>
<p>路径相关:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_filesystem/">FileSystem</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="vfs">VFS</h1>
<p>Linux采用虚拟文件系统，支持多个文件系统协议．</p>
<hr>
<h1 id="extext2ext3ext4">ext/ext2/ext3/ext4</h1>
<h1 id="jfs2">JFS2</h1>
<h1 id="ramfs">ramfs</h1>
<p>linux的VM(虚拟内存)包括ramfs和swap.</p>
<p>对内存的支持</p>
<h1 id="swap">swap</h1>
<p>交换分区，当内存不足，会把内存上暂时不运行的程序保存到swap，获取部分内存空间运行．</p>
<h1 id="tmpfs">tmpfs</h1>
<p>临时文件系统, 优先使用ramfs,　其次使用swap.</p>
<pre><code># 挂载tmpfs
mount -t tmpfs -o size=1024m tmpfs /path/to/mount
# /etc/fstab　
tmpfs /dev/shm tmpfs,defaults,size=512m 0 0
</code></pre>
<h1 id="vfatfatntfs">vfat/fat/ntfs</h1>
<p>windows文件系统</p>
<h1 id="cifssmbfs">cifs/smbfs</h1>
<h1 id="nfs">nfs</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_firewall/">Firewall</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                            <span class="category">Security</span>
                        
                    
                </div>
                
                    <p><h1 id="firewall">Firewall</h1>
<p>UFW: linux防火墙配置工具，底层还是调用iptables.</p>
<p>filewall: centos的防火墙命令, 底层还是调用iptables.</p>
<hr>
<h1 id="selinux">SELinux</h1>
<p>Security-Enhanced-Linux</p>
<p>本地安全</p>
<hr>
<h1 id="netfilter">Netfilter</h1>
<p>网络安全</p>
<hr>
<h1 id="iptables">iptables</h1>
<p>通过iptables操作Netfilter实现应用层安全.</p>
<p>table:</p>
<pre><code>filter 默认表
nat
mangle
raw
security
</code></pre>
<h2 id="filter">filter</h2>
<p>chain:</p>
<pre><code>INPUT
FORWARD
OUTPUT
</code></pre>
<h2 id="nat">nat</h2>
<p>chain:</p>
<pre><code>INPUT
OUTPUT
PREROUTING
POSTROUTING
</code></pre>
<p>postrouting:</p>
<pre><code>snat: 内网主机访问外网经过路由时，源ip会发生变化。
</code></pre>
<p>prerouting:</p>
<pre><code>dnat:  外网访问内网经过路由时，目的ip会发生变化。
</code></pre>
<h2 id="iptables命令">iptables命令</h2>
<pre><code>-L/--list  [chain [ rulenum]]
-S/--list-rules [chain [rulenum]]
-Z/--zero [chain [rulenum]]

-A/--append chain
-C/--check chain
-N/--new chain

-F/--flush [chain] // 删除chain中的rules.
-X/--delete-chain [chain] // 删除自定义chain.

-R/--replace chain rulenum
-D/--delete chain [rulenum]
-I/--insert chain [rulenum]

-P/--policy chain target

-E/--rename-chain old-chain new-chain
</code></pre>
<p>tables:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_grub/">Grub</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="grub">Grub</h1>
<p>引导程序。</p>
<p>linux/unix的引导程序有lilo和grub。</p>
<h1 id="配置">配置</h1>
<p>修改grub:</p>
<pre><code>$ sudo vim /boot/grub/grub.cfg
</code></pre></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux/">Linux</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="linux">Linux</h1>
<p>Linux严格讲指的是Linux这一类操作系统的内核。</p>
<p>Linux内核的github：</p>
<p><a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux</a></p>
<p>Linux内核的站点：</p>
<p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<p>商业化的linux系统：</p>
<ol>
<li>redhat enterprise linux</li>
<li>suse enterprise linux</li>
</ol>
<p>免费的服务器版本：</p>
<ol>
<li>centos (rhel的免费版服务器版)</li>
<li>open suse</li>
<li>debian/ubuntu</li>
</ol>
<p>免费的桌面版本：</p>
<ol>
<li>fedora (原来的redhat desktop linux)</li>
<li>open suse</li>
<li>debian/ubuntu</li>
</ol>
<h1 id="linux桌面环境">Linux桌面环境</h1>
<p>X windows</p>
<p>KDE</p>
<p>GNOME2(Mate)</p>
<p>GNOME3(Mate/Cinnamon)</p>
<p>Unity</p>
<p>xface</p>
<p>lxde</p>
<p>enlightenment(<a href="https://www.enlightenment.org/start">https://www.enlightenment.org/start</a>)</p>
<h1 id="linux桌面管理器">Linux桌面管理器：</h1>
<p>xDM</p>
<p>gDM(gnome)</p>
<p>kDM(kde)</p>
<p>lightDM</p>
<h1 id="linux编程">Linux编程</h1>
<h2 id="linux程序调用结构">Linux程序调用结构：</h2>
<ol>
<li>应用程序(包括shell外部命令)/Shell命令(也就是shell内部命令)</li>
<li>C标准库glibc(包括ISO C和POSIC封装的系统系统调用)</li>
<li>Linux系统调用</li>
<li>Linux内核</li>
</ol>
<h2 id="查看手册">查看手册：</h2>
<p>查看man帮助:</p>
<pre><code>$ man man
</code></pre>
<p>手册章节:</p>
<ol>
<li>Executable programs or shell commands</li>
<li>System calls (functions provided by the kernel)</li>
<li>Library calls (functions within program libraries)</li>
<li>Special files (usually found in /dev)</li>
<li>File formats and conventions eg /etc/passwd</li>
<li>Games</li>
<li>Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)</li>
<li>System administration commands (usually only for root)</li>
<li>Kernel routines [Non standard]</li>
</ol>
<p>查看shell命令</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/linux_monitoring/">Monitoring</a></h2>
                <div class="post-meta">
                    <time>March 31, 2016</time>
                    
                        
                            <span class="category">Linux</span>
                        
                    
                </div>
                
                    <p><h1 id="inode">inode</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/markdown/">Markdown</a></h2>
                <div class="post-meta">
                    <time>March 28, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="markdown">Markdown</h1>
<h2 id="markdown简介">Markdown简介</h2>
<p>Markdown是一种轻量级文本标记语言, Markdown的目标是实现易读易写。
Markdown和html有很大区别，html是一种发布格式，markdown是一种书写格式。</p>
<p>Markdown 中文手册：</p>
<p><a href="http://wowubuntu.com/markdown/index.html">http://wowubuntu.com/markdown/index.html</a></p>
<p>Markdown 英文手册：</p>
<p><a href="http://daringfireball.net/projects/markdown/syntax">http://daringfireball.net/projects/markdown/syntax</a></p>
<p>Markdown文件的扩展名是md。</p>
<h2 id="两个需要特殊处理的字符">两个需要特殊处理的字符</h2>
<p>&lt; 的表示方法：</p>
<blockquote>
<p>&amp; l t ;</p></blockquote>
<p>&amp; 的表示方法：</p>
<blockquote>
<p>&amp; a m p ;</p></blockquote>
<hr>
<h1 id="区块元素">区块元素</h1>
<h2 id="段落和换行">段落和换行</h2>
<p>段落前后要有一个或以上的空行（空格或制表符都可以）。</p>
<h2 id="标题">标题</h2>
<p>markdown支持两个语法格式的标题</p>
<h3 id="setext格式">setext格式</h3>
<p>任意个数下等号=表示大标题:</p>
<pre><code>Title
======
</code></pre>
<p>任意个数下减号表示副标题：</p>
<pre><code>Subtitle
--------
</code></pre>
<h3 id="atx格式">atx格式</h3>
<p>一到六个#表示一到六阶标题,#后面有空格</p>
<pre><code># 一阶标题

## 二阶标题

### 三阶标题

#### 四阶标题

##### 五阶标题

###### 六阶标题
</code></pre>
<h2 id="区块引用">区块引用</h2>
<p>使用&gt;表示单层区块引用：</p>
<p>&gt; block</p>
<blockquote>
<p>block</p></blockquote>
<p>使用多个&gt;嵌套使用：</p>
<p>&gt;&gt; block</p>
<blockquote>
<blockquote>
<p>block</p></blockquote></blockquote>
<p>区块内也可以用标题，列表和代码区块等。</p>
<h2 id="列表">列表</h2>
<h3 id="无序列表">无序列表</h3>
<p>无序列表使用星号、加号或是减号作为列表标记,符号和字符之间有空格：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_nagios/">Nagios</a></h2>
                <div class="post-meta">
                    <time>March 25, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="nagios">Nagios</h1>
<blockquote>
<p>Nagios is the industry standard in IT infrastructure monitoring</p></blockquote>
<blockquote>
<p>Nagios offers complete monitoring and alerting for servers, switches, applications, and services.</p></blockquote>
<p>Nagios官方宣称nagios是IT基础监控的工业标准。</p>
<p>Nagios提供对服务器，交换机，应用和服务的完整的监控和警报。</p>
<p>Nagios是无agent的，nagios的plugin通过协议远程获取信息。</p>
<p><a href="https://www.nagios.org/">https://www.nagios.org/</a></p>
<p><a href="https://www.nagios.com/">https://www.nagios.com/</a></p>
<p><a href="https://exchange.nagios.org/">https://exchange.nagios.org/</a></p>
<p><a href="https://github.com/NagiosEnterprises">https://github.com/NagiosEnterprises</a></p>
<p><a href="https://github.com/nagios-plugins">https://github.com/nagios-plugins</a></p>
<hr>
<h1 id="nagios安装配置">Nagios安装配置</h1>
<h2 id="nagios发展">Nagios发展</h2>
<p>Nagios core 1.0</p>
<p>Nagios core 2.0</p>
<p>Nagios core 3.0</p>
<p>Nagios XI</p>
<p>Nagios core 4.0</p>
<p>目前nagios有两大阵营：</p>
<p>开源解决方案： Nagios core</p>
<p>商业解决方案： Nagios XI</p>
<h2 id="nagios安装配置-1">Nagios安装配置</h2>
<p>安装和配置nagios core,plugins,addons参考</p>
<p>官方文档:</p>
<p><a href="https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html">https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html</a></p>
<p>中文文档：</p>
<p><a href="http://nagios-cn.sourceforge.net/nagios-cn/index.html">http://nagios-cn.sourceforge.net/nagios-cn/index.html</a></p>
<hr>
<h1 id="nagios开源解决方案">Nagios开源解决方案</h1>
<h2 id="nagios-core">Nagios core:</h2>
<blockquote>
<p>Nagios Core is the monitoring and alerting engine that serves as the primary application around which hundreds of Nagios projects are built.</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/metrics_zabbix/">Zabbix</a></h2>
                <div class="post-meta">
                    <time>March 25, 2016</time>
                    
                        
                            <span class="category">DevOps</span>
                        
                    
                </div>
                
                    <p><h1 id="zabbix">Zabbix</h1></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hexo/">Hexo</a></h2>
                <div class="post-meta">
                    <time>March 22, 2016</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="hexo">Hexo</h1>
<h2 id="什么是hexo">什么是hexo</h2>
<blockquote>
<p>Hexo是用nodejs开发的快速、简洁且高效的博客框架，
Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote>
<p>hexo有大量的插件和主题。</p>
<p><a href="https://hexo.io/plugins/">plugins</a></p>
<p><a href="https://hexo.io/themes/">themes</a></p>
<h2 id="安装hexo">安装hexo</h2>
<p>需要安装依赖nodejs(包括npm)和git。</p>
<p>安装hexo命令行插件hexo-cli：</p>
<pre><code>$sudo npm install hexo-cli -g
</code></pre>
<h2 id="next">Next</h2>
<blockquote>
<p>Next是一种文雅的Hexo主题。
一个主题，三种外观，选您所好。
通过主题中的主题（亦称Scheme），您可以方便地改变您博客的外观，同时几乎所有配置同样适用。</p></blockquote>
<p><a href="https://github.com/iissnan/hexo-theme-next">原生的Next</a></p>
<p><a href="https://github.com/crazy-canux/hexo-theme-next">作者的Next</a></p>
<hr>
<h1 id="快速使用">快速使用</h1>
<h2 id="初始化">初始化</h2>
<p>初始化一个hexo的目录：</p>
<pre><code>$hexo init &lt;folder&gt;
</code></pre>
<h2 id="安装依赖">安装依赖</h2>
<p>进入hexo目录安装依赖：</p>
<pre><code>$cd &lt;folder&gt;
$sudo npm install &lt;package-name&gt;
</code></pre>
<p>默认安装下列依赖：</p>
<pre><code>hexo
hexo-server
hexo-generator-index
hexo-generator-archive
hexo-generator-category
hexo-generator-tag
hexo-renderer-ejs
hexo-renderer-marked
hexo-renderer-stylus
</code></pre>
<h2 id="查看文件和目录">查看文件和目录</h2>
<p>安装完成后有下列</p>
<p>文件：</p>
<pre><code>_config.yml
db.json
package.json
</code></pre>
<p>目录：</p>
<pre><code>node_modules
scaffolds
source
themes
</code></pre>
<h2 id="生成静态文件">生成静态文件</h2>
<pre><code>$hexo g
$hexo generate
</code></pre>
<h2 id="启动本地服务器">启动本地服务器</h2>
<pre><code>$hexo s
$hexo server
</code></pre>
<p>用浏览器打开链接即可本地查看默认博客。</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/hugo/">Hugo</a></h2>
                <div class="post-meta">
                    <time>April 1, 2013</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="hugo">Hugo</h1>
<p>go开发的静态站点生成器.</p>
<p><a href="https://github.com/gohugoio/hugo">https://github.com/gohugoio/hugo</a></p>
<p><a href="https://gohugo.io/">https://gohugo.io/</a></p>
<h1 id="搭建博客">搭建博客</h1>
<p>创建环境:</p>
<pre><code># linux, ubuntu18.04默认是非extended, 19.04 默认extended。
$ sudo apt-get install hugo

# extended支持Sass/scss
$ sudo snap install hugo --channel=extended

# windows
PATH:   C:\Hugo\bin\hugo.exe
</code></pre>
<p>测试安装:</p>
<pre><code>$ hugo help
</code></pre>
<p>创建hugo项目:</p>
<pre><code>$ cd /home/canux/sites
&gt; cd C:\hugo\sites
$ hugo new site canuxcheng.com
</code></pre>
<p>生成下列文件和目录:</p>
<pre><code>config.toml
archetypes
content    # md 文件
data
layouts
static
themes
bytes
</code></pre>
<hr>
<h1 id="theme">Theme</h1>
<p><a href="https://github.com/gohugoio/hugoThemes">https://github.com/gohugoio/hugoThemes</a></p>
<p>下载所有主题:</p>
<pre><code>cd blog
git clone --depth 1 --recursive https://github.com/gohugoio/hugoThemes.git themes
</code></pre>
<p>下载单个主题：</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/pelican/">Pelican</a></h2>
                <div class="post-meta">
                    <time>April 1, 2013</time>
                    
                        
                            <span class="category">Web</span>
                        
                    
                </div>
                
                    <p><h1 id="pelican">Pelican</h1>
<p>python开发的静态站点生成器.</p>
<p><a href="http://blog.getpelican.com/">http://blog.getpelican.com/</a></p>
<p><a href="https://github.com/getpelican/pelican">https://github.com/getpelican/pelican</a></p>
<p><a href="http://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html">http://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html</a></p>
<p><a href="http://pelican-zh.readthedocs.io/en/latest/zh-cn/">http://pelican-zh.readthedocs.io/en/latest/zh-cn/</a></p>
<h1 id="搭建博客">搭建博客</h1>
<p>创建环境:</p>
<pre><code>$mkdir blog_pelican
$cd blog_pelican
$virtualenv .venv
$source .venv/bin/activate
$pip install pelican
$pip install markdown
</code></pre>
<p>创建pelican项目:</p>
<pre><code>$pelican-quickstart
</code></pre>
<p>生成下列文件和目录:</p>
<pre><code>publishconf.py # 主配置文件
pelicanconf.py # 发布的配置文件
fabfile.py # fabric配置文件
Makefile   # make配置文件
develop_server.sh # 用于开启测试服务器
content # 用于存放所有文章
output # 静态生成文件
</code></pre>
<h1 id="发布站点">发布站点</h1>
<p>pelican部署博客:</p>
<pre><code># 将rst或md格式转换成html,默认导入到output.
$pelican content
$pelican content -s pelicanconf.py

# 启动web服务器预览
$cd output
$python -m pelican.server
$python2.7 -m SimpleHTTPServer
$python3 -m http.server
$firefox http://localhost:8000/

# 部署站点
# 一般publishconf.py导入pelicanconf.py即可，配置一样．
$pelican content -s publishconf.py
</code></pre>
<p>fabric部署博客:</p></p>
                
            </li>
        
            <li>
                <h2><a href="https://canuxcheng.com/post/sec_security/"></a></h2>
                <div class="post-meta">
                    <time>January 1, 0001</time>
                    
                </div>
                
                    <p><h2 id="date-2016-07-28-160854">Title: Security
Date: 2016-07-28 16:08:54</h2>
<h2 id="draft-false">title: &ldquo;Csrf&rdquo;
date: 2018-07-28T16:08:54
categories: [&ldquo;Security&rdquo;]
tags: [&ldquo;capture&rdquo;]
keywords: []
author: &ldquo;Canux&rdquo;
draft: false</h2>
<h1 id="security">Security</h1>
<p><a href="https://nvd.nist.gov/">https://nvd.nist.gov/</a></p>
<p><a href="http://cve.scap.org.cn/">http://cve.scap.org.cn/</a></p>
<h1 id="gfw">GFW</h1>
<h1 id="ngfw">NGFW</h1>
<h1 id="utm">UTM</h1>
<p>Unified Threat Management, 安全网关</p>
<p>BUV: Block Until Verdict</p>
<h1 id="waf">WAF</h1>
<p>Web Application Firewall, web应用防火墙</p>
<h1 id="ips">IPS</h1>
<p>Intrusion Prevention System, 入侵防御系统</p>
<h1 id="ids">IDS</h1>
<p>Intrusion Detection System, 入侵检测系统</p>
<h1 id="nsm">NSM</h1>
<p>Network Security Monitoring, 网络安全监控</p></p>
                
            </li>
        
    </ul>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
