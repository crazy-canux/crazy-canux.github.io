<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="single-post">
    <article>
        <header>
            <h1>OOP</h1>
            <div class="post-meta">
                <time>June 21, 2016</time>
                
                    
                        <span class="category">Python</span>
                    
                
                
                    
                        <span class="tag">#oop</span>
                    
                
            </div>
        </header>
        
        <div class="post-content">
            <h1 id="面向对象oop">面向对象/OOP</h1>
<p>OOD: Object Oriented Design.</p>
<p>面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．</p>
<p>OOP: Object Oriented Programming.</p>
<p>python内置OOP的结构，但是不必一定要使用类和OOP.</p>
<p>面向对象的两个主题就是类和类实例．</p>
<p>创建实例的过程叫实例化．</p>
<p>属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．</p>
<hr>
<h1 id="类class">类/Class</h1>
<p>类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．</p>
<p>类是一种数据结构的定义，实例是申明了一个这种类型的变量．</p>
<p>类的定义：</p>
<p>Python 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。</p>
<pre><code>class ClassName(object):
    &quot;&quot;&quot;Doc string.&quot;&quot;&quot;
    class_suite
</code></pre>
<p>类的初始化方法init(相当于构造器):</p>
<p>如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。</p>
<p>init方法的第一个参数必须是实例self，而且不能有return语句。</p>
<p>init方法一般用来设置实例属性(也就是数据属性)。</p>
<pre><code>class ClassName(object):
    def __init__(self, *args, **kwargs):
        pass
</code></pre>
<p>特殊方法new:</p>
<p>如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。</p>
<p>new方法的第一个参数必须是类cls。并且需要返回一个实例。</p>
<p>new方法在object中被定义为staticmethod。</p>
<p>相当于析构器的特殊方法del:</p>
<p>__del__特殊方法要在实例对象的所有引用都被清除后才会执行。</p>
<p>不要在del中做与实例没有关系的事情，一般不建议实现该方法。</p>
<pre><code>class ClassName(object):

    def __new__(cls, *args, **kwargs):
        ...
        return ...

    def __del__(self):
        ...
</code></pre>
<h2 id="类属性">类属性</h2>
<p>类属性分为数据属性和方法属性。</p>
<p>类的数据属性仅仅是定义的类的变量。</p>
<p>数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。</p>
<p>直接通过类名来访问类的数据属性。不建议通过实例来访问类的数据属性。</p>
<pre><code>class ClassName(object):
    CONST_VARIABLE = 'value'

    def __init__(self, *args, **kwargs):
        ClassName.CONST_VARIABLE = 'new'

ClassName.CONST_VARIABLE = 'new value'
</code></pre>
<p>类的方法属性仅仅是一个作为类定义的一部分定义的函数, 与类的实例无关。</p>
<p>类中定义的方法的第一个参数是一个实例self。</p>
<p>方法属性必须绑定到一个实例才能被直接调用, 非绑定方法没有给出实例对象一般不能直接调用。</p>
<pre><code>class ClassName(object):
    def func(self, *args, **kwargs):
        pass
</code></pre>
<p>Python 3 中，直接调用 ClassName.func() 会报错：TypeError: func() missing 1 required positional argument: &lsquo;self</p>
<p>调用非绑定方法：</p>
<pre><code>ClassName.func(ClassName()) # 除非传入实例作为第一个参数self的值
# 常用场景： 调用父类中的非绑定方法
class ClassName(BaseClass):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        ...
</code></pre>
<p>调用绑定方法： 自动把实例作为self传入，不用显式传入。</p>
<pre><code>ClassName().func()
</code></pre>
<p>查看类的属性：</p>
<pre><code>dir(class) # 内建函数
class.__dict__ # 类的特殊属性
</code></pre>
<p>类的特殊属性：</p>
<pre><code>class.__name__ # class namkkk
class.__qualname__
class.__module__
class.__doc__ # 文档的特殊属性, 不会被继承.
class.__annotations

class.__bases__ # 类的父类构成的元组
class.__orig_bases__
# 新式类新增的三个特殊属性:
class.__mro__ # 返回方法解析顺序的元组, mro()
class.__subclasses__() # 返回子类的列表

class.__dict__ # 以字典的形式存储对象的属性
class.__weakref__
</code></pre>
<p>方法和函数的特殊属性：</p>
<pre><code>'__doc__',
'__annotations__'
'__qualname__'
'__name__',
'__module__',
'__self__',
'__func__', 
</code></pre>
<h1 id="实例instances">实例/Instances</h1>
<p>实例化：</p>
<pre><code>ins = ClassName()
</code></pre>
<h2 id="实例属性">实例属性</h2>
<p>实例属性：</p>
<p>实例严格来说只有数据属性(方法属性应该属于类属性)，数据属性就是和某个实例相关联的数据值，这些值独立于其它实例或类，当一个实例被释放，相应的数据属性也被释放。通常通过init方法来设置实例的数据属性。</p>
<pre><code>class ClassName(object):
    DATA = &quot;in class&quot; # 类的数据属性

    def __init__(self, default=&quot;default&quot;, *args, **kwargs):
        self.default = default # 当前实例的数据属性
</code></pre>
<p>区别类的数据属性和实例的数据属性。</p>
<pre><code>obj1 = ClassName()
print(obj1.DATA) # &quot;in class&quot;, 当实例没有同名的数据属性，会访问类的数据属性。
obj1.DATA = &quot;in obj1&quot; # 相当于给实例新建了一个数据属性，会覆盖类的数据属性。
print(obj1.DATA) # &quot;in obj1&quot; 访问的是实例的数据属性，覆盖了类的数据属性。
print(ClassName.DATA) # &quot;in class&quot; 访问类的数据属性。
</code></pre>
<p>查看实例属性:</p>
<pre><code>instance.__dict__
</code></pre>
<p>实例的特殊属性：</p>
<pre><code>instance.__dict__ # 以字典的形式存储对象的属性
instance.__class__ # 实例对应的类
</code></pre>
<hr>
<h1 id="封装encapsulation"><strong>封装/Encapsulation</strong></h1>
<p>封装描述了对数据／信息进行隐藏的观念，对数据属性提供接口和访问函数．</p>
<p>默认情况下，数据属性和类属性都是public的．类所在的模块和导入了类的其它模块都可以使用．</p>
<pre><code>var # public
def method_name(self):
</code></pre>
<p>一个下划线开头的属性是protected,能在类本身和子类使用，类的实例可以直接访问，不可以用from module import *导入．</p>
<p>用于把属性限制在一个模块中．</p>
<pre><code>_xxx # protected
def _xxx(self):
</code></pre>
<p>双下划线开头的属性是private, 只能类本身使用，类的实例不能直接访问，子类和其它类都不能使用,子类也不能覆盖．</p>
<p>用于把属性限制在一个类中.</p>
<pre><code>__xxx # private
def __xxx(self):
</code></pre>
<p>系统已经定义的特殊方法，也称魔法方法．</p>
<pre><code>def __xxx__(self): # 系统定义的名字
</code></pre>
<h2 id="composition">Composition</h2>
<p>类之间的关系只有两种继承和包含.</p>
<p>创建复合对象时可以通过composition组合来增加功能和代码的重用性．</p>
<p>当类之间有显著不同，并且较小的类是较大的类所需的组件时一般使用组合．</p>
<pre><code>from .company import Company
from .home import Home
class Emp(object):
    def __init__(self, *args, **kwargs):
        self.comp = Company(args)
        self.home = Home(kwargs)
</code></pre>
<hr>
<h1 id="继承inheritance"><strong>继承/Inheritance</strong></h1>
<p>利用类的两种方式就是包装和继承．</p>
<h2 id="子类和派生">子类和派生</h2>
<p>对于相同的类但是有不同的功能，可以通过derivation派生来实现．</p>
<p>通过使用一个已经定义好的类，扩展它或者修改，而不会影响系统中使用现存类的其它代码片段．</p>
<pre><code>class Father(object):
    def woman(self):
        ...

class Mother(object);
    def man(self):
        ...

class Child(Father, Mother):
    def child(self):
        ...
</code></pre>
<h2 id="继承">继承</h2>
<p>继承描述了基类的属性如何遗传给派生类．</p>
<p>派生类（子类）继承自基类（父类）</p>
<p>python中的类需要继承一个或多个父类．</p>
<p>object类是所有类的父类．</p>
<p>子类继承了基类的属性和方法．</p>
<p>文档字符串__doc__是唯一的，不能继承．</p>
<p>一个类的__bases__属性可以查看它的父类组成的元组．不包括父类的父类．</p>
<pre><code>class.__bases__ # 类的父类构成的元组
</code></pre>
<p>实例调用方法时，默认调用的该对象的类的本身的方法，如果该类没有实现该方法才会调用父类的方法．</p>
<pre><code>class Parent(object):
    def foo(self):
        print(&quot;in parent.&quot;)

class Child(Parent):
    def foo(self):
        print(&quot;in child.&quot;)
</code></pre>
<h2 id="从内置类继承">从内置类继承</h2>
<p>可以从内置类型继承子类，修改一些属性．</p>
<pre><code>class RoundFloat(float):
    def __new__(cls, val):
       return super(RoundFloat, cls).__new__(cls, round(val, 2))

class SortedKeyDict(dict):
    def keys(self):
        return sorted(super(SortedKeyDict, self).keys())
</code></pre>
<h2 id="multiple-inheritance多重继承">Multiple inheritance多重继承</h2>
<p>由于类，类型，内建类型的子类都重新架构，新的类采用MRO算法来查找子类中使用的属性．</p>
<p>MRO: Method Resolution Order, 方法解释顺序．采用广度优先，从左至右边，来获取在子类中的属性．</p>
<p>可以通过新式类的特殊属性查看子类的属性的查找顺序：</p>
<pre><code>class.__mro__ # 返回方法解析顺序的元组
</code></pre>
<p>多继承，mro和super的用法：</p>
<p>super每次只调用MRO中的第一个父类，和getattr的顺序一样．并且相同的父类只调用一次．</p>
<p>数据属性，普通方法属性，特殊方法属性都是按照MRO顺序来查找．</p>
<p><a href="https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance">https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance</a></p>
<hr>
<h1 id="多态polymorphism"><strong>多态/Polymorphism</strong></h1>
<p>python不支持方法重载，但是可以通过对参数的判断，对不同的参数进行不同的处理。以此来实现重载的功能。</p>
<p>python可以重载魔法方法。</p>
<h2 id="magicmethod">magicmethod</h2>
<p>python类有一些可自定义的特殊方法集，它们中的一些有预定义的默认行为，一些没有，留到需要的时候去实现。</p>
<p>这些特殊方法是python中用来扩充类的方法。可以用来模拟标准类型或者重载操作符。</p>
<p>这些特殊方法都是用双下划线开头和结尾的，也被称为魔法方法。</p>
<p>对象创建和销毁：</p>
<pre><code>__init__(self, *args, **kwargs) # 构造器，带一些可选的参数
__new__(cls, *args, **kwargs) # 构造器，带一些可选的参数，通常用来设置不可变数据类型的子类。
__del__(self) # 解构器
</code></pre>
<p>字符串表示：</p>
<pre><code>__str__(self) # str(), print() 
obj = ClassName()
print(obj) # 默认的类的__str__会调用__repr__
# 可以通过重写__str__或__repr__来改变打印的内容

__repr__(self) # repr()
obj = ClassName()
obj # 默认的打印对象的运行时的字符串，&lt;test.RoundFloat at 0x7fb715253e90&gt;
# 可以通过重写__repr__()改变打印的内o

__bool__(self) # 用于bool判断真假
</code></pre>
<p>可调用对象的特殊方法：</p>
<pre><code>__call__(self, *args) # 表示可调用的实例, callable(object) 会返回true.

class TestClass(object):
    def __call__(self, *args):
        print(&quot;Instance is callable after implement call method in class.&quot;)
        print(&quot;Args come from instance invoke is: {}&quot;.format(args))

tc = TestClass()
callable(tc) # True
tc()
tc('arg1')
</code></pre>
<p>实例和类的检查相关特殊方法：</p>
<pre><code>__instancecheck__(self, instance) # isinstance(instance, class)
__subclasscheck__(self, subclass) # issubclass(subclass, class)
</code></pre>
<p>属性相关特殊方法：</p>
<pre><code>__getattr__(self, name) # getattr(), 仅当属性没有在实例／类／父类的__dict__中找到才会调用．
__getattribute__(self, name)
__setattr__(self, name, value)
__delattr__(self, name)
__dir__(self) # dir()

# 描述符相关
__get__(self, instance, owner)
__set__(self, instance, value)
__delete__(self, instance)
</code></pre>
<p>with上下文管理特殊方法：</p>
<pre><code>__enter__(self) # return self, 需要返回self
__exit__(self, exc_type, exc_value, traceback)
</code></pre>
<p>对象比较特殊方法：</p>
<pre><code>__cmp__(self, other) # cmp()
__lt__(self, other)
__le__(self, other)
__eq__(self, other)
__ne__(self, other)
__gt__(self, other)
__ge__(self, other)
</code></pre>
<p>容器类型相关特殊方法:</p>
<pre><code>__len__(self) #　len()
__getitem__(self, key) #
__setitem__(self, key, value) #
__delitem__(self, key) # del
__reversed__(self) # reversed()
__iter__(self) # iter()
__contains__(self, item)
__missing__(self, key)
</code></pre>
<p><a href="https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py">https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py</a></p>
<p>数值类型相关特殊方法：</p>
<pre><code>__add__(self, other)
__sub__(self, other)
__mul__(self, other)
__div__(self, other)
__truediv__(self, other)
__floordiv__(self, other)
__mod__(self, other)
__divmod__(self, other)
__pow__(self, other[, module])
__lshift__(self, other)
__rshift__(self, other)
__and__(self, other)
__xor__(self, other)
__or__(self, other)

__rxxx__(self, other)

# 原位运算必须返回self.
__ixxx__(self, other) # self += other -&gt; self = self + other

__neg__(self)
__pos__(self)
__abs__(self)
__invert__(self)

__complex__(self)
__int__(self)
__long__(self)
__float__(self)

__oct__(self)
__hex__(self)

__index__(self)
__coerce__(self, other)
</code></pre>
<h2 id="delegation--wrapping">Delegation &amp; Wrapping</h2>
<p>Wrapping包装就是对一个已经存在的对象增加，删除或修改已经存在的功能．</p>
<p>Delegation授权(代理)是Wrapping包装的一个特性,用于简化处理相关命令性功能，最大化重用代码．</p>
<p>实现delegation的关键在于覆盖__getattr__()特殊方法．通过调用内置函数getattr()得到一个对象的默认行为．</p>
<pre><code>class Wrapper(object):
    def __init__(self, obj):
        self.__data = obj

    def __getattr__(self, attr):
        return getattr(self.__data, attr)
</code></pre>
<hr>
<h1 id="metaclass元类">metaclass元类</h1>
<p>metaclass 是&quot;创建类的类&quot;。正如实例是类的实例化，类也是元类的实例化。在 Python 中，类本身也是对象，而元类就是用来创建这些类对象的。</p>
<p>元类用来定义某些类是如何被创建的。改变类的默认行为和创建方式。</p>
<p>大多数情况下不需要创建元类，一般使用系统的元类的默认方式。</p>
<p>在执行类定义的时候，解释器必须知道这个类的元类；</p>
<pre><code>class ClassName(metaclass=MetaClassName):
    pass
</code></pre>
<p>在执行类定义时候检查元类，元类传递三个参数到构造器：</p>
<pre><code>类名
从基类继承数据的元组, __bases__
类的属性字典, __dict__
</code></pre>
<p>元类相关的可定制属性：</p>
<pre><code>__metaclass__
</code></pre>
<p>定义一个元类：</p>
<pre><code>class MetaClassName(type):
    def __new__(cls, name, bases, dicts):
        super().__new__(cls, name, bases, dicts)
        # 在这里做一些你希望使用该元类的类在定义时做的操作
    def __call__(cls, *args, **kwargs):
       if cls not in cls._instances:
          cls._instances[cls] = super().__call__(*args, **kwargs)
      return cls._instances[cls]

class ClassName(metaclass=MetaClassName):
    def __init__(self, value):
        self.value = value
    ...
</code></pre>
<p><a href="https://github.com/crazy-canux/python/tree/master/python/metaclass">https://github.com/crazy-canux/python/tree/master/python/metaclass</a></p>
<p>使用场景：</p>
<ul>
<li>单例模式</li>
<li>自动注册类</li>
<li>属性验证和转</li>
<li>ORM模型创建</li>
<li>抽象基类和接口检查</li>
</ul>
<h2 id="abstractmethod">abstractmethod</h2>
<p>抽象方法，类似于java的interface.</p>
<p>最简单的抽象方法：</p>
<pre><code># 如果子类没有实现同名的该方法，就会抛出异常．
def base_method(self):
    raise NotImplementedError
</code></pre>
<p>或者使用abc标准库来实现：</p>
<p><a href="https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py">https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py</a></p>
<hr>
<h1 id="descriptors描述符">descriptors描述符</h1>
<p>普通对象访问(set/get/delete)属性的优先级：</p>
<pre><code>obj.__dict__['attr'] # 先访问实例对象
obj.__class__.__dict__['attr'] # 再访问类对象
obj.__class__.__base__.__dict__['attr'] # 接着访问基类的对象,不包括metaclass.
__getattr__ # 如果实现了的话，优先级最低
</code></pre>
<p>描述符是一个对象，它定义了当另一个对象的属性被访问时应该如何处理。任何定义了 <strong>get</strong>()、<strong>set</strong>() 或 <strong>delete</strong>() 方法的类都是描述符。</p>
<pre><code>__get__(self, obj, type=None) # 返回一个属性的值
__set__(self, obj, value) # 设置一个属性的值，返回None
__delete__(self, obj) # 属性的引用递减，返回None
</code></pre>
<p>描述符是数据property，class，staticmethod，classmethod, 以及super的机制．</p>
<p>data descriptor:定义了__get__和__set__的对象是数据描述符, 主要用于数据属性．</p>
<p>non data descriptor:仅仅定义了__get__的对象是非数据描述符，主要用于方法属性．</p>
<p>如果实例的字典(obj.<strong>dict</strong>)具有与数据描述符相同名称的条目，则数据描述符优先。</p>
<p>如果实例的字典(obj.<strong>dict</strong>)具有与非数据描述符相同名称的条目，则字典条目优先。</p>
<pre><code>class DescriptorName(object):
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, typ):
        print('__get__', instance, typ)
        return self.name

    def __set__(self, instance, value):
        print('__set__', instance, value)
        self.name = value

class TestClass(object):
    name = DescriptorName('canux')

tc = TestClass()
print(tc.name) # __get__(tc, type(tc))被调用
print(TestClass.name) # __get__(None, TestClass)被调用
tc.__dict__['name'] = 'test' # 无效
tc.name = 'test' # __set__被调用
TestClass.name = 'test' # 仅仅是重新定义类的属性，覆盖了描述符
# 此时tc.__dict__有同名属性，如果定义了__set__
print(tc.name) # __get__被调用，属性已经修改
print(TestClass.name) # __get__被调用,属性已经修改
# 如果没有定义__set__，就是调用的tc.__dict__里面的．
</code></pre>
<p>描述符访问属性的优先级：</p>
<pre><code>数据描述符(__set__, __get__)
# 对于访问实例属性obj.__getattribute__调用方式：type(obj).__dict__['attr'].__get__(obj, type(obj))
# 对于访问类属性class.__getattribute__调用方式：ClassName.__dict__['attr'].__get__(None, ClassName)
instance.__dict__
非数据描述符(__get__)
__getattr__ # 如果实现了的话，在描述符中优先级最低
</code></pre>
<p>描述符是由__getattribute__特殊方法调用，覆盖该方法可以防止描述符自动调用.</p>
<p>obj.__getattribute__和class.__getattribute__的调用方式不同．</p>
<p>描述符的三个特殊方法一般是通过属性访问自动调用．</p>
<p>函数和方法的描述符：</p>
<p>在属性访问期间函数包括了__get__方法用于绑定方法．因此函数和方法是非数据描述符．</p>
<pre><code>class TClass(object):
    def __get__(self, obj, typ=None):
        return types.MethodType(self, obj, typ)


    def tmethod(self, args):
        return args

class Foo(object):
    @Tclass
    def bar(self):
        print('in bar')

obj = TClass()
TClass.__dict__['tmethod'] # function __main__.f
TClass.tmethod # unbound method TClass.tmethod
obj.tmethod # bound method TClass.tmethod of &lt;__main__.TClass object at 0x7f8a4f084c10&gt;

obj.function(*args) -&gt; function(obj, *args)
Class.function(*args) -&gt; function(*args)
</code></pre>
<h2 id="property">property</h2>
<p>property属性是一种有用的特殊类型的描述符． 也是descriptor的主要用途．</p>
<pre><code>property(fget=None, fset=None, fdel=None, doc=None) # 返回一个property类型的对象
</code></pre>
<p>通过上面的descriptor的普通方式实现纯pytho写的property:</p>
<pre><code>class Property(object):
    def __init__(self, fget, fset, fdelete):
        self.fget = fget
        self.fset = fset
        self.fdelete = fdelete

    def __get__(self, obj, typ=None):
        return self.fget(obj)

    def __set__(self, obj, val):
        self.fset(obj, val)

    def __delete__(self, obj):
        self.fdelete(obj)

class Foo(object):
    def fget(self):
        print 'fget called'

    def fset(self, val):
        print 'fset called'

    def fdelete(self):
        print 'fdelete called'

    bar = Property(fget, fset, fdelete)
</code></pre>
<p>通过装饰器@property来实现：</p>
<pre><code>class Person(object):
    def __init__(self):
        self._email = None

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        m = re.match('\W+@\W+\.\W+', value)
        if not m:
            raise Exception('email not valid')
        self._email = value

    @email.deleter
    def email(self):
        del self._email
</code></pre>
<p><a href="https://github.com/crazy-canux/python/tree/master/python/descriptor">https://github.com/crazy-canux/python/tree/master/python/descriptor</a></p>
<hr>
<h1 id="super">super</h1>
<p>因为同名的方法子类会覆盖父类，在子类中调用父类的同名方法可以通过super内置函数。</p>
<p>super()方法实际是一个构造器。自动找到基类方法，同时传入self参数。</p>
<pre><code>super().__init__() # 不需要传递参数
</code></pre>
<p>对于单继承, super用来调用父类同名方法。</p>
<pre><code>class Child(Parent):
    def foo(self):
        Parent.foo(self) # 可以手动调用父类同名的方法，调用非绑定方法，传入self参数。

class Child(Parent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs) 
        ...

    def foo(self, *args, **kwargs):
        super().foo(*args, **kwargs) 
        ...
</code></pre>
<p>对于多继承，super用法参考上面的多继承．</p>
<p>常用场景：</p>
<ul>
<li>调用父类构造函数</li>
<li>扩展父类方法</li>
<li>多重继承场景</li>
<li>属性设置场景</li>
<li>合作式继承</li>
<li>类方法中使用</li>
<li>静态方法中使用</li>
</ul>
<p>super()返回的对象有一个用于调用Descriptor的定制__getattribute__()方法．</p>
<pre><code>super(B, obj).method() -&gt;
obj.__class__.__mro__ -&gt;
A.__dict__['method'].__get__(obj, B)
</code></pre>
<p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">https://rhettinger.wordpress.com/2011/05/26/super-considered-super/</a></p>
<h1 id="classmethod">classmethod</h1>
<p>classmethod 是一个内置装饰器，用于将方法转换为类方法。类方法的特点是：</p>
<ul>
<li>第一个参数是类本身 cls，而不是实例 self</li>
<li>可以通过类或实例调用</li>
<li>可以访问类属性，但不能直接访问实例属性</li>
<li>常用于创建备选构造函数</li>
</ul>
<p>类方法通常用于替代类构造函数．</p>
<pre><code>class ClassName(object):
    @classmethod
    def demo_cm(cls, *args, **kwargs):
        ...

# 可以通过类来调用, 也就是可以直接调用非绑定方法．自动传入类作为第一个参数．
ClassName.demo_cm(args, kwargs)
# 也可以通过实例来调用, 自动传入类作为第一个参数
ClassName().demo_cm(args, kwargs) // not recommend
</code></pre>
<p>描述符相关：</p>
<pre><code>obj.function(*args) -&gt; function(type(obj), *args)
Class.function(*args) -&gt; function(Class, *args)
</code></pre>
<p>常用场景：</p>
<ul>
<li>备选构造函数</li>
<li>工厂方法模式</li>
<li>访问和修改类属性</li>
<li>配置和设置相关方o</li>
<li>继承中的类方法</li>
</ul>
<h1 id="staticmethod">staticmethod</h1>
<p>staticmethod 是一个内置装饰器，用于将方法转换为静态方法。静态方法的特点是：</p>
<ul>
<li>不接收隐式的第一个参数（不需要 self 或 cls）</li>
<li>可以通过类或实例调……</li>
<li>不能访问类或实例的属性</li>
<li>行为类似普通函数，只是在类的命名空间中</li>
</ul>
<p>例子:</p>
<pre><code>class ClassName(object):
    @staticmethod
    def demo_sm():
        ...

ClassName.demo_sm()
ClassName().demo_sm()
</code></pre>
<p>描述符相关：</p>
<pre><code>obj.function(*args) -&gt; function(*args)
Class.function(*args) -&gt; function(*args)
</code></pre>
<p>常用场景：</p>
<ul>
<li>工具函数</li>
<li>验证和转换函数</li>
<li>常量和配置相关</li>
<li>工厂方法辅助函数</li>
</ul>
<hr>
<h1 id="class-decorators">Class Decorators</h1>
<p>类装饰器比函数装饰器更灵活，高内聚，封装性等优点．</p>
<p>类装饰器用于装饰一个类.</p>
<pre><code>def deco_name(cls):
    class WrapperName(cls, ...):
        def __init__(self, *args, **kwargs):
            cls.__init__()
            ....__init__()
            ...
    return WrapperName

@deco_name
class ClassName(object):
    def __init__(self, *args, **kwargs):
        ...
    ...
</code></pre>
<p><a href="https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py">https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py</a></p>
<hr>

        </div>
    </article>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
