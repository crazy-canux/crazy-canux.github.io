<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSL_system - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="single-post">
    <article>
        <header>
            <h1>GSL_system</h1>
            <div class="post-meta">
                <time>January 1, 2018</time>
                
                    
                        <span class="category">Golang</span>
                    
                
                
                    
                        <span class="tag">#system</span>
                    
                
            </div>
        </header>
        
        <div class="post-content">
            <h1 id="os">os</h1>
<p>提供了操作系统的不依赖平台的接口</p>
<pre><code>import &quot;os&quot;
</code></pre>
<h2 id="constants">constants</h2>
<pre><code># flag 参数
const (
    O_RDONLY int = syscall.O_RDONLY
    O_WRONLY int = syscall.O_WRONLY
    O_RDWR int = syscall.O_RDWR
    O_CREATE int = syscall.O_CREATE # 不存在就创建
    O_APPEND int = syscall.O_APPEND # 追加写入
    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件
    O_EXCL int = syscall.O_EXCL
    O_SYNC int = syscall.O_SYNC
)

const (
    SEEK_SET int = 0
    SEEK_CUR int = 1
    SEEK_END int = 2
)

const (
    // 操作系统指定的路径分隔符
    PathSeperator = '/'
    // 操作系统指定的表分隔符
    PathListSeparator = ':'
)

// 操作系统空设备的名字
const DevNull = &quot;/dev/null&quot;
</code></pre>
<h2 id="variables">variables</h2>
<pre><code>var (
    ErrInvalid = errors.New(&quot;invalid argument&quot;)
    ...
)

// 指向标准输入／输出／错误的文件描述符
var (
    Stdin = NewFile(uintptr(syscall.Stdin), &quot;/dev/stdin&quot;)
    Stdout = NewFile(uintptr(syscall.Stdout), &quot;/dev/stdout&quot;)
    Stderr = NewFile(uintptr(syscall.Stderr), &quot;/dev/stderr&quot;)
)

// 保存了命令行参数，第一个是程序名
var Args []string
</code></pre>
<h2 id="functions">functions</h2>
<pre><code>// 返回内核提供的主机名
func Hostname() (name string, err error)

// 当前程序以给出的状态码马上退出，defer不会执行
func Exit(code int)

// 返回key=value格式的环境变量的字符串的切片拷贝
func Environ() []string
</code></pre>
<p>文件相关的操作</p>
<pre><code>func IsExist(err error) bool // 文件存在返回true
func IsNotExist(err error) bool // 文件不存在返回true

func IsPathSeparator(c uint8) bool
...
func SameFile(fi1, fi2 FileInfo) bool
func Getwd() (dir string, err error)
func Chdir(dir string) error
func Chmod(name string, mode FileMode) error
func Chown(name string, uid, gid int) error
...
func Mkdir(name string, perm FileMode) error // 创建单个目录
func MkdirAll(path string, perm FileMode) error // 创建多级目录
func Rename(oldpath, newpath string) error
func Truncate(name string, size int64) error
func Remove(name string) error
func RemoveAll(path string) error
func Readlink(name string) (string, error)
func Symlink(oldname, newname string) error // 创建符号连接
func Link(oldname, newname string) error // 创建硬连接
func TempDir() string // 返回一个用于保管临时文件的默认目录

// 从filename指定的文件读取数据并返回, 成功返回文件内容和nil
func ReadFile(filename string) ([]byte, error)

// 向filename指定文件写入数据，如果文件存在先清空文件，如果不存在创建文件.
func WriteFile(filename string, data []byte, perm os.FileMode) error
</code></pre>
<h2 id="signal">Signal</h2>
<p>interface:</p>
<pre><code>type Signal interface {
    String() string
    Signal()
}
</code></pre>
<p>variable:</p>
<pre><code>var (
    Interrupt Signal = syscall.SIGINT
    Kill Signal = syscall.SIGKILL
)
</code></pre>
<h2 id="filemode">FileMode</h2>
<p>代表文件模式和权限位．</p>
<pre><code>type FileMode uint32
</code></pre>
<p>constant:</p>
<pre><code>const (
    ModeDir    FileMode = 1 &lt;&lt; (32 - 1 - iota) // d: 目录
    ...
    ModeType = ModeDir | ModeSymlink | ModeNamePipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777
)
</code></pre>
<p>methods:</p>
<pre><code>func (m FileMode) IsDir() bool
func (m FileMode) IsRegular() bool
</code></pre>
<h2 id="fileinfo">FileInfo</h2>
<p>用来描述一个文件对象</p>
<pre><code>type FileInfo interface {
    Name() string
    Size() int64
    Mode() FileMode
    ModeTime() time.Time
    IsDir() bool
    Sys() interface{}
}
</code></pre>
<p>function:</p>
<pre><code>// 获取一个文件对象
func Stat(name string) (fi FileInfo, err error)

func Lstat(name string) (fi FileInfo, err error)
</code></pre>
<h2 id="file">File</h2>
<p>表示一个打开的文件对象</p>
<p>struct:</p>
<pre><code>type File struct {}
</code></pre>
<p>functions:</p>
<pre><code>// 采用flag=os.O_RDWR和perm=0666模式创建一个名为name的文件, 返回读写文件句柄
// 文件已存在就截断
func Create(name string) (file *File, err error)

// 打开指定文件，返回只读文件句柄, flag=os.O_RDONLY
func Open(name string) (file *File, err error)

// 指定flag和perm创建／打开文件
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)

// 使用给定的文件描述服和名称创建一个文件.
func NewFile(fd uintptr, name string) *File

// 返回一对关联的文件对象
func Pipe() (r *File, w *File, err error)
</code></pre>
<p>methods:</p>
<pre><code>// 从文件f中最多读取len(b)字节数据写入b, 返回读取的字节数
// 返回0, io.EOF, 表示读取0个字节,文件终止．
func (f *File) Read(b []byte) (n int, err error)

func (f *File) ReadAt(b []byte, off int64) (n int, err error)

// 向文件f写入len(b)字节数据b，返回写入字节数
func (f *File) Write(b []byte) (n int, err error)

func (f *File) WriteAt(b []byte, off int64) (ret int, err error)

func (f *File) WriteString(s string) (ret int, err error)

func (f *File) Close() error
</code></pre>
<h2 id="process">Process</h2>
<p>保存一个被StarProcess创建的进程的信息</p>
<p>struct:</p>
<pre><code>type Process struct {
    Pid int
}
</code></pre>
<p>functions:</p>
<pre><code>// 启动一个新进程
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)

// 查找一个运行中的进程
func FindProcess(pid int) (p *Process, err error)
</code></pre>
<p>methods:</p>
<pre><code>// 向进程发送信号
func (p *Process) Signal(sig Signal) error

// 阻塞直到进程退出
func (p *Process) Wait() (*ProcessState, error)

// 让进程立刻退出
func (p *Process) Kill() error

// 释放进程绑定的资源
func (p *Process) Release() error
</code></pre>
<h2 id="processstate">ProcessState</h2>
<p>保管Wait函数报告的某个已退出进程的信息．</p>
<p>struct:</p>
<pre><code>type ProcessState struct {}
</code></pre>
<p>methods:</p>
<pre><code>// 返回一个已退出的进程的id
func (p *ProcessState) Pid() int

// 报告进程是否已退出
func (p *ProcessState) Exited() bool

// 报告进程是否成功退出
func (p *ProcessState) Success() bool

// 返回已退出进程及其子进程耗费的系统cpu时间
func (p *ProcessState) SystemTime() time.Duration

// 返回已退出进程及其子进程耗费的用户cpu时间
func (p *ProcessState) UserTime() time.Duration

func (p *ProcessState) Sys() interface{}

func (p *ProcessState) SysUsage() interface{}

func (p *ProcessState) String() string
</code></pre>
<h2 id="procattr">ProcAttr</h2>
<p>保存被StratProcess启动的新进程的属性</p>
<p>struct:</p>
<pre><code>type ProcAttr struct {
    Dir string
    Env []string
    Files []*File
    Sys *syscall.SysProcAttr
}
</code></pre>
<hr>
<h1 id="osexec">os/exec</h1>
<p>执行外部命令，包装了os.StartProcess函数，提供更高级的接口.</p>
<h2 id="variable">variable</h2>
<pre><code>var ErrNotFound = errors.New(&quot;executable file not found in $PATH&quot;)
</code></pre>
<h2 id="functions-1">functions</h2>
<pre><code>// 在环境变量指定的目录中搜索可执行文件file
func LookPath(file string) (string, error)
</code></pre>
<h2 id="cmd">Cmd</h2>
<p>表示一个准备执行或执行中的外部命令</p>
<p>struct:</p>
<pre><code>type Cmd struct {
    Path string
    Args []string
    Env []string
    Dir string
    stdin io.Reader
    Stdout io.Writer
    Stderr io.Writer
    ExtraFiles []*os.File
    SysProcAttr *syscall.SysProcAttr
    Process *os.Process
    ProcessState *os.ProcessState
}
</code></pre>
<p>functions:</p>
<pre><code>// 返回*Cmd
func Command(name string, arg ***string) *Cmd
</code></pre>
<p>methods:</p>
<pre><code>// 同步：执行命令，并阻塞直到完成
func (c *Cmd) Run() error

// 异步：开始执行命令，不阻塞直接返回，
func (c *Cmd) Start() error
// 阻塞通过Start执行的命令直到完成，设置状态码并释放资源．
func (c *Cmd) Wait() error

func (c *Cmd) StdinPipe() (io.WriteCloser, error)
func (c *Cmd) StdoutPipe() (io.ReadCloser, error)
func (c *Cmd) StderrPipe() (io.ReadCloser, error)

// 执行命令并返回stdout的切片
func (c *Cmd) Output() ([]byte, error)
// 执行命令并返回stdout和stderr合并后的切片
func (c *Cmd) CombinedOutput() ([]byte, error)
</code></pre>
<hr>
<h1 id="ossignal">os/signal</h1>
<hr>
<h1 id="osuser">os/user</h1>
<hr>
<h1 id="syscall">syscall</h1>
<p>提供了操作系统级别的调用．</p>
<pre><code>import &quot;syscall&quot;
</code></pre>
<h2 id="constants-1">constants</h2>
<pre><code>const (
    AF_ALG    = 0x26
    ...
)

// 定义异常
const (
    E2BIG    = Errno(0x70)
    ...
)

// 定义信号
const (
    SIGABRT    = Signal(0x6)
    ...
)

const (
    SYS_READ    = 0
    ...
)

const (
    SizeofSockaddrInet4    = 0x10
    ...
)

const (
    IFA_UNSPEC    = 0x0
    ...
)

const (
    SizeofSockFilter    = 0x8
    ...
)

const (
    VINTR    = 0x0
    ...
)

const ImplementsGetwd = true

const PathMax = 0x1000

const SizeofInotifyEvent = 0x10
</code></pre>
<h2 id="variables-1">variables</h2>
<pre><code>var (
    Stdin = 0
    Stdout = 1
    Stderr = 2
)

var ForkLock sync.RWMutex

var SocketDisableIPv6 bool
</code></pre>
<h2 id="others">others</h2>
<p>参考文档</p>
<hr>
<h1 id="io">io</h1>
<p>提供了对IO原语的基本接口</p>
<p>go1.16 删除了io/ioutil</p>
<pre><code>import &quot;io&quot;
</code></pre>
<h2 id="variables-2">variables</h2>
<pre><code>// 放无法获取更多输入时Read方法返回os.EOF
var EOF = errors.New(&quot;EOF&quot;)
</code></pre>
<h2 id="functions-2">functions</h2>
<pre><code>func ReadAll(r io.Reader) ([]byte, error)
func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
func ReadFull(r Reader, buf []byte) (n int, err error)

// 将src数据拷贝到dst, 直到EOF或出错，返回拷贝的字节数
func Copy(dst Writer, src Reader) (written int64, err error)

// 类似Copy，不过只拷贝n个字节.
func CopyN(dst Writer, src Reader, n int64) (written int64, err error)

func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)

// 将字符串s写入w
func WriteString(w Writer, s string) (n int, err error)
</code></pre>
<h2 id="reader">Reader</h2>
<p>用于包装基本的读取方法</p>
<p>os.File(os.Stdout, os.Stdin. os.Stderr), bytes.Buffer 和 bufio.Reader 都是io.Reader接口</p>
<p>interface:</p>
<pre><code>type Reader interface {
    Read(p []byte) (n int, err error)
}
</code></pre>
<h2 id="writer">Writer</h2>
<p>用于包装基本的写入方法</p>
<p>os.File(os.Stdin, os.Stderr, os.Stdin), bytes.Buffer 和 bufio.Writer, net/http.ResponseWriter 都是io.Writer接口</p>
<p>interface:</p>
<pre><code>type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<h2 id="closer">Closer</h2>
<p>用于包装基本的关闭方法</p>
<p>interface:</p>
<pre><code>type Closer interface {
    Close() error
}
</code></pre>
<h2 id="seeker">Seeker</h2>
<p>用于包装基本的移位方法</p>
<p>interface:</p>
<pre><code>type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
</code></pre>
<h2 id="readwriter">ReadWriter</h2>
<p>interface:</p>
<pre><code>type ReadWriter interface {
    Reader
    Writer
}
</code></pre>
<hr>
<h1 id="bufio">bufio</h1>
<p>bufio实现了有缓冲的IO</p>
<h2 id="constants-2">constants</h2>
<pre><code>const (
    // 用于缓冲一个token
    MaxScanTokenSize = 64 * 1024
)
</code></pre>
<h2 id="variables-3">variables</h2>
<pre><code>// 会被Scanner返回的错误
var (
    ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)
    ...
)
</code></pre>
<h2 id="functions-3">functions</h2>
<pre><code>func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)

// 将每一行文本去掉末尾的换行标记，然后作为一个token返回
func ScanLines (data []byte, atEOF bool) (advance int, token []byte, err error)
</code></pre>
<h2 id="reader-1">Reader</h2>
<p>给io.Reader接口对象附加缓冲</p>
<p>struct:</p>
<pre><code>type Reader struct {}
</code></pre>
<p>functions:</p>
<pre><code>func NewReader(rd io.Reader) *Reader

func NewReaderSize(rd io.Reader, size int) *Reader
</code></pre>
<p>methods:</p>
<pre><code>func (b *Reader) Read(p []byte) (n int, err error)
// 读取直到第一次遇到delim字节，返回一个包含已读取数据和delim字节的字符串
// 当且仅当返回的切片不以delim结尾时，返回非nil错误
func (b *Reader) ReadString(delim byte) (line string, err error)
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)

func (b *Reader) ReadByte() (c byte, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
</code></pre>
<h2 id="writer-1">Writer</h2>
<p>给io.Writer接口对象提供缓冲</p>
<p>struct:</p>
<pre><code>type Writer struct {}
</code></pre>
<p>functions:</p>
<pre><code>func NewWriter(w io.Writer) *Writer

func NewWriterSize(w io.Writer, size int) *Writer
</code></pre>
<p>methods:</p>
<pre><code>func (b *Writer) Write(p []byte) (nn int, err error)
func (b *Writer) WriteString(s string) (int, error)
func (b *Writer) WriteByte(c byte) error
func (b *Writer) WriteRune(r rune) (size int, err error)

func (b *Writer) Flush() error
</code></pre>
<h2 id="readwriter-1">ReadWriter</h2>
<p>struct:</p>
<pre><code>type ReadWriter struct {
    *Reader
    *Writer
}
</code></pre>
<p>functions:</p>
<pre><code>func NewReadWriter(r *Reader, w *Writer) *ReadWriter
</code></pre>
<h2 id="scanner">Scanner</h2>
<p>提供了方便的读取数据接口</p>
<p>struct:</p>
<pre><code>type Scanner struct {}
</code></pre>
<p>functions:</p>
<pre><code>// 创建并返回一个从r读取数据的Scanner，默认分割函数是ScanLines
func NewScanner(r io.Reader) *Scanner
</code></pre>
<p>methods:</p>
<pre><code>// 设置s的分割函数
func (s *Scanner) Split(split SplitFunc)

// 获取当前位置的token, 并让Scanner的扫描位置移动到下一个token.
func (s *Scanner) Scan() bool

// 返回最近一次Scan调用生成的token.
func (s *Scanner) Bytes() []byte

// 创建一个字符串保存Bytes返回的token,并返回
func (s *Scanner) Text() string

// 返回Scanner遇到的第一个非EOF错误
func (s *Scanner) Err() error
</code></pre>
<h2 id="splitfunc">SplitFunc</h2>
<pre><code>type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
</code></pre>
<hr>
<h1 id="fmt">fmt</h1>
<p>实现了类似于C的printf/scanf的格式化IO.</p>
<pre><code>import &quot;fmt&quot;
</code></pre>
<p>通用占位符:</p>
<pre><code>%v    相应值的默认格式
%+v   同时打印结构体的字段名
%#v   相应值的go语法表示
%T    相应值的类型的go语法表示
%%    字面上的百分号
</code></pre>
<p>布尔类型：</p>
<pre><code>%t    true/false
</code></pre>
<p>整数类型：</p>
<pre><code>%b    二进制表示
%c    相应的unicode码点所表示的字符
%d    十进制表示
%o    八进制表示
%q    单引号包围的字符字面值
%x    十六进制(字母小写)
%X    十六进制(字母大写)
%U    unicode格式
</code></pre>
<p>浮点数类型：</p>
<pre><code>%b    无小数部分的，指数为二的幂的科学计数法．
%e    科学计数法
%E    科学计数法
%f    有小数点，而无指数
%g    根据情况选择%e 或 %f
%G    根据情况选择E% 或 %f

%[宽度]Type
%.[精度]Type
%[宽度].[精度]Type
</code></pre>
<p>字符串与字节切片：</p>
<pre><code>%s    字符串或切片的字节
%q    双引号包围的字符串
%x    十六进制(小写字母)
%X    十六进制(大写字母)
</code></pre>
<p>指针：</p>
<pre><code>%p    十六进制表示(0x)
</code></pre>
<h2 id="functions-4">functions</h2>
<pre><code>// 返回一个包含该格式化字符串的错误
func Errorf(format string, a ...interface{}) error

// 写入到STDOUT, 返回写入字节数
// 默认格式化
func Print(a ...interface{}) (n int, err error)
// 默认格式化，自动结尾添加换行符
func Println(a ...interface{}) (n int, err error)
// 指定格式化
func Printf(format string, a ...interface{}) (n int, err error)

// 写入到w, 返回写入字节数
// w: os.File bufio.Writer
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

// 返回该字符串
func Sprint(a ...interface{}) string
func Sprintln(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string

// 从STDIN扫描文本存入a,返回成功扫描的个数
// 换行视为空白，获取len(a)个条目才停止扫描
func Scan(a ...interface{}) (n int, err error)
// 换行才停止扫描
func Scanln(a ...interface{}) (n int, err error)
// 根据空格分割的条目格式化写入指定参数a
func Scanf(format string, a ...interface{}) (n int, err error)

// 从r扫描文本存入a, 返回成功扫描的条目
// r: os.File bufio.Reader
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)

// 从字符串str扫描文本存入a,  返回扫描成功的条目
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
</code></pre>
<h2 id="stringer">Stringer</h2>
<p>interface:</p>
<pre><code>type Stringer initerface {
    String() string
}
</code></pre>
<h2 id="gostringer">GoStringer</h2>
<p>interface:</p>
<pre><code>type GoStringer interface {
    GoString() string
}
</code></pre>
<h2 id="state">State</h2>
<p>interface:</p>
<pre><code>type State interface {
    Write(b []byte) (ret int, err error)
    Width() (wid int, ok bool)
    Precision() (prec int, ok bool)
    Flag(c int) bool
}
</code></pre>
<h2 id="formatter">Formatter</h2>
<p>interface:</p>
<pre><code>type Formatter interface {
    Format(f State, c rune)
}
</code></pre>
<h2 id="scanstate">ScanState</h2>
<p>interface:</p>
<pre><code>type ScanState interface {
    ReadRune() (r rune, size int, err error)
    UnreadRune() error
    SkipSpace()
    Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
    Width() (wid int, ok bool)
    Read(buf []byte) (n int, err error)
}
</code></pre>
<h2 id="scanner-1">Scanner</h2>
<p>interface:</p>
<pre><code>type Scanner interface {
    Scan(state ScanState, verb rune) error
}
</code></pre>
<hr>
<h1 id="log">log</h1>
<p>实现了简单的日志服务.</p>
<h2 id="constants-3">Constants</h2>
<pre><code>const (
    Ldate        = 1 &lt;&lt; iota     // 日期
    Ltime              // 时间
    Lmicroseconds      // 微秒
    Llongfile          // 绝对文件名和行好 /path/to/file.go:13
    Lshortfile         // 文件名和行好, 覆盖上面字段 file.go:13
    LstdFlags    = Ldate | Ltime      // 标准logger的初始值
)
</code></pre>
<h2 id="functions-5">functions</h2>
<pre><code>func Printf(format string, v ...interface{})
func Print(v ...interface{})
func Println(v ...interface{})

// 下列函数在Print...函数基础上再调用os.Exit(1)
func Fatalf(format string, v ...interface{})
func Fatal(v ...interface{})
func Fatalln(v ...interface{})

// 下列函数在Print...函数基础上再调用panic(...)
// panic会执行当前函数的defer, 然后退出当前函数，返回到调用者，
// 调用函数会执行defer, 直到应用程序退出.最后panic.
func Panicf(format string, v ...interface{})
func Panic(v ...interface{})
func Panicln(v ...interface{})
</code></pre>
<h2 id="logger">Logger</h2>
<p>struct:</p>
<pre><code>type Logger struct {}
</code></pre>
<p>function:</p>
<pre><code>// 创建一个Logger.
func New(out io.Writer, prefix string, flag int) *Logger
</code></pre>
<p>methods:</p>
<pre><code>func (l *Logger) Flags() int
</code></pre>
<hr>
<h1 id="flag">flag</h1>
<p>实现了命令行参数解析</p>
<p>第三方包:</p>
<p><a href="https://github.com/alecthomas/kingpin">https://github.com/alecthomas/kingpin</a></p>
<h2 id="variables-4">variables</h2>
<pre><code>var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

//
var ErrHelp = errors.New(&quot;flag: help requested&quot;)

//
var Usage = func() {
    fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, os.Args[0])
    PrintDefaults()
}
</code></pre>
<h2 id="functions-6">functions</h2>
<pre><code>// 返回已被设置的flag数量
func NFlag() int
// 返回已注册flag的结构体指针
func Lookup(name string) *Flag

// 非flag参数不能在flag参数前面指定，否则flag参数不会被解析．
// 返回非flag参数个数
func NArg() int
// 返回所有非flag参数
func Args() []string
// 返回第i个非flag参数, i=0 就是第一个参数，而不是程序名称
func Arg(i int) string

// 向Stderr写入所有注册好的flag的默认值
func PrintDefaults()

// 从os.Args[1:] 中解析注册的flag.
func Parse()
// 返回是否Parse是否被调用过
func Parsed() bool

// 按照字典顺序遍历flag，并对每个flag调用fn, 只针对解析时设置了的flag
func Visit(fn func(*Flag))
// 按照字典顺序遍历flag,　并对每个flag调用fn, 针对所有flag.
func VisitAll(fn func(*Flag))

// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 返回一个保存了该flag的值的指针
func Bool(name string, value bool, usage string) *bool
// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 将flag值保存到指针p指向的变量
func BoolVar(p *bool, name string, value bool, usage string)

func Int
func IntVar
func Int64
func Int64Var

func Uint
func UintVar
func Uint64
func Uint64Var

func Float64
func Float64Var

func String
func StringVar

// time.Duration类型
func Duration
func DurationVar

// 用指定的名字，帮助信息，注册一个flag，类型由value决定
func Var(value Value, name string, usage string)
// 设置已注册的flag的值
func Set(name, value string) error
</code></pre>
<h2 id="errorhandling">ErrorHandling</h2>
<p>定义如何处理flag解析错误</p>
<pre><code>type ErrorHandling int

const (
    ContinueOnError ErrorHandling = iota
    ExitOnError
    PanicOnError
)
</code></pre>
<h2 id="flag-1">Flag</h2>
<p>定义一个flag</p>
<p>struct:</p>
<pre><code>type Flag struct {
    Name     string
    Usage    string
    Value    Value
    DefValue string
}
</code></pre>
<h2 id="flagset">FlagSet</h2>
<p>代表一个已注册flag集合.</p>
<p>FlagSet零值没有名字，默认采用ContinueOnError.</p>
<p>struct:</p>
<pre><code>type FlagSet struct {
    Usage func()
}
</code></pre>
<p>functions:</p>
<pre><code>// 创建一个新的FlagSet叫name，采用errorHandling为错误处理策略
func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet
</code></pre>
<p>methods:</p>
<pre><code>// 设置f的名字和错误处理策略.
func (f *FlagSet) Init(name string, errorHandling ErrorHandling)
</code></pre>
<h2 id="value">Value</h2>
<p>用于将动态值保存在flag里.</p>
<p>interface:</p>
<pre><code>type Value interface {
    String() string
    Set(string) error
}
</code></pre>
<h2 id="getter">Getter</h2>
<hr>
<h1 id="logrus">logrus</h1>
<p><a href="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></p>
<hr>
<h1 id="cobra">cobra</h1>
<p><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></p>

        </div>
    </article>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
