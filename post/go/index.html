<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go - Morgoth</title>
    <meta name="description" content="">
    
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #fff;
            padding: 1rem 0;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
        }
        nav {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        nav a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }
        nav a:hover {
            color: #007acc;
        }
        .site-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007acc;
        }
        main {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .post-meta {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        .post-content h1, .post-content h2, .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .post-list {
            list-style: none;
            padding: 0;
        }
        .post-list li {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #eee;
        }
        .post-list h2 {
            margin: 0 0 0.5rem 0;
        }
        .post-list h2 a {
            text-decoration: none;
            color: #333;
        }
        .post-list h2 a:hover {
            color: #007acc;
        }
        footer {
            text-align: center;
            padding: 2rem 0;
            color: #666;
            border-top: 1px solid #ddd;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <a href="https://canuxcheng.com/" class="site-title">Morgoth</a>
                
                    <a href="/">Home</a>
                
                    <a href="/about/">About</a>
                
                    <a href="/categories/">Categories</a>
                
                    <a href="/tags/">Tags</a>
                
                    <a href="/rtfm/">RTFM</a>
                
                    <a href="/samuel/">Samuel</a>
                
            </nav>
        </div>
    </header>
    
    <div class="container">
        <main>
            
<div class="single-post">
    <article>
        <header>
            <h1>Go</h1>
            <div class="post-meta">
                <time>January 1, 2018</time>
                
                    
                        <span class="category">Golang</span>
                    
                
                
                    
                        <span class="tag">#golang</span>
                    
                
            </div>
        </header>
        
        <div class="post-content">
            <h1 id="go概述">Go概述</h1>
<p><a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a></p>
<p>go语言表达能力强，简洁，清晰，高效．</p>
<p>go是一个快速的，静态的，强类型的，编译型语言．</p>
<p>go具有高并发和垃圾回收功能.</p>
<hr>
<h1 id="go基本语法">Go基本语法</h1>
<p>go源程序叫*.go</p>
<p>go大小写敏感</p>
<p>go程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．</p>
<p>go中只有首字母大写的名称才能从包中导出．</p>
<p>go的类型在变量名后面．</p>
<p>go函数外的每个语句都必须以关键字开始.</p>
<p>go标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.</p>
<p>go使用大括号{}表示一个代码块.</p>
<p>go使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．</p>
<p>go的包名一般是小写的单个单词(文件所在的最后一层目录名).</p>
<p>go一般使用驼峰命名法.</p>
<p>go没有逗号操作符.</p>
<p>go中++/&ndash;是语句不是表达式．</p>
<p>go中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.</p>
<hr>
<h1 id="go注释">Go注释</h1>
<p>单行注释：</p>
<pre><code>// comment
</code></pre>
<p>多行注释：</p>
<pre><code>/* comment */
</code></pre>
<hr>
<h1 id="go关键字">Go关键字</h1>
<pre><code>var const 
break continue for if else switch case default goto fallthrough
func return defer
package import
range type struct map
interface
select go chan
</code></pre>
<hr>
<h1 id="go运算符和优先级">Go运算符和优先级</h1>
<p>go中的运算都是从左到右结合．</p>
<pre><code>^    #
!    # 逻辑非

*
/    # 结果取整数
%
&lt;&lt;   # 位运算，左移
&gt;&gt;   # 位运算，右移
&amp;    # 位运算，　按位与
&amp;^   #

+
-
|    # 位运算,按位或
^    # 位运算,按位异或

==
!=
&lt;
&lt;=
&gt;
&gt;=

&lt;- # chan运算符

&amp;&amp;   # 逻辑与
||   # 逻辑或
</code></pre>
<hr>
<h1 id="go数据类型">Go数据类型</h1>
<h2 id="变量">变量</h2>
<p>定义/申明变量:</p>
<p>通过关键字var在包或函数中申明/定义变量</p>
<p>在函数或块中定义的变量作用域就是当前函数或当前块。</p>
<p>在函数外部定义的全局变量作用域是整个包.</p>
<p>大写字母开头的全局变量能被其它包引用。</p>
<p>全局变量必须使用var关键字．</p>
<p>没有初始化的变量在申明的时候赋予零值.</p>
<p>已经申明但没有使用的变量在编译时会报错．</p>
<p>通过等号给变量赋值就是定义变量.</p>
<p>大写字母开头的变量是public, 小写字母开头的是private变量.</p>
<p>申明变量:</p>
<pre><code># 一个变量一种类型
var varname Type

# 多个变量一种类型
var varname varname1 ... Type
</code></pre>
<p>定义(初始化)变量:</p>
<pre><code># 定义的时候初始化
var i, j int = 1, 2
# 初始化使用表达式可以省略类型，从值中获取类型
var i, j = true, &quot;str&quot;

# 多个变量多种类型
var (
    var1 Type1 = val1
    var2 Type2 = val2
    # 给类型取别名
    variable alias Type = value
    ...
)
</code></pre>
<p>特殊变量：</p>
<pre><code>_  # 下划线是个特殊变量名，用于忽略一个值.
</code></pre>
<h2 id="常量">常量</h2>
<p>定义常量：</p>
<p>通过关键字const在包或函数中定义常量．</p>
<pre><code># 常量可以是bool, string, 数值
const Pi float = 3.14
const World = &quot;China&quot;
const Truth = true
# 定义多个常量
const (
    Pi = 3.14
    ...
)
</code></pre>
<p>枚举:</p>
<pre><code># iota内置常量用来统计枚举中的行数
const (
    con = val
    ...
)
</code></pre>
<p>常量不能用:=语法来申明。</p>
<h2 id="bool">bool</h2>
<p>bool类型变量的零值是false.</p>
<p>bool类型是值传递．</p>
<pre><code>true
false
</code></pre>
<h2 id="数值类型">数值类型</h2>
<p>数值类型变量的零值是0.</p>
<p>数值类型是值传递.</p>
<p>有符号类型：</p>
<pre><code>int int8 int16 int32(rune) int64
</code></pre>
<p>无符号类型:</p>
<pre><code>uint uint8(byte) uint16 uint32 uint64 uintptr
</code></pre>
<p>int, uint, uintptr 在32位系统是32bit, 在64位系统是64bit</p>
<p>浮点类型：</p>
<pre><code>float32
float64
</code></pre>
<p>复数类型：</p>
<pre><code>complex64
complex128
</code></pre>
<h2 id="string">string</h2>
<p>string类型变量的零值是&quot;&quot;.</p>
<p>string类型是值传递.</p>
<p>go中的字符串都采用utf-8编码.</p>
<p>go中的字符串用双引号  或者　反引号</p>
<pre><code># 单行字符串
var str string = &quot;hello&quot;
# 多行字符串(原样输出)
var str string = `hello
                 world`

var str = &quot;hello&quot; // 类型可以通过值确定
</code></pre>
<p>go中的字符串是不可变的, 修改字符串：</p>
<pre><code># 使用类型转换
var str string = &quot;hello&quot;
c := []byte(str) # str转换成 []byte 类型
c[index] = value # 重新赋值
newString := string(c) # []byte 转换成 string

# 使用索引运算
s := &quot;hello&quot;
s = &quot;str&quot; + s[1:]
</code></pre>
<p>字符串运算：</p>
<pre><code>s1 := &quot;hello&quot;
s2 := &quot;world&quot;
s3 := s1 + s2
</code></pre>
<p>遍历字符串：</p>
<pre><code>for index, value := range s {...}
for index := range s {...}
for _, value := range s {...}
</code></pre>
<h2 id="结构体struct">结构体/struct</h2>
<p>结构体就是字段的集合．结构体字段通过点操作符来访问．</p>
<p>结构体是值传递.</p>
<p>申明一个结构体类型：</p>
<pre><code>type StructName struct {
    var Type
    var1 Type1
    ...
}
</code></pre>
<p>申明多个结构体类型:</p>
<pre><code>type (
    StructB struct {
        ...
    }

    StructB struct {
    }
)
</code></pre>
<p>申明一个结构体类型的变量</p>
<pre><code>var s StructName
</code></pre>
<p>定义结构体变量:</p>
<pre><code># 列出全部字段
var s = StructName{val, ...}
s := StructName{val, ...}

# 使用val: 可以仅列出部分字段, 未列出的字段使用默认值
var s = StructName{
    var: val,
    ...
}
s := StructName{
    var: val,
    ...
}

# 给字段赋值
s.var1 = value
</code></pre>
<p>结构体指针:</p>
<pre><code>type StructName struct {
    var Type
    var1 Type1
}

var s = &amp;StructName{}
s := &amp;StructName{}

(*s).Var1 = val1
s.Var1 = val1 // go允许隐士间接引用

s := StructName{val, val1}
p := &amp;s
# 原本应该通过(*p).var来访问，go允许隐式间接引用．
p.var = p.var1
</code></pre>
<h2 id="指针pointer">指针/pointer</h2>
<p>指针的零值为nil.</p>
<p>go的指针保存了值的内存地址, go没有指针运算．</p>
<p>通过指针实现引用传递.</p>
<p>申明一个指针变量：</p>
<pre><code>var point *int
</code></pre>
<p>&amp;操作符会生成一个指向其操作数的指针(保存变量的地址)：</p>
<pre><code>point = &amp;variable
</code></pre>
<p>*操作符表示指针指向的数值(读写该地址保存的值：</p>
<pre><code>*point = value
</code></pre>
<h2 id="数组array">数组/array</h2>
<p>数组通过下标来访问．数组不能改变大小（长度）</p>
<p>数组是值传递．</p>
<p>数组的属性有类型和长度,只有长度和类型都相同的才是同类型数组,才能相互赋值.</p>
<p>数组长度和容量相同．</p>
<p>申明数组:</p>
<pre><code>var ArrayName [number]Type
</code></pre>
<p>定义数组：</p>
<pre><code>var ArrayName = [number]Type{}

ArrayName := [number]Type{val, val1, ...}
ArrayName := [number]Type{index: value, ...} // 给指定索引赋值,其余为零值
ArrayName := []Type{val, ...} // 容量也可以由初始化的元素个数决定.

ArrayName := [number]*Type{0: new(int), 1: new(string), ...} // 指针数组
</code></pre>
<p>数组元素赋值：</p>
<pre><code>ArrayName[0] = val

*ArrayName[0] = val // 指针数组
</code></pre>
<p>数组赋值（值传递）：</p>
<pre><code># 只有类型和长度相同的数组才能赋值
# 非指针数组赋值，会另外开辟地址空间.
 # 修改newArray的值，不会改变ArrayName的值
 newArray = ArrayName

# 指针类型的数组赋值，指向的是相同的地址.
</code></pre>
<p>多维数组(嵌套数组):</p>
<pre><code>doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6 7, 8}}
</code></pre>
<p>遍历数组：</p>
<pre><code>for index, value := range a {
    fmt.Println('%d, %d\n', index, value)
}

# 只要索引, 去掉,value即可
for index := range a {...}
# 只要值，用_忽略索引
for _, value := range a {...}
</code></pre>
<h2 id="切片slice">切片/slice</h2>
<p>切片的零值是nil, nil切片的长度和容量都是０，且没有底层数组．</p>
<p>切片传递的是地址(引用传递),修改切片的元素值其实就是修改底层数组的对应的元素的值,共享该元素的其它切片的值也相应改变．</p>
<p>切片的属性包括指向底层数组的指针，切片的长度，切片的容量.</p>
<p>切片不存储数据，只是描述数组的一段,因此切片不指定大小（长度）.</p>
<pre><code># 表示切片类型
[]Type
</code></pre>
<p>申明切片:</p>
<pre><code>var SliceName []Type
</code></pre>
<p>定义切片：</p>
<pre><code>// 通过字面量定义
var SliceName = []Type{}
SliceName := []Type{val, val1, ...}

SliceName := []Type{index: value}   // 索引就表示长度和容量

// 通过make函数创建切片
var SliceName = make([]type, len, cap)
SliceName := make([]Type, len, cap)
</code></pre>
<p>通过切片定义新切片:</p>
<pre><code>切片的操作返回新的切片。
NewS := SName[i:j]
cap(SName) = k
NewS 长度和容量：
len = j-i
cap = k-i
NewS 无法访问指向的底层数组第一个元素之前的元素。
也不能访问超出长度之后的索引,但是可以通过append增加切片长度之后访问.
NewS[index] //当index &gt;= j编译器报错 ，超出了NewS 的长度，无法访问。
</code></pre>
<p>三索引操作:</p>
<pre><code>NewS := SName[i:j:k]
三索引表示容量， i:j 表示长度， i:k 表示容量.
容量不能超过可用容量(也就是SName的容量).
</code></pre>
<p>切片操作：</p>
<pre><code># 半开区间，不包括最后一个下标
s[low:high]
s[:high] // low=0, default
s[low:] // high=max, default
s[:] // s[0:max], default

s[:0] // 把切片的长度变为０（清空切片)
s[:4] // 扩展为４
s[2:] // 扩展为 arrayname[2:4]
</code></pre>
<p>二维切片：</p>
<pre><code>[][]Type
</code></pre>
<p>遍历切片：</p>
<pre><code># 切片遍历和数组相同
for index, value := range s {
    ...
}
for index := range s {...}
for _, value := range s {...}
</code></pre>
<p>slice作为函数参数:</p>
<pre><code>切片作为函数参数，传递的其实是值,函数会使用和切片相同的底层数组创建一个新的切片来操作.
所以函数内部修改了切片的值,作为参数的切片的值也被修改了.
</code></pre>
<h2 id="映射map">映射/map</h2>
<p>映射的零值是nil, 既没有键，也不能添加键．</p>
<p>map是引用传递．是存储键值对的无序集合.</p>
<p>map是无序的，只能通过key索引，没有下标操作.</p>
<p>map的key需要支持==或!= 运算，不能是函数，映射，切片</p>
<p>申明:</p>
<pre><code>// 申明值为nil的空映射，不能用于存储键值对.
var MapName map[keyType]ValueType
</code></pre>
<p>定义映射：</p>
<pre><code>var MapName = map[keyType]ValueType{}
var MapName = map[keyType]ValueType{
    key: value,
    ...
}

MapName := map[keyType]valueType{}
MapName := map[KeyType]ValueType{
    &quot;key&quot;: value,
    ...
}

# 通过make定义map
var MapName = make(map[keyType]ValueType, cap)
MapName := make(map[keyType]ValueType, cap)
</code></pre>
<p>映射操作：</p>
<pre><code>m[key] = value

value = m[key]
# 若key在m中ok为true, 否则为false, 且value是对应类型的零值
value, ok := m[key]
</code></pre>
<p>遍历映射：</p>
<pre><code>for key, value := range m {...}
for key := range m {...}
for _, value := range m {...}
</code></pre>
<p>map作为函数参数:</p>
<pre><code>不会创建该映射的副本，该函数对映射的修改就是对原始参数指向的映射的修改.
</code></pre>
<h2 id="类型转换">类型转换</h2>
<p>go中兼容的类型才能转换，而且必须显示转换．</p>
<pre><code>ValueA [:]= TypeA(ValueB)

floatA := float64(uint64Var)
</code></pre>
<h2 id="others">others</h2>
<p>any</p>
<p>comparable</p>
<p>byte</p>
<p>error</p>
<hr>
<h1 id="go控制流">Go控制流</h1>
<p>go控制流的左大括号不能另起一行．</p>
<p>golang没有内置的while循环。</p>
<h2 id="for循环">for循环</h2>
<p>go只有for可以循环．</p>
<pre><code>for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre>
<p>for循环有三种模式：</p>
<p>for循环后面没有小括号，代码块必须要大括号．</p>
<pre><code>for init; condition; statement {
    ...
}
</code></pre>
<p>for循环的初始化语句init和后置语句statement可以省略,相当于while．</p>
<pre><code>for condition {
    ...
}
</code></pre>
<p>无限循环, 相当于for(;;)：</p>
<pre><code>for {
    ...
}
</code></pre>
<h2 id="if条件语句">if条件语句</h2>
<p>if后面的小括号不要，但是代码块需要大括号．</p>
<pre><code>if condition {
    ...
} else if condition {
    ...
} else {
    ...
}
</code></pre>
<h2 id="switch条件语句">switch条件语句</h2>
<p>go中的switch-case的variable无需为常量，且取值可以不是整数．</p>
<p>go中的只执行匹配的case，相当于默认在每个case后面加了break语句．</p>
<p>case匹配到的语句如果只有一行可以和case语句写在同一行</p>
<pre><code>switch variable {
case value1:
    ...
case value2: expression
default:
    ...
}
</code></pre>
<p>多个条件可以放到一个case:</p>
<pre><code>switch variable {
    case value1, value2, ...: expression
    case valuen: fallthrough
    defalut:
        ...
}
</code></pre>
<p>没有条件的switch-case</p>
<pre><code>switch {
case condition:
    ...
...
}
</code></pre>
<p>如果不需要默认的break,需要添加fallthrough:</p>
<p>fallthrough不会判断后面的case的condition,而是直接执行后面所有的case.</p>
<pre><code>switch variable {
case val1:
    ...
    fallthrough
...
}
</code></pre>
<h2 id="label">label</h2>
<p>golang的label不需要缩进:</p>
<pre><code>LabelName:
</code></pre>
<h2 id="break">break</h2>
<p>break用于跳出for/switch/select循环.</p>
<pre><code>break
</code></pre>
<p>break也支持label:</p>
<p>break的label可以跳出外层循环.</p>
<pre><code>break [tag]

label:
for i := 0; i &lt; 1000; i++ {
    for j :=0; j &lt; 1000; j++ {
        if j &lt; i {
            break label // 跳出最外层循环.
        }
    }
}
</code></pre>
<h2 id="continue">continue</h2>
<p>continue语句只能在for循环中使用</p>
<pre><code>continue
</code></pre>
<p>continue也支持label:</p>
<p>continue的label可以从外层循环继续执行.</p>
<pre><code>continue [tag]

next:
for outer := 2; outer &lt; 3000; outer++ {
    for inner :=2; inner &lt; outer; inner++ {
        if outer%inner == 0 {
            continue next // 并非继续内存循环，而是从外层循环继续执行.
        }
    }
}
</code></pre>
<h2 id="goto">goto</h2>
<p>goto跳转语句，跳转到指定标签运行．</p>
<p>标签区分大小写.</p>
<pre><code>Label:
    expression

...
goto Label
continue LABEL
break LABEL
...
</code></pre>
<hr>
<h1 id="go函数">Go函数</h1>
<p>函数的零值是nil.</p>
<p>函数是引用类型.</p>
<p>大写字母开头的函数是public, 小写字母开头的是private.</p>
<p>创建函数：</p>
<pre><code>func FuncName(var Type, var1 Type1) rType {
    ...
    return ...
}
</code></pre>
<p>多值返回：</p>
<pre><code>func FuncName(var Type) (rType, rType1, ...) {
    ...
    return ...
}
</code></pre>
<p>命名返回值(必须用括号)：</p>
<pre><code>// 一般return后面不带返回值，否则需要返回定义的所有变量
func FuncName(var Type) (rvar rType, rvar1 rType) {
    ...
    rvar = ...
    rvar1 = ...
    return
}
</code></pre>
<p>多个变量类型相同时保留最后一个的类型即可：</p>
<pre><code>func FuncName(var, var1 Type) (rvar, rvar1 rType) {
    ...
    return ...
}
</code></pre>
<p>变量作用域：</p>
<pre><code>函数内部定义的变量是局部变量
函数外定义的变量是全局变量．
局部变量优先使用．
</code></pre>
<p>形式参数：</p>
<pre><code>形式参数的作用域范围和函数体中的局部变量一致．
</code></pre>
<p>返回值：</p>
<pre><code>函数返回值的作用域范围和函数体中的局部变量一致．
</code></pre>
<p>实际参数：</p>
<pre><code>实际参数可以是值传递，也可以是引用传递．
</code></pre>
<p>指针参数：</p>
<pre><code># 实参必须是指针才能调用该函数
func FuncName(v *Type) rType {
    ...
}
</code></pre>
<p>函数中短变量申明(局部变量):</p>
<pre><code># 在函数内部，明确值的类型的情况下可以用 := 代替var关键字定义变量
func FuncName() {
    variable := value
    var1, var2, ... := val1, val2, ...
}
</code></pre>
<p>重复申明短变量：</p>
<pre><code>本次申明与已申明的变量在同一作用域．
在初始化中与已申明的变量类型相同才能赋值．
本次申明中至少另有一个变量是新申明的．
</code></pre>
<p>defer关键字：</p>
<p>defer会将函数推迟到外层函数返回之后执行.</p>
<p>推迟调用的函数其参数会立即求值，然后压入defer栈中,外层函数返回后按照后进先出的顺序调用．</p>
<pre><code>func FuncOut() {
    ...
    defer FuncName()
    ...
}
</code></pre>
<p>函数也是值，也可以传递，可以用作函数的参数或返回值：</p>
<pre><code>func FuncName(variable func(Type, ...) rType) rType {
    ...
}

FuncName := func(variable Type, ...) rType {
    ..
}
</code></pre>
<p>匿名函数:</p>
<pre><code>func(&lt;arguments&gt;) (returns) {}()
</code></pre>
<p>可变参数:</p>
<pre><code>func FuncName(vars ...Type) rType {}
FuncName(vars..)
</code></pre>
<p>closures/闭包:</p>
<p>init函数:</p>
<pre><code># 每个包中可以有任意个init函数.
# 这些init函数会在main函数执行之前调用.
# init函数不能有参数和返回值
# main中的init最后调用.
func init() {}
</code></pre>
<hr>
<h1 id="go文件和输入输出">Go文件和输入输出</h1>
<p>go的标准库fmt实现了类似于C语言的printf和scanf格式化I/O函数.</p>
<p>还有io和bufio标准库可用</p>
<h2 id="输入">输入</h2>
<p>输入的本质就是从Stdin读取</p>
<p>fmt:</p>
<pre><code>var input string
fmt.Scan*(&amp;input)
</code></pre>
<p>bufio.Reader:</p>
<pre><code>inputReader := bufio.NewReader(os.Stdin)
inputReader.Read*()
</code></pre>
<h2 id="输出">输出</h2>
<p>输出的本质就是往os.Stdout写</p>
<p>fmt:</p>
<pre><code>fmt.Print*()
</code></pre>
<p>os.File:</p>
<pre><code>os.Stdout.Write*(&quot;hello&quot;)
</code></pre>
<p>bufio.Writer:</p>
<pre><code>outputWriter := bufio.NewWriter(os.Stdout)
outputWriter.Writer*()
outputWriter.Flush()
</code></pre>
<h2 id="文件">文件</h2>
<p>标准库os.File结构的指针用来表示文件句柄</p>
<p>标准库bufio提供了带缓冲的操作</p>
<p>读文件</p>
<pre><code>readFile, err := os.Open(&quot;filename&quot;)
readFile.Read*()

inputReader := bufio.NewReader(readFile)
inputReader.Read*('\n')
</code></pre>
<p>写文件</p>
<pre><code>writeFile, err := os.Create(&quot;filename&quot;)
writeFile.Write*()

outputWriter := bufio.NewWriter(outputFile)
outputWriter.Write*(&quot;string&quot;)
outputWriter.Flush()
</code></pre>
<hr>
<h1 id="go错误和异常">Go错误和异常</h1>
<p>go的标准库errors实现了用于错误处理的函数.</p>
<p>内置函数panic是断言函数，会触发一个异常，用于终止当前的线程(会在defer执行完之后终止线程)</p>
<p>内置接口定义了error接口类型, error类型都有一个Error方法.</p>
<pre><code>type error interface {
    Error() string
}
</code></pre>
<p>定义错误:</p>
<pre><code>var errName error = errors.New(&quot;error message.&quot;)

err := errors.New(&quot;error message.&quot;)

err := fmt.Errorf(format string, a ...interface{})
</code></pre>
<p>panic:</p>
<p>相当于抛出一个异常，在运行完defer之后,返回到调用者继续运行defer，直到最外层的defer执行完毕，终止程序.</p>
<pre><code>panic(v interface{})
panic(&quot;ERROR: command not found&quot;)
</code></pre>
<p>recover:</p>
<p>只能用于defer修饰的函数，用于接收panic调用中传递过来的错误值,没有panic返回nil.</p>
<p>当前函数的后面不会被执行，recover捕获异常之后会返回到调用者继续执行.</p>
<p>相当于catch一个异常.</p>
<pre><code>recover() interface{}
defer func() {
    if err := recover(); err != nil {
        fmt.Println(e)
        // &quot;ERROR: command not found&quot;
    }
}()
</code></pre>
<p>总结：</p>
<ol>
<li>在包内部，总是应该从panic中recover．</li>
<li>总是向包的调用者返回错误值，而不是panic.</li>
</ol>
<hr>
<h1 id="go包">Go包</h1>
<p>创建包：</p>
<p>包名一般和所在路径的最后一层目录一致．一般是小写的单个单词.</p>
<p>同一个目录中的代码文件使用同一个包名．</p>
<pre><code>package pkg1
</code></pre>
<p>单个导入:</p>
<pre><code>import &quot;pkg1&quot;
import &quot;pkg2&quot;
# 导入时创建别名
import alias &quot;pkg&quot;
</code></pre>
<p>组合导入:</p>
<pre><code>import (
    &quot;pkg1&quot;
    &quot;pkg2&quot;
    ...
)
</code></pre>
<p>包内的函数名首字母大些才能被其它包导入，否则就是私有的．</p>
<p>命名导入:</p>
<pre><code>import (
    alias &quot;pkg&quot; # 给包取别名
)
</code></pre>
<p>导入副作用：</p>
<p>只执行导入包中的init函数并初始化全局变量，不导入其它内容．</p>
<p>编译时不检查该导入是否使用.也不能通过包名调用其中的导出函数.</p>
<pre><code>import _ &quot;path/pkg&quot;

import (
    _ &quot;path/pkg&quot;
)
</code></pre>
<p>go包查找顺序:</p>
<pre><code>$GOROOT/src/... # 安装golang的路径里面的标准库
$GOPATH
</code></pre>
<hr>
<h1 id="go文档">Go文档</h1>
<p>通过注释编写文档，godoc会自动识别．对包，函数，类型，全局变量都可以.</p>
<pre><code>// this is documents
func Fucntion() {}

/*
    This is documents
*/
type St struct {}
</code></pre>
<p>也可以给包写一段文字较多的文档，通过在包内创建doc.go.</p>
<p>这段文档会显示在所有其它文档之前．</p>
<pre><code># vim doc.go
/*
    This docs for package
    ...
*/
package pkg # 使用和包一样的名字.
</code></pre>
<hr>

        </div>
    </article>
</div>

        </main>
    </div>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 Morgoth. Designed by Canux</p>
        </div>
    </footer>
</body>
</html>
