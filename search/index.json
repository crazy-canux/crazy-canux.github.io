[
  {
    "title": "DevOps Metrics",
    "permalink": "https://canuxcheng.com/post/devops_metrics/",
    "date": "2025-01-10",
    "summary": "\u003ch1 id=\"devops-metrics\"\u003eDevOps Metrics\u003c/h1\u003e\n\u003cp\u003e从业务角度来看，公司希望更准确地度量其开发人员的生产力，原因如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMonitoring progress over time\u003c/li\u003e\n\u003cli\u003eCreation of benchmarks\u003c/li\u003e\n\u003cli\u003eRewarding top performers\u003c/li\u003e\n\u003cli\u003eDetermining resource allocation\u003c/li\u003e\n\u003cli\u003eIdentification of more productive development processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e框架是想法、概念和关系的简单总结，因此基于您的上下文、环境和团队，您可以选择一组您可以解释的指标，以确定团队是否在它应该在的地方。\u003c/p\u003e\n\u003ch2 id=\"dora\"\u003eDORA\u003c/h2\u003e\n\u003cp\u003eDevOps Research and Assessment.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://getdx.com/\"\u003ehttps://getdx.com/\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"speed-metrics\"\u003eSpeed metrics\u003c/h3\u003e\n\u003cp\u003eDeployment frequency: This measures how often a team deploys code to production.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLow performance: once per month - once per semester. (inadequate integration, lack of automation.)\u003c/li\u003e\n\u003cli\u003eMedium performance: once per month - once per week.\u003c/li\u003e\n\u003cli\u003eHigh performance: daily for multiple times per day.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLead time for change: This measures the time it takes from the moment a code change is made until it is successfully deployed to production.\u003c/p\u003e",
    "content": "DevOps Metrics 从业务角度来看，公司希望更准确地度量其开发人员的生产力，原因如下:\nMonitoring progress over time Creation of benchmarks Rewarding top performers Determining resource allocation Identification of more productive development processes 框架是想法、概念和关系的简单总结，因此基于您的上下文、环境和团队，您可以选择一组您可以解释的指标，以确定团队是否在它应该在的地方。\nDORA DevOps Research and Assessment.\nhttps://getdx.com/\nSpeed metrics Deployment frequency: This measures how often a team deploys code to production.\nLow performance: once per month - once per semester. (inadequate integration, lack of automation.) Medium performance: once per month - once per week. High performance: daily for multiple times per day. Lead time for change: This measures the time it takes from the moment a code change is made until it is successfully deployed to production.\nLow performance: one - six months. (time-consuming manual testing, lack of automation.) Medium performance: one week - one month. High performance: less than one day. Stability metrics change failure rate: This metric measures the proportion of deployments that result in failures.\nPoor performance: 46% - 60%. (quality and reliability issues). Average performance: 15%-45%. High performance: 0% - 15%. mean time to restore: This metric helps assess team’s ability to handle incidents and failures.\nLow performance: one week - one month. (lack of adequate monitoring and diagnostic tools). Medium performance: one day - one week. High performance: less than one day. SPACE S: Satisfaction and well-being\nP: Performance\nA: Activity\nC: Collaboration and communication\nE: Efficiency and flow\nDevEx Developer Experience: DevEx captures how developers feel, how they think, and how they value their work.\nFeedback loops perceptions:\nsatisfaction with automated test speed and output. satisfaction with time it takes to validate a local change. satisfaction with time it takes to deploy a change to production. workflows:\ntime it takes to generate CI results. code review turnaround time. deployment lead time. Cognitive load perceptions\nperceive complexity of codebase. ease of debugging production systems easy of understanding documentation. workflows\ntime it takes to get answers to technical questions. manual steps required to deploy a change. frequency of documentation improvements. Flow state perceptions\nperceived ability to focus and avoid interruptions. satisfaction with clarity of task or project goals. perceived disruptiveness of being on-call. workflows\nnumber of blocks of time without meetings or interruptions. frequency of unplanned tasks or requests. frequency of incidents requiring team attention. ",
    "categories": ["DevOps"],
    "tags": ["devops"]
  },
  {
    "title": "Secret",
    "permalink": "https://canuxcheng.com/post/sec_secret/",
    "date": "2024-07-28",
    "summary": "\u003ch1 id=\"secret\"\u003eSecret\u003c/h1\u003e\n\u003cp\u003esecret scan tools\u003c/p\u003e\n\u003ch2 id=\"trufflehog\"\u003etrufflehog\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/trufflesecurity/trufflehog\"\u003ehttps://github.com/trufflesecurity/trufflehog\u003c/a\u003e\u003c/p\u003e",
    "content": "Secret secret scan tools\ntrufflehog https://github.com/trufflesecurity/trufflehog\n",
    "categories": ["Security"],
    "tags": ["CA"]
  },
  {
    "title": "React",
    "permalink": "https://canuxcheng.com/post/js_react/",
    "date": "2024-01-27",
    "summary": "\u003ch1 id=\"react\"\u003eReact\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://react.dev/\"\u003ehttps://react.dev/\u003c/a\u003e\u003c/p\u003e",
    "content": "React https://react.dev/\n",
    "categories": ["Web"],
    "tags": ["react"]
  },
  {
    "title": "AWS Development",
    "permalink": "https://canuxcheng.com/post/aws_development/",
    "date": "2024-01-23",
    "summary": "\u003ch1 id=\"development\"\u003eDevelopment\u003c/h1\u003e\n\u003ch2 id=\"tools\"\u003eTools\u003c/h2\u003e\n\u003ch3 id=\"cloud9\"\u003eCloud9\u003c/h3\u003e\n\u003ch3 id=\"codeartifact\"\u003eCodeArtifact\u003c/h3\u003e\n\u003ch3 id=\"codebuild\"\u003eCodeBuild\u003c/h3\u003e\n\u003ch3 id=\"codecommit\"\u003eCodeCommit\u003c/h3\u003e\n\u003ch3 id=\"codedeploy\"\u003eCodeDeploy\u003c/h3\u003e\n\u003ch3 id=\"codeguru\"\u003eCodeGuru\u003c/h3\u003e\n\u003ch3 id=\"codepipeline\"\u003eCodePipeline\u003c/h3\u003e\n\u003ch3 id=\"codestar\"\u003eCodeStar\u003c/h3\u003e\n\u003ch3 id=\"x-ray\"\u003eX-Ray\u003c/h3\u003e\n\u003chr\u003e\n\u003ch2 id=\"blockchain\"\u003eBlockchain\u003c/h2\u003e\n\u003chr\u003e\n\u003ch2 id=\"multimedia\"\u003eMultimedia\u003c/h2\u003e\n\u003ch3 id=\"elastic-transcoder\"\u003eElastic Transcoder\u003c/h3\u003e\n\u003ch3 id=\"kinesis-video-streams\"\u003eKinesis Video Streams\u003c/h3\u003e\n\u003chr\u003e\n\u003ch2 id=\"webmobile\"\u003eWeb\u0026amp;Mobile\u003c/h2\u003e\n\u003ch3 id=\"amplify\"\u003eAmplify\u003c/h3\u003e\n\u003ch3 id=\"api-gateway\"\u003eAPI Gateway\u003c/h3\u003e\n\u003ch3 id=\"device-farm\"\u003eDevice Farm\u003c/h3\u003e\n\u003ch3 id=\"pinpoint\"\u003ePinpoint\u003c/h3\u003e\n\u003chr\u003e\n\u003ch2 id=\"iot\"\u003eIoT\u003c/h2\u003e\n\u003ch3 id=\"iot-analytics\"\u003eIoT Analytics\u003c/h3\u003e\n\u003ch3 id=\"iot-core\"\u003eIoT Core\u003c/h3\u003e\n\u003ch3 id=\"iot-events\"\u003eIoT Events\u003c/h3\u003e\n\u003cp\u003e\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"mlai\"\u003eML\u0026amp;AI\u003c/h2\u003e\n\u003ch3 id=\"comprehend\"\u003eComprehend\u003c/h3\u003e\n\u003ch3 id=\"forecast\"\u003eForecast\u003c/h3\u003e\n\u003ch3 id=\"fraud-detector\"\u003eFraud Detector\u003c/h3\u003e\n\u003ch3 id=\"kendra\"\u003eKendra\u003c/h3\u003e\n\u003ch3 id=\"lex\"\u003eLex\u003c/h3\u003e\n\u003cp\u003e\u0026hellip;\u0026hellip;\u003c/p\u003e",
    "content": "Development Tools Cloud9 CodeArtifact CodeBuild CodeCommit CodeDeploy CodeGuru CodePipeline CodeStar X-Ray Blockchain Multimedia Elastic Transcoder Kinesis Video Streams Web\u0026amp;Mobile Amplify API Gateway Device Farm Pinpoint IoT IoT Analytics IoT Core IoT Events \u0026hellip;\u0026hellip;\nML\u0026amp;AI Comprehend Forecast Fraud Detector Kendra Lex \u0026hellip;\u0026hellip;\n",
    "categories": ["Cloud"],
    "tags": ["aws"]
  },
  {
    "title": "Security",
    "permalink": "https://canuxcheng.com/post/k8s_security/",
    "date": "2023-10-19",
    "summary": "\u003ch1 id=\"k8s-security\"\u003eK8S Security\u003c/h1\u003e\n\u003ch2 id=\"tetragon\"\u003eTetragon\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cilium/tetragon\"\u003ehttps://github.com/cilium/tetragon\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"falco\"\u003eFalco\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/falcosecurity/falco\"\u003ehttps://github.com/falcosecurity/falco\u003c/a\u003e\u003c/p\u003e",
    "content": "K8S Security Tetragon https://github.com/cilium/tetragon\nFalco https://github.com/falcosecurity/falco\n",
    "categories": ["CNCF","Security"],
    "tags": ["k8s"]
  },
  {
    "title": "API Gateway",
    "permalink": "https://canuxcheng.com/post/k8s_apigateway/",
    "date": "2023-08-04",
    "summary": "\u003ch1 id=\"api-gateway\"\u003eAPI Gateway\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/gateway-api\"\u003ehttps://github.com/kubernetes-sigs/gateway-api\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eGatewayClass没有namespace\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eemissary ingress\u003c/li\u003e\n\u003cli\u003ekong\u003c/li\u003e\n\u003cli\u003ehigress\u003c/li\u003e\n\u003c/ul\u003e",
    "content": "API Gateway https://github.com/kubernetes-sigs/gateway-api\nGatewayClass没有namespace\nemissary ingress kong higress ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "First_Aid",
    "permalink": "https://canuxcheng.com/post/first_aid/",
    "date": "2023-07-17",
    "summary": "\u003ch1 id=\"first-aid\"\u003eFirst Aid\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/images/fa1.jpg\" alt=\"pic0\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/fa2.jpg\" alt=\"pic1\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e确认现场环境安全\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e判断呼吸和意识\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e先跪下判断意识和呼吸情况，两手拍肩膀呼叫，判断意识，看胸口起伏判断呼吸，数数1001，1002，\u0026hellip; 1008 八秒；如果没有意识和呼吸才需要心肺复苏。否则可能是气道梗阻。\u003c/p\u003e\n\u003ch2 id=\"气道梗阻\"\u003e气道梗阻\u003c/h2\u003e\n\u003cp\u003e不完全气道梗阻：\u003c/p\u003e\n\u003cp\u003e有意识，能沟通，优先咳嗽排出。\n其次采用背部叩击。\n最后才使用腹部冲击（海姆利克法）。\u003c/p\u003e\n\u003cp\u003e完全气道梗阻：\u003c/p\u003e\n\u003cp\u003e没有意识，没有呼吸，需要心肺复苏。\u003c/p\u003e\n\u003ch2 id=\"心肺复苏\"\u003e心肺复苏\u003c/h2\u003e\n\u003cp\u003e来人啊，救命啊，有人晕倒了，我是急救员，请你拨打120，有AED一并带来，会急救的和我一起。\u003c/p\u003e\n\u003cp\u003e胸部按压30次01，02\u0026hellip; 30，深度5cm左右，确保完全回弹。\u003c/p\u003e\n\u003cp\u003e然后清理口腔异物，吹气两次。\u003c/p\u003e\n\u003cp\u003e胸部按压和吹气连续做5组。\u003c/p\u003e\n\u003cp\u003e每做完5组检查脉搏和呼吸。一只手放头部，另一只手两个指头放劲动脉。计数1001，1002，\u0026hellip; 1008；若有呼吸抢救成功，否则重复上述步骤。\u003c/p\u003e\n\u003cp\u003e如果有AED，随到随用，先打开电源，一个贴片用于病人右侧胸部上方，一个用于左侧胸部侧方，提醒旁人离开，开始分析是否需要除颤，若需要提示旁人离开，按下按钮。提示完成后继续心肺复苏。\u003c/p\u003e",
    "content": "First Aid 确认现场环境安全\n判断呼吸和意识\n先跪下判断意识和呼吸情况，两手拍肩膀呼叫，判断意识，看胸口起伏判断呼吸，数数1001，1002，\u0026hellip; 1008 八秒；如果没有意识和呼吸才需要心肺复苏。否则可能是气道梗阻。\n气道梗阻 不完全气道梗阻：\n有意识，能沟通，优先咳嗽排出。 其次采用背部叩击。 最后才使用腹部冲击（海姆利克法）。\n完全气道梗阻：\n没有意识，没有呼吸，需要心肺复苏。\n心肺复苏 来人啊，救命啊，有人晕倒了，我是急救员，请你拨打120，有AED一并带来，会急救的和我一起。\n胸部按压30次01，02\u0026hellip; 30，深度5cm左右，确保完全回弹。\n然后清理口腔异物，吹气两次。\n胸部按压和吹气连续做5组。\n每做完5组检查脉搏和呼吸。一只手放头部，另一只手两个指头放劲动脉。计数1001，1002，\u0026hellip; 1008；若有呼吸抢救成功，否则重复上述步骤。\n如果有AED，随到随用，先打开电源，一个贴片用于病人右侧胸部上方，一个用于左侧胸部侧方，提醒旁人离开，开始分析是否需要除颤，若需要提示旁人离开，按下按钮。提示完成后继续心肺复苏。\n",
    "categories": ["Misc"],
    "tags": ["misc"]
  },
  {
    "title": "Arduino",
    "permalink": "https://canuxcheng.com/post/hardware_arduino/",
    "date": "2023-05-15",
    "summary": "\u003ch1 id=\"arduino-uno\"\u003eArduino Uno\u003c/h1\u003e\n\u003cp\u003etinogo-windows开发环境配置\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tinygo.org/getting-started/install/windows/\"\u003ehttps://tinygo.org/getting-started/install/windows/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escoop install go\nscoop install tinygo\nscoop install avrdude\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewindows烧写程序\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etinygo flash -monitor -baudrate=9600 -target arduino -port COMX /path/to/blinky1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emacos烧写程序\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etinygo flash --target arduino -port /dev/cu.usbserial-0001 ./blinking.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"microcontroller\"\u003eMicrocontroller\u003c/h2\u003e\n\u003cp\u003eArduino Uno 使用的是ATmega328p 控制器\u003c/p\u003e\n\u003cp\u003e支持的外设接口:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGPIO：general-purpose input/output，数字接口\u003c/li\u003e\n\u003cli\u003eUART：Universal asynchronous receiver-transmitter，异步串行接口\u003c/li\u003e\n\u003cli\u003eSPI：Serial Peripheral Interface，同步串行接口\u003c/li\u003e\n\u003cli\u003eI2C：Inter-Integrated Circuit, 同步串行接口\u003c/li\u003e\n\u003cli\u003eADC：Analog-to-digital, 模拟转数字接口\u003c/li\u003e\n\u003cli\u003ePWM: Pulse-width modulation,\u003c/li\u003e\n\u003cli\u003eUSB：不支持，异步串行接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"machine-包\"\u003emachine 包\u003c/h2\u003e\n\u003cp\u003emachine包是tinygo中核心包\u003c/p\u003e\n\u003ch2 id=\"driver\"\u003eDriver\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://tinygo.org/docs/reference/devices/\"\u003ehttps://tinygo.org/docs/reference/devices/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装支持的driver\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego get tinygo.org/x/drivers\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Arduino Uno tinogo-windows开发环境配置\nhttps://tinygo.org/getting-started/install/windows/\nscoop install go scoop install tinygo scoop install avrdude windows烧写程序\ntinygo flash -monitor -baudrate=9600 -target arduino -port COMX /path/to/blinky1 macos烧写程序\ntinygo flash --target arduino -port /dev/cu.usbserial-0001 ./blinking.go Microcontroller Arduino Uno 使用的是ATmega328p 控制器\n支持的外设接口:\nGPIO：general-purpose input/output，数字接口 UART：Universal asynchronous receiver-transmitter，异步串行接口 SPI：Serial Peripheral Interface，同步串行接口 I2C：Inter-Integrated Circuit, 同步串行接口 ADC：Analog-to-digital, 模拟转数字接口 PWM: Pulse-width modulation, USB：不支持，异步串行接口 machine 包 machine包是tinygo中核心包\nDriver https://tinygo.org/docs/reference/devices/\n安装支持的driver\ngo get tinygo.org/x/drivers ",
    "categories": ["HW"],
    "tags": ["arduino"]
  },
  {
    "title": "GCP",
    "permalink": "https://canuxcheng.com/post/gcp/",
    "date": "2023-04-23",
    "summary": "\u003ch1 id=\"gcp\"\u003eGCP\u003c/h1\u003e\n\u003cp\u003egcp certification:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGoogle Cloud Certified Cloud Digital Leader\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Associate Cloud Engineer\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified DevOps Engineer\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Machine Learning Engineer\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Professional Cloud Architect\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Professional Data Engineer\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Professional Network Engineer\u003c/li\u003e\n\u003cli\u003eGoogle Cloud Certified Professional Security Engineer\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cloud-sdk\"\u003eCloud SDK\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://cloud.google.com/sdk/docs/install\"\u003ehttps://cloud.google.com/sdk/docs/install\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e默认安装的组件:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebq\u003c/li\u003e\n\u003cli\u003ebundled-python3-unix\u003c/li\u003e\n\u003cli\u003egsutil\u003c/li\u003e\n\u003cli\u003ecore\u003c/li\u003e\n\u003cli\u003egcloud-crc32c\u003c/li\u003e\n\u003cli\u003ealpha\u003c/li\u003e\n\u003cli\u003ebeta\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e安装其它组件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egcloud components install app-engine-go docker-credential-gcr kustomize log-streaming terraform-tools app-engine-python app-engine-python-extras gke-gcloud-auth-plugin kubectl kubectl-oidc \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e卸载:\u003c/p\u003e",
    "content": "GCP gcp certification:\nGoogle Cloud Certified Cloud Digital Leader Google Cloud Certified Associate Cloud Engineer Google Cloud Certified DevOps Engineer Google Cloud Certified Machine Learning Engineer Google Cloud Certified Professional Cloud Architect Google Cloud Certified Professional Data Engineer Google Cloud Certified Professional Network Engineer Google Cloud Certified Professional Security Engineer Cloud SDK https://cloud.google.com/sdk/docs/install\n默认安装的组件:\nbq bundled-python3-unix gsutil core gcloud-crc32c alpha beta 安装其它组件:\ngcloud components install app-engine-go docker-credential-gcr kustomize log-streaming terraform-tools app-engine-python app-engine-python-extras gke-gcloud-auth-plugin kubectl kubectl-oidc 卸载:\ngcloud components remove \u0026lt;component_id\u0026gt; 升级\ngcloud components update GCP Command Line Interface 使用:\ngcloud --help CLI credentials 初始化：\ngcloud init gcloud init --no-launch-browser gcloud init --console-only 配置：\n配置存储位置:\nlinux/unix: ~/.config/gcloud windows: %APPDATA%\\gcloud 配置管理:\n// 创建配置 gcloud config configurations create [name] // 列出配置 gcloud config configurations list // 查看配置属性 gcloud config configurations describe [name] // 激活配置 gcloud config configurations activate [name] // 删除配置 gcloud config configurations delete [name] 属性管理:\n// 查看属性 gcloud config list // 切换account gcloud config set account [account] // 切换project gcloud config set project [project] // 查看可用属性 gcloud config set --help // 显示可用属性的列表 gcloud topic configurations 登录:\n// 默认打开浏览器授权 gcloud auth login // 用于没有浏览器的机器 // 复制gcloud auth login --remote-bootstrap=\u0026quot;命令在另外一台安装了浏览器和gcloud cli的机器打开。 // 将浏览器的输出帖回没有浏览器的机器。 gcloud auth login --no-browser // 用于没有浏览器的机器，复制Https网址打开浏览器授权。 gcloud auth login --no-launch-browser // 列出账号. gcloud auth list // 禁止通过cli登录 gcloud auth revoke [account] // 查找凭据文件位置 gcloud info Application Default Credentials（ADC):\n// 将用户凭据提供给ADC(用于sdk或者terraform等交互）。 gcloud auth application-default login --no-launch-browser 交互式shell\ngcloud beta interactive compute Kubernetes: GKE(EKS) Compute engine(EC2): compute engine Batch workload manager ServerLess cloud run cloud functions app engine api gateway endpoints network VPC cloud router cloud DNS(route53) cloud domains(route53) cloud firewall(DNS firewall, network firewall, SG, ACL) cloud interconnect(direct connect) cloud VPN cloud NAT cloud CDN cloud load balancing Cloud Load balancer Application LB(http/https):\nexternal LB(gce): external global lb(gke-l7-global-external-managed), external classic global lb(gke-l7-gxlb), external regional lb（gke-l7-regional-external-managed）. internal LB(gce-internal, gke-l7-rilb): internal regional lb. Proxy LB(TCP/SSL):\nexternal internal Passthrough LB(TCP/UDP):\nexternal internal storage persistent disk(EBS): (balanced/extreme/ssd/standard) 创建vm的时候创建块存储。 cloud storage(S3): (standard/nearline/coldline/archive) 可以在全球范围内随时存储和检索任意数量的数据 cloud storage for filebase(S3): 专为需要存储和提供用户生成的内容（如照片或视频）的应用开发者而打造的 filestore(EFS): file storage Database Cloud SQL(RDS, Aurora): RDBMA Cloud Spanner(Aurora): RDBMS Cloud Bigtable(dynamoDB): NoSQL: Key-value datastore(dynamoDB): NoSQL: Indexed memorystore(elastiCache): In-memory data store, memcached/redis BigQuery Security certificate authority service(ACM): Certificate management cloud identity(IAM): Identity and access management(IAM): Identity-Aware Proxy(IAM): cloud key management service(KMS): IAM members:\ngoogle account google service account google groups cloud identity domain google workspace domain IAM basic roles:\nOwner Editor Viewer Billing Administrator Service account types:\nuser created built-in (compute engine or gke default SA) Google APIs SA Operation Monitoring Debugger Logging Error reporting Trace Profiler Analytics BigQuery Pub/Sub CI/CD cloud build cloud deploy container registry artifact registry source repositories how to ssh to vm Metadata 分为Project metadata和instance metadata。\nssh Only for external IP (public IP).\nssh key for vm: add ssh pub key to instance metadata. ssh key for project: add ssh pub key to project metadata. ssh to vm\nssh username_from_metadata@external_IP gcloud 首次运行会创建ssh 密钥对，用户名是本地机器用户名,google_compute_engine.\n公钥会自动上传到project/instance metadata.\ngcloud compute ssh public-instance \\ --project=PJ \\ --zone=RZ OS Login 设置 OS Login 元数据时，Compute Engine 会删除虚拟机的 authorized_keys 文件，并且不再接受来自项目或实例元数据中存储的 SSH 密钥的连接。\n用户名为canuxcheng@gmail.com =\u0026gt; canuxcheng_gmail_com\nssh 使用ssh需要将公钥上传到OS Login配置(忽略密钥中的用户名）。\ngcloud compute os-login ssh-keys add \\ --key-file=public_KEY_FILE_PATH \\ --project=PROJECT \\ --ttl=EXPIRE_TIME ssh\nssh canuxcheng_gmail_com@IP gcloud 首次运行会创建ssh 密钥对，公钥会自动上传到os login config.\ngcloud compute ssh instance --internal-ip --project=PJ --zone=RZ IAP Identity-Aware Proxy\nhttps://cloud.google.com/iap/docs/using-tcp-forwarding?_ga=2.127808461.-1134224509.1683858043\u0026amp;hl=zh-cn#firewall\nuse internal ip directly:\ngcloud compute ssh private-instance --project=PJ --zone=europe-west4-a --internal-ip use iap:\ngcloud compute ssh private-instance \\ --project=PJ \\ --zone=RZ \\ --tunnel-through-iap ",
    "categories": ["Cloud"],
    "tags": ["gcp"]
  },
  {
    "title": "Auth",
    "permalink": "https://canuxcheng.com/post/django_auth/",
    "date": "2022-01-14",
    "summary": "\u003ch1 id=\"authpy\"\u003eauth.py\u003c/h1\u003e\n\u003cp\u003e自定义authentication backend.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.contrib.auth.backends import BaseBackend\n\nclass MyBackend(BaseBackend):\n    def authenticate(self, request):\n        ...\n    def get_user(self, user_id):\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置使用自定义backend\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAUTHENTICATION_BACKENDS =  (\u0026quot;apps.ldap_auth.auth.MyBackend\u0026quot;,)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/etianen/django-python3-ldap\"\u003ehttps://github.com/etianen/django-python3-ldap\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"auth\"\u003eauth\u003c/h1\u003e\n\u003cp\u003e配置\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eINSTALLED_APPS = (\n    'django.contrib.auth'，\n    'django.contrib.contenttypes'\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u0026lsquo;django.contrib.auth\u0026rsquo; 包含了验证框架的内核和它的默认模型。\u003c/p\u003e\n\u003cp\u003e\u0026lsquo;django.contrib.contenttypes\u0026rsquo; 是 Django content type system ，允许你创建的模型和权限相关联。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMIDDLEWARE_CLASSES = (\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用户登录:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.contrib.auth import authenticate, login\nuser = authenticate(username='name', password='pw')\nlogin(request, user)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e登陆时的默认验证后端:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAUTHENTICATION_BACKENDS = ['django.contrib.auth.backends.ModelBackend']\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用户登出:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.contrib.auth import logout\nlogout(request)\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e",
    "content": "auth.py 自定义authentication backend.\nfrom django.contrib.auth.backends import BaseBackend class MyBackend(BaseBackend): def authenticate(self, request): ... def get_user(self, user_id): ... 配置使用自定义backend\nAUTHENTICATION_BACKENDS = (\u0026quot;apps.ldap_auth.auth.MyBackend\u0026quot;,) https://github.com/etianen/django-python3-ldap\nauth 配置\nINSTALLED_APPS = ( 'django.contrib.auth'， 'django.contrib.contenttypes' ) \u0026lsquo;django.contrib.auth\u0026rsquo; 包含了验证框架的内核和它的默认模型。\n\u0026lsquo;django.contrib.contenttypes\u0026rsquo; 是 Django content type system ，允许你创建的模型和权限相关联。\nMIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', ) 用户登录:\nfrom django.contrib.auth import authenticate, login user = authenticate(username='name', password='pw') login(request, user) 登陆时的默认验证后端:\nAUTHENTICATION_BACKENDS = ['django.contrib.auth.backends.ModelBackend'] 用户登出:\nfrom django.contrib.auth import logout logout(request) ",
    "categories": ["Django"],
    "tags": ["auth"]
  },
  {
    "title": "Application",
    "permalink": "https://canuxcheng.com/post/cncf_application/",
    "date": "2021-12-04",
    "summary": "\u003ch1 id=\"application-definition--image-build\"\u003eApplication Definition \u0026amp; Image Build\u003c/h1\u003e\n\u003cp\u003eapplication choreography.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehelm\u003c/li\u003e\n\u003cli\u003ebackstage\u003c/li\u003e\n\u003cli\u003ebuildpack.io\u003c/li\u003e\n\u003cli\u003eoperatorframework\u003c/li\u003e\n\u003cli\u003edapr\u003c/li\u003e\n\u003cli\u003ekubevela\u003c/li\u003e\n\u003cli\u003ekubevirt\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"backstage\"\u003ebackstage\u003c/h2\u003e",
    "content": "Application Definition \u0026amp; Image Build application choreography.\nhelm backstage buildpack.io operatorframework dapr kubevela kubevirt backstage ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "AWS CLF",
    "permalink": "https://canuxcheng.com/post/aws_clf/",
    "date": "2021-10-23",
    "summary": "\u003ch1 id=\"clf\"\u003eCLF\u003c/h1\u003e\n\u003cp\u003eFoundational: 6个月经验. Cloud Practitioner Foundational(CLF).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFundamental cloud concepts for AWS\u003c/li\u003e\n\u003cli\u003eUnderstanding AWS core services\u003c/li\u003e\n\u003cli\u003eIntroduction to security \u0026amp; architecture on AWS\u003c/li\u003e\n\u003cli\u003eAWS certified cloud practitioner exam prep\u003c/li\u003e\n\u003c/ul\u003e",
    "content": "CLF Foundational: 6个月经验. Cloud Practitioner Foundational(CLF).\nFundamental cloud concepts for AWS Understanding AWS core services Introduction to security \u0026amp; architecture on AWS AWS certified cloud practitioner exam prep ",
    "categories": ["Cloud"],
    "tags": ["aws"]
  },
  {
    "title": "RTFM",
    "permalink": "https://canuxcheng.com/rtfm/",
    "date": "2021-10-14",
    "summary": "\u003cp\u003eRead The Fucking Manual\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/home/\"\u003ehttps://kubernetes.io/docs/home/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.docker.com/\"\u003ehttps://docs.docker.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://golang.org/doc/\"\u003ehttps://golang.org/doc/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.python.org/3/\"\u003ehttps://docs.python.org/3/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.typescriptlang.org/docs/\"\u003ehttps://www.typescriptlang.org/docs/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://nodejs.org/en/docs/\"\u003ehttps://nodejs.org/en/docs/\u003c/a\u003e\u003c/p\u003e",
    "content": "Read The Fucking Manual\nhttps://kubernetes.io/docs/home/\nhttps://docs.docker.com/\nhttps://golang.org/doc/\nhttps://docs.python.org/3/\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript\nhttps://www.typescriptlang.org/docs/\nhttps://nodejs.org/en/docs/\n",
    "categories": null,
    "tags": null
  },
  {
    "title": "AWS Management",
    "permalink": "https://canuxcheng.com/post/aws_management/",
    "date": "2021-09-23",
    "summary": "\u003ch1 id=\"aws-monitor\"\u003eAWS Monitor\u003c/h1\u003e\n\u003ch2 id=\"cli\"\u003eCLI\u003c/h2\u003e\n\u003ch2 id=\"management-console\"\u003eManagement Console\u003c/h2\u003e\n\u003ch2 id=\"quotas\"\u003eQuotas\u003c/h2\u003e\n\u003ch2 id=\"service-catalog\"\u003eService Catalog\u003c/h2\u003e\n\u003ch2 id=\"cloudwatch\"\u003eCloudWatch\u003c/h2\u003e\n\u003cp\u003e监控和管理服务，收集logs, metrics 和 events，支持基于metrics的alert。\u003c/p\u003e\n\u003cp\u003eMTTR\nTCO\u003c/p\u003e\n\u003ch2 id=\"cloudwatch-logs\"\u003eCloudWatch Logs\u003c/h2\u003e\n\u003ch2 id=\"cloudtrail\"\u003eCloudTrail\u003c/h2\u003e\n\u003cp\u003e可以用来记录，持续监控和保留与AWS基础设施中的操作相关的账户活动。\u003c/p\u003e\n\u003cp\u003e将审计记录插入S3或者cloudwatch log， 记录突发事件。\u003c/p\u003e\n\u003ch2 id=\"aws-config\"\u003eAWS Config\u003c/h2\u003e\n\u003cp\u003e提供基础设施的历史配置。基于规则持续评估基础设施。\u003c/p\u003e\n\u003ch2 id=\"aws-trusted-advisor\"\u003eAWS Trusted Advisor\u003c/h2\u003e\n\u003cp\u003e优化性能和安全性\u003c/p\u003e\n\u003ch2 id=\"amazon-grafana\"\u003eAmazon Grafana\u003c/h2\u003e\n\u003ch2 id=\"amazon-prometheus\"\u003eAmazon Prometheus\u003c/h2\u003e\n\u003ch2 id=\"cloudformation\"\u003eCloudFormation\u003c/h2\u003e\n\u003cp\u003e提供基于模板(yaml/json)的基础设施服务(IaaS).\u003c/p\u003e\n\u003ch2 id=\"compute-optimizer\"\u003eCompute Optimizer\u003c/h2\u003e\n\u003ch2 id=\"control-tower\"\u003eControl Tower\u003c/h2\u003e\n\u003ch2 id=\"health-dashboard\"\u003eHealth Dashboard\u003c/h2\u003e\n\u003ch2 id=\"aws-systems-manager\"\u003eAWS Systems Manager\u003c/h2\u003e\n\u003cp\u003e提供运维数据，并且在跨基础设施中进行自动化操作。\u003c/p\u003e\n\u003ch2 id=\"aws-organizations\"\u003eAWS Organizations\u003c/h2\u003e\n\u003cp\u003e账号集中管理。\u003c/p\u003e\n\u003ch2 id=\"aws-license-manager\"\u003eAWS License Manager\u003c/h2\u003e\n\u003ch2 id=\"proton\"\u003eProton\u003c/h2\u003e\n\u003ch2 id=\"aws-well-architected-tool\"\u003eAWS Well-Architected Tool\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"financial-management\"\u003eFinancial Management\u003c/h1\u003e\n\u003ch2 id=\"budgets\"\u003eBudgets\u003c/h2\u003e\n\u003ch2 id=\"cost-explorer\"\u003eCost Explorer\u003c/h2\u003e\n\u003ch2 id=\"savings-plans\"\u003eSavings Plans\u003c/h2\u003e",
    "content": "AWS Monitor CLI Management Console Quotas Service Catalog CloudWatch 监控和管理服务，收集logs, metrics 和 events，支持基于metrics的alert。\nMTTR TCO\nCloudWatch Logs CloudTrail 可以用来记录，持续监控和保留与AWS基础设施中的操作相关的账户活动。\n将审计记录插入S3或者cloudwatch log， 记录突发事件。\nAWS Config 提供基础设施的历史配置。基于规则持续评估基础设施。\nAWS Trusted Advisor 优化性能和安全性\nAmazon Grafana Amazon Prometheus CloudFormation 提供基于模板(yaml/json)的基础设施服务(IaaS).\nCompute Optimizer Control Tower Health Dashboard AWS Systems Manager 提供运维数据，并且在跨基础设施中进行自动化操作。\nAWS Organizations 账号集中管理。\nAWS License Manager Proton AWS Well-Architected Tool Financial Management Budgets Cost Explorer Savings Plans ",
    "categories": ["Cloud","DevOps"],
    "tags": ["aws"]
  },
  {
    "title": "Samuel",
    "permalink": "https://canuxcheng.com/samuel/",
    "date": "2021-07-30",
    "summary": "\u003cp\u003e\u003cimg src=\"/images/xinyan5.jpg\" alt=\"pic0\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/xinyan1.jpg\" alt=\"pic1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/xinyan2.jpg\" alt=\"pic2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/xinyan3.jpg\" alt=\"pic3\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/xinyan4.jpg\" alt=\"pic4\"\u003e\u003c/p\u003e",
    "content": "\n",
    "categories": null,
    "tags": null
  },
  {
    "title": "CORS",
    "permalink": "https://canuxcheng.com/post/sec_cors/",
    "date": "2021-07-28",
    "summary": "\u003ch1 id=\"cors\"\u003eCORS\u003c/h1\u003e\n\u003cp\u003eCORS: Cross-Origin resource sharing, 跨域资源共享.\u003c/p\u003e\n\u003cp\u003e是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"same-origin-policy\"\u003esame-origin policy\u003c/h2\u003e\n\u003cp\u003e同源策略，是一种关键的安全机制，它限制由一个源加载的文档或脚本如何与来自另一个源的资源进行交互。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e同源包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eprotocal (http, https, \u0026hellip;\u0026hellip;)\u003c/li\u003e\n\u003cli\u003ehost\u003c/li\u003e\n\u003cli\u003eport(80, 443, \u0026hellip;\u0026hellip;)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"简单请求\"\u003e简单请求\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e请求方法是以下三种方法之一：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eHEAD\u003c/li\u003e\n\u003cli\u003eGET\u003c/li\u003e\n\u003cli\u003ePOST\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eHTTP的头信息不超出以下几种字段：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eAccept\u003c/li\u003e\n\u003cli\u003eAccept-Language\u003c/li\u003e\n\u003cli\u003eContent-Language\u003c/li\u003e\n\u003cli\u003eLast-Event-ID\u003c/li\u003e\n\u003cli\u003eContent-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e简单请求在header添加Origin字段说明请求的源(协议，域名，端口):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eOrigin: https://domain.com:port\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"预检请求\"\u003e预检请求\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e针对其它方法或字段类型.\u003c/p\u003e\n\u003ch2 id=\"http-headers\"\u003ehttp headers\u003c/h2\u003e\n\u003cp\u003e响应header中可以带以下字段：\u003c/p\u003e\n\u003cp\u003eAccess-Control-Allow-Origin\u003c/p\u003e\n\u003cp\u003eAccess-Control-Max-Age\u003c/p\u003e\n\u003cp\u003eAccess-Control-Allow-Credentials\u003c/p\u003e\n\u003cp\u003eAccess-Control-Allow-Methods\u003c/p\u003e\n\u003cp\u003eAccess-Control-Expose-Headers\nAccess-Control-Allow-Headers\u003c/p\u003e\n\u003cp\u003e请求header中的字段：\u003c/p\u003e\n\u003cp\u003eOrigin\u003c/p\u003e\n\u003cp\u003eAccess-Control-Request-Method\u003c/p\u003e\n\u003cp\u003eAccess-Control-Request-Headers\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers\u003c/a\u003e\u003c/p\u003e",
    "content": "CORS CORS: Cross-Origin resource sharing, 跨域资源共享.\n是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其他源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\nsame-origin policy 同源策略，是一种关键的安全机制，它限制由一个源加载的文档或脚本如何与来自另一个源的资源进行交互。\nhttps://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n同源包括：\nprotocal (http, https, \u0026hellip;\u0026hellip;) host port(80, 443, \u0026hellip;\u0026hellip;) 简单请求 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82\n请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain. 简单请求在header添加Origin字段说明请求的源(协议，域名，端口):\nOrigin: https://domain.com:port 预检请求 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82\n针对其它方法或字段类型.\nhttp headers 响应header中可以带以下字段：\nAccess-Control-Allow-Origin\nAccess-Control-Max-Age\nAccess-Control-Allow-Credentials\nAccess-Control-Allow-Methods\nAccess-Control-Expose-Headers Access-Control-Allow-Headers\n请求header中的字段：\nOrigin\nAccess-Control-Request-Method\nAccess-Control-Request-Headers\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers\n",
    "categories": ["Security"],
    "tags": ["capture"]
  },
  {
    "title": "Let's Encrypt",
    "permalink": "https://canuxcheng.com/post/sec_letsencrypt/",
    "date": "2021-07-28",
    "summary": "\u003ch1 id=\"lets-encrypt\"\u003eLet\u0026rsquo;s Encrypt\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://letsencrypt.org/\"\u003ehttps://letsencrypt.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/letsencrypt\"\u003ehttps://github.com/letsencrypt\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e是非盈利组织ISRG提供的免费的证书颁发机构。\u003c/p\u003e\n\u003cp\u003elet\u0026rsquo;s encrypt生成证书的工具很多certbot, acme.sh等.\u003c/p\u003e\n\u003ch1 id=\"certbot\"\u003ecertbot\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/certbot/certbot\"\u003ehttps://github.com/certbot/certbot\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"acmesh\"\u003eacme.sh\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/acmesh-official/acme.sh\"\u003ehttps://github.com/acmesh-official/acme.sh\u003c/a\u003e\u003c/p\u003e",
    "content": "Let\u0026rsquo;s Encrypt https://letsencrypt.org/\nhttps://github.com/letsencrypt\n是非盈利组织ISRG提供的免费的证书颁发机构。\nlet\u0026rsquo;s encrypt生成证书的工具很多certbot, acme.sh等.\ncertbot https://github.com/certbot/certbot\nacme.sh https://github.com/acmesh-official/acme.sh\n",
    "categories": ["Security"],
    "tags": ["CA"]
  },
  {
    "title": "BSP",
    "permalink": "https://canuxcheng.com/post/hardware_bsp/",
    "date": "2021-05-15",
    "summary": "\u003ch1 id=\"bsp\"\u003eBSP\u003c/h1\u003e\n\u003cp\u003eBSP，Board Support Package，板级支持包.\u003c/p\u003e\n\u003cp\u003e熟悉常见的接口协议，如I2C, SPI, UART, USB等。\u003c/p\u003e",
    "content": "BSP BSP，Board Support Package，板级支持包.\n熟悉常见的接口协议，如I2C, SPI, UART, USB等。\n",
    "categories": ["HW"],
    "tags": ["fpga"]
  },
  {
    "title": "FPGA",
    "permalink": "https://canuxcheng.com/post/hardware_fpga/",
    "date": "2021-05-15",
    "summary": "\u003ch1 id=\"fpga\"\u003eFPGA\u003c/h1\u003e\n\u003cp\u003eFPGA: Field Programmable Gate Array, 现场可编程逻辑门阵列.\u003c/p\u003e\n\u003cp\u003e下面介绍各家厂商和对应的产品系列.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"xilinx赛灵思\"\u003exilinx/赛灵思\u003c/h1\u003e\n\u003cp\u003eSpartan\u003c/p\u003e\n\u003cp\u003eArtix\u003c/p\u003e\n\u003cp\u003eKintex\u003c/p\u003e\n\u003cp\u003eVirtex\u003c/p\u003e\n\u003cp\u003eSoC/MPSoC\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"altera阿尔特拉\"\u003eAltera/阿尔特拉\u003c/h1\u003e\n\u003cp\u003e被Intel英特尔收购\u003c/p\u003e\n\u003cp\u003eMAXII\u003c/p\u003e\n\u003cp\u003eCyclone\u003c/p\u003e\n\u003cp\u003eStratix\u003c/p\u003e\n\u003cp\u003eArria\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"lattice莱迪思\"\u003eLattice/莱迪思\u003c/h1\u003e\n\u003cp\u003eECP\u003c/p\u003e\n\u003cp\u003eICE\u003c/p\u003e\n\u003cp\u003eMach\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"synplicity\"\u003eSynplicity\u003c/h1\u003e\n\u003cp\u003e被Synopsys新思科技收购\u003c/p\u003e\n\u003ch2 id=\"haps\"\u003eHAPS\u003c/h2\u003e\n\u003cp\u003eHAPS系列产品是专为ASIC/SOC设计者提供的高性能、高容量的基于FPGA的原型验证板.\u003c/p\u003e",
    "content": "FPGA FPGA: Field Programmable Gate Array, 现场可编程逻辑门阵列.\n下面介绍各家厂商和对应的产品系列.\nxilinx/赛灵思 Spartan\nArtix\nKintex\nVirtex\nSoC/MPSoC\nAltera/阿尔特拉 被Intel英特尔收购\nMAXII\nCyclone\nStratix\nArria\nLattice/莱迪思 ECP\nICE\nMach\nSynplicity 被Synopsys新思科技收购\nHAPS HAPS系列产品是专为ASIC/SOC设计者提供的高性能、高容量的基于FPGA的原型验证板.\n",
    "categories": ["HW"],
    "tags": ["fpga"]
  },
  {
    "title": "Hardware",
    "permalink": "https://canuxcheng.com/post/hardware/",
    "date": "2021-05-15",
    "summary": "\u003ch1 id=\"hardware\"\u003eHardware\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/micropython/micropython\"\u003ehttps://github.com/micropython/micropython\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/tinygo-org/tinygo\"\u003ehttps://github.com/tinygo-org/tinygo\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"soc\"\u003eSoC\u003c/h1\u003e\n\u003cp\u003eSOC：（System-On-Chip)片上系统。可以简单的理解为把系统做在一块芯片上。\u003c/p\u003e\n\u003cp\u003eAP: application processor, CPU, GPU, NPU, ISP, DSP, ROM/RAM.\u003c/p\u003e\n\u003cp\u003eBP: base-band processor, BBU.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/chip.png\" alt=\"pic\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/ISP.png\" alt=\"pic\"\u003e\u003c/p\u003e\n\u003cp\u003eEUV: Extreme Ultraviolet Lithography，极紫外光刻\u003c/p\u003e\n\u003cp\u003eDSP: Digital Signal Processing.\u003c/p\u003e\n\u003cp\u003eISP: image signal process.\u003c/p\u003e\n\u003cp\u003e厂商：紫光展锐，华为海思，全志科技，瑞芯微。\u003c/p\u003e\n\u003ch1 id=\"rfic\"\u003eRFIC\u003c/h1\u003e\n\u003cp\u003e射频芯片\u003c/p\u003e",
    "content": "Hardware https://github.com/micropython/micropython\nhttps://github.com/tinygo-org/tinygo\nSoC SOC：（System-On-Chip)片上系统。可以简单的理解为把系统做在一块芯片上。\nAP: application processor, CPU, GPU, NPU, ISP, DSP, ROM/RAM.\nBP: base-band processor, BBU.\nEUV: Extreme Ultraviolet Lithography，极紫外光刻\nDSP: Digital Signal Processing.\nISP: image signal process.\n厂商：紫光展锐，华为海思，全志科技，瑞芯微。\nRFIC 射频芯片\n",
    "categories": ["HW"],
    "tags": ["hw"]
  },
  {
    "title": "KubeVirt",
    "permalink": "https://canuxcheng.com/post/k8s_kubevirt/",
    "date": "2021-05-10",
    "summary": "\u003ch1 id=\"kubevirt\"\u003eKubeVirt\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://kubevirt.io/quickstart_cloud/\"\u003ehttps://kubevirt.io/quickstart_cloud/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://quay.io/organization/kubevirt\"\u003ehttps://quay.io/organization/kubevirt\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html\"\u003ehttps://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"virtctl\"\u003evirtctl\u003c/h2\u003e\n\u003ch2 id=\"vm\"\u003eVM\u003c/h2\u003e\n\u003cp\u003e创建vm\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: kubevirt.io/v1\nkind: VirtualMachine\nmetadata:\nname: testvm\nspec:\nrunning: false\ntemplate:\n    metadata:\n    labels:\n        kubevirt.io/size: small\n        kubevirt.io/domain: testvm\n    spec:\n    domain:\n        devices:\n        disks:\n            - name: containerdisk\n            disk:\n                bus: virtio\n            - name: cloudinitdisk\n            disk:\n                bus: virtio\n        interfaces:\n        - name: default\n            masquerade: {}\n        resources:\n        requests:\n            memory: 64M\n    networks:\n    - name: default\n        pod: {}\n    volumes:\n        - name: containerdisk\n        containerDisk:\n            image: quay.io/kubevirt/cirros-container-disk-demo\n        - name: cloudinitdisk\n        cloudInitNoCloud:\n            userDataBase64: SGkuXG4=\n    nodeSelector:\n        kubernetes.io/arch: arm64\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "KubeVirt https://kubevirt.io/quickstart_cloud/\nhttps://quay.io/organization/kubevirt\nhttps://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html\nvirtctl VM 创建vm\napiVersion: kubevirt.io/v1 kind: VirtualMachine metadata: name: testvm spec: running: false template: metadata: labels: kubevirt.io/size: small kubevirt.io/domain: testvm spec: domain: devices: disks: - name: containerdisk disk: bus: virtio - name: cloudinitdisk disk: bus: virtio interfaces: - name: default masquerade: {} resources: requests: memory: 64M networks: - name: default pod: {} volumes: - name: containerdisk containerDisk: image: quay.io/kubevirt/cirros-container-disk-demo - name: cloudinitdisk cloudInitNoCloud: userDataBase64: SGkuXG4= nodeSelector: kubernetes.io/arch: arm64 ",
    "categories": ["CNCF","Virtualization"],
    "tags": ["k8s","livirt"]
  },
  {
    "title": "Cache",
    "permalink": "https://canuxcheng.com/post/django_cache/",
    "date": "2021-05-04",
    "summary": "\u003ch1 id=\"cache\"\u003ecache\u003c/h1\u003e\n\u003cp\u003e缓存的backend可以是django内置的，也可以是第三方的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e缓存整个站点\u003c/p\u003e\n\u003cp\u003eMIDDLEWARE = [\n\u0026lsquo;django.middleware.cache.UpdateCacheMiddleware\u0026rsquo;,\n\u0026lsquo;django.middleware.common.CommonMiddleware\u0026rsquo;,\n\u0026lsquo;django.middleware.cache.FetchFromCacheMiddleware\u0026rsquo;,\n]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e视图缓存\u003c/p\u003e\n\u003cp\u003efrom django.views.decorators.cache import cache_page\u003c/p\u003e\n\u003cp\u003e@cache_page(60 * 2)\ndef my_view(request):\n\u0026hellip;\u003c/p\u003e\n\u003cp\u003e或者在URLconf中指定\nurlpatterns = [\npath(\u0026lsquo;foo/\u003ca href=\"int:code\"\u003eint:code\u003c/a\u003e/\u0026rsquo;, cache_page(60 * 2)(my_view)),\n]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e模板片段缓存\u003c/p\u003e\n\u003cp\u003e{% load cache %}\n{% cache \u0026hellip; %}\n\u0026hellip;\n{% endcache %}\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"redis\"\u003eredis\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eCACHES = {\n    \u0026quot;default\u0026quot;: {\n        \u0026quot;BACKEND\u0026quot;: \u0026quot;django_redis.cache.RedisCache\u0026quot;,\n        \u0026quot;LOCATION\u0026quot;: os.environ.get(\u0026quot;REDIS_URL\u0026quot;, ''),\n        \u0026quot;OPTIONS\u0026quot;: {\n            \u0026quot;CLIENT_CLASS\u0026quot;: \u0026quot;django_redis.client.DefaultClient\u0026quot;,\n        },\n        \u0026quot;TIMEOUT\u0026quot;: 60,\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"memcached\"\u003ememcached\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n        'LOCATION': '127.0.0.1:11211',\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"database\"\u003edatabase\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',\n        'LOCATION': 'my_cache_table',\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "cache 缓存的backend可以是django内置的，也可以是第三方的。\n缓存整个站点\nMIDDLEWARE = [ \u0026lsquo;django.middleware.cache.UpdateCacheMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.common.CommonMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.cache.FetchFromCacheMiddleware\u0026rsquo;, ]\n视图缓存\nfrom django.views.decorators.cache import cache_page\n@cache_page(60 * 2) def my_view(request): \u0026hellip;\n或者在URLconf中指定 urlpatterns = [ path(\u0026lsquo;foo/int:code/\u0026rsquo;, cache_page(60 * 2)(my_view)), ]\n模板片段缓存\n{% load cache %} {% cache \u0026hellip; %} \u0026hellip; {% endcache %}\nredis CACHES = { \u0026quot;default\u0026quot;: { \u0026quot;BACKEND\u0026quot;: \u0026quot;django_redis.cache.RedisCache\u0026quot;, \u0026quot;LOCATION\u0026quot;: os.environ.get(\u0026quot;REDIS_URL\u0026quot;, ''), \u0026quot;OPTIONS\u0026quot;: { \u0026quot;CLIENT_CLASS\u0026quot;: \u0026quot;django_redis.client.DefaultClient\u0026quot;, }, \u0026quot;TIMEOUT\u0026quot;: 60, } } memcached CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': '127.0.0.1:11211', } } database CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.db.DatabaseCache', 'LOCATION': 'my_cache_table', } } ",
    "categories": ["Django"],
    "tags": ["cache"]
  },
  {
    "title": "AWS",
    "permalink": "https://canuxcheng.com/post/aws/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws\"\u003eAWS\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/donnemartin/awesome-aws\"\u003ehttps://github.com/donnemartin/awesome-aws\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eaws certification:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFoundational: 6个月经验. Cloud Practitioner Foundational(CLF).\u003c/li\u003e\n\u003cli\u003eAssociate: 一年经验. Solutions Architect Associate(SAA); Developer, SysOps Administrator\u003c/li\u003e\n\u003cli\u003eProfessional: 两年经验. Solutions Architect Professional(SAP), Devops Engineer.\u003c/li\u003e\n\u003cli\u003eSpecialty: 特殊领域.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"sdk\"\u003eSDK\u003c/h2\u003e\n\u003cp\u003epython\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/boto/boto3\"\u003ehttps://github.com/boto/boto3\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003egolang\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/aws/aws-sdk-go\"\u003ehttps://github.com/aws/aws-sdk-go\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"aws-management-console\"\u003eAWS Management Console\u003c/h2\u003e\n\u003cp\u003e通过webUI管理资源.\nkkkkjjkijijijkkjddkkkkjj\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"aws-command-line-interface\"\u003eAWS Command Line Interface\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/aws/aws-cli\"\u003ehttps://github.com/aws/aws-cli\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/awslabs/aws-shell\"\u003ehttps://github.com/awslabs/aws-shell\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e推荐使用awscli-V2:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html\"\u003ehttps://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e使用:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws [-h] [--profile PROFILE] [--debug]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eoption:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-h, --help\n--profile PROFILE\n--debug\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecomand option:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws \u0026lt;service\u0026gt; \u0026lt;subcommand\u0026gt; help \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"cli-credentials\"\u003eCLI credentials\u003c/h3\u003e\n\u003cp\u003e优先级：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e命令行选项\u003c/li\u003e\n\u003cli\u003ecredentials文件\u003c/li\u003e\n\u003cli\u003econfig文件\u003c/li\u003e\n\u003cli\u003e容器凭证\u003c/li\u003e\n\u003cli\u003e实例配置文件凭证\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eCLI\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e配置default profile\u003c/p\u003e",
    "content": "AWS https://github.com/donnemartin/awesome-aws\naws certification:\nFoundational: 6个月经验. Cloud Practitioner Foundational(CLF). Associate: 一年经验. Solutions Architect Associate(SAA); Developer, SysOps Administrator Professional: 两年经验. Solutions Architect Professional(SAP), Devops Engineer. Specialty: 特殊领域. SDK python\nhttps://github.com/boto/boto3\ngolang\nhttps://github.com/aws/aws-sdk-go\nAWS Management Console 通过webUI管理资源. kkkkjjkijijijkkjddkkkkjj\nAWS Command Line Interface https://github.com/aws/aws-cli\nhttps://github.com/awslabs/aws-shell\n推荐使用awscli-V2:\nhttps://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html\n使用:\naws [-h] [--profile PROFILE] [--debug] option:\n-h, --help --profile PROFILE --debug comand option:\naws \u0026lt;service\u0026gt; \u0026lt;subcommand\u0026gt; help CLI credentials 优先级：\n命令行选项 credentials文件 config文件 容器凭证 实例配置文件凭证 CLI 配置default profile\n$aws configure AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Default region name [None]: us-west-2 Default output format [None]: json/yaml/text/table/yaml-stream // 配置指定用户 $aws configure --profile canux // 查看配置 $aws configure list $aws configure --profile canux list 命令行选项指定配置文件\n$aws --profile canux ... 环境变量指定配置文件\nexport AWS_PROFILE=canux export AWS_DEFAULT_PROFILE=canux Shared credentials file 文件配置\n// windows %USERPROFILE%\\.aws\\credentials // linux ~/.aws/credentials // 默认账号配置 [default] aws_access_key_id=AKIAIOSFODNN7EXAMPLE aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY // 指定用户配置 [canux] aws_access_key_id=AKIAI44QH8DHBEXAMPLE aws_secret_access_key=je7MtGbClwBF/2Zp9Utk/h3yCo8nvbEXAMPLEKEY 通过环境变量配置\nexport AWS_ACCESS_KEY_ID=\u0026quot;id\u0026quot; export AWS_SECRET_ACCESS_KEY=\u0026quot;key\u0026quot; export AWS_SESSION_TOKEN=\u0026quot;token\u0026quot; Config file 配置文件\n// linux ~/.aws/config [default] region = eu-west-1 output = yaml [profile pro] sso_start_url = https://lz.awsapps.com/start sso_region = eu-west-1 sso_role_name = ProjAdmins sso_account_id = 123404000510 region = us-west-2 output = json // windows %USERPROFILE%\\.aws\\config IAM role how to check:\n$aws sts get-caller-identity --profile pro services iam ec2 sts eks aws eks describe-addon-versions --addon-name aws-ebs-csi-driver ",
    "categories": ["Cloud"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Compute Services",
    "permalink": "https://canuxcheng.com/post/aws_cs/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws-compute-service\"\u003eAWS Compute Service\u003c/h1\u003e\n\u003ch2 id=\"ec2\"\u003eEC2\u003c/h2\u003e\n\u003cp\u003eElastic Compute.\u003c/p\u003e\n\u003cp\u003eAMI: Amazon Machine Image.\u003c/p\u003e\n\u003cp\u003eEC2实例类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通用型实例\u003c/li\u003e\n\u003cli\u003e计算优化型实例\u003c/li\u003e\n\u003cli\u003e内存优化型实例\u003c/li\u003e\n\u003cli\u003e加速计算型实例\u003c/li\u003e\n\u003cli\u003e存储优化型实例\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEC2付费类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e按需(on-demand)\u003c/li\u003e\n\u003cli\u003e预留实例(reserved)\u003c/li\u003e\n\u003cli\u003e储蓄计划(savings plans)\u003c/li\u003e\n\u003cli\u003eSpot实例\u003c/li\u003e\n\u003cli\u003e专用主机(dedicated)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"elastic-beanstalk\"\u003eElastic Beanstalk\u003c/h2\u003e\n\u003cp\u003efeatures:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emonitoring\u003c/li\u003e\n\u003cli\u003edeployment\u003c/li\u003e\n\u003cli\u003escaling\u003c/li\u003e\n\u003cli\u003eEC2 customization\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"lambda\"\u003eLambda\u003c/h2\u003e\n\u003ch2 id=\"lightsail\"\u003eLightsail\u003c/h2\u003e\n\u003ch2 id=\"batch\"\u003eBatch\u003c/h2\u003e\n\u003ch2 id=\"app-runner\"\u003eApp Runner\u003c/h2\u003e\n\u003ch2 id=\"auto-scaling\"\u003eAuto Scaling\u003c/h2\u003e\n\u003ch2 id=\"fargate\"\u003eFargate\u003c/h2\u003e\n\u003ch2 id=\"outposts\"\u003eOutposts\u003c/h2\u003e\n\u003ch2 id=\"wavelength\"\u003eWavelength\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"app-integration\"\u003eApp Integration\u003c/h1\u003e\n\u003ch2 id=\"appflow\"\u003eAppFlow\u003c/h2\u003e\n\u003ch2 id=\"appsync\"\u003eAppSync\u003c/h2\u003e\n\u003ch2 id=\"eventbridge\"\u003eEventBridge\u003c/h2\u003e\n\u003ch2 id=\"step-functions\"\u003eStep Functions\u003c/h2\u003e\n\u003cp\u003e无服务架构.\u003c/p\u003e\n\u003ch2 id=\"sns\"\u003eSNS\u003c/h2\u003e\n\u003cp\u003eSimple Notification Service是消息发布订阅服务.\u003c/p\u003e\n\u003ch2 id=\"sqs\"\u003eSQS\u003c/h2\u003e\n\u003cp\u003eSimple Queue Service是消息队列服务.\u003c/p\u003e\n\u003cp\u003e支持256KB的payload.\u003c/p\u003e\n\u003cp\u003e提供两种类型的queues:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estandard queue\u003c/li\u003e\n\u003cli\u003eFIFO queue\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"mq\"\u003eMQ\u003c/h2\u003e\n\u003cp\u003eactiveMQ 和 rabbitmq 托管服务。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"business-app-integration\"\u003eBusiness app integration\u003c/h1\u003e\n\u003ch2 id=\"simple-email-service\"\u003eSimple Email Service\u003c/h2\u003e\n\u003cp\u003eSES\u003c/p\u003e",
    "content": "AWS Compute Service EC2 Elastic Compute.\nAMI: Amazon Machine Image.\nEC2实例类型:\n通用型实例 计算优化型实例 内存优化型实例 加速计算型实例 存储优化型实例 EC2付费类型:\n按需(on-demand) 预留实例(reserved) 储蓄计划(savings plans) Spot实例 专用主机(dedicated) Elastic Beanstalk features:\nmonitoring deployment scaling EC2 customization Lambda Lightsail Batch App Runner Auto Scaling Fargate Outposts Wavelength App Integration AppFlow AppSync EventBridge Step Functions 无服务架构.\nSNS Simple Notification Service是消息发布订阅服务.\nSQS Simple Queue Service是消息队列服务.\n支持256KB的payload.\n提供两种类型的queues:\nstandard queue FIFO queue MQ activeMQ 和 rabbitmq 托管服务。\nBusiness app integration Simple Email Service SES\nAlexa for Business 终端用户计算 AppStream WorkSpaces ",
    "categories": ["Cloud"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Containers",
    "permalink": "https://canuxcheng.com/post/aws_containers/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws-containers\"\u003eAWS Containers\u003c/h1\u003e\n\u003ch2 id=\"ecr\"\u003eECR\u003c/h2\u003e\n\u003cp\u003eElastic Container Registry.\u003c/p\u003e\n\u003ch2 id=\"ecs-anywhere\"\u003eECS Anywhere\u003c/h2\u003e\n\u003ch2 id=\"ecs\"\u003eECS\u003c/h2\u003e\n\u003cp\u003eElastic Container Service.\u003c/p\u003e\n\u003ch2 id=\"eks-distro\"\u003eEKS Distro\u003c/h2\u003e\n\u003ch2 id=\"eks-anywhere\"\u003eEKS Anywhere\u003c/h2\u003e\n\u003ch2 id=\"eks\"\u003eEKS\u003c/h2\u003e\n\u003cp\u003eElastic Kubernetes Service.\u003c/p\u003e\n\u003ch3 id=\"通过aws-cli创建eks\"\u003e通过AWS CLI创建EKS\u003c/h3\u003e\n\u003cp\u003e通过MC创建的资源都可以通过CLI(aws)创建.\u003c/p\u003e\n\u003cp\u003e创建具有公有和私有子网且符合 Amazon EKS 要求的 Amazon VPC\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ aws cloudformation create-stack \\\n--stack-name my-eks-vpc-stack \\\n--region region-code \\\n--template-url https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建集群 IAM 角色并向其附加所需的 Amazon EKS IAM 托管策略\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 创建EKS IAM role\naws iam create-role \\\n--role-name my-EKSClusterRole \\\n--assume-role-policy-document file://cluster-role-trust-policy.json\u0026quot; \\\n--permissions-boundary arn:aws:iam::\u0026lt;Your AWS ID\u0026gt;:policy/ProjAdminsPermBoundaryv2\n\n{\n    \u0026quot;Version\u0026quot;: \u0026quot;2012-10-17\u0026quot;,\n    \u0026quot;Statement\u0026quot;: [\n        {\n            \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;,\n            \u0026quot;Principal\u0026quot;: {\n                \u0026quot;Service\u0026quot;: \u0026quot;eks.amazonaws.com\u0026quot;\n            },\n            \u0026quot;Action\u0026quot;: \u0026quot;sts:AssumeRole\u0026quot;,\n            \u0026quot;Condition\u0026quot;: {}\n        }\n    ]\n}\n\n// 绑定role和eks策略\naws iam attach-role-policy \\\n--policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy \\\n--role-name my-EKSClusterRole\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建EKS cluster:\u003c/p\u003e",
    "content": "AWS Containers ECR Elastic Container Registry.\nECS Anywhere ECS Elastic Container Service.\nEKS Distro EKS Anywhere EKS Elastic Kubernetes Service.\n通过AWS CLI创建EKS 通过MC创建的资源都可以通过CLI(aws)创建.\n创建具有公有和私有子网且符合 Amazon EKS 要求的 Amazon VPC\n$ aws cloudformation create-stack \\ --stack-name my-eks-vpc-stack \\ --region region-code \\ --template-url https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml 创建集群 IAM 角色并向其附加所需的 Amazon EKS IAM 托管策略\n// 创建EKS IAM role aws iam create-role \\ --role-name my-EKSClusterRole \\ --assume-role-policy-document file://cluster-role-trust-policy.json\u0026quot; \\ --permissions-boundary arn:aws:iam::\u0026lt;Your AWS ID\u0026gt;:policy/ProjAdminsPermBoundaryv2 { \u0026quot;Version\u0026quot;: \u0026quot;2012-10-17\u0026quot;, \u0026quot;Statement\u0026quot;: [ { \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Principal\u0026quot;: { \u0026quot;Service\u0026quot;: \u0026quot;eks.amazonaws.com\u0026quot; }, \u0026quot;Action\u0026quot;: \u0026quot;sts:AssumeRole\u0026quot;, \u0026quot;Condition\u0026quot;: {} } ] } // 绑定role和eks策略 aws iam attach-role-policy \\ --policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy \\ --role-name my-EKSClusterRole 创建EKS cluster:\naws eks create-cluster --name my-cluster \\ --role-arn arn:aws:iam::\u0026lt;ID\u0026gt;:role/my-EKSClusterRole \\ --resources-vpc-config vpc.json / --resources-vpc-config subnetIds=subnet-6782e71e,subnet-e7e761ac,securityGroupIds=sg-6979fe18 \\ --kubernetes-network-config eks.json / --kubernetes-network-config serviceIpv4Cidr=string,ipFamily=string \\ --kubernetes-version \u0026lt;version\u0026gt; --tags \u0026lt;tags\u0026gt; --logging \u0026lt;logging\u0026gt; 给集群创建节点\n// 创建节点IAM role aws iam create-role \\ --role-name my-EKSNodeRole \\ --assume-role-policy-document file://node-role-trust-policy.json\u0026quot; \\ --permissions-boundary arn:aws:iam::\u0026lt;ID\u0026gt;:policy/ProjAdminsPermBoundaryv2 { \u0026quot;Version\u0026quot;: \u0026quot;2012-10-17\u0026quot;, \u0026quot;Statement\u0026quot;: [ { \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Principal\u0026quot;: { \u0026quot;Service\u0026quot;: \u0026quot;ec2.amazonaws.com\u0026quot; }, \u0026quot;Action\u0026quot;: \u0026quot;sts:AssumeRole\u0026quot;, \u0026quot;Condition\u0026quot;: {} } ] } // 绑定role和node策略 aws iam attach-role-policy \\ --policy-arn arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy \\ --role-name my-EKSNodeRole aws iam attach-role-policy \\ --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly \\ --role-name my-EKSNodeRole aws iam attach-role-policy \\ --policy-arn arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy \\ --role-name my-EKSNodeRole 创建managed node group:\naws eks create-nodegroup \\ --cluster-name my-cluster --nodegroup-name my-mng --subnets \u0026lt;value\u0026gt; --node-role \u0026lt;value\u0026gt; \\ --scaling-config minSize=integer,maxSize=integer,desiredSize=integer \\ --instance-types \u0026lt;value\u0026gt; --ami-type \u0026lt;value\u0026gt; --remote-access \u0026lt;value\u0026gt; --disk-size \u0026lt;value\u0026gt; 将计算机配置为与您的集群通信\naws eks describe-cluster --name my-cluster // 通过aws eks自动更新kube.config文件. // 需要该role具有可以操作eks cluster的policy. $ aws eks update-kubeconfig --name my-cluster --role-arn \u0026lt;role\u0026gt; --region eu-west-1 --verbose $ kubectl get svc 删除集群和节点:\naws eks delete-nodegroup --nodegroup-name my-mng --cluster-name my-cluster aws eks delete-cluster --name my-cluster aws cloudformation delete-stack --stack-name my-stack 通过eksctl创建EKS https://github.com/weaveworks/eksctl\nhttps://eksctl.io/usage/schema/\n创建集群和节点：\n$ eksctl create cluster -f/--config-file ./cluster.yaml $ eksctl create nodegroup -f/--config-file ./nodegroup.yaml 删除集群和节点\n$ eksctl delete cluster --name my-cluster --region us-west-2 $ eksctl delete nodegroup --cluster my-cluster --region us-west-2 --name my-ng 通过Terraform创建EKS ",
    "categories": ["Cloud","CNCF"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Data",
    "permalink": "https://canuxcheng.com/post/aws_data/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"data-processing\"\u003eData Processing\u003c/h1\u003e\n\u003ch2 id=\"athena\"\u003eAthena\u003c/h2\u003e\n\u003cp\u003eserverless交互式分析\u003c/p\u003e\n\u003ch2 id=\"data-exchange\"\u003eData Exchange\u003c/h2\u003e\n\u003ch2 id=\"glue\"\u003eGlue\u003c/h2\u003e\n\u003cp\u003eAWS上的ETL(extract, transform and load)服务，提供数据的提取，转换，加载服务。\u003c/p\u003e\n\u003ch2 id=\"data-pipeline\"\u003eData pipeline\u003c/h2\u003e\n\u003cp\u003e也是ETL服务。\u003c/p\u003e\n\u003ch2 id=\"emr\"\u003eEMR\u003c/h2\u003e\n\u003cp\u003eEMR: Elastic MapReduce.\u003c/p\u003e\n\u003cp\u003eAWS的大数据平台。支持spark, hive, hbase, flink, hudi 和presto.\u003c/p\u003e\n\u003ch2 id=\"kinesis\"\u003eKinesis\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eData Analytics\u003c/li\u003e\n\u003cli\u003eData Firehose\u003c/li\u003e\n\u003cli\u003eData Streams\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"lake-formation\"\u003eLake Formation\u003c/h2\u003e\n\u003ch2 id=\"quicksight\"\u003eQuickSight\u003c/h2\u003e\n\u003ch2 id=\"opensearch\"\u003eOpenSearch\u003c/h2\u003e\n\u003ch2 id=\"msk\"\u003eMSK\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"data-analysis\"\u003eData Analysis\u003c/h1\u003e\n\u003ch2 id=\"athena-1\"\u003eAthena\u003c/h2\u003e\n\u003cp\u003eserverless服务\u003c/p\u003e\n\u003ch2 id=\"quicksight-1\"\u003eQuicksight\u003c/h2\u003e\n\u003ch2 id=\"aws-cloudsearch\"\u003eAWS CloudSearch\u003c/h2\u003e\n\u003chr\u003e",
    "content": "Data Processing Athena serverless交互式分析\nData Exchange Glue AWS上的ETL(extract, transform and load)服务，提供数据的提取，转换，加载服务。\nData pipeline 也是ETL服务。\nEMR EMR: Elastic MapReduce.\nAWS的大数据平台。支持spark, hive, hbase, flink, hudi 和presto.\nKinesis Data Analytics Data Firehose Data Streams Lake Formation QuickSight OpenSearch MSK Data Analysis Athena serverless服务\nQuicksight AWS CloudSearch ",
    "categories": ["Cloud"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Database",
    "permalink": "https://canuxcheng.com/post/aws_database/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws-database\"\u003eAWS Database\u003c/h1\u003e\n\u003ch2 id=\"rds\"\u003eRDS\u003c/h2\u003e\n\u003cp\u003eRelational Database Service， 关系型数据库服务.\u003c/p\u003e\n\u003cp\u003e支持的数据库引擎：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAmazon Aurora\u003c/li\u003e\n\u003cli\u003ePostgreSQL\u003c/li\u003e\n\u003cli\u003eMySQL\u003c/li\u003e\n\u003cli\u003eMariaDB\u003c/li\u003e\n\u003cli\u003eOracle Database\u003c/li\u003e\n\u003cli\u003eMicrosoft SQL Server\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"aurora-serverless\"\u003eAurora Serverless\u003c/h2\u003e\n\u003ch2 id=\"aurora\"\u003eAurora\u003c/h2\u003e\n\u003cp\u003e兼容mysql和postgresql.\u003c/p\u003e\n\u003ch2 id=\"dynamodb\"\u003eDynamoDB\u003c/h2\u003e\n\u003cp\u003e非关系数据库(NoSQL).\u003c/p\u003e\n\u003cp\u003eDynamoDB是一项键值数据库服务. 无服务器，自动扩展。\u003c/p\u003e\n\u003cp\u003e具有Key-Value数据库和Document数据库的功能。\u003c/p\u003e\n\u003ch2 id=\"documentdb\"\u003eDocumentDB\u003c/h2\u003e\n\u003cp\u003e兼容MongoDB.\u003c/p\u003e\n\u003ch2 id=\"elasticcache\"\u003eElasticCache\u003c/h2\u003e\n\u003cp\u003e内存数据库(in-memory). 兼容redis和memcached.\u003c/p\u003e\n\u003ch2 id=\"keyspaces\"\u003eKeyspaces\u003c/h2\u003e\n\u003cp\u003e兼容cassandra的无服务器数据库。\u003c/p\u003e\n\u003ch2 id=\"redshift\"\u003eRedshift\u003c/h2\u003e\n\u003cp\u003eAmazon Redshift 是一项数据仓库服务，可用于进行大数据分析。\u003c/p\u003e\n\u003ch2 id=\"neptune\"\u003eNeptune\u003c/h2\u003e\n\u003cp\u003e图形数据库\u003c/p\u003e\n\u003ch2 id=\"timesteam\"\u003eTimesteam\u003c/h2\u003e",
    "content": "AWS Database RDS Relational Database Service， 关系型数据库服务.\n支持的数据库引擎：\nAmazon Aurora PostgreSQL MySQL MariaDB Oracle Database Microsoft SQL Server Aurora Serverless Aurora 兼容mysql和postgresql.\nDynamoDB 非关系数据库(NoSQL).\nDynamoDB是一项键值数据库服务. 无服务器，自动扩展。\n具有Key-Value数据库和Document数据库的功能。\nDocumentDB 兼容MongoDB.\nElasticCache 内存数据库(in-memory). 兼容redis和memcached.\nKeyspaces 兼容cassandra的无服务器数据库。\nRedshift Amazon Redshift 是一项数据仓库服务，可用于进行大数据分析。\nNeptune 图形数据库\nTimesteam ",
    "categories": ["Cloud","Database"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Network",
    "permalink": "https://canuxcheng.com/post/aws_network/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws-network\"\u003eAWS Network\u003c/h1\u003e\n\u003ch2 id=\"vpc\"\u003eVPC\u003c/h2\u003e\n\u003cp\u003eVirtual Private Cloud.\u003c/p\u003e\n\u003cp\u003eEC2的私有内部网络.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esubnets\u003c/li\u003e\n\u003cli\u003eroute tables\u003c/li\u003e\n\u003cli\u003einternet gateways\u003c/li\u003e\n\u003cli\u003enat gateways\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eENI: Elastic network interfaces.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/images/vpc.png\"\u003epic\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"elb\"\u003eELB\u003c/h2\u003e\n\u003cp\u003eELB: Elastic Load Balancing\u003c/p\u003e\n\u003cp\u003e弹性负载均衡，可以和EC2,ECS和lambda集成.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://aws.amazon.com/cn/elasticloadbalancing/features/\"\u003ehttps://aws.amazon.com/cn/elasticloadbalancing/features/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e支持四种负载均衡器：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eClassic Load Balancer(默认)\u003c/li\u003e\n\u003cli\u003eGateway Load Balancer\u003c/li\u003e\n\u003cli\u003eApplication Load Balancer(ALB)\u003c/li\u003e\n\u003cli\u003eNetwork Load Balancer(NLB)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html\"\u003ehttps://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e可以使用aws默认自带的NLB controller.也可以通过安装aws-load-balancer-controller。推荐后者。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/aws-load-balancer-controller\"\u003ehttps://github.com/kubernetes-sigs/aws-load-balancer-controller\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e需要给vpc上的node的subnet打tag:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekubernetes.io/role/elb: 1\nkubernetes.io/role/internal-elb: 1\nkubernetes.io/cluster/${cluster-name}: owned/shared\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"route-53\"\u003eRoute 53\u003c/h2\u003e\n\u003cp\u003eDNS服务.\u003c/p\u003e\n\u003cp\u003e在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。\u003c/p\u003e\n\u003cp\u003e申请好了证书，需要在route 53创建记录.\u003c/p\u003e\n\u003cp\u003e可以通过external-DNS 自动同步eks上的service和ingress到dns。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws route53 list-hosted-zones\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"cloudfront\"\u003eCloudFront\u003c/h2\u003e\n\u003cp\u003eCDN服务.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"direct-connect\"\u003eDirect Connect\u003c/h2\u003e\n\u003cp\u003e提供数据中心和AWS直连。\u003c/p\u003e",
    "content": "AWS Network VPC Virtual Private Cloud.\nEC2的私有内部网络.\nsubnets route tables internet gateways nat gateways ENI: Elastic network interfaces.\npic\nELB ELB: Elastic Load Balancing\n弹性负载均衡，可以和EC2,ECS和lambda集成.\nhttps://aws.amazon.com/cn/elasticloadbalancing/features/\n支持四种负载均衡器：\nClassic Load Balancer(默认) Gateway Load Balancer Application Load Balancer(ALB) Network Load Balancer(NLB) https://docs.aws.amazon.com/zh_cn/eks/latest/userguide/aws-load-balancer-controller.html\n可以使用aws默认自带的NLB controller.也可以通过安装aws-load-balancer-controller。推荐后者。\nhttps://github.com/kubernetes-sigs/aws-load-balancer-controller\n需要给vpc上的node的subnet打tag:\nkubernetes.io/role/elb: 1 kubernetes.io/role/internal-elb: 1 kubernetes.io/cluster/${cluster-name}: owned/shared Route 53 DNS服务.\n在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。\n申请好了证书，需要在route 53创建记录.\n可以通过external-DNS 自动同步eks上的service和ingress到dns。\naws route53 list-hosted-zones CloudFront CDN服务.\nDirect Connect 提供数据中心和AWS直连。\nGlobal Accelerator PrivateLink Transit Gateway VPN ",
    "categories": ["Cloud","Network"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Security",
    "permalink": "https://canuxcheng.com/post/aws_security/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"security\"\u003eSecurity\u003c/h1\u003e\n\u003cp\u003eAcceptable Use Policy.\u003c/p\u003e\n\u003ch2 id=\"iam\"\u003eIAM\u003c/h2\u003e\n\u003cp\u003eIAM: Identity and Access Management.\u003c/p\u003e\n\u003cp\u003eSTS: Security Token Service.\u003c/p\u003e\n\u003cp\u003eACL: Access control list.\u003c/p\u003e\n\u003cp\u003eSG: Security Group.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://aws.amazon.com/cn/iam/\"\u003ehttps://aws.amazon.com/cn/iam/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$aws iam list-users\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIAM的三种身份类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUsers\u003c/li\u003e\n\u003cli\u003eGroups\u003c/li\u003e\n\u003cli\u003eRoles\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIAM通过Policy(json)分配权限。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"sso\"\u003eSSO\u003c/h2\u003e\n\u003cp\u003esso登陆:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws configure sso\naws sso login --no-browser \naws sso logout\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2 id=\"secrets-manager\"\u003eSecrets Manager\u003c/h2\u003e\n\u003chr\u003e\n\u003ch2 id=\"acm\"\u003eACM\u003c/h2\u003e\n\u003cp\u003eAWS Certificate Manager.\u003c/p\u003e\n\u003cp\u003e在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。\u003c/p\u003e\n\u003cp\u003e申请好了证书，需要在route 53创建记录.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws acm list-certificates --region eu-west-1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eaws-load-balancer-controller可以自动关联ACM的证书和ingress.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"artifact\"\u003eArtifact\u003c/h2\u003e\n\u003cp\u003e自助的合规报告。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"waf\"\u003eWAF\u003c/h2\u003e\n\u003ch2 id=\"shield\"\u003eShield\u003c/h2\u003e\n\u003chr\u003e\n\u003ch2 id=\"kms\"\u003eKMS\u003c/h2\u003e\n\u003cp\u003eKey Management Service.\u003c/p\u003e",
    "content": "Security Acceptable Use Policy.\nIAM IAM: Identity and Access Management.\nSTS: Security Token Service.\nACL: Access control list.\nSG: Security Group.\nhttps://aws.amazon.com/cn/iam/\n$aws iam list-users IAM的三种身份类型:\nUsers Groups Roles IAM通过Policy(json)分配权限。\nSSO sso登陆:\naws configure sso aws sso login --no-browser aws sso logout Secrets Manager ACM AWS Certificate Manager.\n在route 53创建托管区(hosted zones)之后，可以在ACM申请证书。\n申请好了证书，需要在route 53创建记录.\naws acm list-certificates --region eu-west-1 aws-load-balancer-controller可以自动关联ACM的证书和ingress.\nArtifact 自助的合规报告。\nWAF Shield KMS Key Management Service.\nInspector GuardDuty Cognito 支持google/amazon/MS-AD/SAML 登陆。\nAudit Manager CloudHSM Detective Directory Service Firewall Manager Macie Network Firewall RAM Resource Access Manager\nSecurity Hub STS Security Token Service\n",
    "categories": ["Cloud","Security"],
    "tags": ["aws"]
  },
  {
    "title": "AWS Storage",
    "permalink": "https://canuxcheng.com/post/aws_storage/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"aws-storage\"\u003eAWS Storage\u003c/h1\u003e\n\u003ch2 id=\"s3\"\u003eS3\u003c/h2\u003e\n\u003cp\u003eSimple Storage Service.\u003c/p\u003e\n\u003cp\u003eS3分类：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eS3标准\u003c/li\u003e\n\u003cli\u003eS3标准-IA\u003c/li\u003e\n\u003cli\u003eS3单区-IA\u003c/li\u003e\n\u003cli\u003eS3智能分层\u003c/li\u003e\n\u003cli\u003eS3 Glacier\u003c/li\u003e\n\u003cli\u003eS3 Glacire Deep Archive\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e特点:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无限存储\u003c/li\u003e\n\u003cli\u003e单个对象达到5Tb\u003c/li\u003e\n\u003cli\u003e一次写入，多次读取\u003c/li\u003e\n\u003cli\u003e99%持久性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"s3-glacier\"\u003eS3 Glacier\u003c/h2\u003e\n\u003cp\u003e用于存放归档文件，按照访问量收费。\u003c/p\u003e\n\u003ch2 id=\"ebs\"\u003eEBS\u003c/h2\u003e\n\u003cp\u003eElastic Block Store.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/aws-ebs-csi-driver\"\u003ehttps://github.com/kubernetes-sigs/aws-ebs-csi-driver\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eEBS可以连接到EC2实例，可用区级资源，需要位于同一可用区中才能连接到EC2实例，卷不会自动扩展。\u003c/p\u003e\n\u003cp\u003eEBS只能被单个EC2实例访问。\u003c/p\u003e\n\u003cp\u003e特点:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大小高达16Tb\u003c/li\u003e\n\u003cli\u003eEC2实例终止后仍然存在\u003c/li\u003e\n\u003cli\u003e默认情况下为固态(SSD)\u003c/li\u003e\n\u003cli\u003e提供IOPS SSD和HDD选项\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"efs\"\u003eEFS\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/aws-efs-csi-driver\"\u003ehttps://github.com/kubernetes-sigs/aws-efs-csi-driver\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eElastic File System 是linux的NFS服务.\u003c/p\u003e\n\u003cp\u003eEFS是区域性服务，将数据存储在多个可用区中。可以被上千个EC2实例同时访问。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e完全托管的NFS文件系统\u003c/li\u003e\n\u003cli\u003e为linux负载而设计\u003c/li\u003e\n\u003cli\u003e支持PB级别数据\u003c/li\u003e\n\u003cli\u003e可以跨多个区域存储数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEFS提供两种存储类型(StorageClass): Standard, Infrequent access.\u003c/p\u003e\n\u003ch2 id=\"fsx\"\u003eFSx\u003c/h2\u003e\n\u003cp\u003eFSx是windows File Server服务.\u003c/p\u003e\n\u003ch2 id=\"storage-gateway\"\u003eStorage Gateway\u003c/h2\u003e\n\u003cp\u003e支持三种类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTape gateway\u003c/li\u003e\n\u003cli\u003eVolume gateway\u003c/li\u003e\n\u003cli\u003eFile Gateway\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"aws-backup\"\u003eAWS Backup\u003c/h2\u003e\n\u003ch2 id=\"aws-edr\"\u003eAWS EDR\u003c/h2\u003e\n\u003cp\u003eElastic Disaster Recovery.\u003c/p\u003e",
    "content": "AWS Storage S3 Simple Storage Service.\nS3分类：\nS3标准 S3标准-IA S3单区-IA S3智能分层 S3 Glacier S3 Glacire Deep Archive 特点:\n无限存储 单个对象达到5Tb 一次写入，多次读取 99%持久性 S3 Glacier 用于存放归档文件，按照访问量收费。\nEBS Elastic Block Store.\nhttps://github.com/kubernetes-sigs/aws-ebs-csi-driver\nEBS可以连接到EC2实例，可用区级资源，需要位于同一可用区中才能连接到EC2实例，卷不会自动扩展。\nEBS只能被单个EC2实例访问。\n特点:\n大小高达16Tb EC2实例终止后仍然存在 默认情况下为固态(SSD) 提供IOPS SSD和HDD选项 EFS https://github.com/kubernetes-sigs/aws-efs-csi-driver\nElastic File System 是linux的NFS服务.\nEFS是区域性服务，将数据存储在多个可用区中。可以被上千个EC2实例同时访问。\n完全托管的NFS文件系统 为linux负载而设计 支持PB级别数据 可以跨多个区域存储数据 EFS提供两种存储类型(StorageClass): Standard, Infrequent access.\nFSx FSx是windows File Server服务.\nStorage Gateway 支持三种类型:\nTape gateway Volume gateway File Gateway AWS Backup AWS EDR Elastic Disaster Recovery.\nSnow Family Snowcone Snowball 针对large-scale 数据传输 支持PB级别数据 通过物理设备上传数据到S3 Snowmobile 针对large-scale数据传输 支持EB级别数据 通过工作站上传数据到S3 Transfer family SFTP, FTPS, FTP.\nAWS Migration and Transfer ADS Application Discovery Service.\nAMS Application Migration Service.\nDMS Database Migration Service.\n让您能够迁移关系数据库、非关系数据库和其他类型的数据存储。\nSCT Schema Conversion Tool\nDataSync Migration Hub ",
    "categories": ["Cloud","Storage"],
    "tags": ["aws"]
  },
  {
    "title": "CDK",
    "permalink": "https://canuxcheng.com/post/cloud_cdk/",
    "date": "2021-04-23",
    "summary": "\u003ch1 id=\"cdk\"\u003eCDK\u003c/h1\u003e\n\u003cp\u003eCloud Development Kit\u003c/p\u003e\n\u003cp\u003eSDK一般是和service交互的。\nCDK用来和基础设施交互的。\u003c/p\u003e\n\u003ch2 id=\"aws-cdk\"\u003eAWS CDK\u003c/h2\u003e\n\u003cp\u003eThe AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/aws/aws-cdk\"\u003ehttps://github.com/aws/aws-cdk\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"cdk8s\"\u003eCDK8S\u003c/h2\u003e\n\u003cp\u003ecdk8s is an open-source software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s apps synthesize into standard Kubernetes manifests which can be applied to any Kubernetes cluster.\u003c/p\u003e",
    "content": "CDK Cloud Development Kit\nSDK一般是和service交互的。 CDK用来和基础设施交互的。\nAWS CDK The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation.\nhttps://github.com/aws/aws-cdk\nCDK8S cdk8s is an open-source software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s apps synthesize into standard Kubernetes manifests which can be applied to any Kubernetes cluster.\nhttps://github.com/cdk8s-team/cdk8s\nCKDTF Cloud Development Kit for Terraform (CDKTF) allows you to use familiar programming languages to define cloud infrastructure and provision it through HashiCorp Terraform. This gives you access to the entire Terraform ecosystem without learning HashiCorp Configuration Language (HCL) and lets you leverage the power of your existing toolchain for testing, dependency management, etc.\nhttps://www.terraform.io/cdktf\n$ npm install --global cdktf-cli@latest $ cd cdktf-demo $ cdktf init --template=\u0026quot;go\u0026quot; --local $ cdktf get $ go mod tidy $ cdktf synth $ cdktf deploy $ cdktf destroy ",
    "categories": ["Cloud"],
    "tags": ["cdk"]
  },
  {
    "title": "TypeScript",
    "permalink": "https://canuxcheng.com/post/js_ts/",
    "date": "2021-03-05",
    "summary": "\u003ch1 id=\"typescript\"\u003eTypeScript\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/microsoft/TypeScript\"\u003ehttps://github.com/microsoft/TypeScript\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.typescriptlang.org/zh/\"\u003ehttps://www.typescriptlang.org/zh/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/microsoft/tsdoc\"\u003ehttps://github.com/microsoft/tsdoc\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"tsx\"\u003eTSX\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;*.tsx\u0026rdquo; 是js的扩展，允许使用xml语法。\u003c/p\u003e\n\u003cp\u003etypescript支持interface。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"jsc\"\u003ejsc\u003c/h2\u003e\n\u003cp\u003e将TS编译成JS, tsconfig.json是配置文件。\u003c/p\u003e\n\u003chr\u003e",
    "content": "TypeScript https://github.com/microsoft/TypeScript\nhttps://www.typescriptlang.org/zh/\nhttps://github.com/microsoft/tsdoc\nTSX \u0026ldquo;*.tsx\u0026rdquo; 是js的扩展，允许使用xml语法。\ntypescript支持interface。\njsc 将TS编译成JS, tsconfig.json是配置文件。\n",
    "categories": ["Web"],
    "tags": ["typescript"]
  },
  {
    "title": "BitBake",
    "permalink": "https://canuxcheng.com/post/linux_bitbake/",
    "date": "2020-07-12",
    "summary": "\u003ch1 id=\"bitbake\"\u003eBitBake\u003c/h1\u003e\n\u003cp\u003ebitbake是类似于make的构建工具，主要用于OpenEmbedded和yocto构建linux发行版.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openembedded/bitbake\"\u003ehttps://github.com/openembedded/bitbake\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ebitbake:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ bitbake python -c devshell/devpyshell\n$ bitbake python -c clean/cleanall/cleanstate\n$ bitbake python -c compile\n$ bitbake python -c fetch/fetchall\n\n# 查找下载地址\n$ bitbake -e python | grep ^SRC_URI\n\n# 根据文件查找包名\nbitbake\u0026gt; oe-pkgdata-util find-path /usr/bin/python3\n\n# 包名查找recipe\nbitbake\u0026gt; oe-pkgdata-util lookup-recipe python3-core\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"openembedded\"\u003eopenembedded\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openembedded/openembedded-core\"\u003ehttps://github.com/openembedded/openembedded-core\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"yoctopoky\"\u003eyocto(poky)\u003c/h1\u003e\n\u003cp\u003epoky是一个开源的最小构建示例，内置bitbake，可直接编译.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/\"\u003ehttp://git.yoctoproject.org/cgit/cgit.cgi/poky/log/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers\"\u003ehttp://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/crazy-canux/poky\"\u003ehttps://github.com/crazy-canux/poky\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"toaster\"\u003etoaster\u003c/h1\u003e",
    "content": "BitBake bitbake是类似于make的构建工具，主要用于OpenEmbedded和yocto构建linux发行版.\nhttps://github.com/openembedded/bitbake\nbitbake:\n$ bitbake python -c devshell/devpyshell $ bitbake python -c clean/cleanall/cleanstate $ bitbake python -c compile $ bitbake python -c fetch/fetchall # 查找下载地址 $ bitbake -e python | grep ^SRC_URI # 根据文件查找包名 bitbake\u0026gt; oe-pkgdata-util find-path /usr/bin/python3 # 包名查找recipe bitbake\u0026gt; oe-pkgdata-util lookup-recipe python3-core openembedded https://github.com/openembedded/openembedded-core\nyocto(poky) poky是一个开源的最小构建示例，内置bitbake，可直接编译.\nhttp://git.yoctoproject.org/cgit/cgit.cgi/poky/log/\nhttp://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers\nhttps://github.com/crazy-canux/poky\ntoaster ",
    "categories": ["Linux"],
    "tags": ["bitbake"]
  },
  {
    "title": "kernel",
    "permalink": "https://canuxcheng.com/post/linux_kernel/",
    "date": "2020-05-27",
    "summary": "\u003ch1 id=\"kernel\"\u003eKernel\u003c/h1\u003e\n\u003ch1 id=\"command\"\u003ecommand\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003elsmod 查看已加载的模块    # /proc/modules\nrmmod \u0026lt;name\u0026gt; 删除模块\n\nmodprobe -c 查看已编译可加载的内核模块\nmodprobe \u0026lt;name\u0026gt; 加载模块 # /etc/modules\nmodprobe -r \u0026lt;name\u0026gt; 删除模块\n\n// modprobe 重启就没了\necho \u0026quot;ipmi_devintf\u0026quot; \u0026gt;\u0026gt; /etc/modules\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Kernel command lsmod 查看已加载的模块 # /proc/modules rmmod \u0026lt;name\u0026gt; 删除模块 modprobe -c 查看已编译可加载的内核模块 modprobe \u0026lt;name\u0026gt; 加载模块 # /etc/modules modprobe -r \u0026lt;name\u0026gt; 删除模块 // modprobe 重启就没了 echo \u0026quot;ipmi_devintf\u0026quot; \u0026gt;\u0026gt; /etc/modules ",
    "categories": ["Linux"],
    "tags": ["kernel"]
  },
  {
    "title": "Linux Security",
    "permalink": "https://canuxcheng.com/post/linux_security/",
    "date": "2020-05-24",
    "summary": "\u003ch1 id=\"selinux\"\u003eSeLinux\u003c/h1\u003e\n\u003cp\u003eSecurity-Enhanced Linux\u003c/p\u003e\n\u003ch1 id=\"seccomp\"\u003eSecComp\u003c/h1\u003e\n\u003cp\u003eSecure computing mode (seccomp) is a Linux kernel feature.\u003c/p\u003e\n\u003ch1 id=\"apparmor\"\u003eAppArmor\u003c/h1\u003e\n\u003cp\u003eAppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats.\u003c/p\u003e",
    "content": "SeLinux Security-Enhanced Linux\nSecComp Secure computing mode (seccomp) is a Linux kernel feature.\nAppArmor AppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats.\n",
    "categories": ["Linux","Security"],
    "tags": ["security"]
  },
  {
    "title": "K8S CNI",
    "permalink": "https://canuxcheng.com/post/k8s_cni/",
    "date": "2020-03-26",
    "summary": "\u003ch1 id=\"network-add-ons\"\u003eNetwork add-ons\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/containernetworking\"\u003ehttps://github.com/containernetworking\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eflannel\u003c/li\u003e\n\u003cli\u003ecilium\u003c/li\u003e\n\u003cli\u003ecalico\u003c/li\u003e\n\u003cli\u003evpc-cni (aws)\u003c/li\u003e\n\u003cli\u003ekube-router\u003c/li\u003e\n\u003cli\u003eweavenet\u003c/li\u003e\n\u003cli\u003eantrea\u003c/li\u003e\n\u003cli\u003eromana\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cilium\"\u003ecilium\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cilium/cilium\"\u003ehttps://github.com/cilium/cilium\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"flannel\"\u003eFlannel\u003c/h2\u003e\n\u003cp\u003eflannel是k8s最常用的网络插件.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/coreos/flannel\"\u003ehttps://github.com/coreos/flannel\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在所有node上部署cni-plugin:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/containernetworking/plugins/releases\"\u003ehttps://github.com/containernetworking/plugins/releases\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo mkdir -p /opt/cni/bin\n// 下载并解压所有插件命令到该目录.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enetwork-addon(master上操作即可):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003everyfy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ kubectl get nodes\n$ kubectl get pod --all-namespaces\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e删除插件:\u003c/p\u003e\n\u003cp\u003e删除插件会影响已经部署的pod.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 删除flannel \n$ kubectl delete -f X.yml  \n$ sudo systemctl stop kubelet docker\n\n// 第二步，在node节点清理flannel网络留下的文件\nifconfig cni0 down\nip link delete cni0 \nifconfig flannel.1 down\nip link delete flannel.1 \nrm -rf /var/lib/cni /etc/cni /run/flannel\n$ sudo rm -rf /var/lib/kubelet /var/lib/etcd\n\n// 重启kubelet\n$ sudo systemctl start kubelet docker\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改配置:\u003c/p\u003e",
    "content": "Network add-ons https://github.com/containernetworking\nflannel cilium calico vpc-cni (aws) kube-router weavenet antrea romana cilium https://github.com/cilium/cilium\nFlannel flannel是k8s最常用的网络插件.\nhttps://github.com/coreos/flannel\n在所有node上部署cni-plugin:\nhttps://github.com/containernetworking/plugins/releases\n$ sudo mkdir -p /opt/cni/bin // 下载并解压所有插件命令到该目录. network-addon(master上操作即可):\n$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml veryfy:\n$ kubectl get nodes $ kubectl get pod --all-namespaces 删除插件:\n删除插件会影响已经部署的pod.\n// 删除flannel $ kubectl delete -f X.yml $ sudo systemctl stop kubelet docker // 第二步，在node节点清理flannel网络留下的文件 ifconfig cni0 down ip link delete cni0 ifconfig flannel.1 down ip link delete flannel.1 rm -rf /var/lib/cni /etc/cni /run/flannel $ sudo rm -rf /var/lib/kubelet /var/lib/etcd // 重启kubelet $ sudo systemctl start kubelet docker 修改配置:\n/etc/kube-flannel/net-conf.json\n{ \u0026quot;Network\u0026quot;: \u0026quot;10.244.0.0/16\u0026quot;, \u0026quot;SubnetLen\u0026quot;: 24, \u0026quot;SubnetMin\u0026quot;: \u0026quot;10.244.0.0\u0026quot;, \u0026quot;SubnetMax\u0026quot;: \u0026quot;10.244.255.0\u0026quot;, \u0026quot;Backend\u0026quot;: { \u0026quot;Type\u0026quot;: \u0026quot;vxlan\u0026quot; } } 使用kubeadm：\nkubeadm init必须指定flannel的Network参数:\n--pod-network-cidr=10.244.0.0/16 如果需要修改其它参数，同时需要修改kubeadm的配置\n",
    "categories": ["CNCF","Network"],
    "tags": ["k8s"]
  },
  {
    "title": "K8S CSI",
    "permalink": "https://canuxcheng.com/post/k8s_csi/",
    "date": "2020-03-25",
    "summary": "\u003ch1 id=\"csi\"\u003eCSI\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/container-storage-interface/spec\"\u003ehttps://github.com/container-storage-interface/spec\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erook\u003c/li\u003e\n\u003cli\u003ecubefs\u003c/li\u003e\n\u003cli\u003elonghorn\u003c/li\u003e\n\u003cli\u003eceph\u003c/li\u003e\n\u003cli\u003eminio\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"卷volume\"\u003e卷Volume\u003c/h2\u003e\n\u003cp\u003e和docker中的一样。\u003c/p\u003e\n\u003cp\u003evolume支持的卷类型有: awsEBS, azureDisk, azureFile, gcePD, secret, configMap, emptyDir, hostPath, local, nfs等.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: v1\nkind: Pod\nmetadata:\n  name: test-ebs\nspec:\n  containers:\n  - image: k8s.gcr.io/test-webserver\n    name: test-container\n    volumeMounts:\n    - mountPath: /test-ebs\n      name: test-volume\n  volumes:\n  - name: test-volume\n    # 此 AWS EBS 卷必须已经存在\n    awsElasticBlockStore:\n      volumeID: \u0026quot;\u0026lt;volume-id\u0026gt;\u0026quot;\n      fsType: ext4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAWS的EBS和EFS需要安装驱动:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/aws-ebs-csi-driver\"\u003ehttps://github.com/kubernetes-sigs/aws-ebs-csi-driver\u003c/a\u003e\n\u003ca href=\"https://github.com/kubernetes-sigs/aws-efs-csi-driver\"\u003ehttps://github.com/kubernetes-sigs/aws-efs-csi-driver\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"存储类storageclass\"\u003e存储类StorageClass\u003c/h2\u003e\n\u003cp\u003estorageclass没有namespace.\u003c/p\u003e\n\u003cp\u003e每个存储类包含provisioner, parameters和reclaimPolicy.\u003c/p\u003e\n\u003cp\u003e内置provisioner的卷插件:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eawsEBS\u003c/li\u003e\n\u003cli\u003eazureFile\u003c/li\u003e\n\u003cli\u003eazureDisk\u003c/li\u003e\n\u003cli\u003egcePD\u003c/li\u003e\n\u003cli\u003eopenstack cinder\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e没有provisioner的卷类型可以使用外部插件或者自己开发.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner\"\u003ehttps://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner\u003c/a\u003e\u003c/p\u003e",
    "content": "CSI https://github.com/container-storage-interface/spec\nrook cubefs longhorn ceph minio 卷Volume 和docker中的一样。\nvolume支持的卷类型有: awsEBS, azureDisk, azureFile, gcePD, secret, configMap, emptyDir, hostPath, local, nfs等.\napiVersion: v1 kind: Pod metadata: name: test-ebs spec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-ebs name: test-volume volumes: - name: test-volume # 此 AWS EBS 卷必须已经存在 awsElasticBlockStore: volumeID: \u0026quot;\u0026lt;volume-id\u0026gt;\u0026quot; fsType: ext4 AWS的EBS和EFS需要安装驱动:\nhttps://github.com/kubernetes-sigs/aws-ebs-csi-driver https://github.com/kubernetes-sigs/aws-efs-csi-driver\n存储类StorageClass storageclass没有namespace.\n每个存储类包含provisioner, parameters和reclaimPolicy.\n内置provisioner的卷插件:\nawsEBS azureFile azureDisk gcePD openstack cinder 没有provisioner的卷类型可以使用外部插件或者自己开发.\nhttps://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner\nawsEBS:\nkind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: sourcegraph labels: deploy: sourcegraph # provisioner: ebs.csi.aws.com provisioner: kubernetes.io/aws-ebs parameters: type: gp2 # This configures SSDs (default). fsType: ext4 # (default) reclaimPolicy: Retain volumeBindingMode: WaitForFirstConsumer allowVolumeExpansion: true nfs:\nkubernetes不包含nfs驱动，需要使用外部驱动创建nfs存储类.\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: example-nfs provisioner: example.com/external-nfs parameters: server: nfs-server.example.com path: /share readOnly: false local:\n本地卷不支持动态制备.\nkind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: local-storage provisioner: kubernetes.io/no-provisioner volumeBindingMode: WaitForFirstConsumer 持久卷PV persistentvolume没有namespace, 用来指定具体的存储资源。有静态和动态两种方式，最终需要绑定到pvc上。\npv的回收策略ReclaimPolicy:\nRetained保留 Deleted删除 pv的卷绑定模式volumeBindingMode:\nWaitForFirstConsumer Immediate 卷模式volumeMode:\nFilesystem(默认) Block 访问模式accessMode:\nRWO: ReadWriteOnce ROX: ReadOnlyMany RWX: ReadWriteMany RWOP: ReadWriteOncePod 卷的阶段：\nAvaliable Bound Released Failed static volume provisioning 静态pvc和pv的绑定通过storageClassName, accessMode和capacity来判断。\npv中的capacity必须大于等于pvc。\napiVersion: v1 kind: PersistentVolume metadata: name: nas-csi-pv labels: app: demo spec: storageClassName: persistentVolumeReclaimPolicy: Retained/Recycled accessModes: - ReadWriteMany capacity: storage: 5Gi hostPath: path: \u0026quot;/home/path\u0026quot; csi: driver: ... dynamic volume provisioning 动态pv需要storageclass, 由StorageClass动态的创建PV, 不需要手动创建pv，只需要在pvc中指定storageclass即可.\nstorageclass没有namespace\nkind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: sourcegraph labels: deploy: sourcegraph provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain volumeBindingMode: WaitForFirstConsumer allowVolumeExpansion: true apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pgsql labels: deploy: sourcegraph sourcegraph-resource-requires: no-cluster-admin app.kubernetes.io/component: pgsql spec: // 通过storageClassName自动给pvc创建pv storageClassName: sourcegraph accessModes: - ReadWriteOnce resources: requests: storage: 200Gi PVC apiVersion: v1 kind: PersistentVolumeClaim metadata: name: nsa-pvc namespace: test labels: app: demo spec: accessModes: - ReadWriteMany resources: requests: storage: 5Gi // 通过selector让PVC使用指定的PV。 selector: app: demo VolumeSnapshotClass VolumeSnapshot VS是对资源的请求.\napiVersion: snapshot.storage.k8s.io/v1 kind: VolumeSnapshot metadata: name: new-snapshot-test spec: volumeSnapshotClassName: csi-hostpath-snapclass source: persistentVolumeClaimName: pvc-test VolumeSnapshotContent VSC实际中资源管理.\napiVersion: snapshot.storage.k8s.io/v1 kind: VolumeSnapshotContent metadata: name: snapcontent-72d9a349-aacd-42d2-a240-d775650d2455 spec: deletionPolicy: Delete driver: hostpath.csi.k8s.io source: volumeHandle: ee0cfb94-f8d4-11e9-b2d8-0242ac110002 volumeSnapshotClassName: csi-hostpath-snapclass volumeSnapshotRef: name: new-snapshot-test namespace: default uid: 72d9a349-aacd-42d2-a240-d775650d2455 ",
    "categories": ["CNCF","Storage"],
    "tags": ["k8s"]
  },
  {
    "title": "Kubectl",
    "permalink": "https://canuxcheng.com/post/k8s_kubectl/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"kubectl\"\u003ekubectl\u003c/h1\u003e\n\u003cp\u003ekubectl是kubernetes的管理工具.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/tasks/tools/#kubectl\"\u003ehttps://kubernetes.io/docs/tasks/tools/#kubectl\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cloudnativelabs/kube-shell\"\u003ehttps://github.com/cloudnativelabs/kube-shell\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jonmosco/kube-ps1\"\u003ehttps://github.com/jonmosco/kube-ps1\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ahmetb/kubectx\"\u003ehttps://github.com/ahmetb/kubectx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在master上通过kubectl命令管理集群.\u003c/p\u003e\n\u003cp\u003ekubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.24 版本的客户端能与 v1.23、 v1.24 和 v1.25 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。\u003c/p\u003e\n\u003ch2 id=\"options\"\u003eOptions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003ekubectl options # 查看所有命令可用选项\n\n--kubeconfig\nkubectl --kubeconfig=$HOME/.kube.config (default)\n\n-n/--namespace\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"basic-command\"\u003ebasic command\u003c/h2\u003e\n\u003cp\u003ecreate:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 通过yaml或json文件创建资源\n$ kubectl create -f FILENAME [options]\n\noptions:\n-f/--filename\n\nkubectl create secret tls kubernetes-dashboard-tls --key ca.key --cert ca.crt -n kubernetes-dashboard\n\n// 输出一个资源的yaml格式.\nkubectl create deployment \u0026lt;name\u0026gt; --image=\u0026lt;img-name\u0026gt; --dry-run=client --output=yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edelete:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 删除资源\n$ kubectl delete (-f FILENAME | -k DICT | TYPE [(NAME|-l label|--all)]) [optiions]\n\noptions:\n-f/--filename\n--all  \n--all-namespaces\n--force\n\n$ kubectl delete pods --all\n$ kubectl delete pod \u0026lt;name\u0026gt;\n// 删除指定ns下所有资源.\n$ kubectl delete all --all -n {namespace}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e删除带有finalizers字段的对象，对象实际被更新了，没有真的被删除。可以通过patch来删除。\u003c/p\u003e",
    "content": "kubectl kubectl是kubernetes的管理工具.\nhttps://kubernetes.io/docs/tasks/tools/#kubectl\nhttps://github.com/cloudnativelabs/kube-shell\nhttps://github.com/jonmosco/kube-ps1\nhttps://github.com/ahmetb/kubectx\n在master上通过kubectl命令管理集群.\nkubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.24 版本的客户端能与 v1.23、 v1.24 和 v1.25 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。\nOptions kubectl options # 查看所有命令可用选项 --kubeconfig kubectl --kubeconfig=$HOME/.kube.config (default) -n/--namespace basic command create:\n# 通过yaml或json文件创建资源 $ kubectl create -f FILENAME [options] options: -f/--filename kubectl create secret tls kubernetes-dashboard-tls --key ca.key --cert ca.crt -n kubernetes-dashboard // 输出一个资源的yaml格式. kubectl create deployment \u0026lt;name\u0026gt; --image=\u0026lt;img-name\u0026gt; --dry-run=client --output=yaml delete:\n// 删除资源 $ kubectl delete (-f FILENAME | -k DICT | TYPE [(NAME|-l label|--all)]) [optiions] options: -f/--filename --all --all-namespaces --force $ kubectl delete pods --all $ kubectl delete pod \u0026lt;name\u0026gt; // 删除指定ns下所有资源. $ kubectl delete all --all -n {namespace} 删除带有finalizers字段的对象，对象实际被更新了，没有真的被删除。可以通过patch来删除。\n删除带有ownerReferences字段的对象，删除父对象默认会删除所有子对象，通过\u0026ndash;cascade=false只删除父对象。\nexpose:\n# 创建serivce: $ kubectl expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP|SCTP] [--target-port=...] [--name=...] [--external-ip=...] [--type=type] [options] # 创建service，并且使用NodePort # nodeport可以使用任意节点的IP访问. $ kubectl expose deployment hello-world --type=NodePort --name=example-service // 获取service的yaml kubectl expose deployment \u0026lt;deploy-name\u0026gt; --type=LoadBalancer --port=80 --dry-run=client --output=yaml run:\n# 创建pod/container(docker run): $ kubectl run NAME --image=image [--env=\u0026quot;key=value\u0026quot;] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...] [options] set:\n$ kubectl set SUBCOMMAND [options] // 更新镜像 $ kubectl set image deployment.v1.apps/\u0026lt;deploy-name\u0026gt; \u0026lt;container-name\u0026gt;=\u0026lt;image:tag\u0026gt; get:\n// 获取resource信息(docker ps) $ kubectl [-n \u0026lt;namespace\u0026gt;] get [resource] [flags] [options] options: -A/--all-namespaces -f/--filename -o/--output json/yaml/json/wide/name/... -w/--watch --watch-only kubectl get nodes --show-labels kubectl get nodes/no # 获取node节点信息 kubectl get namespace/ns # 获取namespace信息 kubectl get componentstatuses/cs kubectl get all --all-namespaces kubectl -n kube-system get all kubectl get pod/pods/po kubectl get po -w/--watch kubectl get po -o wide kubectl get deployment/deployments/deploy kubectl get service/services/svc explain:\nhttps://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/\n// 查看资源解析 $ kubectl explain RESOURCE [options] kubectl explain deploy.spec edit:\n// 在线修改资源，直接生效. $ kubectl edit advanced commands apply:\n$ kubectl apply diff:\n$ kubectl diff patch\n$ kubectl patch // 删除terminating状态的resource $ kubectl patch persistentvolumeclaim/storage -p '{\u0026quot;metadata\u0026quot;:{\u0026quot;finalizers\u0026quot;:null}}' -n \u0026lt;ns\u0026gt; $ kubectl replace $ kubectl wait $ kubectl kustomize deploy command scale:\n$ kubectl scale $ kubectl scale deployment \u0026lt;deploy-name\u0026gt; -n \u0026lt;ns\u0026gt; --replicas=0 autoscale:\n$ kubectl autoscale rollout:\n// 回滚 $ kubectl rollout // 暂停/恢复/重启 deployment. kubectl rollout pause/resume/restart deploy/katib-mysql -n kubeflow debug\u0026amp;troubleshoot describe:\n// like docker inspect $ kubectl describe (-f FILENAME | TYPE ... | TYPE/NAME) [options] options: -A/--all-namespaces -f/--filename // 查看node信息 $ kubectl describe nodes \u0026lt;name\u0026gt; //查看pod详细信息 $ kubectl describe pods \u0026lt;name\u0026gt; // 获取k8s-dashboard的token $ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}') logs:\n# like docker logs $ kubectl logs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER] [options] options: --all-containers -f/--follow -p/--previous // 查看pod中指定container log kubectl logs -f \u0026lt;pod\u0026gt; -c \u0026lt;container\u0026gt; -n \u0026lt;ns\u0026gt; exec:\n# like docker exec $ kubectl exec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] [options] options: -c/--container -i/--stdin -t/--tty $ kubectl exec -it \u0026lt;pod\u0026gt; -n \u0026lt;ns\u0026gt; -- /bin/bash port-forward:\n由于已知的限制，目前的端口转发仅适用于 TCP 协议.\n只能通过运行转发命令的IP/FQDN访问。\n$ kubectl port-forward // 转发本地端口到deploy/rs/svc/pod $ kubectl port-forward svc/redis-service 6379:6379 -n redis $ kubectl port-forward --address 0.0.0.0 -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 proxy:\n$ kubectl proxy // 通过proxy可以访问默认的clusterIP服务. attach:\n$ kubectl attach cp:\n$ kubectl cp auth:\n$ kubectl auth debug:\n$ kubectl debug // debug node -- 直接进入node的shell，log在/host/var/log kubectl debug node/\u0026lt;name\u0026gt; -it --image=ubuntu cluster management top:\n$ kubectl top $ kubectl cluster-info $ kubectl certificate // 节点变成unschedulable $ kubectl cordon // 节点变成schedulable $ kubectl uncordon // 安全下线节点：Ready,SchedulingDisabled $ kubectl drain kubectl drain \u0026lt;node\u0026gt; --delete-emptydir-data --ignore-daemonsets //定义污点 $ kubectl taint kubectl taint nodes \u0026lt;node\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;:NoSchedule- Settings Commands label\nlabel Update the labels on a resource kubectl label nodes \u0026lt;your-node-name\u0026gt; disktype=ssd annotate:\nannotate Update the annotations on a resource completion:\ncompletion Output shell completion code for the specified shell (bash or zsh) others api-resources:\n// api-resources Print the supported API resources on the server. kubectl api-resources api-versions:\n// api-versions Print the supported API versions on the server, in the form of \u0026quot;group/version\u0026quot;. kubectl api-versions config:\n// 参考kubectx config Modify kubeconfig files. plugin:\n// 参考krew plugin Provides utilities for interacting with plugins. // 查看安装的plugin $ kubectl plugin list version:\nversion Print the client and server version information. shell-auotcompletion bash/zsh 自动补全工具.\nhttps://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion\n$ kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl krew https://github.com/kubernetes-sigs/krew\n安装kubectl plugin的工具\n// 下载插件列表 $ kubectl krew update // 查找插件 $ kubectl krew search // 安装插件 $ kubectl krew install \u0026lt;name\u0026gt; // 升级插件 $ kubectl krew upgrade // 卸载插件 $ kubectl krew uninstall \u0026lt;name\u0026gt; kubectx https://github.com/ahmetb/kubectx\n在cluster和namespace之间切换的命令行工具.\n包括kubectx 和 kubedns\n通过krew安装，作为kubectl的plugin:\n$ kubectl krew install ctx $ kubectl krew install ns circtl 用于对node调试.\nhttps://github.com/kubernetes-sigs/cri-tools\nhttps://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/\nnerdctl 调试node。\nhttps://github.com/containerd/nerdctl\ntelepresence 用于本地调试集群上的服务.\nhttps://github.com/telepresenceio/telepresence\n",
    "categories": ["CNCF"],
    "tags": ["tag"]
  },
  {
    "title": "CI/CD",
    "permalink": "https://canuxcheng.com/post/k8s_cicd/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"continuous-integration--delivery\"\u003eContinuous Integration \u0026amp; Delivery\u003c/h1\u003e\n\u003ch2 id=\"argo-cd\"\u003eargo-cd\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/argoproj/argo-cd\"\u003ehttps://github.com/argoproj/argo-cd\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"flux-cd\"\u003eflux-cd\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/fluxcd/flux\"\u003ehttps://github.com/fluxcd/flux\u003c/a\u003e\u003c/p\u003e",
    "content": "Continuous Integration \u0026amp; Delivery argo-cd https://github.com/argoproj/argo-cd\nflux-cd https://github.com/fluxcd/flux\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Contribution",
    "permalink": "https://canuxcheng.com/post/k8s_oss/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"kubernetes-contribution\"\u003eKubernetes Contribution\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md\"\u003ehttps://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"创建google账号\"\u003e创建google账号\u003c/h2\u003e\n\u003cp\u003e推荐申请一个google邮箱。\u003c/p\u003e\n\u003cp\u003e在开发机配置git\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git config --global user.email name@gmail.com   \n$ git config user.email name@gmail.com            \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"签cla并阅读coc\"\u003e签CLA并阅读CoC\u003c/h2\u003e\n\u003cp\u003e个人开发者需要签署CLA, 选择individual contributors并用github账号登陆，然后去邮箱授权；之后重新进入，再去邮箱签字。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://identity.linuxfoundation.org/projects/cncf\"\u003ehttps://identity.linuxfoundation.org/projects/cncf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e读一下CoC和CV\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md\"\u003ehttps://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/community/blob/master/values.md\"\u003ehttps://github.com/kubernetes/community/blob/master/values.md\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"配置开发环境\"\u003e配置开发环境\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging\"\u003ehttps://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e可以在docker里面编译，也可以直接在操作系统上编译。\u003c/p\u003e\n\u003cp\u003e在docker里面编译\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md\"\u003ehttps://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebuild/run.sh make 只编译linux平台\nbuild/run.sh make cross 编译所有平台\nbuild/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64 编译指定平台的指定组件\n\nbuild/run.sh make test 单元测试\nbuild/run.sh make test-integration 集成测试\nbuild/run.sh make test-cmd  命令行测试\n\nbuild/copy-output.sh 将编译的binary从_output/dockerized/bin拷贝到本地\n\nbuild/make-clean.sh 清空_output\n\nbuild.shell.sh 交互模式进入编译的container\n\nbuild/release.sh 编译，测试，打包，kubernetes.tar.gz\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在操作系统上编译\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment\"\u003ehttps://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装依赖\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo apt-get update\nsudo apt-get install build-essential\n// apt: docker, rsync, jq, go, \n// python: pyyaml,\n\n// 安装etcd用于集成测试\n./hack/install-etcd.sh\nexport PATH=\u0026quot;$GOPATH/src/k8s.io/kubernetes/third_party/etcd:${PATH}\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e编译和测试\u003c/p\u003e",
    "content": "Kubernetes Contribution https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md\n创建google账号 推荐申请一个google邮箱。\n在开发机配置git\n$ git config --global user.email name@gmail.com $ git config user.email name@gmail.com 签CLA并阅读CoC 个人开发者需要签署CLA, 选择individual contributors并用github账号登陆，然后去邮箱授权；之后重新进入，再去邮箱签字。\nhttps://identity.linuxfoundation.org/projects/cncf\n读一下CoC和CV\nhttps://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md\nhttps://github.com/kubernetes/community/blob/master/values.md\n配置开发环境 https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging\n可以在docker里面编译，也可以直接在操作系统上编译。\n在docker里面编译\nhttps://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md\nbuild/run.sh make 只编译linux平台 build/run.sh make cross 编译所有平台 build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64 编译指定平台的指定组件 build/run.sh make test 单元测试 build/run.sh make test-integration 集成测试 build/run.sh make test-cmd 命令行测试 build/copy-output.sh 将编译的binary从_output/dockerized/bin拷贝到本地 build/make-clean.sh 清空_output build.shell.sh 交互模式进入编译的container build/release.sh 编译，测试，打包，kubernetes.tar.gz ... 在操作系统上编译\nhttps://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment\n安装依赖\nsudo apt-get update sudo apt-get install build-essential // apt: docker, rsync, jq, go, // python: pyyaml, // 安装etcd用于集成测试 ./hack/install-etcd.sh export PATH=\u0026quot;$GOPATH/src/k8s.io/kubernetes/third_party/etcd:${PATH}\u0026quot; 编译和测试\nmake all 全部编译 make WHAT=cmd/kubectl 指定编译组件 make cross 编译所有平台 make cross KUBE_BUILD_PLATFORMS=windows/amd64 编译指定平台 make verify presubmission verification测试 make test 单元测试 make test-integration 集成测试依赖etcd https://github.com/kubernetes/test-infra\n了解社区 https://github.com/kubernetes/community\n因为项目组件很多，所以通过特别兴趣小组来分类。\nSIG: Special Interest Groups WG: Working Group UG: User Group KEP: Kubernetes Enhancement Proposal\n对于功能和API的修改需要在KEP提交议案讨论。\nhttps://github.com/kubernetes/enhancements\nhttp://slack.k8s.io/\nhttps://discuss.kubernetes.io/\n选取修改的CL 从github选取一个Issue进行修改。\n推荐新手从“good first issue\u0026quot; 开始。\n也可以通过sig或者kind标签过滤。\nhttps://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22\n提交patch github用户直接fork到自己账号，clone下来即可。\ngit clone https://github.com/kubernetes/kubernetes.git 创建开发分支并修改代码\ngit checkout -b canux_dev ... git add -A git commit -m \u0026quot;...\u0026quot; git push ... code review 提交之后trybots会自动构建，可以通过build dashboard查看各个平台build结果:\nhttps://build.golang.org/\n查看自己的patch的review情况：\nhttps://go-review.googlesource.com/dashboard/self\n显示随时间变化的历史测试结果：\nhttps://testgrid.k8s.io/\n显示pow中的自动化测试情况：\nhttps://prow.k8s.io/\n查看所有PR:\nhttps://gubernator.k8s.io/pr/all\n把相似的失败聚合在一起以便排除故障:\nhttps://storage.googleapis.com/k8s-triage/index.html\n",
    "categories": ["CNCF"],
    "tags": ["oss"]
  },
  {
    "title": "K8S API",
    "permalink": "https://canuxcheng.com/post/k8s_api/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"api\"\u003eAPI\u003c/h1\u003e\n\u003cp\u003eapi-server统一的操作入口.\u003c/p\u003e\n\u003cp\u003ekubectl, UI, 等都是通过api-server操作资源.\u003c/p\u003e\n\u003cp\u003epayload可以是json，也可以是yaml.\u003c/p\u003e\n\u003cp\u003eyaml文件中#表示行注释。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"yaml\"\u003eyaml\u003c/h1\u003e\n\u003cp\u003e部署k8s可以通过yaml文件来配置资源.\u003c/p\u003e\n\u003cp\u003e资源对象组成部分:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: \nkind: \nmetadata: 元数据\nspec: 期望的状态\nstatus: 观测到的状态\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看apiVersion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekubectl api-versions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看Kind:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekubectl api-resources\n\n# In a namespace\nkubectl api-resources --namespaced=true\n\n# Not in a namespace\nkubectl api-resources --namespaced=false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emetadata:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emetadata:\n\n  name:\n  namespace:\n\n  labels/标签: 用户筛选资源，唯一的资源组合方法, 可以使用selector来查询.\n\n  annotations/注解: 存储资源的非标识性信息，扩展资源的spec/status.\n\n  ownerReference/关系: 方便反向查找创建资源的对象，方便进行级联删除。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003espec:\u003c/p\u003e\n\u003cp\u003estatus:\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"调度抢占驱逐\"\u003e调度，抢占，驱逐\u003c/h1\u003e\n\u003cp\u003etaints: 污点，使节点排斥特定pod。应用于node。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etaints:\n- effect: NoSchedule\n  key: kubernetes.io/arch\n  value: arm64\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etolerations: 容忍度，使pod被吸引到特定节点。应用于pod。\n这个只能让pod能部署到加了污点的node，pod也能部署到其它没有加污点的node。\u003c/p\u003e",
    "content": "API api-server统一的操作入口.\nkubectl, UI, 等都是通过api-server操作资源.\npayload可以是json，也可以是yaml.\nyaml文件中#表示行注释。\nyaml 部署k8s可以通过yaml文件来配置资源.\n资源对象组成部分:\napiVersion: kind: metadata: 元数据 spec: 期望的状态 status: 观测到的状态 查看apiVersion:\nkubectl api-versions 查看Kind:\nkubectl api-resources # In a namespace kubectl api-resources --namespaced=true # Not in a namespace kubectl api-resources --namespaced=false metadata:\nmetadata: name: namespace: labels/标签: 用户筛选资源，唯一的资源组合方法, 可以使用selector来查询. annotations/注解: 存储资源的非标识性信息，扩展资源的spec/status. ownerReference/关系: 方便反向查找创建资源的对象，方便进行级联删除。 spec:\nstatus:\n调度，抢占，驱逐 taints: 污点，使节点排斥特定pod。应用于node。\ntaints: - effect: NoSchedule key: kubernetes.io/arch value: arm64 tolerations: 容忍度，使pod被吸引到特定节点。应用于pod。 这个只能让pod能部署到加了污点的node，pod也能部署到其它没有加污点的node。\ntolerations: - key: \u0026quot;key1\u0026quot; operator: \u0026quot;Equal\u0026quot;/\u0026quot;Exists\u0026quot; value: \u0026quot;value1\u0026quot; effect: \u0026quot;NoSchedule\u0026quot;/\u0026quot;NoExecute\u0026quot; affinity: 亲和力，affinity可以通过label指定pod部署到node。 但是不能保证其它pod不部署到这个node。\naffinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/arch operator: In values: - arm64 nodeSelector: 节点选择，\nnodeSelector: kubernetes.io/arch: arm64 Pod pod模板， 通常使用deployment, job和statefulset, daemonset来管理pod.\napiVersion: v1 kind: Pod metadata: name: test namespace: test labels: app: test spec: //// containers os: // 操作系统模板 name: imagePullSecrets: // 私有镜像授权 - name: my-harbor initContainers: // initcontainer模板 - name: init image: my-image command: ... args: ... containers: // container 模板 - name: test // image image: image imagePullPolicy: Always/IfNotPresent/Never // entrypoint command: args: workingDir: // port ports: // resources resources: requests: // 申明需要的资源 memory: \u0026quot;64Mi\u0026quot; // byte cpu: \u0026quot;250m\u0026quot; // millicore (1 core = 1000 millicore) ephemeral-storage: \u0026quot;2Gi\u0026quot; // byte limits: memory: \u0026quot;128Mi\u0026quot; cpu: \u0026quot;500m\u0026quot; ephemeral-storage: \u0026quot;4Gi\u0026quot; // environment variables, 针对单个键值对. env: - name: key value: value - name: key valueFrom: // 将cm-name中的值cm-key传给key configMapKeyRef: name: cm-name key: cm-key optional: - name: key valueFrom: // 挂载secret secretKeyRef: key: name: optional: fieldRef: resourceFieldRef: // 环境变量，针对文件中所有键值对. envFrom: - configMapRef // 将my-cm中的所有键值对变成环境变量. name: my-cm optional: - secretRef name: optional: // volumeMounts (去Volume找对应资源) // 如果没有subpath，整个目录会被覆盖，目录下只有secret/configmap挂载的文件. volumeMounts: // secret以文件形式挂载到/etc/foo - name: my-secret mountPath: \u0026quot;/etc/foo\u0026quot; // 挂载之后覆盖整个目录 readOnly: true - name: my-configmap mountPath: \u0026quot;/etc/bar\u0026quot; // 挂载之后覆盖整个目录 // 如果有subpath, secret/configmap里的data里的文件名需要与subpath和mountpath指定的文件名一致. - name: config mountPath: /etc/app/app.conf // 是文件，文件名要和subpath一致。 subPath: app.conf // 挂载之后只覆盖目录中同名文件,其它文件不影响. // lifecycle livenessProbe: initialDelaySeconds: 10 periodSeconds: 10 timeoutSeconds: 5 httpGet: path: /admin port: django # httpHeaders: # - name: Authorization # value: Basic $LDAP_ACCOUNT readinessProbe: initialDelaySeconds: 10 periodSeconds: 10 timeoutSeconds: 5 httpGet: path: /admin port: django # httpHeaders: # - name: Authorization # value: Basic $LDAP_ACCOUNT // securityContext securityContext: // debugging stdin: false stdinOnce: false tty: false //// security context securityContext: // pod级别security context定义 runAsuser: 1000 runAsGroup: 3000 fsGroup: 2000 //// volumes volumes: - name: my-secret // 指定要挂载的secret secret: secretName: mysecret - name: my-configmap configMap: name: myconfigmap //// lifecycle restartPolicy: //// scheduling nodeName: nodeSelector: // 将pod部署到指定node key: value affinity: tolerations: //// others hostname: hostNetwork: serviceAccountName: pod中的container共享存储(pod volume):\napiVersion: v1 Kind: Pod medadata: spec: # 两种pod volume volumes: # emptyDir： pod删除之后该目录也会被删除 - name: cache-volume emptyDir: {} # hostPath: pod删除之后该目录还在host上. - name: hostpath-volume hostPath: path: /path/on/host containers: - name: container1 image: test volumeMounts: - name: cache-volume mountpath: /path/on/container # subPath会在emptyDir或hostPath目录下创建子目录 subPath: cache1 - name: container2 image: test volumeMounts: - name: hostpath-volume mountpath: /path/on/container readOnly: true Deployment 用于部署无状态服务。\napiVersion: apps/v1 kind: Deployment metadata: name: my-app-deploy namespace: my-ns lables: app: my-app spec: replicas: 3 # 选择器 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app image: image:latest imagePullPolicy: IfNotPresent/Always ports: - containerPort: 443 volumeMounts: - name: my-hostpath mountPath: /path/on/cpod - name: my-pvc mountPath: /data volumes: - name: my-hostpath hostPath: path: /path/on/host - name: my-pvc persistentVolumeClaim: claimName: nfs-pvc DaemonSet 每个node上部署一个pod，用于部署agent。\nDaemonSet\napiVersion: apps/v1 kind: DaemonSet metadata: name: my-ds namespace: my-ns labels: k8s-app: my-app spec: selector: matchLabels: name: my-app template: metadata: labels: name: my-app spec: containers: - name: my-container image: my-img StatefulSet 用于部署有状态服务。\nStatefulSet 中的 Pod 拥有一个唯一的顺序索引和稳定的网络身份标识。\napiVersion: apps/v1 kind: StatefulSet metadata: name: web namespace: test labels: k8s-app: my-app spec: serviceName: \u0026quot;nginx\u0026quot; replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: k8s.gcr.io/nginx-slim:0.8 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ \u0026quot;ReadWriteOnce\u0026quot; ] resources: requests: storage: 1Gi Job Job\nappVersion: batch/v1 kind: Job metadata: name: my-job spec: # 代表本pod队列执行此次数(被执行8次) completions: 8 # 代表并行执行个数(同时有两个在运行) parallelism: 2 backoffLimit: 4 template: spec: containers: - name: my-job image: my-image conmand: ['test'] restartPolicy: Never CronJob CronJob\napiVersion: batch/v1 kind: CronJob metadata: name: my-cj spec: schedule: \u0026quot;* * * * *\u0026quot; startingDeadlineSeconds: None(default)/10 concurrencyPolicy: Allow(default)/Forbid/Replace suspend: false(default)/true successfulJobsHistoryLimit: 3(default) failedJobsHistoryLimit: 1(default) jobTemplate: spec: template: metadata: annotations: ... labels: ... spec: nodeSelector: ... imagePullSecrets: ... restartPolicy: OnFailure containers: - name: image image: image args: - /bin/sh - -c - date ConfigMap configmap只能在当前namespace使用.\nconfigmap的配置在pod中无法修改绑定的文件.\ndata里面的文件名就是挂载之后的文件名。\nConfigMap\napiVersion: v1 kind: ConfigMap metadata: labels: app: flanel tier: node name: flannel-cfg namespace: kube-system data: cni-conf.json: | { \u0026quot;name\u0026quot;: \u0026quot;n1\u0026quot; } 创建配置文件的configmap\n$ kubectl -n app create cm my-conf --from-file ./config.ini -o yaml \u0026gt; myconf-configmap.yaml $ kubectl -n influxdata create cm dashboard-docker --from-file Docker.json -o yaml \u0026gt; grafana-dashboard-docker-configmap.yaml Secret secret只能在当前namespace使用.\ndata里的文件名就是挂载之后的文件名。\nOpaque是用户自定义格式\ngeneric secret\nkubectl create secret generic empty-secret apiVersion: v1 kind: Secret type: Opaque metadata: name: mysecret namespace: kube-system data: username: name password: pw 创建tls secret账号:\nkubectl -n kubernetes-dashboard create secret tls \\ kubernetes-dashboard-tls --key ca.key --cert ca.crt 类型为 kubernetes.io/tls 的 Secret 中包含密钥和证书的 DER 数据，以 Base64 格式编码。 如果你熟悉私钥和证书的 PEM 格式，base64 与该格式相同，只是你需要略过 PEM 数据中所包含的第一行和最后一行。\napiVersion: v1 kind: Secret metadata: name: secret-tls type: kubernetes.io/tls data: tls.crt: | MIIC2DCCAcCgAwIBAgIBATANBgkqh ... tls.key: | MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ... 创建docker secret:\nkubernetes.io/dockercfg\t~/.dockercfg 文件的序列化形式\nkubernetes.io/dockerconfigjson\t~/.docker/config.json 文件的序列化形式\n给一个private registry创建secret:\n$ kubectl -n ns create secret docker-registry \u0026lt;name\u0026gt; \\ --docker-server=https://harbor.domain.com --docker-username=user --docker-password=pw --docker-email=canuxcheng@gmail.com 根据本地的文件创建secret（如果需要多个registry，可以先在本地登陆）\n$ kubectl -n ns create secret generic regcred \\ --from-file=.dockerconfigjson=$HOME/.docker/config.json \\ --type=kubernetes.io/dockerconfigjson apiVersion: v1 kind: Secret metadata: name: artifactory-cred namespace: ... type: kubernetes.io/dockerconfigjson data: .dockerconfigjson: ewoJImF1d...... Service apiVersion: v1 kind: Service metadata: name: grafana-service namespace: influxdata spec: type: NodePort ports: - name: https port: 3000 // 集群内部访问的port. targetPort: 3000 // pod指定的port. nodePort: 32000 // 集群外部访问内部service的port. selector: // 匹配资源的metadata.labels app: grafana ExternalName Service ExternalName Service 是 Service 的特例，它没有选择算符，但是使用 DNS 名称, 将服务映射到 DNS 名称，而不是selector.\n访问其它namespace的service.\n当查找主机 my-service.my-ns.svc.cluster.local 时，集群 DNS 服务返回 CNAME 记录， 其值为 out-service.out-ns.svc.cluster.local。 访问 my-service 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发\napiVersion: v1 kind: Service metadata: name: my-service namespace: my-ns spec: type: ExternalName externalName: out-service.out-ns.svc.cluster.local // 指向其它namespace的service. Endpoint 下面场景可以使用Endpoint.\n希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。 希望服务指向另一个 命名空间 中或其它集群中的服务。 您正在将工作负载迁移到 Kubernetes。 在评估该方法时，您仅在 Kubernetes 中运行一部分后端。 先创建service:\napiVersion: v1 kind: Service metadata: name: mysql-service namespace: influxdata spec: ports: - protocol: TCP port: 3306 targetPort: 3306 再创建endpoint：\napiVersion: v1 kind: Endpoints metadata: name: mysql-service namespace: influxdata subsets: - addresses: - ip: 10.103.X.X // 指向外部服务的IP ports: - port: 3306 HPC Horizontal Pod Autoscaler\napiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: labels: spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: d-name minReplicas: 2 maxReplicas: 20 metrics: - type: Resource resource: name: cpu targetAverageUtilization: 80 - type: Resource resource: name: memory targetAverageUtilization: 80 Authentication 默认的ClusterRole和ClusterRoleBinding大部分是system:开头。\nServiceAccont 服务账户是在具体名字空间的。\napiVersion: v1 kind: ServiceAccount metadata: name: default namespace: default 1.22之前k8s会自动给SA创建token.\n1.24之后使用TokenRequest获取有时间限制的token。\n创建持久化token\napiVersion: v1 kind: Secret type: kubernetes.io/service-account-token metadata: name: mysecretname annotations: kubernetes.io/service-account.name: myserviceaccount Role 通过role来给指定ns内的资源授权.\napiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-reader rules: - apiGroups: [\u0026quot;\u0026quot;] # \u0026quot;\u0026quot; 标明 core API 组 resources: [\u0026quot;pods\u0026quot;] verbs: [\u0026quot;get\u0026quot;, \u0026quot;watch\u0026quot;, \u0026quot;list\u0026quot;] RoleBinding 将role或clusterrole权限赋予具体的角色.\napiVersion: rbac.authorization.k8s.io/v1 # 此角色绑定允许 \u0026quot;jane\u0026quot; 读取 \u0026quot;default\u0026quot; 名字空间中的 Pods kind: RoleBinding metadata: name: read-pods namespace: default subjects: # 你可以指定不止一个“subject（主体）” - kind: User name: jane # \u0026quot;name\u0026quot; 是区分大小写的 apiGroup: rbac.authorization.k8s.io roleRef: # \u0026quot;roleRef\u0026quot; 指定与某 Role 或 ClusterRole 的绑定关系 kind: Role # 此字段必须是 Role 或 ClusterRole name: pod-reader # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配 apiGroup: rbac.authorization.k8s.io ClusterRole clusterrole给整个集群授权.不需要namespace.\napiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: # \u0026quot;namespace\u0026quot; 被忽略，因为 ClusterRoles 不受名字空间限制 name: secret-reader rules: - apiGroups: [\u0026quot;\u0026quot;] # 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 \u0026quot;secrets\u0026quot; resources: [\u0026quot;secrets\u0026quot;] verbs: [\u0026quot;get\u0026quot;, \u0026quot;watch\u0026quot;, \u0026quot;list\u0026quot;] ClusterRoleBinding 跨集群授权（也就是要访问不同ns的资源).不需要namespace.\napiVersion: rbac.authorization.k8s.io/v1 # 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets kind: ClusterRoleBinding metadata: name: read-secrets-global subjects: - kind: Group name: manager # 'name' 是区分大小写的 apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Operator",
    "permalink": "https://canuxcheng.com/post/k8s_operator/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"operator\"\u003eOperator\u003c/h1\u003e\n\u003cp\u003eTPR(Third Party Resource) 在k8s 1.7 被集成，并命名为CRD(Custom Resource Definition).\u003c/p\u003e\n\u003cp\u003e通过CRD，K8S可以动态的添加和管理资源，controller跟踪这些资源。\u003c/p\u003e\n\u003cp\u003eCRD+custom Controller = decalartive API(声明式API),一般分为通用性controller和operator.\u003c/p\u003e\n\u003cp\u003e通用型controller一般用于平台需求，operator一般用于部署特定应用.\u003c/p\u003e\n\u003cp\u003e用于开发operator的工具有kubebuilder和operator-sdk, 他们都是基于controller-runtime开发.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/operator-framework/awesome-operators\"\u003ehttps://github.com/operator-framework/awesome-operators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index\"\u003ehttps://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://operatorhub.io/\"\u003ehttps://operatorhub.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e开发示例:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/sample-controller\"\u003ehttps://github.com/kubernetes/sample-controller\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eoperator的build三种模式:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ego\u003c/li\u003e\n\u003cli\u003eansible\u003c/li\u003e\n\u003cli\u003ehelm\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eoperator的run三种模式:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在集群外部本地运行（开发测试).\u003c/li\u003e\n\u003cli\u003e作为deployment在集群内部运行.\u003c/li\u003e\n\u003cli\u003e通过OLM部署.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"operator-sdk\"\u003eoperator-sdk\u003c/h1\u003e\n\u003cp\u003eredhat的operator-sdk可以方便的开发opeartor.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/operator-framework/operator-sdk\"\u003ehttps://github.com/operator-framework/operator-sdk\u003c/a\u003e\n\u003ca href=\"https://sdk.operatorframework.io/docs/installation/\"\u003ehttps://sdk.operatorframework.io/docs/installation/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"kubebuilder\"\u003ekubebuilder\u003c/h1\u003e\n\u003cp\u003esig维护的kubebuilder也能方便的开发operator.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/kubebuilder\"\u003ehttps://github.com/kubernetes-sigs/kubebuilder\u003c/a\u003e\u003c/p\u003e",
    "content": "Operator TPR(Third Party Resource) 在k8s 1.7 被集成，并命名为CRD(Custom Resource Definition).\n通过CRD，K8S可以动态的添加和管理资源，controller跟踪这些资源。\nCRD+custom Controller = decalartive API(声明式API),一般分为通用性controller和operator.\n通用型controller一般用于平台需求，operator一般用于部署特定应用.\n用于开发operator的工具有kubebuilder和operator-sdk, 他们都是基于controller-runtime开发.\nhttps://github.com/operator-framework/awesome-operators\nhttps://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index\nhttps://operatorhub.io/\n开发示例:\nhttps://github.com/kubernetes/sample-controller\noperator的build三种模式:\ngo ansible helm operator的run三种模式:\n在集群外部本地运行（开发测试). 作为deployment在集群内部运行. 通过OLM部署. operator-sdk redhat的operator-sdk可以方便的开发opeartor.\nhttps://github.com/operator-framework/operator-sdk https://sdk.operatorframework.io/docs/installation/\nkubebuilder sig维护的kubebuilder也能方便的开发operator.\nhttps://github.com/kubernetes-sigs/kubebuilder\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Service Discovery",
    "permalink": "https://canuxcheng.com/post/k8s_servicediscovery/",
    "date": "2020-01-10",
    "summary": "\u003ch1 id=\"coordination--service-discovery\"\u003eCoordination \u0026amp; Service Discovery\u003c/h1\u003e\n\u003cp\u003e微服务的服务注册和服务发现.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecoredns\u003c/li\u003e\n\u003cli\u003eetcd\u003c/li\u003e\n\u003cli\u003ezookeeper\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"etcd\"\u003eEtcd\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/etcd-io/etcd\"\u003ehttps://github.com/etcd-io/etcd\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e类似的有consul和zoomkeeper.\u003c/p\u003e\n\u003ch3 id=\"etcdctl\"\u003eetcdctl\u003c/h3\u003e\n\u003cp\u003e使用证书访问:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ etcdctl \\\n--cacert=/etc/kubernetes/pki/etcd/ca.crt \\\n--cert=/etc/kubernetes/pki/etcd/server.crt  \\\n--key=/etc/kubernetes/pki/etcd/server.key \\\n--insecure-skip-tls-verify=true \\\n\u0026lt;command\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看所有key\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ etcdctl get / --prefix --keys-only\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2 id=\"zookeeper\"\u003ezookeeper\u003c/h2\u003e",
    "content": "Coordination \u0026amp; Service Discovery 微服务的服务注册和服务发现.\ncoredns etcd zookeeper Etcd https://github.com/etcd-io/etcd\n类似的有consul和zoomkeeper.\netcdctl 使用证书访问:\n$ etcdctl \\ --cacert=/etc/kubernetes/pki/etcd/ca.crt \\ --cert=/etc/kubernetes/pki/etcd/server.crt \\ --key=/etc/kubernetes/pki/etcd/server.key \\ --insecure-skip-tls-verify=true \\ \u0026lt;command\u0026gt; 查看所有key\n$ etcdctl get / --prefix --keys-only zookeeper ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Compose",
    "permalink": "https://canuxcheng.com/post/cncf_compose/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"docker-compose\"\u003edocker-compose\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/docker/compose\"\u003ehttps://github.com/docker/compose\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e通过一个yaml文件来管理容器中的服务，包括网络和存储。\u003c/p\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://docs.docker.com/compose/install/\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n$ sudo chmod +x /usr/local/bin/docker-compose\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"docker-compose命令\"\u003edocker-compose命令\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003edocker-compose [-f \u0026lt;arg\u0026gt;...] [options] [COMMAND] [ARGS...]\n-f/--file\n-p/--project-name # 默认目录名\n-H/--host\n\n# 拉取compose文件中指定的镜像\n$ docker-compose -f service.yml pull\n\n# 根据docker-compose.yml把stack打包成一个Distributed Application Bundles文件.\n$ docker-compose bundle -o \u0026lt;project name\u0026gt;.dab\n\n$ docker-compose start [servoce...]\n$ docker-compose stop [service...]\n$ docker-compose restart [service...]\n$ docker-compose up -d [service...]\n$ docker-compose down -v\n\n$ docker-compose logs -f\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"docker-composeyml\"\u003edocker-compose.yml\u003c/h1\u003e\n\u003cp\u003ecompose中的变量：\u003c/p\u003e",
    "content": "docker-compose https://github.com/docker/compose\n通过一个yaml文件来管理容器中的服务，包括网络和存储。\n安装:\nhttps://docs.docker.com/compose/install/ $ sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose docker-compose命令 docker-compose [-f \u0026lt;arg\u0026gt;...] [options] [COMMAND] [ARGS...] -f/--file -p/--project-name # 默认目录名 -H/--host # 拉取compose文件中指定的镜像 $ docker-compose -f service.yml pull # 根据docker-compose.yml把stack打包成一个Distributed Application Bundles文件. $ docker-compose bundle -o \u0026lt;project name\u0026gt;.dab $ docker-compose start [servoce...] $ docker-compose stop [service...] $ docker-compose restart [service...] $ docker-compose up -d [service...] $ docker-compose down -v $ docker-compose logs -f docker-compose.yml compose中的变量：\n\u0026ldquo;x-\u0026ldquo;开头的会被compose忽略，但是会被yaml解析.\nx-var-name: \u0026amp;default-label key1: val1 key2: val2 services: mysql: \u0026lt;\u0026lt;: *default-label image: mysql compose文件\nversion: \u0026quot;3.6\u0026quot; services: mongo: image: mongo:latest hostname: hostname init dns dns_search expose extra_hosts healthcheck: test: curl -f https://host/ping || exit 1 test: wget --no-verbose --tries=1 --spider https://host/ping || exit 1 interval: timeout: retries: stat_period: stop_grrace_period isolation pid profiles stop_signal labels: com.example.key: value // start: 下列选项不能用于swarm stack部署. sysctls(19.03+) privileged: true depends_on: - service-name build cgroup_parent container_name devices: - /dev/vboxdrv:/dev/vboxdrv tmpfs external_links links network_mode: bridge/host/none restart: no(default) security_opt userns_mode ulimits cap_add cap_drop // end networks: - mynetwork // 只有自定义网络可以指定静态IP networks: mynetwork: ipv4_address: 172.19.0.100 volumes: // short syntax - /container/dir // 自动创建volume - myvolume:/container/dir - /host/dir:/container/dir volumes: // long syntax - type: valume/bind/tmpfs source: target: read_only: bind: volume: tmpfs: consistency: volumes: - \u0026quot;/path/to/file:/path/to/file 挂载文件 configs: - my-conf configs: - source: config-name target: file-name secrets: - my-sec secrets: - source: secret-name target: file-name in /run/secrets/ logging: driver: syslog options: syslog-address: \u0026quot;tcp://192.168.0.42:123\u0026quot; ports: // long syntax - target: 80 published: 8080 mode: host protocol: tcp/udp ports: // short syntax - 80 // host上的port没有指定就是一个随机的port - 80:80 - 1234:1234/udp // 设置环境变量 environment: RABBITMQ_DEFAULT_USER: sandbox RABBITMQ_DEFAULT_PASS: password environment: - RABBITMQ_DEFAULT_USER=sandbox - RABBITMQ_DEFAULT_PASS=password - TZ=UTC // 设置时区 \u0026lt;https://docs.docker.com/compose/compose-file/#env_file\u0026gt; # When you set the same environment variable in multiple files, # here’s the priority used by Compose to choose which value to use: # 1. Compose file (environment) # 2. Shell environment variables(export key=value) # 3. Environment file (env_file) # 4. Dockerfile # 5. Variable is not defined env_file: entrypoint: command: [\u0026quot;./wait-for-it.sh\u0026quot;, \u0026quot;db:5432\u0026quot;, \u0026quot;--\u0026quot;, \u0026quot;python\u0026quot;, \u0026quot;app.py\u0026quot;] // 块结构，和上面的[]等效. command: - \u0026quot;./wait-for-it.sh\u0026quot; - \u0026quot;:b:5432\u0026quot; - \u0026quot;--\u0026quot; - \u0026quot;python\u0026quot; - \u0026quot;app.py\u0026quot; // 解析为: \u0026quot;line1 line2\\n\u0026quot;, 会自动加换行符. command: \u0026gt; line1 line2 // 解析为: \u0026quot;line1 line2\u0026quot;, 没有换行符. command: \u0026gt;- line1 line2 // start: 下面三个deploy下面的字段，也能用于非swarm模式. // 在compose v3 中针对非swarm模式的container做资源限制等操作. // --compatibility If set, Compose will attempt to convert keys in v3 files to their non-Swarm equivalent $ docker-compose --compatibility up -d // --compatibility 支持下面三种key: replicas: restart_policy: condition: any(default) max_attempts: resources: limits: cpus: '0.5' memory: 1G reservations: cpus: '0.25' memory: 20M // start: 定义config/secret/volume/netework资源 configs: c-name: // 根据文件创建 file: ./httpd.conf // 使用已经创建好的 external: true secrets: s-name: // 根据文件创建 file: ./server.cert // 使用已经创建好的 external: true volumes: data-volume: // 以定义好的volume volumes: data: external: true // (推荐)使用已经创建好的网络 // 通过命令行或者api 创建网络 networks: mynetwork: external: true name: lan0 // 通过docker network ls 查看名字 // 创建bridge网络 // 会在网络名字自动加namespace networks: mynetwork: driver: bridge driver_opts: com.docker.network.bridge.name: lan0 ipam: driver: default config: - subnet: 192.168.1.0/24 // 创建overlay网络 // 会在网络名字自动加namespace networks: ol0: driver: overlay attachable: true driver_opts: com.docker.network.bridge.name: ol0 ipam: driver: default config: - subnet: 172.12.0.0/16 compose文件中用到的变量\n.Service.ID Service ID .Service.Name Service name .Service.Labels Service labels .Node.ID Node ID .Node.Hostname Node Hostname .Task.ID Task ID .Task.Name Task name .Task.Slot Task slot yaml变量：\nkey: \u0026amp;varhash value key1: *varhash # 定义变量 list: \u0026amp;varlist key1: value1 key2: value2 # 将list的元素赋值给list1 list1: \u0026lt;\u0026lt;: *varlist key3: value2 Kompose https://github.com/kubernetes/kompose\ninstall:\n$ curl -L https://github.com/kubernetes/kompose/releases/download/v1.19.0/kompose-linux-amd64 -o kompose $ chmod +x kompose $ sudo mv ./kompose /usr/local/bin/kompose ",
    "categories": ["CNCF"],
    "tags": ["docker"]
  },
  {
    "title": "API Access Control",
    "permalink": "https://canuxcheng.com/post/k8s_accesscontrol/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"api-access-control\"\u003eAPI Access Control\u003c/h1\u003e\n\u003ch2 id=\"admission-controllers\"\u003eAdmission Controllers\u003c/h2\u003e\n\u003ch3 id=\"mutatingadmissionwebhook\"\u003eMutatingAdmissionWebhook\u003c/h3\u003e\n\u003ch3 id=\"validatingadmissionwebhook\"\u003eValidatingAdmissionWebhook\u003c/h3\u003e\n\u003ch3 id=\"validatingwebhookconfiguration\"\u003eValidatingWebhookConfiguration\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  annotations:\n    meta.helm.sh/release-name: ingress-nginx-internal\n    meta.helm.sh/release-namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/component: admission-webhook\n    app.kubernetes.io/instance: ingress-nginx-internal\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n    app.kubernetes.io/version: 1.9.1\n    helm.sh/chart: ingress-nginx-4.8.1\n  name: ingress-nginx-internal-admission\nwebhooks:\n- admissionReviewVersions:\n  - v1\n  clientConfig:\n    caBundle: \n    service:\n      name: ingress-nginx-internal-controller-admission\n      namespace: ingress-nginx\n      path: /networking/v1/ingresses\n      port: 443\n  failurePolicy: Fail\n  matchPolicy: Equivalent\n  name: validate.nginx.ingress.kubernetes.io\n  namespaceSelector: {}\n  objectSelector: {}\n  rules:\n  - apiGroups:\n    - networking.k8s.io\n    apiVersions:\n    - v1\n    operations:\n    - CREATE\n    - UPDATE\n    resources:\n    - ingresses\n    scope: '*'\n  sideEffects: None\n  timeoutSeconds: 10\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"mutatingwebhookconfiguration\"\u003eMutatingWebhookConfiguration\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: admissionregistration.k8s.io/v1\nkind: MutatingWebhookConfiguration\nmetadata:\n  annotations:\n    meta.helm.sh/release-name: vault-secrets-webhook\n    meta.helm.sh/release-namespace: vault-secrets-webhook\n  labels:\n    app.kubernetes.io/managed-by: Helm\n  name: vault-secrets-webhook\nwebhooks:\n- admissionReviewVersions:\n  - v1beta1\n  clientConfig:\n    caBundle:\n    service:\n      name: vault-secrets-webhook\n      namespace: vault-secrets-webhook\n      path: /pods\n      port: 443\n  failurePolicy: Ignore\n  matchPolicy: Equivalent\n  name: pods.vault-secrets-webhook.admission.banzaicloud.com\n  namespaceSelector:\n    matchExpressions:\n    - key: name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - vault-secrets-webhook\n  objectSelector:\n    matchExpressions:\n    - key: security.banzaicloud.io/mutate\n      operator: NotIn\n      values:\n      - skip\n  reinvocationPolicy: Never\n  rules:\n  - apiGroups:\n    - '*'\n    apiVersions:\n    - '*'\n    operations:\n    - CREATE\n    resources:\n    - pods\n    scope: '*'\n  sideEffects: NoneOnDryRun\n  timeoutSeconds: 10\n- admissionReviewVersions:\n  - v1beta1\n  clientConfig:\n    caBundle:\n    service:\n      name: vault-secrets-webhook\n      namespace: vault-secrets-webhook\n      path: /secrets\n      port: 443\n  failurePolicy: Ignore\n  matchPolicy: Equivalent\n  name: secrets.vault-secrets-webhook.admission.banzaicloud.com\n  namespaceSelector:\n    matchExpressions:\n    - key: name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - vault-secrets-webhook\n  objectSelector:\n    matchExpressions:\n    - key: owner\n      operator: NotIn\n      values:\n      - helm\n    - key: security.banzaicloud.io/mutate\n      operator: NotIn\n      values:\n      - skip\n  reinvocationPolicy: Never\n  rules:\n  - apiGroups:\n    - '*'\n    apiVersions:\n    - '*'\n    operations:\n    - CREATE\n    - UPDATE\n    resources:\n    - secrets\n    scope: '*'\n  sideEffects: NoneOnDryRun\n  timeoutSeconds: 10\n- admissionReviewVersions:\n  - v1beta1\n  clientConfig:\n    caBundle:\n    service:\n      name: vault-secrets-webhook\n      namespace: vault-secrets-webhook\n      path: /configmaps\n      port: 443\n  failurePolicy: Ignore\n  matchPolicy: Equivalent\n  name: configmaps.vault-secrets-webhook.admission.banzaicloud.com\n  namespaceSelector:\n    matchExpressions:\n    - key: name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - kube-system\n    - key: kubernetes.io/metadata.name\n      operator: NotIn\n      values:\n      - vault-secrets-webhook\n  objectSelector:\n    matchExpressions:\n    - key: owner\n      operator: NotIn\n      values:\n      - helm\n    - key: security.banzaicloud.io/mutate\n      operator: NotIn\n      values:\n      - skip\n  reinvocationPolicy: Never\n  rules:\n  - apiGroups:\n    - '*'\n    apiVersions:\n    - '*'\n    operations:\n    - CREATE\n    - UPDATE\n    resources:\n    - configmaps\n    scope: '*'\n  sideEffects: NoneOnDryRun\n  timeoutSeconds: 10\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "API Access Control Admission Controllers MutatingAdmissionWebhook ValidatingAdmissionWebhook ValidatingWebhookConfiguration apiVersion: admissionregistration.k8s.io/v1 kind: ValidatingWebhookConfiguration metadata: annotations: meta.helm.sh/release-name: ingress-nginx-internal meta.helm.sh/release-namespace: ingress-nginx labels: app.kubernetes.io/component: admission-webhook app.kubernetes.io/instance: ingress-nginx-internal app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.9.1 helm.sh/chart: ingress-nginx-4.8.1 name: ingress-nginx-internal-admission webhooks: - admissionReviewVersions: - v1 clientConfig: caBundle: service: name: ingress-nginx-internal-controller-admission namespace: ingress-nginx path: /networking/v1/ingresses port: 443 failurePolicy: Fail matchPolicy: Equivalent name: validate.nginx.ingress.kubernetes.io namespaceSelector: {} objectSelector: {} rules: - apiGroups: - networking.k8s.io apiVersions: - v1 operations: - CREATE - UPDATE resources: - ingresses scope: '*' sideEffects: None timeoutSeconds: 10 MutatingWebhookConfiguration apiVersion: admissionregistration.k8s.io/v1 kind: MutatingWebhookConfiguration metadata: annotations: meta.helm.sh/release-name: vault-secrets-webhook meta.helm.sh/release-namespace: vault-secrets-webhook labels: app.kubernetes.io/managed-by: Helm name: vault-secrets-webhook webhooks: - admissionReviewVersions: - v1beta1 clientConfig: caBundle: service: name: vault-secrets-webhook namespace: vault-secrets-webhook path: /pods port: 443 failurePolicy: Ignore matchPolicy: Equivalent name: pods.vault-secrets-webhook.admission.banzaicloud.com namespaceSelector: matchExpressions: - key: name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - vault-secrets-webhook objectSelector: matchExpressions: - key: security.banzaicloud.io/mutate operator: NotIn values: - skip reinvocationPolicy: Never rules: - apiGroups: - '*' apiVersions: - '*' operations: - CREATE resources: - pods scope: '*' sideEffects: NoneOnDryRun timeoutSeconds: 10 - admissionReviewVersions: - v1beta1 clientConfig: caBundle: service: name: vault-secrets-webhook namespace: vault-secrets-webhook path: /secrets port: 443 failurePolicy: Ignore matchPolicy: Equivalent name: secrets.vault-secrets-webhook.admission.banzaicloud.com namespaceSelector: matchExpressions: - key: name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - vault-secrets-webhook objectSelector: matchExpressions: - key: owner operator: NotIn values: - helm - key: security.banzaicloud.io/mutate operator: NotIn values: - skip reinvocationPolicy: Never rules: - apiGroups: - '*' apiVersions: - '*' operations: - CREATE - UPDATE resources: - secrets scope: '*' sideEffects: NoneOnDryRun timeoutSeconds: 10 - admissionReviewVersions: - v1beta1 clientConfig: caBundle: service: name: vault-secrets-webhook namespace: vault-secrets-webhook path: /configmaps port: 443 failurePolicy: Ignore matchPolicy: Equivalent name: configmaps.vault-secrets-webhook.admission.banzaicloud.com namespaceSelector: matchExpressions: - key: name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - kube-system - key: kubernetes.io/metadata.name operator: NotIn values: - vault-secrets-webhook objectSelector: matchExpressions: - key: owner operator: NotIn values: - helm - key: security.banzaicloud.io/mutate operator: NotIn values: - skip reinvocationPolicy: Never rules: - apiGroups: - '*' apiVersions: - '*' operations: - CREATE - UPDATE resources: - configmaps scope: '*' sideEffects: NoneOnDryRun timeoutSeconds: 10 ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Automation \u0026 Configuration",
    "permalink": "https://canuxcheng.com/post/cncf_platform/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"automation--configuration\"\u003eAutomation \u0026amp; Configuration\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eCloud Custodian\u003c/li\u003e\n\u003cli\u003ekubeedge\u003c/li\u003e\n\u003cli\u003epulumi\u003c/li\u003e\n\u003cli\u003eterraform\u003c/li\u003e\n\u003cli\u003eopentofu\u003c/li\u003e\n\u003cli\u003ekratix\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eplatform orchestration.\u003c/p\u003e\n\u003ch2 id=\"kratix\"\u003ekratix\u003c/h2\u003e",
    "content": "Automation \u0026amp; Configuration Cloud Custodian kubeedge pulumi terraform opentofu kratix platform orchestration.\nkratix ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Dashboard",
    "permalink": "https://canuxcheng.com/post/k8s_dashboard/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"dashboard-add-ons\"\u003edashboard add-ons\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003ekubernetes-dashboard\u003c/li\u003e\n\u003cli\u003elens\u003c/li\u003e\n\u003cli\u003eoctant\u003c/li\u003e\n\u003cli\u003eweave scope\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"kubernetes-dashboard\"\u003ekubernetes-dashboard\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/dashboard\"\u003ehttps://github.com/kubernetes/dashboard\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 部署dashboard\n$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml\n\n// check\n$ kubectl -n kubernetes-dashboard get pods --watch\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e1\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 删除已安装的dashboard\n$ kubectl delete ns kubernetes-dashboard\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"dashboard-arguments\"\u003edashboard arguments\u003c/h3\u003e\n\u003cp\u003e使用basic auth:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e--enable-skip-login\n--enable-insecure-login\n--system-banner=\u0026quot;Welcome to Kubernetes\u0026quot;\n--authentication-mode=\u0026quot;basic\u0026quot; // 默认是 token 登陆.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"access-control\"\u003eaccess control\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ekubeconfig\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eauthorization header\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etoken\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebasic\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eusername/password login\u003c/p\u003e\n\u003ch3 id=\"access-dashboard\"\u003eaccess dashboard\u003c/h3\u003e\n\u003cp\u003e本机访问\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ kubectl proxy\n#\u0026gt; http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e远程访问\u003c/p\u003e\n\u003cp\u003eport-forward:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 --address 0.0.0.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enodePort:\u003c/p\u003e",
    "content": "dashboard add-ons kubernetes-dashboard lens octant weave scope kubernetes-dashboard https://github.com/kubernetes/dashboard\n// 部署dashboard $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml // check $ kubectl -n kubernetes-dashboard get pods --watch 1\n// 删除已安装的dashboard $ kubectl delete ns kubernetes-dashboard dashboard arguments 使用basic auth:\n--enable-skip-login --enable-insecure-login --system-banner=\u0026quot;Welcome to Kubernetes\u0026quot; --authentication-mode=\u0026quot;basic\u0026quot; // 默认是 token 登陆. access control kubeconfig\nauthorization header\ntoken\nbasic\nusername/password login\naccess dashboard 本机访问\n$ kubectl proxy #\u0026gt; http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 远程访问\nport-forward:\n$ kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 --address 0.0.0.0 nodePort:\nkind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: type: NodePort ports: - port: 443 targetPort: 8443 nodePort: 30001 selector: k8s-app: kubernetes-dashboard #\u0026gt; https://\u0026lt;node-ip\u0026gt;:30001 ingress:\n#\u0026gt; https://\u0026lt;ingress-host\u0026gt;:\u0026lt;ingress-port\u0026gt; metrics-server https://github.com/kubernetes-sigs/metrics-server\n参数:\n--kubelet-preferred-address-types --kubelet-insecure-tls --requestheader-client-ca-file 部署:\n# deploy 0.3.6 # 修改image为 registry.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6 $ kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Key Management",
    "permalink": "https://canuxcheng.com/post/k8s_km/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"key-management\"\u003eKey Management\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003espiffe\u003c/li\u003e\n\u003cli\u003espire\u003c/li\u003e\n\u003c/ul\u003e",
    "content": "Key Management spiffe spire ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Microservivce",
    "permalink": "https://canuxcheng.com/post/k8s_microservice/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"microservivce\"\u003eMicroservivce\u003c/h1\u003e\n\u003cp\u003e微服务是一种架构。\u003c/p\u003e\n\u003cp\u003e常见的架构:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMonolithic application 单体应用.\u003c/li\u003e\n\u003cli\u003eSOA(service-oriented architecture) 面向服务的体系结构.\u003c/li\u003e\n\u003cli\u003eMicroServices 微服务.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e微服务架构的服务治理包括:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eservice registry 服务注册\u003c/li\u003e\n\u003cli\u003eservice discovery 服务发现\u003c/li\u003e\n\u003cli\u003eobservability 可观测性(metrics,logging,trace)\u003c/li\u003e\n\u003cli\u003e流量管理\u003c/li\u003e\n\u003cli\u003e安全\u003c/li\u003e\n\u003cli\u003e控制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e微服务应用可以通过容器化(docker, k8s)部署，也可以通过serverless方式部署.\u003c/p\u003e\n\u003cp\u003e不同的语言有不同的微服务框架.\njava的dubbo, sprint boot.\ngolang的go-kit,  go-zero, kratos.\npython的zappa, nameko.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"dapr\"\u003eDapr\u003c/h2\u003e\n\u003cp\u003eDapr is a portable, event-driven, runtime for building distributed applications across cloud and edge.\u003c/p\u003e",
    "content": "Microservivce 微服务是一种架构。\n常见的架构:\nMonolithic application 单体应用. SOA(service-oriented architecture) 面向服务的体系结构. MicroServices 微服务. 微服务架构的服务治理包括:\nservice registry 服务注册 service discovery 服务发现 observability 可观测性(metrics,logging,trace) 流量管理 安全 控制 微服务应用可以通过容器化(docker, k8s)部署，也可以通过serverless方式部署.\n不同的语言有不同的微服务框架. java的dubbo, sprint boot. golang的go-kit, go-zero, kratos. python的zappa, nameko.\nDapr Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge.\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Scheduling \u0026 Orchestration",
    "permalink": "https://canuxcheng.com/post/cncf_orchestration/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"scheduling--orchestration\"\u003eScheduling \u0026amp; Orchestration\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003edocker swarm.\u003c/li\u003e\n\u003cli\u003eKEDA\u003c/li\u003e\n\u003cli\u003eCrossplane\u003c/li\u003e\n\u003cli\u003eKnative\u003c/li\u003e\n\u003cli\u003eKubeflow\u003c/li\u003e\n\u003cli\u003eVolcano\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"crossplane\"\u003eCrossplane\u003c/h2\u003e",
    "content": "Scheduling \u0026amp; Orchestration docker swarm. KEDA Crossplane Knative Kubeflow Volcano Crossplane ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Serverless",
    "permalink": "https://canuxcheng.com/post/k8s_serverless/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"serverless\"\u003eServerless\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2 id=\"knative\"\u003eKnative\u003c/h2\u003e\n\u003cp\u003eKnative is a developer-focused serverless application layer which is a great complement to the existing Kubernetes application constructs. Knative consists of three components: an HTTP-triggered autoscaling container runtime called “Knative Serving”, a CloudEvents-over-HTTP asynchronous routing layer called “Knative Eventing”, and a developer-focused function framework which leverages the Serving and Eventing components, called \u0026ldquo;Knative Functions\u0026rdquo;.\u003c/p\u003e",
    "content": "Serverless Knative Knative is a developer-focused serverless application layer which is a great complement to the existing Kubernetes application constructs. Knative consists of three components: an HTTP-triggered autoscaling container runtime called “Knative Serving”, a CloudEvents-over-HTTP asynchronous routing layer called “Knative Eventing”, and a developer-focused function framework which leverages the Serving and Eventing components, called \u0026ldquo;Knative Functions\u0026rdquo;.\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Service Mesh",
    "permalink": "https://canuxcheng.com/post/k8s_servicemesh/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"service-mesh\"\u003eService Mesh\u003c/h1\u003e\n\u003cp\u003eservivce mesh是cncf基于sidecar推出的下一代面向云原生的微服务架构，是微服务基础设施, 用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性.\u003c/p\u003e\n\u003cp\u003esidecar: 边车模式，就是把业务无关的功能，日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制和服务调用可视化等独立出来。\u003c/p\u003e\n\u003cp\u003e特点:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应用程序通信的中间层\u003c/li\u003e\n\u003cli\u003e轻量级网络代理\u003c/li\u003e\n\u003cli\u003e应用程序无感知\u003c/li\u003e\n\u003cli\u003e解耦应用程序的重试、超时、监控、追踪和服务发现.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eService Mesh是建立在物理或者虚拟网络层之上的，基于策略的微服务的流量控制，与一般的网络协议不同的是它有以下几个特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开发者驱动\u003c/li\u003e\n\u003cli\u003e可配置策略\u003c/li\u003e\n\u003cli\u003e服务优先的网络配置而不是协议\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"istio\"\u003eIstio\u003c/h2\u003e\n\u003chr\u003e\n\u003ch2 id=\"linkerd\"\u003eLinkerd\u003c/h2\u003e\n\u003chr\u003e",
    "content": "Service Mesh servivce mesh是cncf基于sidecar推出的下一代面向云原生的微服务架构，是微服务基础设施, 用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性.\nsidecar: 边车模式，就是把业务无关的功能，日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制和服务调用可视化等独立出来。\n特点:\n应用程序通信的中间层 轻量级网络代理 应用程序无感知 解耦应用程序的重试、超时、监控、追踪和服务发现. Service Mesh是建立在物理或者虚拟网络层之上的，基于策略的微服务的流量控制，与一般的网络协议不同的是它有以下几个特点：\n开发者驱动 可配置策略 服务优先的网络配置而不是协议 Istio Linkerd ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Service Proxy",
    "permalink": "https://canuxcheng.com/post/k8s_proxy/",
    "date": "2020-01-04",
    "summary": "\u003ch1 id=\"service-proxy\"\u003eService Proxy\u003c/h1\u003e\n\u003cp\u003eingress =\u0026gt; gateway api\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eenvoy\u003c/li\u003e\n\u003cli\u003econtour\u003c/li\u003e\n\u003cli\u003etraefik proxy\u003c/li\u003e\n\u003cli\u003ehaproxy\u003c/li\u003e\n\u003cli\u003emetaLB\u003c/li\u003e\n\u003cli\u003enginx\u003c/li\u003e\n\u003cli\u003eopenelb\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"ingress-controller\"\u003eingress controller\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIngress-nginx(nginx)\u003c/li\u003e\n\u003cli\u003eaws-load-balancer-controller(alb)\u003c/li\u003e\n\u003cli\u003eingress-gce\u003c/li\u003e\n\u003cli\u003eTraefik\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe kubernetes.io/ingress.class annotation is deprecated from kubernetes v1.22+.通过IngressClasses来选择ingress controller。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eingressClassName: nginx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eingress 语法\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: minimal-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  ingressClassName: nginx-example\n  defaultBackend:\n    resource:\n      apiGroup: k8s.example.com\n      kind: StorageBucket\n      name: static-assets\n  rules:\n  - http:\n      paths:\n      - path: /testpath\n        pathType: Prefix\n        backend:\n          service:\n            name: test\n            port:\n              number: 80\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eImplementationSpecific：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 pathType 处理或者与 Prefix 或 Exact 类型作相同处理。\u003c/p\u003e",
    "content": "Service Proxy ingress =\u0026gt; gateway api\nenvoy contour traefik proxy haproxy metaLB nginx openelb ingress controller Ingress-nginx(nginx) aws-load-balancer-controller(alb) ingress-gce Traefik The kubernetes.io/ingress.class annotation is deprecated from kubernetes v1.22+.通过IngressClasses来选择ingress controller。\ningressClassName: nginx ingress 语法\napiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: minimal-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: ingressClassName: nginx-example defaultBackend: resource: apiGroup: k8s.example.com kind: StorageBucket name: static-assets rules: - http: paths: - path: /testpath pathType: Prefix backend: service: name: test port: number: 80 ImplementationSpecific：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 pathType 处理或者与 Prefix 或 Exact 类型作相同处理。\nExact：精确匹配 URL 路径，且区分大小写。\nPrefix：基于以 / 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 / 分隔符分隔的路径中的标签列表。 如果每个 p 都是请求路径 p 的元素前缀，则请求与路径 p 匹配。\ningressclass没有namespace。\ngateway api controller cilium contour GKE EKS kong traefik ingress-nginx https://github.com/kubernetes/ingress-nginx\n// 部署 $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.34.1/deploy/static/provider/baremetal/deploy.yaml // 验证部署 $ kubectl get pods --all-namespaces -l app.kubernetes.io/name=ingress-nginx --watch // Detect installed version POD_NAMESPACE=ingress-nginx POD_NAME=$(kubectl get pods -n $POD_NAMESPACE -l app.kubernetes.io/name=ingress-nginx -o jsonpath='{.items[0].metadata.name}') $ kubectl exec -it $POD_NAME -n $POD_NAMESPACE -- /nginx-ingress-controller --version tls:\nhttps://kubernetes.github.io/ingress-nginx/user-guide/tls/\nhttps://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/\ntraefik traefik2.2+\nhttps://github.com/traefik/traefik\ninstall with helm:\nhelm repo add traefik https://helm.traefik.io/traefik helm repo update helm install --create-namespace traefik -n traefik traefik traefik/traefik -f ./value.yaml # expose dashboard: kubectl port-forward -n traefik $(kubectl get pods -n traefik --selector \u0026quot;app.kubernetes.io/name=traefik\u0026quot; --output=name) 9000:9000 --address 0.0.0.0 请求模型\nClient =\u0026gt; Traefik =\u0026gt; Backend 端口:\n9000: traefik管理页面端口 重要组件 Providers: 自动发现平台上的服务. Entrypoints: 监听传入的流量，定义接受请求的端口. Routers: 分析请求，负责将传入请求连接到负责处理的服务上. Middlewares: 在routers转给services之前修改请求. Services/LB: 将请求转给应用, 负责配置处理请求的实际服务. 配置 两种配置类型\n静态配置: 启动时的配置，通过配置文件(/etc/traefik/traefik.[toml|yaml]，环境变量或命令行参数配置 providers和entrypoints等. 动态配置: 动态的路由配置，定义系统如何处理请求,从providers获取动态配置. 静态配置:\nentrypoints providers servertransport certificatesresolvers api ping experimental hostresolver accesslog log metrics(datadog, influxdb, prometheus,statsd) tracing(datadog, elastic, haystack, instana, jaeger, zipkin) 全局配置:\n--global.checknewversion --global.sendanonymoususagge 控制Traefik到Backend的连接的参数serversTransport:\n--serversTransport.insecureSkipVerify=true # self-signed TLS CA. --serversTransport.rootCAs=foo.crt,bar.crt --serversTransport.maxIdleConnsPerHost=7 --serversTransport.forwardingTimeouts.dialTimeout=1s --serversTransport.forwardingTimeouts.responseHeaderTimeout=1s --serversTransport.forwardingTimeouts.idleConnTimeout=1s kubernetes provider kubernetes provider有三种类型\nIngress IngressRoute Gateway API https \u0026amp; tls traefik的证书可以是手动创建证书，也可以通过let\u0026rsquo;s encrypt自动创建\n--- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: name namespace: ns spec: tls: secretName: my-tls 通过Let\u0026rsquo;s encrypt来自动创建证书有三种验证方式（tls, http, dns).\n- \u0026quot;--certificatesresolvers.myresolver.acme.httpchallenge=true\u0026quot; - \u0026quot;--certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web\u0026quot; - \u0026quot;--certificatesresolvers.myresolver.acme.tlschallenge=true\u0026quot; - \u0026quot;--certificatesresolvers.myresolver.acme.tlschallenge.entrypoint=websecure\u0026quot; - \u0026quot;--certificatesresolvers.myresolver.acme.email=canux.cheng@arm.com\u0026quot; - \u0026quot;--certificatesresolvers.myresolver.acme.storage=acme.json\u0026quot; ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Kubeadm",
    "permalink": "https://canuxcheng.com/post/k8s_kubeadm/",
    "date": "2019-12-30",
    "summary": "\u003ch1 id=\"kubeadm\"\u003ekubeadm\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kubeadm\"\u003ehttps://github.com/kubernetes/kubeadm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ekubeadm是k8s自带的部署集群的工具.\u003c/p\u003e\n\u003ch1 id=\"install\"\u003eInstall\u003c/h1\u003e\n\u003ch2 id=\"准备工作\"\u003e准备工作\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\"\u003ehttps://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装runtime\"\u003e安装runtime\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\"\u003ehttps://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e默认的cgroup驱动时cgroupfs,如果系统是systemd，就会有两个cgroup driver，会出问题.\u003c/p\u003e\n\u003cp\u003e如果修改cgroup driver需要同时修改CRI和kubelet.\u003c/p\u003e\n\u003cp\u003e修改containerd的cgroup driver:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo vim /etc/containerd/config.toml\n#disabled_plugins = [\u0026quot;cri\u0026quot;]\n[plugins.\u0026quot;io.containerd.grpc.v1.cri\u0026quot;.containerd.runtimes.runc.options]\n  SystemdCgroup = true\n\n$ sudo systemctl restart containerd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改kubelet的cgroup driver(kubeadm-config.yaml):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# kubeadm-config.yaml\nkind: ClusterConfiguration\napiVersion: kubeadm.k8s.io/v1beta3\nkubernetesVersion: v1.21.0    // kubelet --version\n---\napiVersion: kubelet.config.k8s.io/v1beta1\nkind: KubeletConfiguration\ncgroupDriver: systemd\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"安装kubeadm-kubelet-kubectl\"\u003e安装kubeadm, kubelet, kubectl\u003c/h2\u003e\n\u003cp\u003e在每台机器上安装 kubeadm, kubelet, kubectl:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get update\n$ sudo apt-get install -y apt-transport-https ca-certificates curl\n$ sudo curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - \n$ echo \u0026quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\u0026quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list\n$ sudo apt-get update\n$ sudo apt-get --yes --allow-unauthenticated install kubeadm kubelet kubectl\n$ sudo apt-mark hold kubelet kubeadm kubectl\n$ sudo systemctl enable kubelet\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"kubeadm-cli\"\u003eKubeadm CLI\u003c/h1\u003e\n\u003cp\u003einit:\u003c/p\u003e",
    "content": "kubeadm https://github.com/kubernetes/kubeadm\nkubeadm是k8s自带的部署集群的工具.\nInstall 准备工作 https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n安装runtime https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\n默认的cgroup驱动时cgroupfs,如果系统是systemd，就会有两个cgroup driver，会出问题.\n如果修改cgroup driver需要同时修改CRI和kubelet.\n修改containerd的cgroup driver:\n$ sudo vim /etc/containerd/config.toml #disabled_plugins = [\u0026quot;cri\u0026quot;] [plugins.\u0026quot;io.containerd.grpc.v1.cri\u0026quot;.containerd.runtimes.runc.options] SystemdCgroup = true $ sudo systemctl restart containerd 修改kubelet的cgroup driver(kubeadm-config.yaml):\n# kubeadm-config.yaml kind: ClusterConfiguration apiVersion: kubeadm.k8s.io/v1beta3 kubernetesVersion: v1.21.0 // kubelet --version --- apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration cgroupDriver: systemd 安装kubeadm, kubelet, kubectl 在每台机器上安装 kubeadm, kubelet, kubectl:\n$ sudo apt-get update $ sudo apt-get install -y apt-transport-https ca-certificates curl $ sudo curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - $ echo \u0026quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\u0026quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list $ sudo apt-get update $ sudo apt-get --yes --allow-unauthenticated install kubeadm kubelet kubectl $ sudo apt-mark hold kubelet kubeadm kubectl $ sudo systemctl enable kubelet Kubeadm CLI init:\n$ kubeadm init --config kubeadm-config.yaml --kubernetes-version \u0026lt;version\u0026gt; // kubelet --version --apiserver-advertise-address \u0026lt;master\u0026gt; // 多网卡指定网卡IP --image-repository \u0026lt;registry\u0026gt; // default: k8s.gcr.io --pod-network-cidr \u0026lt;cidr\u0026gt; // 指定pod的cidr --service-cidr \u0026lt;cidr\u0026gt; // default: 10.96.0.0/12 --service-dns-domain // default: cluster.local --cri-socket // 如果安装了多个cri需要指定. --ignore-preflight-errors --upload-certs join:\n$ kubeadm join [apiserver-advertise-address] --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash \u0026lt;hash\u0026gt; reset:\n$ kubeadm reset -f/--force token:\n$ kubeadm token create/delete/generate/list 部署Cluster 部署master 关闭swap\n$ sudo swapoff -a 初始化\n$ sudo kubeadm init \\ --pod-network-cidr=10.244.0.0/16 \\ --apiserver-advertise-address=\u0026lt;IP\u0026gt; \\ --kubernetes-version=v1.17.0 \\ --image-repository=registry.aliyuncs.com/google_containers \\ --cri-socket=/run/containerd/containerd.sock \\ -v=6 // --config 一般使用默认即可. // --pod-network-cidr=10.244.0.0/16 是固定用法，表示选择flannel为网络插件。 // --image-repository 指定registry, 默认是gcr 配置当前帐号\nmkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 部署网络插件\n// 在所有node上部署cni-plugin: // \u0026lt;https://github.com/containernetworking/plugins/releases\u0026gt; $ sudo mkdir -p /opt/cni/bin // 下载并解压所有插件命令到该目录. 默认CNI_PATH=/opt/cni/bin // \u0026lt;https://docs.cilium.io/en/stable/installation/k8s-install-kubeadm/\u0026gt; // cilium会自动下载plugins到/opt/cni/bin. // \u0026lt;https://github.com/flannel-io/flannel\u0026gt; $ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 配置master是否部署pod\n# enable master deploy pod (默认不部署pod到master) kubectl taint nodes --all node-role.kubernetes.io/control-plane- # disable master deploy pod kubectl taint nodes \u0026lt;node\u0026gt; node-role.kubernetes.io/master=true:NoSchedule 部署node $ sudo swapoff -a // 如果有vpn，kubeadm会自动下载安装 // 在所有node上部署cni-plugin: // \u0026lt;https://github.com/containernetworking/plugins/releases\u0026gt; $ sudo mkdir -p /opt/cni/bin // 下载并解压所有插件命令到该目录. $ sudo kubeadm join 192.168.1.1:6443 \\ --token 8po0v5.m1qlbc7w0btq15of \\ --discovery-token-ca-cert-hash sha256:21d8365e336d5218637ddf26e2ec5d91c7dd2de518dbe47973e089837b13265b 验证 $ kubectl get pods -n kube-system $ kubectl get nodes 删除cluster 所有node运行:\n$ sudo kubeadm reset -f // 自动停止kubelet并且删除下列文件和目录 [/etc/kubernetes/manifests /etc/kubernetes/pki] [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf] [/var/lib/etcd /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni] 需要手动删除:\n$ sudo rm -rf /etc/cni/net.d 所有node上删除flannel的网络配置\n$ sudo ifconfig cni0 down $ sudo ip link delete cni0 $ sudo ifconfig flannel.1 down $ sudo ip link delete flannel.1 $ sudo rm -rf /run/flannel 所有node清空iptables\n$ sudo iptables -F $ sudo iptables -X $ sudo iptables -t nat -F $ sudo iptables -t nat -X 如果使用了IPVS:\n$ ipvsadm --clear 删除配置\n$ rm -rf $HOME/.kube 部署HA Cluster ha需要在所有master节点安装haproxy和keepalived.\nhttps://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/\nhttps://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing\n在master1上初始化：\n$ sudo kubeadm init --config ./kubeadm.yaml -v=6 --upload-certs 加入其它master:\n$ sudo kubeadm join 192.168.1.200:8443 --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash \u0026lt;hash\u0026gt; --control-plane --certificate-key \u0026lt;key\u0026gt; 加入node:\n$ sudo kubeadm join 192.168.1.200:8443 --token \u0026lt;token\u0026gt; --discovery-token-ca-cert-hash \u0026lt;hash\u0026gt; 配置 https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/\n使用自定义配置:\n$ sudo kubeadm init --config ./config.yaml -v=6 查看默认配置:\n$ kubeadm config print init-defaults 配置kubeadm：\napiVersion: kubeadm.k8s.io/v1beta2 kind: InitConfiguration bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authentication localAPIEndpoint: advertiseAddress: 10.103.1.1 // master IP bindPort: 6443 nodeRegistration: criSocket: /run/containerd/containerd.sock name: debug // master hostname taints: - effect: NoSchedule key: node-role.kubernetes.io/master 配置kubernetes:\n// 定制control plane \u0026lt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/\u0026gt; apiVersion: kubeadm.k8s.io/v1beta2 kind: ClusterConfiguration certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controlPlaneEndpoint: 10.58.203.200:8443 // HA中haproxy的VIP和port dns: type: CoreDNS etcd: local: dataDir: /var/lib/etcd networking: dnsDomain: cluster.local serviceSubnet: 10.96.0.0/12 podSubnet: 10.244.0.0/16 // for flannel imageRepository: k8s.gcr.io kubernetesVersion: v1.18.6 controllerManager: ... extraArgs: \u0026lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/\u0026gt; allocate-node-cidrs: 'true' node-cidr-mask-size: '16' // flannel的SubNetLen cluster-cidr: '10.0.0.0/8' // flannel的Network apiServer: timeoutForControlPlane: 4m0s \u0026lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/\u0026gt; extraArgs: advertise-address: 192.168.0.103 ... scheduler: ... \u0026lt;https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/\u0026gt; extraArgs: ... 修改kubelet的cgroup driver:\napiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration cgroupDriver: systemd ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Minikube",
    "permalink": "https://canuxcheng.com/post/k8s_minikube/",
    "date": "2019-12-30",
    "summary": "\u003ch1 id=\"minikube\"\u003eminikube\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/zh/docs/setup/learning-environment/minikube/\"\u003ehttps://kubernetes.io/zh/docs/setup/learning-environment/minikube/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eminikube 能快速创建k8s的开发集群，支持在虚拟机上创建，也支持裸机创建.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 在裸机上创建：\nsudo minikube start --vm-driver=none\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "minikube https://kubernetes.io/zh/docs/setup/learning-environment/minikube/\nminikube 能快速创建k8s的开发集群，支持在虚拟机上创建，也支持裸机创建.\n// 在裸机上创建： sudo minikube start --vm-driver=none ",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Image",
    "permalink": "https://canuxcheng.com/post/cncf_image/",
    "date": "2019-12-03",
    "summary": "\u003ch1 id=\"image\"\u003eimage\u003c/h1\u003e\n\u003cp\u003e容器镜像\u003c/p\u003e\n\u003cp\u003edocker image driver: aufs, btrfs, devicemapper, overlay.\u003c/p\u003e\n\u003ch2 id=\"multi-platform-images\"\u003emulti-platform images\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://docs.docker.com/build/building/multi-platform/\"\u003ehttps://docs.docker.com/build/building/multi-platform/\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"qemu\"\u003eqemu\u003c/h3\u003e\n\u003cp\u003e使用qume:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 安装bitfmt\ndocker run --privileged --rm tonistiigi/binfmt --install all\n\n// 查看支持的平台\nls -l /proc/sys/fs/binfmt_misc/qemu-*\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"multiple-native-nodes\"\u003emultiple native nodes\u003c/h3\u003e\n\u003cp\u003e安装\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// linux\nsudo apt install docker-buildx-plugin\n\n// mac\nbrew install docker-buildx\nmkdir -p ~/.docker/cli-plugins\nln -sfn $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx\ndocker buildx install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看版本\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker buildx version\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e管理builder instance\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker buildx create\n--append 添加node到builder实例。\n--leave 从builder实例删除node\n--driver Driver to use(\u0026quot;docker\u0026quot;, \u0026quot;docker-container\u0026quot;, \u0026quot;kubernetes\u0026quot;)\n--name\n--use\n--node\n--platform \n--bootstrap 启动实例（以容器的形式启动）\n\n// 以本地是amd64为例，创建一个实例.\ndocker buildx create --use --bootstrap --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --name canux-builder\n\n// 如果没有qumu，可以把不同平台的远程机器加到builder实例.\ndocker buildx create \\\n--name local_remote_builder \\\n--append --node \u0026lt;my-arm-server\u0026gt; \\\n--platform linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/mips64le,linux/mips64,linux/arm/v7,linux/arm/v6 \\\nssh://user@\u0026lt;my-arm-server\u0026gt; \n\ndocker buildx rm\n\ndocker buildx stop\n\ndocker buildx inspect\n\ndocker buildx use\n\n// 查看当前可用的builders\ndocker buildx ls\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建多平台镜像\u003c/p\u003e",
    "content": "image 容器镜像\ndocker image driver: aufs, btrfs, devicemapper, overlay.\nmulti-platform images https://docs.docker.com/build/building/multi-platform/\nqemu 使用qume:\n// 安装bitfmt docker run --privileged --rm tonistiigi/binfmt --install all // 查看支持的平台 ls -l /proc/sys/fs/binfmt_misc/qemu-* multiple native nodes 安装\n// linux sudo apt install docker-buildx-plugin // mac brew install docker-buildx mkdir -p ~/.docker/cli-plugins ln -sfn $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx docker buildx install 查看版本\ndocker buildx version 管理builder instance\ndocker buildx create --append 添加node到builder实例。 --leave 从builder实例删除node --driver Driver to use(\u0026quot;docker\u0026quot;, \u0026quot;docker-container\u0026quot;, \u0026quot;kubernetes\u0026quot;) --name --use --node --platform --bootstrap 启动实例（以容器的形式启动） // 以本地是amd64为例，创建一个实例. docker buildx create --use --bootstrap --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --name canux-builder // 如果没有qumu，可以把不同平台的远程机器加到builder实例. docker buildx create \\ --name local_remote_builder \\ --append --node \u0026lt;my-arm-server\u0026gt; \\ --platform linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/mips64le,linux/mips64,linux/arm/v7,linux/arm/v6 \\ ssh://user@\u0026lt;my-arm-server\u0026gt; docker buildx rm docker buildx stop docker buildx inspect docker buildx use // 查看当前可用的builders docker buildx ls 构建多平台镜像\ndocker buildx build --platform \u0026lt;p1,p2\u0026gt; ... // 一次编译多个平台的镜像直接push到registry。 docker buildx build --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --push -t name/target:tag . // 编辑成不同的image docker buildx build -o type=docker --platform linux/amd64 -t name:1.0.0 . docker buildx build -o type=docker --platform linux/arm64 -t name:1.0.0-linux-arm64 . cross-compilation Overlay 最下层是一个 lower 层，也就是镜像层，它是一个只读层；\n右上层是一个 upper 层，upper 是容器的读写层，upper 层采用了写实复制的机制，也就是说只有对某些文件需要进行修改的时候才会从 lower 层把这个文件拷贝上来，之后所有的修改操作都会对 upper 层的副本进行修改；\nupper 并列的有一个 workdir，它的作用是充当一个中间层的作用。也就是说，当对 upper 层里面的副本进行修改时，会先放到 workdir，然后再从 workdir 移到 upper 里面去，这个是 overlay 的工作机制；\n最上面的是 mergedir，是一个统一视图层。从 mergedir 里面可以看到 upper 和 lower 中所有数据的整合，然后我们 docker exec 到容器里面，看到一个文件系统其实就是 mergedir 统一视图层。\n# 挂载到overlay mount -t overlay -o lowerdir=/path/lower,upperdir=/path/upper,workdir=/path/work overlay /path/di scratch scratch是空白镜像，一般用于基础镜像构建.比如制作alpine/ubuntu/debian/busybox镜像.\nubuntu/debian Hash Sum mismatch:\nRUN set -ex \\ \u0026amp;\u0026amp; apt-get clean \\ \u0026amp;\u0026amp; apt-get update -o Acquire::CompressionTypes::Order::=gz \\ \u0026amp;\u0026amp; apt-get update \\ \u0026amp;\u0026amp; apt-get install -y --allow-unauthenticated --no-install-recommends \\ build-essential \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* centos/fedora buildpack-deps 在ubuntu/debian基础上安装一些工具，比ubuntu/debian镜像更大.\nhttps://github.com/docker-library/buildpack-deps\nbusybox https://github.com/docker-library/busybox\nalpine(推荐) 很多语言的都是基于alpine: python-version:alpine-version, golang-version:alpine-version.\n一个基于musl和busybox的linux发行版.\nhttps://www.alpinelinux.org/\nalpine比distroless尺寸大，包含包管理和shell，方便调试.\nalpine使用musl代替glibc会导致有的程序无法运行, 解决:\n# mkdir /lib64 # ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2 注意wget 部分参数不可用.\ndistroless google提供的只包含运行时的精简镜像.\n缺点是没有包管理和shell，不方便调试.\nhttps://github.com/GoogleContainerTools/distroless\nslim 减小image大小,适用于web程序.\n\u0026lt;https://github.com/docker-slim/docker-slim\n",
    "categories": ["CNCF","Storage"],
    "tags": ["docker"]
  },
  {
    "title": "Helm",
    "permalink": "https://canuxcheng.com/post/k8s_helm/",
    "date": "2019-09-05",
    "summary": "\u003ch1 id=\"helm\"\u003eHelm\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/helm/helm\"\u003ehttps://github.com/helm/helm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ehelm2有两个组件:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehelm: 客户端\u003c/li\u003e\n\u003cli\u003etiller: 服务端(helm3被移除)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e概念:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echart: helm包，包含运行一个应用所需的镜像，依赖和资源.\u003c/li\u003e\n\u003cli\u003erepository: 用于发布和存储chart的仓库.\u003c/li\u003e\n\u003cli\u003erelease: 在k8s集群上运行的一个chart实例.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003erepository有哪些:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echarts: OSS, public, 已经被artifacthub取代, \u003ca href=\"https://github.com/helm/charts\"\u003ehttps://github.com/helm/charts\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eartifacthub: OSS, public,  \u003ca href=\"https://artifacthub.io/\"\u003ehttps://artifacthub.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003echartmuseum: OSS, private, self-host, \u003ca href=\"https://github.com/helm/chartmuseum\"\u003ehttps://github.com/helm/chartmuseum\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eharbor: OSS, private, self-host.\u003c/li\u003e\n\u003cli\u003eartifactory(jfrog): enterprise, private, self-host.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"安装\"\u003e安装\u003c/h2\u003e\n\u003cp\u003ehelm和kubectl一样，访问指定配置的k8s集群。\u003c/p\u003e\n\u003cp\u003ehelm2需要安装tiller并且执行helm init初始化,helm不需要tiller.\u003c/p\u003e\n\u003cp\u003e本地二进制安装helm3+:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurl https://baltocdn.com/helm/signing.asc | sudo apt-key add -\nsudo apt-get install apt-transport-https --yes\necho \u0026quot;deb https://baltocdn.com/helm/stable/debian/ all main\u0026quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list\nsudo apt-get update\nsudo apt-get install helm\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"命令\"\u003e命令\u003c/h2\u003e\n\u003ch3 id=\"repo管理\"\u003erepo管理\u003c/h3\u003e\n\u003cp\u003e查看有哪些repo,默认没有repo\u003c/p\u003e",
    "content": "Helm https://github.com/helm/helm\nhelm2有两个组件:\nhelm: 客户端 tiller: 服务端(helm3被移除) 概念:\nchart: helm包，包含运行一个应用所需的镜像，依赖和资源. repository: 用于发布和存储chart的仓库. release: 在k8s集群上运行的一个chart实例. repository有哪些:\ncharts: OSS, public, 已经被artifacthub取代, https://github.com/helm/charts artifacthub: OSS, public, https://artifacthub.io/ chartmuseum: OSS, private, self-host, https://github.com/helm/chartmuseum harbor: OSS, private, self-host. artifactory(jfrog): enterprise, private, self-host. 安装 helm和kubectl一样，访问指定配置的k8s集群。\nhelm2需要安装tiller并且执行helm init初始化,helm不需要tiller.\n本地二进制安装helm3+:\ncurl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \u0026quot;deb https://baltocdn.com/helm/stable/debian/ all main\u0026quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm 命令 repo管理 查看有哪些repo,默认没有repo\n$ helm repo list 添加repo并命名\n$ helm repo add [NAME] [URL] [flags] // 添加charts/artifactoryhub stable命名为stable $ helm repo add stable https://charts.helm.sh/stable 更新repo:\n$ helm repo update chart管理 从repo中查找chart:\n$ helm search hub [KEYWORD] [flags] 从repo里面的chart里面搜索关键字:\n$ helm search repo [keyword] [flags] //查看repo里面所有chart $ helm search repo // 查看repo里面所有treafik chart $ helm search repo traefik 查看chart信息:\nhelm show chart traefik/traefik helm show values traefik/traefik \u0026gt; value.yaml 下载chart:\nhelm pull chart-name release管理 install/upgrade/uninstall/rollback\nstatus/list/get/history\n安装chart:\nhelm install [name] [chart] [flags] // 验证签名 helm install --verify ... helm install traefik traefik/traefik // 需提前创建namespace, 修改value helm install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard -f value.yaml -n kubernetes-dashboard 查看release(每个install都是一个release):\nhelm list -a, --all show all releases without any filter applied. -A, --all-namespaces list releases across all namespaces. 卸载release:\nhelm uninstall kubernetes-dashboard -n kubernetes-dashboard 查看状态:\nhelm status mysql 获取release信息:\nhelm get manifest [name] misc helm plugin helm env chart开发 创建chart:\nhelm create my-chart debug chart：\n// 检查语法 helm lint my-chart // 模拟安装 helm install my-chart ./my-chart --dry-run --debug 模板管理:\nhelm template [name] [chart] // 在本地渲染模板 helm template my-chart ./my-chart 依赖chart管理:\nhelm dependency // 将依赖的chart下载到chart目录. helm dep up \u0026lt;chart-name\u0026gt; 测试chart:\nhelm test 打包chart:\nhttps://helm.sh/zh/docs/topics/provenance/\nhelm package my-chart // 会另外生成一个.prov文件 helm package --sign --key \u0026quot;Canux\u0026quot; --keyring ~/.gnupg/secring.gpg my-chart 验证打包的chart:\nhelm verify my-chart.tgz 生成index文件:\nhelm repo index my-chart-folder --url \u0026lt;repo-url\u0026gt; 上传chart到registry：\n有的registry支持ui上直接upload，或者CLI上传，也可以通过helm push上传.\nhelm registry login helm push my-chart.tgz oci://registry/helm-charts helm registry logout 如果是OCI registry目前只支持以下命令：\nhelm registry login/logout helm push helm pull helm show helm template helm install helm upgrade chart 目录:\nvalues.yaml Chart.yaml charts/ templates/ templates/tests/ Chart.yaml语法:\nhttps://helm.sh/zh/docs/topics/charts/#chartyaml-%E6%96%87%E4%BB%B6\ntemplate的流控制:\nhttps://helm.sh/zh/docs/chart_template_guide/control_structures/\n// 用$代替. 来获取上一级的变量 {{- range .Values.worker }} apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \u0026quot;app.fullname\u0026quot; $ }}-worker-{{ .name }} labels: {{- include \u0026quot;worker.labels\u0026quot; $ | nindent 4 }} spec: {{- if not .autoscaling.enabled }} replicas: {{ $.Values.replicaCount }} {{- end }} ...... --- {{- end }} template的函数:\nhttps://helm.sh/zh/docs/chart_template_guide/function_list/\nhooks:\nhelm uninstall 不会删除有hook的资源。\nhttps://helm.sh/zh/docs/topics/charts_hooks/\nannotations: # This is what defines this resource as a hook. Without this line, the # job is considered part of the release. \u0026quot;helm.sh/hook\u0026quot;: post-install, pre-install, ... \u0026quot;helm.sh/hook-weight\u0026quot;: \u0026quot;-5\u0026quot; \u0026quot;helm.sh/hook-delete-policy\u0026quot;: hook-succeeded, hook-failed, ... ",
    "categories": ["CNCF"],
    "tags": ["helm"]
  },
  {
    "title": "K8S CRI",
    "permalink": "https://canuxcheng.com/post/k8s_cri/",
    "date": "2019-06-05",
    "summary": "\u003ch1 id=\"cri\"\u003eCRI\u003c/h1\u003e\n\u003cp\u003eCRI: Container Runtime Intarface\u003c/p\u003e\n\u003cp\u003e定义了k8s和container runtime进行交互的接口.\u003c/p\u003e\n\u003cp\u003e是k8s与container交互的标准.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\"\u003ehttps://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econtainerd\u003c/li\u003e\n\u003cli\u003ecri-o\u003c/li\u003e\n\u003cli\u003erkt\u003c/li\u003e\n\u003cli\u003ekata\u003c/li\u003e\n\u003cli\u003erancher\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"docker\"\u003edocker\u003c/h2\u003e\n\u003cp\u003ek8s_1.20 开始警告不再支持docker.\u003c/p\u003e\n\u003cp\u003ek8s_1.23 开始移除dockershim.\u003c/p\u003e\n\u003cp\u003e/var/run/dockerhsim.sock\u003c/p\u003e\n\u003ch2 id=\"containerd\"\u003econtainerd\u003c/h2\u003e\n\u003cp\u003e/run/container/containerd.sock\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/containerd/containerd\"\u003ehttps://github.com/containerd/containerd\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装配置:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd\"\u003ehttps://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"cri-o\"\u003eCRI-O\u003c/h2\u003e\n\u003cp\u003eredhat.\u003c/p\u003e\n\u003cp\u003e/var/run/crio/crio.sock\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cri-o/cri-o\"\u003ehttps://github.com/cri-o/cri-o\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"kata\"\u003ekata\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kata-containers/runtime\"\u003ehttps://github.com/kata-containers/runtime\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"rkt\"\u003erkt\u003c/h2\u003e\n\u003cp\u003eredhat(coreos)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rkt/rkt\"\u003ehttps://github.com/rkt/rkt\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e",
    "content": "CRI CRI: Container Runtime Intarface\n定义了k8s和container runtime进行交互的接口.\n是k8s与container交互的标准.\nhttps://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/\ncontainerd cri-o rkt kata rancher docker k8s_1.20 开始警告不再支持docker.\nk8s_1.23 开始移除dockershim.\n/var/run/dockerhsim.sock\ncontainerd /run/container/containerd.sock\nhttps://github.com/containerd/containerd\n安装配置:\nhttps://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd\nCRI-O redhat.\n/var/run/crio/crio.sock\nhttps://github.com/cri-o/cri-o\nkata https://github.com/kata-containers/runtime\nrkt redhat(coreos)\nhttps://github.com/rkt/rkt\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Virtualbox",
    "permalink": "https://canuxcheng.com/post/virtualbox/",
    "date": "2019-06-03",
    "summary": "\u003ch1 id=\"virtualbox\"\u003eVirtualbox\u003c/h1\u003e\n\u003cp\u003e虚拟化工具virtualbox.\u003c/p\u003e\n\u003ch1 id=\"vboxmanage\"\u003evboxmanage\u003c/h1\u003e\n\u003cp\u003evm\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 导入ova\n$ vboxmanage import win7.ova \n\n// 添加host网络\n$ vboxmanage modifyvm \u0026quot;win764\u0026quot; --nic1 hostonly --hostonlyadapter1 vboxnet0\n// 添加bridge网络\n$ vboxmanage modifyvm \u0026quot;Win732\u0026quot; --nic2 bridged --bridgeadapter2 docker_gwbridge\n// 重命名vm\n$ vboxmanage modifyvm \u0026lt;vm\u0026gt; --name \u0026lt;new-name\u0026gt; \n// 修改参数\n$ vboxmanage modifyvm \u0026lt;vm\u0026gt; --memory 4096 --cpus 4 --hwvirtex on --ioapic on\n\n// 启动虚拟机\n$ vboxmanage startvm \u0026quot;Win732\u0026quot;\n$ vboxmanage startvm \u0026lt;vm\u0026gt; --type headless \n$ VBoxHeadless --startvm \u0026lt;uuid|name\u0026gt; --vrde on\n\n// 控制虚拟机\n$ vboxmanage controlvm \u0026lt;vm\u0026gt; pause/resume/reset/poweroff/savestate\n\n// 查看所有/运行虚拟机\n$ vboxmanage list vms/runningvms \n\n// 删除vm\n$ vboxmanage unregistervm \u0026lt;vm\u0026gt; --delete\n\n// linux上执行命令\n$ vboxmanage guestcontrol {} --username {} --password {} run --exe /bin/bash -- -l -c 'pwd'\n\n// windows上执行命令\n$ vboxmanage guestcontrol {} --username 'Administrator' run --exe 'C:\\\\Program Files\\\\Oracle\\\\VirtualBox Guest Additions\\\\uninst.exe' -- uninst.exe /S\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emedia\u003c/p\u003e",
    "content": "Virtualbox 虚拟化工具virtualbox.\nvboxmanage vm\n// 导入ova $ vboxmanage import win7.ova // 添加host网络 $ vboxmanage modifyvm \u0026quot;win764\u0026quot; --nic1 hostonly --hostonlyadapter1 vboxnet0 // 添加bridge网络 $ vboxmanage modifyvm \u0026quot;Win732\u0026quot; --nic2 bridged --bridgeadapter2 docker_gwbridge // 重命名vm $ vboxmanage modifyvm \u0026lt;vm\u0026gt; --name \u0026lt;new-name\u0026gt; // 修改参数 $ vboxmanage modifyvm \u0026lt;vm\u0026gt; --memory 4096 --cpus 4 --hwvirtex on --ioapic on // 启动虚拟机 $ vboxmanage startvm \u0026quot;Win732\u0026quot; $ vboxmanage startvm \u0026lt;vm\u0026gt; --type headless $ VBoxHeadless --startvm \u0026lt;uuid|name\u0026gt; --vrde on // 控制虚拟机 $ vboxmanage controlvm \u0026lt;vm\u0026gt; pause/resume/reset/poweroff/savestate // 查看所有/运行虚拟机 $ vboxmanage list vms/runningvms // 删除vm $ vboxmanage unregistervm \u0026lt;vm\u0026gt; --delete // linux上执行命令 $ vboxmanage guestcontrol {} --username {} --password {} run --exe /bin/bash -- -l -c 'pwd' // windows上执行命令 $ vboxmanage guestcontrol {} --username 'Administrator' run --exe 'C:\\\\Program Files\\\\Oracle\\\\VirtualBox Guest Additions\\\\uninst.exe' -- uninst.exe /S media\n// 列出所有hdd $ vboxmanage list hdds // 删除hdd $ vboxmanage closemedium disk \u0026lt;uuid\u0026gt; --delete snapshot\n//查看快照 $ vboxmanage snapshot \u0026lt;vm\u0026gt; list $ vboxmanage snapshot \u0026lt;vm\u0026gt; take \u0026lt;name\u0026gt; --live --pause // 创建快照 $ vboxmanage snapshot \u0026lt;vm\u0026gt; delete \u0026lt;snapshot-name/uuid\u0026gt; // 删除快照 $ vboxmanage snapshot \u0026lt;vm\u0026gt; restore \u0026lt;name\u0026gt; hostonly-network\n$ vboxmanage hostonlyif crate // 创建hostonly bridge $ vboxmanage hostonlyif ipconfig vboxnet0 --ip 192.168.1.1 --netmask 255.255.255.0 // 给hostonly bridge分配ip和netmask. $ vboxmanage hostonlyif remove \u0026lt;name\u0026gt; // 查看所有hostonly网路 $ vboxmanage list hostonlyifs bridge-network\nnat-network\nstorage\nextpack\n// 安装扩展包 $ sudo vboxmanage extpack install Oracle_VM_VirtualBox_Extension_Pack-6.0.8.vbox-extpack $ sudo vboxmanage extpack uninstall \\ \u0026quot;Oracle VM VirtualBox Extension Pack\u0026quot; ",
    "categories": ["Virtualization"],
    "tags": ["virtualbox"]
  },
  {
    "title": "Package",
    "permalink": "https://canuxcheng.com/post/go_package/",
    "date": "2019-04-23",
    "summary": "",
    "content": "",
    "categories": ["Golang"],
    "tags": ["package"]
  },
  {
    "title": "Command",
    "permalink": "https://canuxcheng.com/post/network_command/",
    "date": "2019-03-31",
    "summary": "\u003ch1 id=\"network-command\"\u003enetwork command\u003c/h1\u003e\n\u003cp\u003enetwork related command\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"net-tools\"\u003enet-tools\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ecki/net-tools\"\u003ehttps://github.com/ecki/net-tools\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install net-tools\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"ifconfig\"\u003eifconfig\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eifconfig # 查看up的interface\nifconfig -a  # 查看所有的interface\nifconfig \u0026lt;bridge\u0026gt;/\u0026lt;interface\u0026gt; up/down\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"netstat\"\u003enetstat\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003enetstat\n-a, --all, --listening # 显示所有socket, 默认只显示connected\n-l, --listening  # 显示listening\n-n, --numeric\n-p, --programs # 显示pid或程序名称\n# socket选项:\n-t, --tcp\n-u, --udp\n-w, --raw\n-x, --unix\n--ax25\n--ipx\n--netrom\n\n# 常用\nnetstat -anp    # 查看哪些端口是打开的．\nsudo netstat -anp | grep port # 查看端口是否被使用\nsudo netstat -tulnp # 查看tcp\u0026amp;udp端口是否被监听\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"arp\"\u003earp\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003earp # 用于确定IP地址的网卡物理地址\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"rarp\"\u003erarp\u003c/h3\u003e\n\u003ch3 id=\"hostname\"\u003ehostname\u003c/h3\u003e\n\u003ch3 id=\"domainname\"\u003edomainname\u003c/h3\u003e\n\u003ch3 id=\"dnsdomainname\"\u003ednsdomainname\u003c/h3\u003e\n\u003ch3 id=\"route\"\u003eroute\u003c/h3\u003e\n\u003cp\u003eFlags:\u003c/p\u003e",
    "content": "network command network related command\nnet-tools https://github.com/ecki/net-tools\n$ sudo apt-get install net-tools ifconfig ifconfig # 查看up的interface ifconfig -a # 查看所有的interface ifconfig \u0026lt;bridge\u0026gt;/\u0026lt;interface\u0026gt; up/down netstat netstat -a, --all, --listening # 显示所有socket, 默认只显示connected -l, --listening # 显示listening -n, --numeric -p, --programs # 显示pid或程序名称 # socket选项: -t, --tcp -u, --udp -w, --raw -x, --unix --ax25 --ipx --netrom # 常用 netstat -anp # 查看哪些端口是打开的． sudo netstat -anp | grep port # 查看端口是否被使用 sudo netstat -tulnp # 查看tcp\u0026amp;udp端口是否被监听 arp arp # 用于确定IP地址的网卡物理地址 rarp hostname domainname dnsdomainname route Flags:\nU: route is up H: target is a host G: use gateway !: reject route Genmask: netmask for destination net.\nMetric: 到target距离, hops.\nRef: 该路由引用次数\nUse: 查找路由的次数\nroute -n iputils https://github.com/iputils/iputils\n$ sudo apt-get install iputils-ping ping ping # 用于确定网络的连通性 arping tracepath clockdiff traceroute sudo apt install traceroute tcpdump sudo apt-get install tcpdump tcpdump tcpdump udp port \u0026lt;port\u0026gt; 抓udp 在port端口的包 tcpdump -i \u0026lt;interface\u0026gt; host \u0026lt;ip\u0026gt; nc/netcat // 有的系统默认安装netcat-traditional $ sudo apt-get install netcat-traditional // 安装netcat-openbsd $ sudo apt-get install netcat-openbsd // 设置默认值 $ sudo update-alternatives --config nc $ sudo update-alternatives --set nc /bin/nc.openbsd nc -z IP PORT # 查看指定tcp://ip:port是否监听 nc -zu IP PORT # 查看udp://ip:port是否监听 // 通过nc监听端口 nc -l PORT // 通过nc发送请求. echo -e '{\u0026quot;method\u0026quot;:\u0026quot;test\u0026quot;,\u0026quot;params\u0026quot;:[\u0026quot;test\u0026quot;],\u0026quot;id\u0026quot;:1}' | nc IP PORT brctl $ sudo apt-get install bridge-utils brctl show brctl addbr \u0026lt;bridge\u0026gt; # 添加bridge brctl delbr \u0026lt;bridge\u0026gt; # 删除bridge brctl addif \u0026lt;bridge\u0026gt; \u0026lt;interface\u0026gt; # 绑定interface到bridge brctl delif \u0026lt;bridge\u0026gt; \u0026lt;interface\u0026gt; # 删除bridge上的interface iproute2 https://github.com/shemminger/iproute2\n$ sudo apt-get install iproute2 ip ip link show # 创建vlan ip link add link eth1 name eth1.10 type vlan id 10 # 添加ip ip addr add 192.168.100.1/24 brd 192.168.100.255 dev eth1.10 # 启动vlan ip link set dev eth1.10 up # 关闭vlan ip link set dev eth1.10 down # 删除vlan ip link delete eth1.10 addr/address\nip addr show route\nip route show rule\nip rule show devlink ifstat bridge dnsutils sudo apt-get install dnsutils nslookup nslookup # 查询IP地址和对应的域名 dig nsupdate delv ethtool sudo apt-get install ethtool ethtool # 查询网络设备信息 iftop http://www.ex-parrot.com/~pdw/iftop/\n$ sudo apt-get install iftop sudo iftop wget wget [option] [URL] -a, --append-output=FILE 输出重定向到日志 -o, --output-file=FILE -q, --quiet 不输出 -b, --background -nv, --no-verbose --header \u0026quot;authorization:c2FuZGJveDpTMG5pY3dhbGwK\u0026quot; -t, --tries=NUMBER 超时重连次数, 0表示不限制, 默认20 -nc, --no-clobber 不覆盖原有文件 -N, --timestamping 只下载比本地新的文件 -c, --continue 断点续传,会覆盖-N -T, --timeout=SECONDS 超时时间, 默认900s -w, --wait=SECONDS 重连之间的等待时间 -O, --output-document=FILE, 重命名下载文件 -nH, --no-host-directories 不创建站点的根目录 -x, --force-directories 创建和服务器一样的结构下载 -P, --directory-prefix=PREFIX 指定下载的目录 -R, --reject=LIST 排除下载的文件 -r, --recursive 迭代下载 -np, --no-parent 不下载父目录的内容 # 同步目录 wget -Nc -r -np -nH --cut-dirs=3 -R \u0026quot;index.*, *.js, *.css, *.html, *.jpg, *.png, *.gif\u0026quot; -P /path/to/source/ http://host/path/to/dest/ # ssl + basic auth wget --no-check-certificate --user \u0026lt;user\u0026gt; --password \u0026lt;pw\u0026gt; -nv -N -P \u0026lt;dest-folder\u0026gt; \u0026lt;src-url\u0026gt; $ wget -q -N -P /folder url $ wget -q -c -O /path/to/file.ext url curl curl -X/--request post/patch/delte/get/... -H/--header 'content-type: application/json' -d/--data '{\u0026quot;key\u0026quot;: \u0026quot;value\u0026quot;}' --data-raw DATA HTTP POST data, '@' allowed (H) --data-ascii DATA HTTP POST ASCII data (H) --data-binary DATA HTTP POST binary data (H) --data-urlencode DATA HTTP POST data url encoded (H) -G, --get Send the -d data with a HTTP GET (H) -k/--insecure ignore ssl check. -u/--user \u0026lt;user:password\u0026gt; -s/--silent Silent mode ",
    "categories": ["Network"],
    "tags": ["command"]
  },
  {
    "title": "Command",
    "permalink": "https://canuxcheng.com/post/storage_command/",
    "date": "2019-03-31",
    "summary": "\u003ch1 id=\"sysstat\"\u003esysstat:\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e# \u0026lt;https://github.com/sysstat/sysstat\u0026gt;\n$ sudo apt-get install sysstat\n# 包括 iostat/mpstat/pidstat/tapestat/cifsiostat\n\niostat -d -x -k 1 10\n\npidstat -d -p pid\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"iotop\"\u003eiotop\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e# 查看进程的diskio\n$ sudo apt-get install iotop\n$ sudo iotop\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"df\"\u003edf\u003c/h1\u003e\n\u003cp\u003edf计算文件系统磁盘空间使用:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edf\n$ df -h\n\n# 查看目录信息(读写哪个设备)\n$ df /path/folder\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"dd\"\u003edd\u003c/h1\u003e\n\u003cp\u003edd转化并拷贝文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edd\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"fsck\"\u003efsck\u003c/h1\u003e\n\u003cp\u003efsck检查并修复文件系统:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efsck\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"fdisk\"\u003efdisk\u003c/h1\u003e\n\u003cp\u003e支持msdos，支持2T以下的磁盘.\u003c/p\u003e\n\u003cp\u003efdisk管理磁盘分区表:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efdisk\nfdisk -l\n\nfdisk /dev/sda # 可以创建新的磁盘分区\n\u0026gt; n ...    创建新的分区\n\u0026gt; t (8e表示linux LVM), 修改分区类型\n\u0026gt; w 保存修改\npartprobe /dev/sda # 在不重启的情况下保存分区\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"parted\"\u003eparted\u003c/h1\u003e\n\u003cp\u003e支持gpt分区表，支持2T以上的大磁盘.\u003c/p\u003e",
    "content": "sysstat: # \u0026lt;https://github.com/sysstat/sysstat\u0026gt; $ sudo apt-get install sysstat # 包括 iostat/mpstat/pidstat/tapestat/cifsiostat iostat -d -x -k 1 10 pidstat -d -p pid iotop # 查看进程的diskio $ sudo apt-get install iotop $ sudo iotop df df计算文件系统磁盘空间使用:\ndf $ df -h # 查看目录信息(读写哪个设备) $ df /path/folder dd dd转化并拷贝文件:\ndd fsck fsck检查并修复文件系统:\nfsck fdisk 支持msdos，支持2T以下的磁盘.\nfdisk管理磁盘分区表:\nfdisk fdisk -l fdisk /dev/sda # 可以创建新的磁盘分区 \u0026gt; n ... 创建新的分区 \u0026gt; t (8e表示linux LVM), 修改分区类型 \u0026gt; w 保存修改 partprobe /dev/sda # 在不重启的情况下保存分区 parted 支持gpt分区表，支持2T以上的大磁盘.\n大存储分区工具,比如nas,raid.\nparted /dev/sda print mkfd mkfs:\nmkfs [options] [-t type fs-options] device [size] mkfs.ext4 /dev/sdb1 # 将分区格式化成ext4格式. mount/umount 相关文件:\n/etc/fstab /etc/mtab 查看磁盘的uuid, 通过uuid挂载 ls -l /dev/disk/by-uuid mount/umount挂载文件系统:\nmount # 查看所有挂载信息 mount -t type -o option device dir # 将目录挂载到指定磁盘分区 mount -t ext4 /dev/sdb1 /opt 等效修改/etc/fstab /dev/sdb1 /opt ext4 defaults 0 0 # 将目录挂在到内存上. mount -t tmpfs -o size=100G tmpfs /var/www # 本机挂载, 将本机的folder2挂载到folder1, folder2中原有的内容会隐藏. mount --bind /path/folder1 /path/folder2 /path/folder1 /path/folder2 none bind 0 0 # 挂载到overlay mount -t overlay -o lowerdir=/path/lower,upperdir=/path/upper,workdir=/path/work overlay /path/dir umount umount device/dir 磁盘管理 # 先创建linux lvm分区 pvcreate \u0026lt;pv-name\u0026gt; # 创建物理卷PV pvdisplay vgextend \u0026lt;vg-name\u0026gt; \u0026lt;pv-name\u0026gt; # 给物理卷创建卷组VG vgdisplay lvextend -r -l +100%FREE \u0026lt;lv-path\u0026gt; # 将物理卷上的空闲空间全部放到逻辑卷LV上 lvdisplay sync同步缓存写入固态存储:\nsync 查看所有硬件设备:\nlshw # 列出硬件 lshw -class disk # 查看磁盘设备 设备管理:\nlspci # 列出所有PCI设备 lsusb # 列出USB设备 lsblk # 列出块设备 setleds loadkeys dumpkeys MAKEDEV IOPS 磁盘IO.\n安装fio:\n$ sudo apt-get install fio 测试随机读写的IO:\n// 测试本地磁盘读写 $ fio -filename=/dev/sda1 -direct=1 -iodepth 1 -thread -rw=randrw \\ -rwmixread=70 -ioengine=psync -bs=16k -size=200G -numjobs=30 -runtime=100 \\ -group_reporting -name=mytest ",
    "categories": ["Storage"],
    "tags": ["command"]
  },
  {
    "title": "Init",
    "permalink": "https://canuxcheng.com/post/linux_init/",
    "date": "2019-02-03",
    "summary": "\u003ch1 id=\"linux-init\"\u003eLinux Init\u003c/h1\u003e\n\u003cp\u003elinux系统启动的第一个进程,pid=1的进程.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ls -l /sbin/init\n$ sudo readlink /sbin/init\n/sbin/init -\u0026gt; upstart\n/sbin/init -\u0026gt; /lib/systemd/systemd\n\n/etc/init.d\nThe directory containing System V init scripts.\n通过service命令操作\n\n/etc/init\nThe directory containing upstart jobs.\n通过initctl命令操作\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"systemd\"\u003esystemd\u003c/h1\u003e\n\u003cp\u003esytemd是upstart的替代版本．通过查看/sbin/init指向systemd还是upstart.\u003c/p\u003e\n\u003cp\u003eservice文件位置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/etc/systemd/system/***.service\n/lib/systemd/system/*.service\n/usr/lib/systemd/system/*.service\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eservice文件编写:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.freedesktop.org/software/systemd/man/systemd.unit.html#\"\u003ehttps://www.freedesktop.org/software/systemd/man/systemd.unit.html#\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[Unit]\nDescription=details\nAfter=containerd.service # 之前启动\nBefore= # 之后运行\nBindsto= #\nWants=containerd.service # 弱依赖\nRequires= # 强依赖\nStartLimitInterval=10s\nStartLimitBurst=5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html#\"\u003ehttps://www.freedesktop.org/software/systemd/man/systemd.service.html#\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[Service]\nType=simple/notify/dbus/forking/idle/oneshot\nExecStartPre=\nExecStart=\nExecStartPost=\nExecStop=\nExecStopPost=\nExecReload=\nKillMode=node/mixed/process/control-group\nRestart=no/on-success/on-failure/on-abnormal/on-abort/on-watchdog/always # always总是开机启动，即使systemctl enable.\nRestartSec=3s # 重启之前等待的时间.\nTimeoutSec=  # TimeoutStartSec+TimeoutStopSec\nLimitNOFILE=49152 # 限制单个service的fd\n\n[Install]\nWantedBy=multi-user.target\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esystemctl命令:\u003c/p\u003e",
    "content": "Linux Init linux系统启动的第一个进程,pid=1的进程.\n$ ls -l /sbin/init $ sudo readlink /sbin/init /sbin/init -\u0026gt; upstart /sbin/init -\u0026gt; /lib/systemd/systemd /etc/init.d The directory containing System V init scripts. 通过service命令操作 /etc/init The directory containing upstart jobs. 通过initctl命令操作 systemd sytemd是upstart的替代版本．通过查看/sbin/init指向systemd还是upstart.\nservice文件位置:\n/etc/systemd/system/***.service /lib/systemd/system/*.service /usr/lib/systemd/system/*.service service文件编写:\nhttps://www.freedesktop.org/software/systemd/man/systemd.unit.html#\n[Unit] Description=details After=containerd.service # 之前启动 Before= # 之后运行 Bindsto= # Wants=containerd.service # 弱依赖 Requires= # 强依赖 StartLimitInterval=10s StartLimitBurst=5 https://www.freedesktop.org/software/systemd/man/systemd.service.html#\n[Service] Type=simple/notify/dbus/forking/idle/oneshot ExecStartPre= ExecStart= ExecStartPost= ExecStop= ExecStopPost= ExecReload= KillMode=node/mixed/process/control-group Restart=no/on-success/on-failure/on-abnormal/on-abort/on-watchdog/always # always总是开机启动，即使systemctl enable. RestartSec=3s # 重启之前等待的时间. TimeoutSec= # TimeoutStartSec+TimeoutStopSec LimitNOFILE=49152 # 限制单个service的fd [Install] WantedBy=multi-user.target systemctl命令:\n# 修改后需要重新加载.service文件 $ systemctl daemon-reload $ systemctl start/stop/status *** $ systemctl list-unit-files $ systemctl show docker # 设置开机自动启动 //在/etc/systemd/system/multi-user.target.wants下创建链接 $ systemctl enable *** $ systemctl disable *** $ systemctl is-enabled *** 日志管理:\n$ sudo journalctl -fu docker.service upstart /etc/init.d/*** /etc/init/***.conf $ sudo service docker start/stop/status/reload/restart $ sudo initctl start/stop/status/reload/restart docker $ sudo initctl list # 设置开机自动启动 $ update-rc.d *** defaults # 取消开机启动 $ update-rc.d *** remove 日志管理:\n$ tail -f /var/log/upstart/docker.log Stanzas功能:\nhttp://upstart.ubuntu.com/wiki/Stanzas?highlight=%28%28CategoryDoc%29%29#pid\n# 添加服务 $ sudo vim /etc/init/docker.conf # docker - container daemon description \u0026quot;docker\u0026quot; start on runlevel [2345] stop on runlevel [!2345] respawn # give up if restart occurs 10 times in 100 seconds. respawn limit 10 100 pre-start script # do something before start end script script echo \u0026quot;ERROR: `date`: docker started by init.\u0026quot; exec docker end script post-start script # do something after start end script # 检查语法错误 $ sudo init-checkconf /etc/init/docker.conf # 注册服务 $ sudo initctl reload-configuration ",
    "categories": ["Linux"],
    "tags": ["init"]
  },
  {
    "title": "Nginx",
    "permalink": "https://canuxcheng.com/post/nginx/",
    "date": "2018-09-27",
    "summary": "\u003ch1 id=\"nginx\"\u003eNginx\u003c/h1\u003e\n\u003cp\u003e安装\u003c/p\u003e\n\u003cp\u003e配置\u003c/p\u003e\n\u003cp\u003e命令：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enginx -s stop/quit/reload/reopen\nnginx -V 详细信息\nnginx -v 版本号\nnginx -t 检查配置文件\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Nginx 安装\n配置\n命令：\nnginx -s stop/quit/reload/reopen nginx -V 详细信息 nginx -v 版本号 nginx -t 检查配置文件 ",
    "categories": ["Web"],
    "tags": ["nginx"]
  },
  {
    "title": "AST",
    "permalink": "https://canuxcheng.com/post/sec_ast/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"ast\"\u003eAST\u003c/h1\u003e\n\u003cp\u003eAST: Application Security Testing, 静态应用程序安全测试, 对应用程序源代码执行直接的白盒分析.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"sast\"\u003eSAST\u003c/h2\u003e\n\u003cp\u003eSAST: Static Application Security Testing\u003c/p\u003e\n\u003cp\u003eTools: SonarQube, Trivy, Coverity.\u003c/p\u003e\n\u003cp\u003egitlab SAST report.\ngitlab secret detection report.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/aquasecurity/trivy\"\u003ehttps://github.com/aquasecurity/trivy\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://scan.coverity.com/\"\u003ehttps://scan.coverity.com/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"dast\"\u003eDAST\u003c/h2\u003e\n\u003cp\u003eDAST: Dynamic Application Security Testing，动态应用程序安全测试, 对应用程序进行黑盒分析.\u003c/p\u003e\n\u003cp\u003eTools:\u003c/p\u003e\n\u003cp\u003eZAP Scan(OWASP ZAP)\u003c/p\u003e\n\u003cp\u003esynopsys WhiteHat Sentinel.\u003c/p\u003e\n\u003cp\u003egitlab DAST report.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"iast\"\u003eIAST\u003c/h2\u003e\n\u003cp\u003eIAST: Interactive Application Security Testing，交互式应用程序安全测试, 结合了SAST和DAST的优点.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"sca\"\u003eSCA\u003c/h2\u003e\n\u003cp\u003eSCA: Software Composition Analysis.\u003c/p\u003e\n\u003cp\u003eSBOM (software Bill of Materials),开源组件安全扫描\u003c/p\u003e\n\u003cp\u003eTools： BlackDuck, Jfrog Xray.\u003c/p\u003e\n\u003cp\u003egitlab dependency scanning report.\u003c/p\u003e",
    "content": "AST AST: Application Security Testing, 静态应用程序安全测试, 对应用程序源代码执行直接的白盒分析.\nSAST SAST: Static Application Security Testing\nTools: SonarQube, Trivy, Coverity.\ngitlab SAST report. gitlab secret detection report.\nhttps://github.com/aquasecurity/trivy\nhttps://scan.coverity.com/\nDAST DAST: Dynamic Application Security Testing，动态应用程序安全测试, 对应用程序进行黑盒分析.\nTools:\nZAP Scan(OWASP ZAP)\nsynopsys WhiteHat Sentinel.\ngitlab DAST report.\nIAST IAST: Interactive Application Security Testing，交互式应用程序安全测试, 结合了SAST和DAST的优点.\nSCA SCA: Software Composition Analysis.\nSBOM (software Bill of Materials),开源组件安全扫描\nTools： BlackDuck, Jfrog Xray.\ngitlab dependency scanning report.\n",
    "categories": ["Security"],
    "tags": ["CA"]
  },
  {
    "title": "CA",
    "permalink": "https://canuxcheng.com/post/sec_ca/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"ca\"\u003eCA\u003c/h1\u003e\n\u003cp\u003eSSL: secure sockets layer\u003c/p\u003e\n\u003cp\u003eTLS: transport layer security\u003c/p\u003e\n\u003cp\u003eCA: Certificate Authority.\u003c/p\u003e\n\u003cp\u003eSNI: server name indication\u003c/p\u003e\n\u003cp\u003e证书类型\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ex509: 只有公钥没有私钥匙\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e编码方式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epem: base64编码\u003c/li\u003e\n\u003cli\u003eder: 二进制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e证书文件:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecrt: 证书文件（可以是pem或der编码）\u003c/li\u003e\n\u003cli\u003ecer: 证书文件（可以是pem或der编码）\u003c/li\u003e\n\u003cli\u003ecsr: 申请签名的文件\u003c/li\u003e\n\u003cli\u003ekey: 私钥文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"创建自签名证书\"\u003e创建自签名证书\u003c/h1\u003e\n\u003cp\u003e创建x509证书:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ openssl genrsa -out server.key 2048   // 创建key\n$ openssl req -new -key server.key -sha256 -out server.csr // 创建csr\n$ openssl x509 -req -days 365 -in server.csr -signkey server.key -sha256 -out server.crt // 创建证书\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看证书信息:\u003c/p\u003e",
    "content": "CA SSL: secure sockets layer\nTLS: transport layer security\nCA: Certificate Authority.\nSNI: server name indication\n证书类型\nx509: 只有公钥没有私钥匙 编码方式\npem: base64编码 der: 二进制 证书文件:\ncrt: 证书文件（可以是pem或der编码） cer: 证书文件（可以是pem或der编码） csr: 申请签名的文件 key: 私钥文件 创建自签名证书 创建x509证书:\n$ openssl genrsa -out server.key 2048 // 创建key $ openssl req -new -key server.key -sha256 -out server.csr // 创建csr $ openssl x509 -req -days 365 -in server.csr -signkey server.key -sha256 -out server.crt // 创建证书 查看证书信息:\n// pem编码 $ openssl x509 -in cert.pem -noout -text // der编码 $ openssl x509 -in cert.der -inform der -noout -text 查看证书有效期:\n$ openssl x509 -in ca.domain.com.crt -noout -dates 客户端 客户端需要信任证书.\nLinux:\n// 添加 $ cp my-cert.crt /usr/local/share/ca-certificates/my-cert.crt $ sudo update-ca-certificates // 删除 $ rm /usr/local/share/ca-certificates/my-cert.crt $ sudo update-ca-certificates --fresh windows:\n// 添加 certutil -addstore -f \u0026quot;ROOT\u0026quot; my-cert.crt // 删除 certutil -delstore \u0026quot;ROOT\u0026quot; my-cert.crt 证书验证 系统默认的根证书在\n/etc/ssl/certs. python的requests包默认使用根证书在\n/usr/local/lib/python3.6/site-packages/requests/cacert.pem requests也通过certifi来管理根证书\n/usr/local/lib/python3.6/site-packages/certifi/cacert.pem 可以通过设置REQUESTS_CA_BUNDLE环境变量来让requests使用系统的根证书。\n",
    "categories": ["Security"],
    "tags": ["CA"]
  },
  {
    "title": "Capture",
    "permalink": "https://canuxcheng.com/post/sec_capture/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"packet-capture\"\u003ePacket Capture\u003c/h1\u003e\n\u003cp\u003e网络抓包\u003c/p\u003e\n\u003ch1 id=\"fiddler\"\u003eFiddler\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://www.telerik.com/fiddler\"\u003ehttp://www.telerik.com/fiddler\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"wireshark\"\u003eWireshark\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.wireshark.org/\"\u003ehttps://www.wireshark.org/\u003c/a\u003e\u003c/p\u003e",
    "content": "Packet Capture 网络抓包\nFiddler http://www.telerik.com/fiddler\nWireshark https://www.wireshark.org/\n",
    "categories": ["Security"],
    "tags": ["capture"]
  },
  {
    "title": "Csrf",
    "permalink": "https://canuxcheng.com/post/sec_csrf/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"csrf\"\u003eCSRF\u003c/h1\u003e\n\u003cp\u003eCross-site request forgery, 跨站请求伪造．\u003c/p\u003e\n\u003cp\u003e发生条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e登陆受信任网站A, 并在本地生成cookie\u003c/li\u003e\n\u003cli\u003e在不退出A的情况下，访问危险网站B\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e预防方法:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e正确使用get,post和cookie\u003c/li\u003e\n\u003cli\u003e在非get请求中增加伪随机数\u003c/li\u003e\n\u003c/ul\u003e",
    "content": "CSRF Cross-site request forgery, 跨站请求伪造．\n发生条件：\n登陆受信任网站A, 并在本地生成cookie 在不退出A的情况下，访问危险网站B 预防方法:\n正确使用get,post和cookie 在非get请求中增加伪随机数 ",
    "categories": ["Security"],
    "tags": ["capture"]
  },
  {
    "title": "HA",
    "permalink": "https://canuxcheng.com/post/ha/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"haproxy\"\u003eHAProxy\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.haproxy.com/\"\u003ehttps://www.haproxy.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install haproxy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo vim /etc/haproxy/haproxy.cfg\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eglobal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    log /dev/log    local0\n    log /dev/log    local1 notice\n    chroot /var/lib/haproxy\n    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners\n    stats timeout 30s\n    user haproxy\n    group haproxy\n    daemon\n\n    # Default SSL material locations\n    ca-base /etc/ssl/certs\n    crt-base /etc/ssl/private\n\n    # Default ciphers to use on SSL-enabled listening sockets.\n    # For more information, see ciphers(1SSL). This list is from:\n    #  https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/\n    # An alternative list with additional directives can be obtained from\n    #  https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy\n    ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS\n    ssl-default-bind-options no-sslv3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edefaults:\u003c/p\u003e",
    "content": "HAProxy https://www.haproxy.com/\n安装:\n$ sudo apt-get install haproxy 配置:\n$ sudo vim /etc/haproxy/haproxy.cfg global:\nlog /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners stats timeout 30s user haproxy group haproxy daemon # Default SSL material locations ca-base /etc/ssl/certs crt-base /etc/ssl/private # Default ciphers to use on SSL-enabled listening sockets. # For more information, see ciphers(1SSL). This list is from: # https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/ # An alternative list with additional directives can be obtained from # https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=haproxy ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS ssl-default-bind-options no-sslv3 defaults:\nlog global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend:\nbackend:\nlisten:\nKeepalived https://www.keepalived.org/\n安装:\n$ sudo apt-get install keepalived 配置:\n$ sudo vim /etc/keepalived/keepalived.conf ",
    "categories": ["Network"],
    "tags": ["haproxy","keepalived"]
  },
  {
    "title": "Sql Injection",
    "permalink": "https://canuxcheng.com/post/sec_sqlinjection/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"sql-injection\"\u003eSQL Injection\u003c/h1\u003e\n\u003cp\u003e什么是sql injection:从数据库获取敏感信息,或者利用数据库的特性执行添加用户,导出文件等一系列恶意操作,甚至有可能获取数据库乃至系统用户最高权限。\u003c/p\u003e\n\u003cp\u003e原因:造成SQL注入的原因是因为程序没有有效过滤用户的输入.\u003c/p\u003e\n\u003cp\u003e预防：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e严格限制数据库的操作权限\u003c/li\u003e\n\u003cli\u003e检查输入的数据格式是否符合要求\u003c/li\u003e\n\u003cli\u003e对进入数据库的特殊字符进行转义\u003c/li\u003e\n\u003cli\u003e数据库查询语句使用数据库提供的参数化查询接口\u003c/li\u003e\n\u003cli\u003e在发布之前使用专业的sql注入检测工具进行检测\u003c/li\u003e\n\u003cli\u003e避免网站打印sql错误信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过表单注入：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusername =\u0026gt; myuser' or 'foo' = 'foo' --\nSELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emssql的sql语句可以执行dos命令:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexec xp_cmdshell 'net user username 2546 /add' # 新建系统用户\nexec xp_cmdshell 'net localgroup administrator username /add' # 授权\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "SQL Injection 什么是sql injection:从数据库获取敏感信息,或者利用数据库的特性执行添加用户,导出文件等一系列恶意操作,甚至有可能获取数据库乃至系统用户最高权限。\n原因:造成SQL注入的原因是因为程序没有有效过滤用户的输入.\n预防：\n严格限制数据库的操作权限 检查输入的数据格式是否符合要求 对进入数据库的特殊字符进行转义 数据库查询语句使用数据库提供的参数化查询接口 在发布之前使用专业的sql注入检测工具进行检测 避免网站打印sql错误信息 通过表单注入：\nusername =\u0026gt; myuser' or 'foo' = 'foo' -- SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx' mssql的sql语句可以执行dos命令:\nexec xp_cmdshell 'net user username 2546 /add' # 新建系统用户 exec xp_cmdshell 'net localgroup administrator username /add' # 授权 ",
    "categories": ["Security"],
    "tags": ["sqlinjection"]
  },
  {
    "title": "Xss",
    "permalink": "https://canuxcheng.com/post/sec_xss/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"xss\"\u003eXSS\u003c/h1\u003e\n\u003cp\u003eXSS: Cross Site Scripting, 跨站脚本攻击\u003c/p\u003e\n\u003cp\u003eXSS攻击涉及到攻击者，客户端，和web应用三者.\u003c/p\u003e\n\u003cp\u003eXSS原理:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWeb应用未对用户提交请求的数据做充分的检查过滤,允许用户在提交的数据中掺入HTML代码(最主要的是“\u0026gt;”、“\u0026lt;”),并将未经转义的恶意代码输出到第三方用户的浏览器解释执行,是导致XSS漏洞的产生原因。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eXSS目前主要手段和目的:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e盗用cookie,获取敏感信息\u003c/li\u003e\n\u003cli\u003e利用植入flash，通过crossdomain权限设置获取更高权限．\u003c/li\u003e\n\u003cli\u003e利用iframe, frame, XMLHttpRequests等方式以用户身份执行一些管理操作．\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eXSS预防:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e过滤特殊字符\u003c/li\u003e\n\u003cli\u003e使用http头指定类型\u003c/li\u003e\n\u003c/ul\u003e",
    "content": "XSS XSS: Cross Site Scripting, 跨站脚本攻击\nXSS攻击涉及到攻击者，客户端，和web应用三者.\nXSS原理:\nWeb应用未对用户提交请求的数据做充分的检查过滤,允许用户在提交的数据中掺入HTML代码(最主要的是“\u0026gt;”、“\u0026lt;”),并将未经转义的恶意代码输出到第三方用户的浏览器解释执行,是导致XSS漏洞的产生原因。 XSS目前主要手段和目的:\n盗用cookie,获取敏感信息 利用植入flash，通过crossdomain权限设置获取更高权限． 利用iframe, frame, XMLHttpRequests等方式以用户身份执行一些管理操作． XSS预防:\n过滤特殊字符 使用http头指定类型 ",
    "categories": ["Security"],
    "tags": ["xss"]
  },
  {
    "title": "Cfssl",
    "permalink": "https://canuxcheng.com/post/sec_cfssl/",
    "date": "2018-07-28",
    "summary": "\u003ch1 id=\"cfssl\"\u003ecfssl\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cloudflare/cfssl\"\u003ehttps://github.com/cloudflare/cfssl\u003c/a\u003e\u003c/p\u003e",
    "content": "cfssl https://github.com/cloudflare/cfssl\n",
    "categories": ["Security"],
    "tags": ["capture"]
  },
  {
    "title": "Gin",
    "permalink": "https://canuxcheng.com/post/gin/",
    "date": "2018-07-20",
    "summary": "\u003ch1 id=\"gin\"\u003eGin\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gin-gonic/gin\"\u003ehttps://github.com/gin-gonic/gin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003einstall\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get -u github.com/gin-gonic/gin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eimport\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026quot;github.com/gin-gonic/gin\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Gin https://github.com/gin-gonic/gin\ninstall\n$ go get -u github.com/gin-gonic/gin import\nimport \u0026quot;github.com/gin-gonic/gin\u0026quot; ",
    "categories": ["Gin"],
    "tags": ["gin","web","golang"]
  },
  {
    "title": "Restful",
    "permalink": "https://canuxcheng.com/post/rest/",
    "date": "2018-07-07",
    "summary": "\u003ch1 id=\"rest\"\u003eREST\u003c/h1\u003e\n\u003cp\u003eREST: REpresentational State Transfer．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"restclient\"\u003erestclient\u003c/h1\u003e\n\u003cp\u003e一个是firefox的插件．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/chao/RESTClient\"\u003ehttps://github.com/chao/RESTClient\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e另一个是java开发的application.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wiztools/rest-client\"\u003ehttps://github.com/wiztools/rest-client\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"postman\"\u003epostman\u003c/h1\u003e\n\u003cp\u003epostman是一个application,同时也可以从chrome启动.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/postmanlabs\"\u003ehttps://github.com/postmanlabs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"soupui\"\u003esoupui\u003c/h1\u003e\n\u003cp\u003e一个用于SOAP和REST的application.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/SmartBear/soapui\"\u003ehttps://github.com/SmartBear/soapui\u003c/a\u003e\u003c/p\u003e",
    "content": "REST REST: REpresentational State Transfer．\nrestclient 一个是firefox的插件．\nhttps://github.com/chao/RESTClient\n另一个是java开发的application.\nhttps://github.com/wiztools/rest-client\npostman postman是一个application,同时也可以从chrome启动.\nhttps://github.com/postmanlabs\nsoupui 一个用于SOAP和REST的application.\nhttps://github.com/SmartBear/soapui\n",
    "categories": ["Network"],
    "tags": ["restful"]
  },
  {
    "title": "Webhook",
    "permalink": "https://canuxcheng.com/post/webhook/",
    "date": "2018-07-07",
    "summary": "\u003ch1 id=\"webhook\"\u003eWebHook\u003c/h1\u003e\n\u003cp\u003e用于server和server之间通讯．\u003c/p\u003e",
    "content": "WebHook 用于server和server之间通讯．\n",
    "categories": ["Network"],
    "tags": ["webhook"]
  },
  {
    "title": "WebService",
    "permalink": "https://canuxcheng.com/post/webservice/",
    "date": "2018-07-07",
    "summary": "\u003ch1 id=\"webservice\"\u003ewebservice\u003c/h1\u003e\n\u003cp\u003ewebservice用于server和browser之间通讯．\u003c/p\u003e\n\u003cp\u003ewebservice是基于http的，无状态的．\u003c/p\u003e\n\u003cp\u003ewebservice一般分为soap webservice和http webservice.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"soap\"\u003eSOAP\u003c/h1\u003e\n\u003cp\u003eSimple Object Access Protocol, 简单对象访问协议，是一个基于XML的协议．\u003c/p\u003e\n\u003cp\u003e简单来说SOAP的思想就是通过http + XML来在server和browser之间交换信息．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"soupui\"\u003esoupui\u003c/h1\u003e\n\u003cp\u003e一个用于SOAP和REST的application.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/SmartBear/soapui\"\u003ehttps://github.com/SmartBear/soapui\u003c/a\u003e\u003c/p\u003e",
    "content": "webservice webservice用于server和browser之间通讯．\nwebservice是基于http的，无状态的．\nwebservice一般分为soap webservice和http webservice.\nSOAP Simple Object Access Protocol, 简单对象访问协议，是一个基于XML的协议．\n简单来说SOAP的思想就是通过http + XML来在server和browser之间交换信息．\nsoupui 一个用于SOAP和REST的application.\nhttps://github.com/SmartBear/soapui\n",
    "categories": ["Network"],
    "tags": ["webservice"]
  },
  {
    "title": "ELK",
    "permalink": "https://canuxcheng.com/post/logging_elk/",
    "date": "2018-06-08",
    "summary": "\u003ch1 id=\"elk\"\u003eELK\u003c/h1\u003e\n\u003cp\u003ekibana: 数据可视化\u003c/p\u003e\n\u003cp\u003eelasticsearch: 搜索，分析，存储数据\u003c/p\u003e\n\u003cp\u003ex-pack: 具有监控和报警功能的工具包.\u003c/p\u003e\n\u003cp\u003elogstash: 动态数据收集管道，支持可扩展的插件．\u003c/p\u003e\n\u003cp\u003ebeats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．\u003c/p\u003e\n\u003chr\u003e",
    "content": "ELK kibana: 数据可视化\nelasticsearch: 搜索，分析，存储数据\nx-pack: 具有监控和报警功能的工具包.\nlogstash: 动态数据收集管道，支持可扩展的插件．\nbeats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．\n",
    "categories": ["DevOps"],
    "tags": ["logging"]
  },
  {
    "title": "Grok",
    "permalink": "https://canuxcheng.com/post/logging_grok/",
    "date": "2018-06-08",
    "summary": "\u003ch1 id=\"grok\"\u003egrok\u003c/h1\u003e\n\u003cp\u003elogstash和telegraf都是用grok来解析log\u003c/p\u003e\n\u003cp\u003e在线检测\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://grokdebug.herokuapp.com/\"\u003ehttp://grokdebug.herokuapp.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003egrok的正则表达式\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kkos/oniguruma/blob/master/doc/RE\"\u003ehttps://github.com/kkos/oniguruma/blob/master/doc/RE\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e可用的pattern(logstash \u0026amp; telegraf-logparser/tail)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns\"\u003ehttps://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns\"\u003ehttps://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"elastic-stack\"\u003eElastic stack\u003c/h1\u003e\n\u003cp\u003ebeats/filebeats: 通过filebeats agent获取log．\u003c/p\u003e\n\u003cp\u003elogstash: 使用filebeats解析log并写入stash(elasticsearch).\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tick-stack\"\u003eTICK stack\u003c/h1\u003e\n\u003cp\u003etelegraf(agent): 通过logparser/tail插件解析log并写入influxdb.\u003c/p\u003e\n\u003cp\u003epattern:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 通过已经定义的变量来定义filter\npatterns = ['''${\u0026lt;capture_syntax\u0026gt;[:\u0026lt;semantic_name\u0026gt;][:\u0026lt;modifier\u0026gt;]}''']\npatterns = ['''%{TIMESTAMP_ISO8601:asctime:string} \\[%{DATA:name:string}\\] %{LOGLEVEL:levelname:string}: %{GREEDYDATA:message:string}''']\n\ncapture_syntax是已经定义好的pattern.\nsemantic_name是field/tag的名字, 默认都是string类型的field\nmodifier 是string/int/float/tag/drop/ts-\u0026quot;CUSTOM\u0026quot;/...类型\n\ntimestamp有特殊的modifier:\ntimestamp 有特殊的modifier：\nTimestamp modifiers:ts (This will auto-learn the timestamp format)\nts-ansic (\u0026quot;Mon Jan _2 15:04:05 2006\u0026quot;)\nts-unix (\u0026quot;Mon Jan _2 15:04:05 MST 2006\u0026quot;)\nts-ruby (\u0026quot;Mon Jan 02 15:04:05 -0700 2006\u0026quot;)\nts-rfc822 (\u0026quot;02 Jan 06 15:04 MST\u0026quot;)\nts-rfc822z (\u0026quot;02 Jan 06 15:04 -0700\u0026quot;)\nts-rfc850 (\u0026quot;Monday, 02-Jan-06 15:04:05 MST\u0026quot;)\nts-rfc1123 (\u0026quot;Mon, 02 Jan 2006 15:04:05 MST\u0026quot;)\nts-rfc1123z (\u0026quot;Mon, 02 Jan 2006 15:04:05 -0700\u0026quot;)\nts-rfc3339 (\u0026quot;2006-01-02T15:04:05Z07:00\u0026quot;)\nts-rfc3339nano (\u0026quot;2006-01-02T15:04:05.999999999Z07:00\u0026quot;)\nts-httpd (\u0026quot;02/Jan/2006:15:04:05 -0700\u0026quot;)\nts-epoch (seconds since unix epoch, may contain decimal)\nts-epochnano (nanoseconds since unix epoch)\nts-syslog (\u0026quot;Jan 02 15:04:05\u0026quot;, parsed time is set to the current year)\nts-\u0026quot;CUSTOM\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecustom_patterns:\u003c/p\u003e",
    "content": "grok logstash和telegraf都是用grok来解析log\n在线检测\nhttp://grokdebug.herokuapp.com/\ngrok的正则表达式\nhttps://github.com/kkos/oniguruma/blob/master/doc/RE\n可用的pattern(logstash \u0026amp; telegraf-logparser/tail)\nhttps://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns\nhttps://github.com/influxdata/telegraf/blob/master/plugins/inputs/logparser/grok/patterns/influx-patterns\nElastic stack beats/filebeats: 通过filebeats agent获取log．\nlogstash: 使用filebeats解析log并写入stash(elasticsearch).\nTICK stack telegraf(agent): 通过logparser/tail插件解析log并写入influxdb.\npattern:\n# 通过已经定义的变量来定义filter patterns = ['''${\u0026lt;capture_syntax\u0026gt;[:\u0026lt;semantic_name\u0026gt;][:\u0026lt;modifier\u0026gt;]}'''] patterns = ['''%{TIMESTAMP_ISO8601:asctime:string} \\[%{DATA:name:string}\\] %{LOGLEVEL:levelname:string}: %{GREEDYDATA:message:string}'''] capture_syntax是已经定义好的pattern. semantic_name是field/tag的名字, 默认都是string类型的field modifier 是string/int/float/tag/drop/ts-\u0026quot;CUSTOM\u0026quot;/...类型 timestamp有特殊的modifier: timestamp 有特殊的modifier： Timestamp modifiers:ts (This will auto-learn the timestamp format) ts-ansic (\u0026quot;Mon Jan _2 15:04:05 2006\u0026quot;) ts-unix (\u0026quot;Mon Jan _2 15:04:05 MST 2006\u0026quot;) ts-ruby (\u0026quot;Mon Jan 02 15:04:05 -0700 2006\u0026quot;) ts-rfc822 (\u0026quot;02 Jan 06 15:04 MST\u0026quot;) ts-rfc822z (\u0026quot;02 Jan 06 15:04 -0700\u0026quot;) ts-rfc850 (\u0026quot;Monday, 02-Jan-06 15:04:05 MST\u0026quot;) ts-rfc1123 (\u0026quot;Mon, 02 Jan 2006 15:04:05 MST\u0026quot;) ts-rfc1123z (\u0026quot;Mon, 02 Jan 2006 15:04:05 -0700\u0026quot;) ts-rfc3339 (\u0026quot;2006-01-02T15:04:05Z07:00\u0026quot;) ts-rfc3339nano (\u0026quot;2006-01-02T15:04:05.999999999Z07:00\u0026quot;) ts-httpd (\u0026quot;02/Jan/2006:15:04:05 -0700\u0026quot;) ts-epoch (seconds since unix epoch, may contain decimal) ts-epochnano (nanoseconds since unix epoch) ts-syslog (\u0026quot;Jan 02 15:04:05\u0026quot;, parsed time is set to the current year) ts-\u0026quot;CUSTOM\u0026quot; custom_patterns:\n# 通过正则表达式或已经定义的变量来定义新的变量 # 一行一个 custom_patterns = ''' LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL) ''' logparser:\n[[inputs.logparser]] files = [\u0026quot;/opt/sandbox/logs/appliance.log\u0026quot;] from_beginning = false watch_method = \u0026quot;inotify\u0026quot; [inputs.logparser.grok] patterns = [''' %{TIMESTAMP_ISO8601:timestamp:ts-\u0026quot;2006-01-02 15:04:05.000\u0026quot;} \\[%{DATA:name:string}\\] %{LOGLEVEL_PYTHON:levelname:tag}: %{GREEDYDATA:message:string}'''] measurement = \u0026quot;log_test\u0026quot; custom_pattern_files = [] custom_patterns = '''LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL)''' timezone = \u0026quot;Local\u0026quot; tail:\n[[inputs.tail]] files = [\u0026quot;/opt/sandbox/logs/appliance.log\u0026quot;] from_beginning = false pipe = false watch_method = \u0026quot;inotify\u0026quot; data_format = \u0026quot;grok\u0026quot; grok_patterns = ['''%{TIMESTAMP_ISO8601:timestamp:ts-\u0026quot;2006-01-02 15:04:05.000\u0026quot;} \\[%{DATA:name:string}\\] %{LOGLEVEL_PYTHON:levelname:tag}: %{GREEDYDATA:message:string}'''] grok_custom_patterns = ''LOGLEVEL_PYTHON (?:WARNING|ERROR|CRITICAL)''' grok_timezone = \u0026quot;Local\u0026quot; ",
    "categories": ["DevOps"],
    "tags": ["logging"]
  },
  {
    "title": "Logging",
    "permalink": "https://canuxcheng.com/post/logging/",
    "date": "2018-06-08",
    "summary": "\u003ch1 id=\"logging\"\u003eLogging\u003c/h1\u003e\n\u003cp\u003e日志采集，存储，可视化.\u003c/p\u003e\n\u003cp\u003e主要有Elastic stack, splunk, loki.\u003c/p\u003e\n\u003chr\u003e",
    "content": "Logging 日志采集，存储，可视化.\n主要有Elastic stack, splunk, loki.\n",
    "categories": ["DevOps"],
    "tags": ["logging"]
  },
  {
    "title": "Loki",
    "permalink": "https://canuxcheng.com/post/logging_loki/",
    "date": "2018-06-08",
    "summary": "\u003ch1 id=\"elk\"\u003eELK\u003c/h1\u003e\n\u003cp\u003ekibana: 数据可视化\u003c/p\u003e\n\u003cp\u003eelasticsearch: 搜索，分析，存储数据\u003c/p\u003e\n\u003cp\u003ex-pack: 具有监控和报警功能的工具包.\u003c/p\u003e\n\u003cp\u003elogstash: 动态数据收集管道，支持可扩展的插件．\u003c/p\u003e\n\u003cp\u003ebeats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．\u003c/p\u003e\n\u003chr\u003e",
    "content": "ELK kibana: 数据可视化\nelasticsearch: 搜索，分析，存储数据\nx-pack: 具有监控和报警功能的工具包.\nlogstash: 动态数据收集管道，支持可扩展的插件．\nbeats(agent): 轻量型数据采集平台，从边缘机器向logstash/elasticsearch发送数据．\n",
    "categories": ["DevOps"],
    "tags": ["logging"]
  },
  {
    "title": "Dns",
    "permalink": "https://canuxcheng.com/post/dns/",
    "date": "2018-05-03",
    "summary": "\u003ch1 id=\"dns\"\u003eDNS\u003c/h1\u003e\n\u003cp\u003eDomain Name System: 域名系统\u003c/p\u003e",
    "content": "DNS Domain Name System: 域名系统\n",
    "categories": ["Network"],
    "tags": ["dns"]
  },
  {
    "title": "Container",
    "permalink": "https://canuxcheng.com/post/cncf_container/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"container\"\u003eContainer\u003c/h1\u003e\n\u003cp\u003eOCI: Open Container Initiative.\u003c/p\u003e\n\u003cp\u003eCRI: Container Runtime Interface.\u003c/p\u003e\n\u003cp\u003eCNI: Container Network Interface.\u003c/p\u003e\n\u003cp\u003eCSI: Container Storage Interface.\u003c/p\u003e\n\u003ch1 id=\"oci\"\u003eOCI\u003c/h1\u003e\n\u003cp\u003eOpen Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作.\u003c/p\u003e\n\u003cp\u003e是container的标准.\u003c/p\u003e\n\u003cp\u003e目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.opencontainers.org/\"\u003ehttps://www.opencontainers.org/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"runc\"\u003erunc\u003c/h2\u003e\n\u003cp\u003edocker(libcontainer)\u003c/p\u003e\n\u003cp\u003erunc支持OCI.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/opencontainers/runc\"\u003ehttps://github.com/opencontainers/runc\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"rkt\"\u003erkt\u003c/h2\u003e\n\u003cp\u003eredhat(coreos)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rkt/rkt\"\u003ehttps://github.com/rkt/rkt\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tools\"\u003etools\u003c/h1\u003e\n\u003ch2 id=\"dumb-init\"\u003edumb-init\u003c/h2\u003e\n\u003cp\u003e管理pid=1的进程的子进程:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Yelp/dumb-init\"\u003ehttps://github.com/Yelp/dumb-init\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"baseimage-docker\"\u003ebaseimage-docker\u003c/h2\u003e\n\u003cp\u003e处理container中运行多个进程的问题:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/phusion/baseimage-docker\"\u003ehttps://github.com/phusion/baseimage-docker\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"watchtower\"\u003ewatchtower\u003c/h2\u003e\n\u003cp\u003e根据registry中的更新自动更新 container:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/containrrr/watchtower/\"\u003ehttps://github.com/containrrr/watchtower/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"hadolint\"\u003ehadolint\u003c/h2\u003e\n\u003cp\u003edockerfile 语法检查:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/hadolint/hadolint\"\u003ehttps://github.com/hadolint/hadolint\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"gosu\"\u003egosu\u003c/h2\u003e\n\u003cp\u003e权限管理\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/tianon/gosu\"\u003ehttps://github.com/tianon/gosu\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"swarm-cronjob\"\u003eswarm-cronjob\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/crazy-max/swarm-cronjob\"\u003ehttps://github.com/crazy-max/swarm-cronjob\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"misc\"\u003emisc\u003c/h1\u003e\n\u003cp\u003eget host ip(docker/docker_gwbridge) from container:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eip route | awk '/default/ { print $3 }'\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Container OCI: Open Container Initiative.\nCRI: Container Runtime Interface.\nCNI: Container Network Interface.\nCSI: Container Storage Interface.\nOCI Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作.\n是container的标准.\n目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）\nhttps://www.opencontainers.org/\nrunc docker(libcontainer)\nrunc支持OCI.\nhttps://github.com/opencontainers/runc\nrkt redhat(coreos)\nhttps://github.com/rkt/rkt\ntools dumb-init 管理pid=1的进程的子进程:\nhttps://github.com/Yelp/dumb-init\nbaseimage-docker 处理container中运行多个进程的问题:\nhttps://github.com/phusion/baseimage-docker\nwatchtower 根据registry中的更新自动更新 container:\nhttps://github.com/containrrr/watchtower/\nhadolint dockerfile 语法检查:\nhttps://github.com/hadolint/hadolint\ngosu 权限管理\nhttps://github.com/tianon/gosu\nswarm-cronjob https://github.com/crazy-max/swarm-cronjob\nmisc get host ip(docker/docker_gwbridge) from container:\nip route | awk '/default/ { print $3 }' ",
    "categories": ["CNCF"],
    "tags": ["container"]
  },
  {
    "title": "Docker",
    "permalink": "https://canuxcheng.com/post/cncf_docker/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"docker\"\u003eDocker\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://store.docker.com/\"\u003ehttps://store.docker.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://hub.docker.com/\"\u003ehttps://hub.docker.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/docker\"\u003ehttps://github.com/docker\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/moby/moby\"\u003ehttps://github.com/moby/moby\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eDocker是一个容器引擎, 分为社区版CE, 和企业版EE, Docker不是虚拟机, 也不依赖虚拟化技术．\u003c/p\u003e\n\u003cp\u003edocker-cli -\u0026gt; dockerd -\u0026gt; containerd -\u0026gt; shim -\u0026gt; runc\u003c/p\u003e\n\u003cp\u003econtainerd是容器运行时管理引擎.\u003c/p\u003e\n\u003cp\u003eshim用于管理容器生命周期.\u003c/p\u003e\n\u003cp\u003eDocker包括三个基本概念:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e仓库repository,集中存放镜像文件的场所,docker hub/store是最大的公开仓库．\u003c/li\u003e\n\u003cli\u003e镜像image, 镜像是一个文件系统.\u003c/li\u003e\n\u003cli\u003e容器container, 容器是镜像的运行的实例．\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e修改docker存储路径:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ service docker stop\n$ mv /var/lib/docker /opt/ssd/docker\n$ ln -s /opt/ssd/docker /var/lib/docker\n$ service docker start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewindows:\n\u0026lt;https://docs.docker.com/docker-for-windows/install/\u0026gt;\n\nlinux:\n\u0026lt;https://docs.docker.com/engine/install/ubuntu/\u0026gt;\n\nmac:\n\u0026lt;https://github.com/abiosoft/colima/blob/main/docs/FAQ.md#docker\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"config\"\u003econfig\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file\"\u003ehttps://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003edocker配置文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/etc/docker/daemon.json\n/lib/systemd/system/docker.service\n\n{\n    // debug\n    \u0026quot;debug\u0026quot;: true,\n    \n    \u0026quot;data-root\u0026quot;： \u0026quot;/var/lib/docker\u0026quot;,\n    \n    \u0026quot;features\u0026quot;: {\n        \u0026quot;buildkit\u0026quot;: true\n    },\n\n    //容器访问外网:\n    ip-forward=true 会设置 net.ipv4.ip_forward=1, 才能访问外网\n    // 容器之间访问:\n    icc=true, \n    iptables=true  会修改iptables的forward策略为accept,\n\n    // 修改默认docker0\n    \u0026quot;bridge\u0026quot;:\n    \u0026quot;bip\u0026quot;: \u0026quot;10.0.0.1/16\u0026quot;  // subnet + gateway\n    \u0026quot;fixed-cidr\u0026quot;: \u0026quot;10.41.0.0/24\u0026quot; // iprange\n    \u0026quot;fixed-cidr-v6\u0026quot;: \u0026quot;\u0026quot;,\n    \u0026quot;mtu\u0026quot;: 1500\n    \u0026quot;default-gateway\u0026quot;:\n\t\u0026quot;default-gateway-v6\u0026quot;: \u0026quot;\u0026quot;,\n\n    // 修改默认dns\n    \u0026quot;dns\u0026quot; : [\n        \u0026quot;114.114.114.114\u0026quot;,\n        \u0026quot;8.8.8.8\u0026quot;\n    ]\n    \u0026quot;dns-opts\u0026quot;: [],\n    \u0026quot;dns-search\u0026quot;: [],\n\n    // ipv6\n    \u0026quot;ipv6\u0026quot;: true\n\n    // private registry\n  \t\u0026quot;insecure-registries\u0026quot;: [],\n\n    // 修改registry\n    \u0026quot;registry-mirrors\u0026quot;: [\n        \u0026quot;https://registry.docker-cn.com\u0026quot;,\n        \u0026quot;https://z4yd270h.mirror.aliyuncs.com\u0026quot;,\n        \u0026quot;http://f1361db2.m.daocloud.io\u0026quot;,\n        \u0026quot;https://docker.mirrors.ustc.edu.cn\u0026quot;\n    ]\n\n    \u0026quot;hosts\u0026quot;: [],\n    \u0026quot;log-level\u0026quot;: \u0026quot;\u0026quot;,\n    \u0026quot;tls\u0026quot;: true,\n    \u0026quot;tlsverify\u0026quot;: true,\n    \u0026quot;tlscacert\u0026quot;: \u0026quot;\u0026quot;,\n    \u0026quot;tlscert\u0026quot;: \u0026quot;\u0026quot;,\n    \u0026quot;tlskey\u0026quot;: \u0026quot;\u0026quot;,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eproxy for pull image from google(gcr):\u003c/p\u003e",
    "content": "Docker https://store.docker.com/\nhttps://hub.docker.com/\nhttps://github.com/docker\nhttps://github.com/moby/moby\nDocker是一个容器引擎, 分为社区版CE, 和企业版EE, Docker不是虚拟机, 也不依赖虚拟化技术．\ndocker-cli -\u0026gt; dockerd -\u0026gt; containerd -\u0026gt; shim -\u0026gt; runc\ncontainerd是容器运行时管理引擎.\nshim用于管理容器生命周期.\nDocker包括三个基本概念:\n仓库repository,集中存放镜像文件的场所,docker hub/store是最大的公开仓库． 镜像image, 镜像是一个文件系统. 容器container, 容器是镜像的运行的实例． 修改docker存储路径:\n$ service docker stop $ mv /var/lib/docker /opt/ssd/docker $ ln -s /opt/ssd/docker /var/lib/docker $ service docker start Install:\nwindows: \u0026lt;https://docs.docker.com/docker-for-windows/install/\u0026gt; linux: \u0026lt;https://docs.docker.com/engine/install/ubuntu/\u0026gt; mac: \u0026lt;https://github.com/abiosoft/colima/blob/main/docs/FAQ.md#docker\u0026gt; config https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file\ndocker配置文件:\n/etc/docker/daemon.json /lib/systemd/system/docker.service { // debug \u0026quot;debug\u0026quot;: true, \u0026quot;data-root\u0026quot;： \u0026quot;/var/lib/docker\u0026quot;, \u0026quot;features\u0026quot;: { \u0026quot;buildkit\u0026quot;: true }, //容器访问外网: ip-forward=true 会设置 net.ipv4.ip_forward=1, 才能访问外网 // 容器之间访问: icc=true, iptables=true 会修改iptables的forward策略为accept, // 修改默认docker0 \u0026quot;bridge\u0026quot;: \u0026quot;bip\u0026quot;: \u0026quot;10.0.0.1/16\u0026quot; // subnet + gateway \u0026quot;fixed-cidr\u0026quot;: \u0026quot;10.41.0.0/24\u0026quot; // iprange \u0026quot;fixed-cidr-v6\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;mtu\u0026quot;: 1500 \u0026quot;default-gateway\u0026quot;: \u0026quot;default-gateway-v6\u0026quot;: \u0026quot;\u0026quot;, // 修改默认dns \u0026quot;dns\u0026quot; : [ \u0026quot;114.114.114.114\u0026quot;, \u0026quot;8.8.8.8\u0026quot; ] \u0026quot;dns-opts\u0026quot;: [], \u0026quot;dns-search\u0026quot;: [], // ipv6 \u0026quot;ipv6\u0026quot;: true // private registry \u0026quot;insecure-registries\u0026quot;: [], // 修改registry \u0026quot;registry-mirrors\u0026quot;: [ \u0026quot;https://registry.docker-cn.com\u0026quot;, \u0026quot;https://z4yd270h.mirror.aliyuncs.com\u0026quot;, \u0026quot;http://f1361db2.m.daocloud.io\u0026quot;, \u0026quot;https://docker.mirrors.ustc.edu.cn\u0026quot; ] \u0026quot;hosts\u0026quot;: [], \u0026quot;log-level\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;tls\u0026quot;: true, \u0026quot;tlsverify\u0026quot;: true, \u0026quot;tlscacert\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;tlscert\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;tlskey\u0026quot;: \u0026quot;\u0026quot;, } proxy for pull image from google(gcr):\nhttps://docs.docker.com/config/daemon/systemd/#httphttps-proxy\ndocker命令 system:\n$ docker system df\t// Show docker disk usage $ docker system events\t// Get real time events from the server $ docker system info\t// Display system-wide information $ docker system prune\t// Remove unused data image管理:\n$ docker image COMMAND \u0026gt; 查看本地镜像: $ docker image ls $ docker image -a \u0026gt; 根据创建dockerfile，创建新的images $ docker image build \u0026gt; 创建tag $ docker image tag \u0026gt; 删除image $ docker image rm \u0026lt;IMAGE ID\u0026gt; $ docker rmi \u0026lt;IMAGE ID\u0026gt; \u0026gt; 删除所有image $ docker rmi $(docker images -a -q) \u0026gt; 清理所有临时images $ docker image prune container管理\n$docker container COMMAND # 列出container: $ docker container ls $ docker ps -a # 默认只显示running状态的 # 运行image,产生一个container: $ docker container run \u0026lt;IMAGE ID\u0026gt;/\u0026lt;REPOSITORY\u0026gt; [COMMAND] [ARGS] # 在container中执行命令 $ docker container exec [OPTIONS] \u0026lt;CONTAINER\u0026gt; COMMAND [ARG...] # 创建container但不启动 $ docker container create --name \u0026lt;name\u0026gt; \u0026lt;CONTAINER\u0026gt; # 启动container: $ docker container start/restart \u0026lt;CONTAINER\u0026gt; # 停止container: $ docker container stop \u0026lt;CONTAINER\u0026gt; # 删除container： $ docker container rm \u0026lt;CONTAINER\u0026gt; $ docker rm \u0026lt;CONTAINER\u0026gt; # 删除所有容器 $ docker rm $(docker ps -a -q) # 清理停止的container $ docker container prune 制作镜像builder\nbuild: deprecated.\n# 根据Dockerfile 构建image docker builder [OPTIONS] PATH | URL | - docker builder build . // 默认就是当前目录的Dockerfile docker builder build -t \u0026lt;repo\u0026gt;/\u0026lt;name\u0026gt;:\u0026lt;tag\u0026gt; . // 创建tag docker builder build -f /path/to/mydockerfile . // 也可以指定其它路径的其它文件 docker builder build --target \u0026lt;stage\u0026gt; . // 指定阶段构建. docker builder build ... --network=host // 使用host网络构建. docker builder build --no-cache // 不使用缓存数据 --cache-from // 使用本地或registry上的cache --cache-to // cache存到本地或registry --progress = auto/plain/tty, // plain 显示更多log。 docker builder prune --all // 清理所有image 的缓存。 # 把image导出到tar包 # 既可以从image也可以从container导出。 # 从container导出不包含运行后的修改，只导出原始镜像。 $ docker save -o name.tgz \u0026lt;repo1\u0026gt;:\u0026lt;tag1\u0026gt; \u0026lt;repo2\u0026gt;:\u0026lt;tag2\u0026gt; ... # 从stdin或文件加载image docker load [OPTIONS] docker load \u0026lt; name.tar.gz docker load --input/-i name.tar # 把container导出到tar包，从container导出镜像。 # 包括container启动后的修改。 docker export -o name.tar [container] # 从container导出的包加载成镜像 docker import name.tar [repo]:[tag] # 根据container的修改创建新的image docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] docker commit -a \u0026quot;author\u0026quot; -c \u0026quot;Dockerfile instruction\u0026quot; -m \u0026quot;commit message\u0026quot; CONTAINER [REPOSITORY[:TAG]] # 创建新的tag docker tag \u0026lt;old\u0026gt; \u0026lt;new\u0026gt; 运行容器\n# 创建一个新的container并运行命令 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] docker run --name [NAME] IMAGE // 运行容器并命名 docker run -d IMAGE // 后台运行 docker run -it IMAGE /bin/bash // 交互模式启动容器 docker run -P IMAGE // 默认将容器的8０端口映射到主机的随机端口 docker run -p [host:port]:[containerPort] // 指定映射端口 --add-host # 相当于修改容器的/etc/hosts,但是容器重启后不会消失 -h/--hostname # 修改容器的/etc/hostname // cpu --cpus decimal Number of CPUs -c, --cpu-shares int CPU shares (relative weight) --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) --cpu-period --cpu-quota // memory -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: '-1' to enable unlimited swap --memory-swappiness int Tune container memory swappiness (0 to 100) (default -1) --oom-kill-disable --oom-score-adj --kernel-memory // io --blkio-weight --blkio-weight-device --device-read-bps --device-write-bps --device-read-iops --device-write-iops // security // https://docs.docker.com/engine/security/apparmor/ // https://docs.docker.com/engine/security/seccomp/ // https://docs.docker.com/engine/security/userns-remap/ // https://docs.docker.com/engine/security/rootless/ privileged sysctl ulimit user userns security_ops cgroup_parent cap_add cap_drop # 在运行的container中执行命令 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] docker exec -d CONTAINER ... // 在后台运行 docker exec -it CONTAINER /bin/bash ... // 进入命令行 # metrics docker stats # resource docker top log:\n// 查看log driver // 默认driver是 json-file, 不同的driver，option不同 // driver是json-file, journald, 通过docker logs docker-compose logs 才能看到log $ docker inspect -f '{{.HostConfig.LogConfig.Type}}' \u0026lt;ID\u0026gt; docker run -it --log-driver \u0026lt;driver\u0026gt; --log-opt mode=blocking --log-opt max-buffer-size=4m alpine ash // --log-driver json-file // --log-opt mode blocking/non-blocking // --log-opt max-buffer-size 其它命令\n# 在container和host之前拷贝文件和目录 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH # 查看容器的日志 docker logs [OPTIONS] CONTAINER docker diff CONTAINER docker history [OPTIONS] IMAGE # 查看healthcheck的log docker inspect --format \u0026quot;{{json .State.Health }}\u0026quot; \u0026lt;container name\u0026gt; | jq docker system prune register使用\n# 登陆到docker hub 或其他register docker login docker login -u/--username \u0026lt;user\u0026gt; -p/--password \u0026lt;password\u0026gt; # 从docker hub/store查找images $ docker search [OPTIONS] TERM $ docker search # 从registry获取repository/images到/var/lib/docker： $ docker pull [OPTIONS] NAME[:TAG|@DIGEST] $ docker pull $ docker pull ubuntu # 默认下载所有tag $ docker pull ubuntu:14.04 # 从中国站点下载 $ docker pull registry.docker-cn.com/library/ubuntu:16.04 # 推送到docker hub $ docker push secret\nsecret以文件形式存在于/run/secrets/\n// 保存敏感数据 $ docker secret docker secret ls docker secret inspect \u0026lt;ID/name\u0026gt; docker secret rm \u0026lt;id/name\u0026gt; // 根据文件创建 docker secret create \u0026lt;s-name\u0026gt; \u0026lt;s-file\u0026gt; config\nconfig以文件形式存在于/\n// 保存非敏感数据 $ docker config docker config ls docker config inspect \u0026lt;id/name\u0026gt; docker config rm \u0026lt;id/name\u0026gt; docker config create \u0026lt;c-name\u0026gt; \u0026lt;c-file\u0026gt; plugin\n// 安装plugin docker plugin install --grant-all-permissions name:tag key=value key=value // 修改plugin的参数 docker plugin set name:tag key=value // 查看plugin的参数，settable里面的是改参数能修改的变量 docker plugin inspect name:tag // 激活plugin docker plugin enable name:tag // 删除 docker plugin rm name:tag 开发插件:\ndocker plugin create name:tag ./plugin docker plugin push name:tag Dockerfile 每个命令都会创建一个layer,尽可能合并相同的命令。\nADD\n# add可以是远程文件，不推荐使用 ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026quot;\u0026lt;src\u0026gt;\u0026quot;,... \u0026quot;\u0026lt;dest\u0026gt;\u0026quot;] COPY\n# 只能操作本地文件, 目标路径不需要创建，不存在会自动创建. COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026quot;\u0026lt;src\u0026gt;\u0026quot;,... \u0026quot;\u0026lt;dest\u0026gt;\u0026quot;] COPY file /path/to/file 相当于 COPY file /path # 不会创建目录 COPY folder /path 相当于 COPY folder/* /path/ # 需要手动指定 COPY folder /path/to/folder ENV\nenv会被派生image继承。 # 指定容器中的环境变量 ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... EXPOSE\nexpose会被派生image继承. # 指定容器需要映射到主机的端口 EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;/\u0026lt;protocol\u0026gt;...] FROM\nFROM \u0026lt;image\u0026gt; [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[@\u0026lt;digest\u0026gt;] [AS \u0026lt;name\u0026gt;] LABEL\nlabel会被派生image继承. LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... STOPSIGNAL\nSTOPSIGNAL signal USER\nUSER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] USER \u0026lt;UID\u0026gt;[:\u0026lt;GID\u0026gt;] VOLUME\n# 指定挂载点做数据持久化 VOLUME [\u0026quot;/data\u0026quot;] WORKDIR\nworkdir会被派生image继承. # 指定后的操作都以该目录为当前目录，目录不存在会自动创建 WORKDIR /path/to/workdir RUN\n# 在容器构建过程中运行 RUN \u0026lt;command\u0026gt; # shell 格式 RUN [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] # exec 格式 RUN set -ex \\ \u0026amp;\u0026amp; cmd1 \\ \u0026amp;\u0026amp; cmd2...... ENTRYPOINT\nentrypoint会被派生image继承，除非你在派生image重新指定. # 和cmd类似,指定容器运行过程中的执行命令 ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] (exec form, preferred) ENTRYPOINT command param1 param2 CMD\ncmd会被派生image继承，除非你在派生image重新指定了entrypoint. # 在容器运行过程中运行, 可以被覆盖 CMD [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;] # exec格式 CMD command param1 param2 # shell 格式,通过/bin/bash 或 /bin/sh 执行. // 同时有cmd和entrypoint,cmd只是entrypoint的参数. CMD [\u0026quot;param2\u0026quot;, \u0026quot;param2\u0026quot;] # entrypoint的参数 ARG\n# 指定构建环境的变量 ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] ONBUILD\nonbuild会被派生image继承. ONBUILD ... stage:\n多级构建，一般0级用来编译源代码，并且组织目录结构。 下一级直接将编译好的或者组织好的目录结构copy到指定位置。 这样最终的image不会含有源代码的overlay. 也不会有临时目录结构的overlay.\n# 不指定stage name, 默认就是数字 COPY --from=0 /path/folder /path/folder COPY --from=stage1 /path/folder /path/folder docker build --target stage1 -t docker:latest . .dockerignore # comment /path/folder path/folder */tmp* */*/tmp* tmp? *.md !README.md docker-machine https://github.com/docker/machine\n在本地安装docker和docker-machine，然后就可以从本机安装或管理远程机器上的docker.\n需要添加ssh的无密码登陆:\nssh-copy-id -i ~/.ssh/id_rsa.pub user@remote-ip 安装:\nhttps://docs.docker.com/machine/install-machine/$ base=https://github.com/docker/machine/releases/download/v0.16.0 \u0026amp;\u0026amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) \u0026gt;/tmp/docker-machine \u0026amp;\u0026amp; sudo install /tmp/docker-machine /usr/local/bin/docker-machine docker-machine命令 docker-machine create -d generic \\ --generic-ip-address=remote-ip \\ --generic-ssh-user=user \\ --generic-ssh-key ~/.ssh/id_rsa \\ node1 docker-machine ls OOM kernel OOM 会导致kernel随机kill一些container释放内存。\n防止kernel OOM的方法就是设置resource limit.\nhttps://docs.docker.com/config/containers/resource_constraints/\nhttps://github.com/docker/compose/issues/4513\nswarm mode:\nswarm模式使用compose format 3来限制资源.\nhttps://docs.docker.com/compose/compose-file/#resources\nnon swarm mode:\n非swarm模式可以用compose format 2 来做资源限制.\nhttps://docs.docker.com/compose/compose-file/compose-file-v2/#cpu-and-other-resources\ncolima https://github.com/abiosoft/colima\ndocker for mac\nbrew install colima colima start brew services restart colima sudo ln -sf /Users/canche01/.colima/default/docker.sock /var/run/docker.sock docker ps -a ",
    "categories": ["CNCF"],
    "tags": ["docker"]
  },
  {
    "title": "Kubernetes",
    "permalink": "https://canuxcheng.com/post/kubernetes/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"kubernetes\"\u003eKubernetes\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kubernetes\"\u003ehttps://github.com/kubernetes/kubernetes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kubeadm\"\u003ehttps://github.com/kubernetes/kubeadm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kops\"\u003ehttps://github.com/kubernetes/kops\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/kubespray\"\u003ehttps://github.com/kubernetes-sigs/kubespray\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ekubernetes简称k8s, 是开源的容器编排工具。\u003c/p\u003e\n\u003cp\u003e安装单机版k8s:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eminikube\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e安装k8s集群:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ekubeadm (k8s内置的，类似于docker swarm mode, 没有HA)\u003c/li\u003e\n\u003cli\u003ekops (目前主要支持aws等云平台, 国内不友好)\u003c/li\u003e\n\u003cli\u003ekubespray (通过ansible部署, 国内不友好)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ek8s发行版：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eopenshift-okd(redhat)\u003c/li\u003e\n\u003cli\u003erancher\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"k8s集群组成\"\u003ek8s集群组成\u003c/h1\u003e\n\u003ch2 id=\"master\"\u003emaster\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eaip-server, 提供资源操作唯一入口\u003c/li\u003e\n\u003cli\u003escheduler, 负责资源调度\u003c/li\u003e\n\u003cli\u003econtroller-manager, 负责维护集群状态\u003c/li\u003e\n\u003cli\u003eetcd(可以部署单独集群), 保存整个集群的状态\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"node\"\u003enode\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ekubelet, 负责维护容器生命周期, 还包括CNI CVI\u003c/li\u003e\n\u003cli\u003ekube-proxy, 为service提供cluster内部的服务发现和负载均衡\u003c/li\u003e\n\u003cli\u003eCRI(containerd), 创建pod\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"addons\"\u003eaddons\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecoredns\u003c/li\u003e\n\u003cli\u003eflannel/cilium/calico\u003c/li\u003e\n\u003cli\u003edashboard, web-gui\u003c/li\u003e\n\u003cli\u003emetrics-server, 取代heapster，用于cpu/memory监控\u003c/li\u003e\n\u003cli\u003eingress-nginx, 为服务提供外网入口\u003c/li\u003e\n\u003cli\u003efederation, 提供跨可用区的集群\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"概念\"\u003e概念\u003c/h1\u003e\n\u003cp\u003ek8s包含的重要概念:\u003c/p\u003e\n\u003cp\u003e-: nodes, 运行pod的物理机或虚拟机.\n-: namespace, 对资源和对象的抽象集合．pods/deployments/services都属于某个ns.\n-: pods,一组紧密关联的容器集合，共享pid,ipc,network,uts,namespace.\u003c/p\u003e\n\u003cp\u003ek8s业务类型:\u003c/p\u003e\n\u003cp\u003e-: long-running 长期伺服型 -\u0026gt; RC, RS, Deployment\n-: batch 批处理型-\u0026gt; Job\n-: node-daemon 节点后台支撑型-\u0026gt; DaemonSet\n-: stateful application 有状态应用型-\u0026gt; StatefulSet\u003c/p\u003e",
    "content": "Kubernetes https://github.com/kubernetes/kubernetes\nhttps://github.com/kubernetes/kubeadm\nhttps://github.com/kubernetes/kops\nhttps://github.com/kubernetes-sigs/kubespray\nkubernetes简称k8s, 是开源的容器编排工具。\n安装单机版k8s:\nminikube 安装k8s集群:\nkubeadm (k8s内置的，类似于docker swarm mode, 没有HA) kops (目前主要支持aws等云平台, 国内不友好) kubespray (通过ansible部署, 国内不友好) k8s发行版：\nopenshift-okd(redhat) rancher k8s集群组成 master aip-server, 提供资源操作唯一入口 scheduler, 负责资源调度 controller-manager, 负责维护集群状态 etcd(可以部署单独集群), 保存整个集群的状态 node kubelet, 负责维护容器生命周期, 还包括CNI CVI kube-proxy, 为service提供cluster内部的服务发现和负载均衡 CRI(containerd), 创建pod addons coredns flannel/cilium/calico dashboard, web-gui metrics-server, 取代heapster，用于cpu/memory监控 ingress-nginx, 为服务提供外网入口 federation, 提供跨可用区的集群 概念 k8s包含的重要概念:\n-: nodes, 运行pod的物理机或虚拟机. -: namespace, 对资源和对象的抽象集合．pods/deployments/services都属于某个ns. -: pods,一组紧密关联的容器集合，共享pid,ipc,network,uts,namespace.\nk8s业务类型:\n-: long-running 长期伺服型 -\u0026gt; RC, RS, Deployment -: batch 批处理型-\u0026gt; Job -: node-daemon 节点后台支撑型-\u0026gt; DaemonSet -: stateful application 有状态应用型-\u0026gt; StatefulSet\napi对象三大类属性:\nmetadata 元数据(至少包含namespace, name, uid). spec 规范 status 状态 kubernetes对外暴露服务的三种方式:\nNodePort: dev/qa. (30000-32767) Ingress: production. LoadBalance: cloud provider. clusterIP 是k8s内部默认服务，外部无法访问，可以通过proxy来访问。\npod 一个pod包含一个或多个容器，这些容器通过infra container共享同一个network namespace。\ninfra container: k8s.gcr.io/pause, 汇编写的，永远处于暂停状态。\npod共享网络:\n同一个pod里面看到的网络跟infra容器看到的是一样的，一个pod只有一个ip,也就是这个Pod的network namespace对应的IP; 整个pod的生命周期跟infra容易是一样的。\npod共享存储:\n通过pod volumes, 使pod中的container共享存储。\n应用:\n一个pod中的某个容器异常退出，被kubelet拉起来之前保证之前的数据部丢失. 同一个pod的多个容器共享数据. pod volume类型:\n本地存储: emptydir/hostpath\u0026hellip;\n网络存储:\nin-tree(ks8内置支持): awsElasticBlockStore/gcePresistentDisk/nfs\u0026hellip;\nout-of-tree(插件): flexvolume/csi\u0026hellip;\nprojected volume: secret/configmap/downwardAPI/serviceAccountToken\npod服务质量配置:\n依据容器对cpu,memory资源的request/limit需求，pod服务质量分类:\nGuaranteed Burstable BestEffort initContainer:\ninitContainer用于普通Container启动前的初始化（如配置文件准备) 和 前置条件校验 (如网络)。\ninitContainer会先于普通container启动执行，直到所有initcontainer执行成功后，普通container 才会执行。 pod中多个initcontainer之间是按次序依次启动执行，而pod中多个普通container是并行启动。 initcontainer 执行成功后就结束退出，而普通container会一直执行或重启。 resources 查看所有对象:\n$ kubectl api-resources https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#statefulsetcondition-v1beta2-apps\nWorkloads replicasets/rs 控制无状态的pod数量,增删Pods.\ndeployments/deploy 定义pod的数目和版本，通过Controller自动恢复失败的pod，滚动升级，重新生成，回滚等。\nDeploymentStatus: complete, processing, failed\nDeployment只负责管理不同版本的ReplicaSet, 由ReplicaSet管理Pod副本个数; 每个版本的ReplicaSet对应了Deployment template的一个版本; 一个ReplicaSet下的Pod都是相同的版本.\ndaemonsets/ds ds作用:\n保证集群内每个节点运行一组相同的pod 跟踪集群节点状态，保证新加入的节点自动创建对应的pod 跟踪集群节点状态，保证移除的节点删除对应的pod 跟踪pod状态，保证每个节点pod处于运行状态 jobs job的作用:\n创建一个或多个pod确保指定数量的Pod可以成功运行和终止. 跟踪pod状态，根据配置及时重试失败的pod. 确定依赖关系，保证上一个任务运行完毕后再运行下一个任务. 控制任务并行度，并根据配置确保pod队列大小。 cronJobs/cj statefulsets/sts 控制有状态的pod数量.\nservice discovery \u0026amp; load balancing services/svc 提供访问一个或多个pod的稳定的访问地址.支持ClusterIP, NodePort, LoadBalancer等访问方式.\ningresses endpointslices Config \u0026amp; Storage secrets secret用于在集群中存储密码，token等敏感信息用的资源对象.\n其中敏感数据采用base-64编码保存.\n四种类型:\nOpaque kubernetes.io/service-account-token kubernetes.io/dockerconfigjson bootstrap.kubernetes.io/token secret主要被pod使用，一般通过volume挂载到指定容器目录，供容器中业务使用.\n访问私有镜像仓库也可以通过secret实现.\nsecret大小限制1M; secret不适合机密信息，推荐用vault.\nconfigmaps/cm 主要管理容器运行所需的配置文件，环境变量，命令行参数等可变配置。\n可用于解耦容器镜像和可变配置，从而保障工作负载的可移植性.\n主要被pod使用，一般用于挂载pod用的配置文件，环境变量，命令行参数.\nConigMap 大小不超过1M; pod只能引用相同namespace中的configmap, pod引用的configmap不存在时，pod无法创建;使用envFrom从ConfigMap配置环境变量时，如果ConfigMap中的某些key被认为无效，该环境变量不会注入容器，但是pod可以创建; 只有通过k8s api创建的pod才能使用ConfigMap, 其它方式创建的pod不能使用ConfigMap.\npersistentvolume/pv static volume provisioning:\ndynamic volume provisioning:\npersistentvolumeclaims/pvc pvc中只需要申明需要的存储size, access mode等业务需求.\npvc简化了用户对存储的需求，pv才是存储的实际信息载体，通过kube-controller-manager中的PersistentVolumeController将PVC与合适的PV 绑定.\ncsidrivers csinodes storageclasses/sc volumeattachments metadata events horizontalpodautoscaler podtemplate cluster componentstatuses/cs namespaces/ns 一个集群内部的逻辑隔离机制，每个资源都属于一个namespace，同一个namespace中的资源命名唯一，不同namespace中的资源可重名.\nnodes/no serviceaccount/sa 解决pod在集群中的身份认证问题.\nTools sonobuoy\nhttps://github.com/vmware-tanzu/sonobuoy\nkuard\nhttps://github.com/kubernetes-up-and-running/kuard\n",
    "categories": ["CNCF"],
    "tags": ["k8s"]
  },
  {
    "title": "Namespace",
    "permalink": "https://canuxcheng.com/post/cncf_ns/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"ns\"\u003eNS\u003c/h1\u003e\n\u003cp\u003enamespace 是 Linux 内核用来隔离内核资源的方式\u003c/p\u003e\n\u003cp\u003eLinux namespace资源：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMount: 挂载点\u003c/li\u003e\n\u003cli\u003eNetwork: 网络设备/协议栈/端口\u003c/li\u003e\n\u003cli\u003eIPC: 进程间通信\u003c/li\u003e\n\u003cli\u003eUSR: 用户和用户组\u003c/li\u003e\n\u003cli\u003ePID: 进程\u003c/li\u003e\n\u003cli\u003eUTS: 主机名和域名\u003c/li\u003e\n\u003cli\u003eCgroup: 控制组\u003c/li\u003e\n\u003cli\u003eTime\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"cgroup\"\u003eCgroup\u003c/h1\u003e\n\u003cp\u003eCgroup: Control Groups.是linux下用于对一个或一组进程资源控制和监控的机制.可以管理cpu, memory,diskIO 等资源.不同资源的具体管理工作由相应的cgrouup子系统来实现.\u003c/p\u003e\n\u003cp\u003ecgroup在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理, 每个cgroup可以包含其它子cgroup.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003els -l /sys/fs/cgroup\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecgroup子系统:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecpu\u003c/li\u003e\n\u003cli\u003ecpuacct\u003c/li\u003e\n\u003cli\u003ecpuset\u003c/li\u003e\n\u003cli\u003ememory\u003c/li\u003e\n\u003cli\u003eblkio\u003c/li\u003e\n\u003cli\u003edevices\u003c/li\u003e\n\u003cli\u003efreezer\u003c/li\u003e\n\u003cli\u003ens\u003c/li\u003e\n\u003cli\u003epid\u003c/li\u003e\n\u003cli\u003enet_cls\u003c/li\u003e\n\u003cli\u003enet_prio\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"lsns\"\u003elsns\u003c/h1\u003e\n\u003cp\u003e查看系统的namespace\u003c/p\u003e\n\u003cp\u003ens类型: mnt, net, ipc, user, pid, uts, cgroup\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$lsns -l\n$lsns -t net\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"unshare\"\u003eunshare\u003c/h1\u003e\n\u003cp\u003e使用非共享的NS运行程序\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 创建unshare 的 ns类型.\n$unshare -f -m/-n/-i/-U/-p/-u/-C ... \n\n// 在net类型的namespace执行sleep命令\n$unshare -fn sleep 10\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"nsenter\"\u003ensenter\u003c/h1\u003e\n\u003cp\u003ens enter: Namespace enter.\u003c/p\u003e",
    "content": "NS namespace 是 Linux 内核用来隔离内核资源的方式\nLinux namespace资源：\nMount: 挂载点 Network: 网络设备/协议栈/端口 IPC: 进程间通信 USR: 用户和用户组 PID: 进程 UTS: 主机名和域名 Cgroup: 控制组 Time Cgroup Cgroup: Control Groups.是linux下用于对一个或一组进程资源控制和监控的机制.可以管理cpu, memory,diskIO 等资源.不同资源的具体管理工作由相应的cgrouup子系统来实现.\ncgroup在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理, 每个cgroup可以包含其它子cgroup.\nls -l /sys/fs/cgroup cgroup子系统:\ncpu cpuacct cpuset memory blkio devices freezer ns pid net_cls net_prio lsns 查看系统的namespace\nns类型: mnt, net, ipc, user, pid, uts, cgroup\n$lsns -l $lsns -t net unshare 使用非共享的NS运行程序\n// 创建unshare 的 ns类型. $unshare -f -m/-n/-i/-U/-p/-u/-C ... // 在net类型的namespace执行sleep命令 $unshare -fn sleep 10 nsenter ns enter: Namespace enter.\nnsenter - run program with namespaces of other processes\n$ nsenter [options] [program [arguments]] // 指定ns的目标进程，可以通过nsls查看. $ nsenter -t/--target // 进入所有类型的ns. $ nsenter -a --all ... // 进入指定类型的ns $ nsenter -m/-u/-i/-n/-p/-C/-U ... // 进入指定ns的指定进程 $ nsenter -t \u0026lt;pid\u0026gt; -n ip a $ nsenter -S/-G/-r/-w ... $ nsenter -F/--no-fork ... $ nsenter -Z/--follow-context ... ",
    "categories": ["CNCF"],
    "tags": ["container"]
  },
  {
    "title": "Registry",
    "permalink": "https://canuxcheng.com/post/cncf_registry/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"container-registry\"\u003eContainer Registry\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eDocker Hub Registry\u003c/li\u003e\n\u003cli\u003eGoogle Container Registry (gcr.io)\u003c/li\u003e\n\u003cli\u003eRedHat Quay Registry (quay.io)\u003c/li\u003e\n\u003cli\u003eGitHub Docker Packages (docker.pkg.github.com)(Deprecated)\u003c/li\u003e\n\u003cli\u003eGitHub Container Registry (ghcr.io)\u003c/li\u003e\n\u003cli\u003eKubernetes Registry(registry.k8s.io =\u0026gt; k8s.gcr.io)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"harbor\"\u003eHarbor\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/goharbor/harbor\"\u003ehttps://github.com/goharbor/harbor\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHabor是由VMWare中国团队开源的容器镜像仓库, 用于存储和分发docker镜像的registry服务器.\u003c/p\u003e\n\u003cp\u003e安装步骤:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e下载并解压安装包, \u003ca href=\"https://github.com/goharbor/harbor/releases\"\u003ehttps://github.com/goharbor/harbor/releases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e配置harbor.cfg;\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e修改配置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evim harbor.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行安装程序:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e./install.sh --with-notary --with-clair --with-chartmuseum\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改web的port:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vim /data/harbor/docker-compose.yml\nproxy:\n  ports:\n    - 8080:80 # 默认http是80\n    - 4433:443 # 默认https是443\n$ vim /data/harbor/harbor.yml\nhostname = ip\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e管理harbor:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# cd /data/harbor\n# docker-compose down -v 　停止并删除container\n\n\u0026gt; 更新配置\n# ./prepare --with-notary --with-clair --with-chartmuseum\n\n\u0026gt; 启动\n# docker-compose up -d\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"docker使用harbor\"\u003edocker使用harbor\u003c/h2\u003e\n\u003cp\u003eDeploy a plain HTTP registry:\u003c/p\u003e",
    "content": "Container Registry Docker Hub Registry Google Container Registry (gcr.io) RedHat Quay Registry (quay.io) GitHub Docker Packages (docker.pkg.github.com)(Deprecated) GitHub Container Registry (ghcr.io) Kubernetes Registry(registry.k8s.io =\u0026gt; k8s.gcr.io) Harbor https://github.com/goharbor/harbor\nHabor是由VMWare中国团队开源的容器镜像仓库, 用于存储和分发docker镜像的registry服务器.\n安装步骤:\n下载并解压安装包, https://github.com/goharbor/harbor/releases 配置harbor.cfg; 修改配置:\nvim harbor.yml 运行安装程序:\n./install.sh --with-notary --with-clair --with-chartmuseum 修改web的port:\n$ vim /data/harbor/docker-compose.yml proxy: ports: - 8080:80 # 默认http是80 - 4433:443 # 默认https是443 $ vim /data/harbor/harbor.yml hostname = ip 管理harbor:\n# cd /data/harbor # docker-compose down -v 停止并删除container \u0026gt; 更新配置 # ./prepare --with-notary --with-clair --with-chartmuseum \u0026gt; 启动 # docker-compose up -d docker使用harbor Deploy a plain HTTP registry:\n# vim /etc/docker/daemon.json { \u0026quot;insecure-registries\u0026quot; : [\u0026quot;myregistrydomain.com:5000\u0026quot;]} Use self-signed certificates:\n# cp your-ca /etc/docker/certs.d/harbor.domain.com/ca.crt # vim /lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --insecure-registry harbor.domain.com:port # systemctl daemon-reload # systemctl restart docker update hosts on docker client:\n# vim /etc/hosts ip harbor.domain.com create user account:\nhttps://\u0026lt;ip:port\u0026gt; push images to harbor:\n$ docker login harbor.domain.com:port $ docker tag SOURCE_IMAGE[:TAG] harbor.domain.com:port/\u0026lt;project\u0026gt;/IMAGE[:TAG] $ docker push harbor.domain.com:port/\u0026lt;project\u0026gt;/IMAGE[:TAG] pull images from harbor:\n$ docker login harbor.domain.com:port $ docker pull harbor.domain.com:port/\u0026lt;project\u0026gt;/IMAGE[:TAG] k8s使用harbor:\nhttps://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\n修改存储路径 默认路径是/data/registry\n停服务:\n$ docker-compose down -v 修改路径:\n$ mv /data/* /new/path $ vim /new/path/harbor/harbor.yml data_volume: /new/path $ vim /new/path/harbor/docker-compose.yml /data =\u0026gt; /new/path 启动服务:\n$ cd /new/path $ docker-compose up -d Artifactory ",
    "categories": ["CNCF"],
    "tags": ["harbor","artifactory","dragonfly"]
  },
  {
    "title": "Swarm",
    "permalink": "https://canuxcheng.com/post/swarm/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"swarm\"\u003eSwarm\u003c/h1\u003e\n\u003cp\u003edocker swarm 是 docker内置的容器编排工具。\u003c/p\u003e\n\u003cp\u003e从docker1.12开始swarm内置于docker engine.\u003c/p\u003e\n\u003cp\u003eswarm mode具有内置kv存储，服务发现，负载均衡，路由网格，动态伸缩，滚动更新，安全传输等功能。\u003c/p\u003e\n\u003cp\u003eswarm: 老版本的swarm, 需要kv store, 可以作为独立的container运行, 已废弃, 已经被docker swarm mode 代替.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/docker/swarm\"\u003ehttps://github.com/docker/swarm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eswarmkit:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/docker/swarmkit\"\u003ehttps://github.com/docker/swarmkit\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"swarm命令\"\u003eswarm命令\u003c/h1\u003e\n\u003cp\u003e创建集群\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker swarm init\n--advertise-addr \u0026lt;ip\u0026gt; 多网卡情况下指定manager的ip\n\ndocker swarm join --token \u0026lt;token\u0026gt; \u0026lt;host:port\u0026gt;\n\n# 查看token\ndocker swarm join-token manager   获取添加manager命令\ndocker swarm join-token worker   获取添加worker命令\ndocker swarm join-token -q worker\n\ndocker swarm leave -f/--force\n\ndocker swarm update\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e管理节点\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker node ls\ndocker node ls --format \u0026quot;{{.Hostname}}\u0026quot;\n​\ndocker node rm\n​\ndocker node inspect\n​\n# 查看node上运行的tasks/container\ndocker node ps -f/--filter NODE\n​\n# 添加label, node.labels.role=api\ndocker node update --label-add role=api node1\n# 删除label\ndocker node update --label-rm role node1\n​\n# 活跃节点\ndocker node update --availability active node1\n# 指定该节点满载,不再分派任务,关闭已有任务并重新分派.\ndocker node update --availability drain node1\n# 已有任务继续运行,不分配新任务.\ndocker node update --availability pause node1\n\n# 查看所有node和label\ndocker node ls -q | xargs docker node inspect -f '{{ .ID }} [{{ .Description.Hostname }}]: {{ .Spec.Labels }}'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eservice\u003c/p\u003e",
    "content": "Swarm docker swarm 是 docker内置的容器编排工具。\n从docker1.12开始swarm内置于docker engine.\nswarm mode具有内置kv存储，服务发现，负载均衡，路由网格，动态伸缩，滚动更新，安全传输等功能。\nswarm: 老版本的swarm, 需要kv store, 可以作为独立的container运行, 已废弃, 已经被docker swarm mode 代替.\nhttps://github.com/docker/swarm\nswarmkit:\nhttps://github.com/docker/swarmkit\nswarm命令 创建集群\ndocker swarm init --advertise-addr \u0026lt;ip\u0026gt; 多网卡情况下指定manager的ip docker swarm join --token \u0026lt;token\u0026gt; \u0026lt;host:port\u0026gt; # 查看token docker swarm join-token manager 获取添加manager命令 docker swarm join-token worker 获取添加worker命令 docker swarm join-token -q worker docker swarm leave -f/--force docker swarm update 管理节点\ndocker node ls docker node ls --format \u0026quot;{{.Hostname}}\u0026quot; ​ docker node rm ​ docker node inspect ​ # 查看node上运行的tasks/container docker node ps -f/--filter NODE ​ # 添加label, node.labels.role=api docker node update --label-add role=api node1 # 删除label docker node update --label-rm role node1 ​ # 活跃节点 docker node update --availability active node1 # 指定该节点满载,不再分派任务,关闭已有任务并重新分派. docker node update --availability drain node1 # 已有任务继续运行,不分配新任务. docker node update --availability pause node1 # 查看所有node和label docker node ls -q | xargs docker node inspect -f '{{ .ID }} [{{ .Description.Hostname }}]: {{ .Spec.Labels }}' service\n# 相当于docker-compose.yml里面的service. docker service ls # 列出所有service ​ docker service rm SERVICE ​ docker service inspect SERVICE ​ # 查看service的log docker service logs -f SERVICE ​ # 查看service的状态,在哪些node上运行,运行状态等 docker service ps SERVICE ​ docker service update docker service update --image \u0026lt;url:tag\u0026gt; # 根据镜像更新服务 ​ docker service scale ​ docker service rollback ​ docker service create --constraint node.id/node.hostname/node.role/node.labels/engine.labels --env/-e --label --limit-cpu --limit-memory --replicas --restart-condition --user/--group --mode global/replicated --endpoint-mode vip/dnsrr stack\n# stack = n*service # service = n*task(container) docker stack ls # 列出所有stack # 查看stack的service docker stack services \u0026lt;stack\u0026gt; # 查看stack的task/container docker stack ps \u0026lt;stack\u0026gt; docker stack rm STACK # 根据docker-compose.yml部署应用 docker stack deploy -c/--compose-file \u0026lt;docker-compose.yml\u0026gt; STACK docker stack deploy --bundle-file \u0026lt;DAB\u0026gt; STACK # 默认所有node从docker hub pull, 如果是私有镜像，需要加参数 # 需要在manager上docker login private-registry docker stack deploy --with-registry-auth -c test.yml test docker stack deploy --resolve-image (always|changed|never) ... docker stack deploy --orchestrator (swarm|kubernetes|all) ... swarm compose 其它字段参考Compose， 这里只分析deploy下的字段.\n通过compose文件部署服务.\ndeploy: endpoint_mode: // 给service打标签(不作用于container) labels: com.examples.key: value // 默认mode=replicated, replicas=1. mode: replicated max_replicas_per_node: replicas: 1 // 部署到匹配的全部node. mode: global ​ # global和replicated都可以用placement. placement: preferences: // 只支持spreed. - spreed: node.labels.datacenter constraints: # 多个约束是and关系 - node.id==... - node.hostname==... - node.role==... - node.role==manager/worker - node.platform.os!=windows - node.platform.arch==x86 - engine.labels.\u0026lt;key\u0026gt;==\u0026lt;value\u0026gt; # 用户自定义标签 - node.labels.\u0026lt;key\u0026gt;==\u0026lt;value\u0026gt; ​ resources: limits: cpus: '0.5' memory: 1G reservations: cpus: '0.25' memory: 20M ​ restart_policy: condition: any(default)/on-failure/none delay: 0(default)/5s max_attempts: never give up(default)/3 window: decide immediately(default)/10s ​ update_config/rollback_config: parallelism: 0 (default 0 means all) delay: 10s (容器升级间隔时间) failure_action: pause(default)/continue/rollback monitor: 0s (更新完成后确认成功的时间) max_failure_ratio: 更新期间允许的失败率 order: stop-first(default)/start-first // 默认endpoint_mode=vip, 支持route mesh, 自动负载均衡和服务发现. deploy: endpoint_mode: vip ports: - target: 80 published: 8080 // 默认mode=ingress, 也可以改为host. mode: ingress protocol: tcp/udp - 8080:80/tcp // dnsrr 模式 deploy: endpoint_mode: dnsrr update_config: // 如果expose端口，不能start-first, 否则报错no suitable node (host-mode port already in use on 1 node order: stop-first // 设置iptables规则，外部访问8080通过prerouting做dnat指定目的ip，通过forward转发给container的80. // iptables-\u0026gt;nat-\u0026gt;prerouting: // DNAT tcp -- !docker_gwbridge * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 to:172.18.0.16:80 // iptables-\u0026gt;filter-\u0026gt;forward: // ACCEPT tcp -- enp5s0 * 0.0.0.0/0 0.0.0.0/0 multiport dports 80 ports: - target: 80 published: 8080 // dnsrr只能用port-\u0026gt;mode=host. mode: host protocol: tcp/udp swarm network global模式container:\neth0: overlay(user define overlay) eth1: ingress(swarm define ingress) eth2: docker_gwbridge(swarm define bridge) replicate模式container:\neth0: overlay(user define overlay) eth1: docker_gwbridge(swarm define bridge) overlay: 通过4789/udp跨主机访问其他container, host不能访问overlay的ip，只有container之间通过container-servicename或者container-overlay的ip相互访问.\noverlay 问题: 通过overlay连接，默认15分钟timeout, 所以数据库建议用dnsrr模式; 如果用vip模式，需要修改内核网络参数:\n$ sudo sysctl -w net.ipv4.tcp_keepalive_time=600 net.ipv4.tcp_keepalive_intvl=60 net.ipv4.tcp_keepalive_probes=3 vip模式就是访问的虚拟ip,replicated的service如果有多个container,通过servicename访问的就是同一个vip,通过vip解析到背后container的真实overlay-ip(自动负载均衡).\ndnsrr模式就是直接解析container的overlay-ip来访问,如果是replicated的service有多个container,每次访问的就是从dns列表中根据负载均衡算法拿到其中一个overlay-ip.\ningress network: 是一个特殊的 overlay 网络，用于服务节点间的负载均衡。当任何 Swarm 节点在发布的端口上接收到请求时，它将该请求交给一个名为 IPVS 的模块。IPVS 跟踪参与该服务的所有IP地址，选择其中的一个，并通过 ingress 网络将请求路由到它。\ndocker_gwbridge: host和container之间通过ip访问, container能访问host的物理网卡的ip和docker_gwbridge的ip, host也能访问container的docker_gwbridge的ip, 但是container之间不能访问bridge的ip.\n修改默认的docker_gwbridge:\n// 对于已存在的，要先删除 $ service docker stop $ sudo ip link set docker_gwbridge down $ sudo ip link del dev docker_gwbridge // 创建swarm之前创建好网络 $ docker network create --subnet \u0026quot;172.18.0.0/16\u0026quot; --ip-range “172.18.1.0/16” \\ --opt com.docker.network.bridge.name=docker_gwbridge \\ --opt com.docker.network.bridge.enable_icc=false \\ --opt com.docker.network.bridge.enable_ip_masquerade=true \\ docker_gwbridge // 创建swarm $ docker swarm init endpoint_mode:\nvip: 通过vip这个虚拟ip对外访问，提供负载均衡，不暴露具体的container的ip. dnssr: DNS round-robin, 为每个服务设置dns,连接到其中一个具体的contaier的ip. swarm scheduler filter过滤器可以实现特定的容器运行在特定的node上, swarm支持３种策略和6个过滤器.\nswarm strategy:\nspread： 默认策略,配置相同的情况下选择容器数量最少的node binpack： 尽可能将容器放到一台node上运行。 random： 直接随机分配 swarm node filters:\nconstraint health containerslots swarm container-configuration filters:\naffinity dependency port ",
    "categories": ["CNCF"],
    "tags": ["swarm"]
  },
  {
    "title": "Swarm CNI",
    "permalink": "https://canuxcheng.com/post/swarm_cni/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"cni\"\u003eCNI\u003c/h1\u003e\n\u003cp\u003eCNI: Container Network Intarface\u003c/p\u003e\n\u003ch2 id=\"单台host上的container通信\"\u003e单台host上的container通信\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003enone\u003c/li\u003e\n\u003cli\u003ehost\u003c/li\u003e\n\u003cli\u003ebridge\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"多台host之间的container通信\"\u003e多台host之间的container通信\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eoverlay\u003c/li\u003e\n\u003cli\u003emacvlan\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"提供overlaymacvlan的网络服务\"\u003e提供overlay/macvlan的网络服务\u003c/h3\u003e\n\u003cp\u003evxlan encapsulated:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecanal\u003c/li\u003e\n\u003cli\u003eflannel\u003c/li\u003e\n\u003cli\u003eweave\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ebgp unencapsulated:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecalico\u003c/li\u003e\n\u003cli\u003eromana\u003c/li\u003e\n\u003cli\u003ecilium\u003c/li\u003e\n\u003cli\u003ekube-router\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"docker网络管理\"\u003eDocker网络管理\u003c/h1\u003e\n\u003cp\u003e查看:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker network ls # 查看所有网络\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e默认支持的三种模式:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 默认启动的容器都是桥接(docker0)，重启后容器的ip就变了。\ndocker run --network bridge  ...\ndocker run --network host ... # 容器和主机使用相同的ip\ndocker run --network none ... # 容器不会分配局域网的ip\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker network create -d \u0026lt;driver\u0026gt; ... [name]\n-d/--driver # 默认是bridge, 可选overlay/macvlan\n--subnet  # CIDR格式\n--gateway\n--ip-range\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用:\u003c/p\u003e",
    "content": "CNI CNI: Container Network Intarface\n单台host上的container通信 none host bridge 多台host之间的container通信 overlay macvlan 提供overlay/macvlan的网络服务 vxlan encapsulated:\ncanal flannel weave bgp unencapsulated:\ncalico romana cilium kube-router Docker网络管理 查看:\n$ docker network ls # 查看所有网络 默认支持的三种模式:\n# 默认启动的容器都是桥接(docker0)，重启后容器的ip就变了。 docker run --network bridge ... docker run --network host ... # 容器和主机使用相同的ip docker run --network none ... # 容器不会分配局域网的ip 创建:\ndocker network create -d \u0026lt;driver\u0026gt; ... [name] -d/--driver # 默认是bridge, 可选overlay/macvlan --subnet # CIDR格式 --gateway --ip-range 使用:\n$ docker network connect [OPTIONS] NETWORK CONTAINER $ docker network disconnect [OPTIONS] NETWORK CONTAINER $ docker run --network [name] --name [container-name] [image:tag] # 使用自定义bridge网络并指定IP: docker run --network [name] --ip [ip] ... opt可用的参数:\ncom.docker.network.bridge.name # bridge名字 com.docker.network.bridge.enable_ip_masquerade # iptables:nat, 容器访问外网. com.docker.network.bridge.enable_icc # iptables:filter, 同一网段容器相互访问. com.docker.network.bridge.host_binding_ipv4 com.docker.network.driver.mtu bridge网络 bridge网络不能跨主机通信(单网卡情况下), node1上的container不能通过container-hostname/ip访问node2上的container.\n主要用于container访问host并通过host访问外部网络，container能通过ip访问host和局域网中的其他node,或者通过node访问外网。\nhost或局域网中的其它机器能通过container-ip(bridge网络)访问container.\n创建:\n$ docker network create -d bridge ... [name] $ docker network create --driver=bridge --gateway=192.168.1.1 --subnet=192.168.1.0/24 --opt com.docker.network.bridge.name=br0 br0 // 定制docker_gwbridge网络 $ docker network create --subnet 172.26.0.0/16 --ip-range 172.26.0.0/16 --gateway 172.26.0.1 \\ --opt com.docker.network.bridge.name=docker_gwbridge \\ --opt com.docker.network.bridge.enable_icc=true \\ --opt com.docker.network.bridge.enable_ip_masquerade=true \\ docker_gwbridge docker0:\n// dockerd 自动的默认bridge网络，不推荐用于production. 1. 删除docker0: // 停止 $ ip link set dev docker0 down $ ifconfig docker0 down // 删除 $ ip link delete docker0 $ brctl delbr docker0 2. 修改默认网络: $ vim /etc/docker/daemon.json { \u0026quot;bip\u0026quot;: \u0026quot;192.168.1.5/24\u0026quot;, \u0026quot;fixed-cidr\u0026quot;: \u0026quot;192.168.1.5/25\u0026quot;, \u0026quot;fixed-cidr-v6\u0026quot;: \u0026quot;2001:db8::/64\u0026quot;, \u0026quot;mtu\u0026quot;: 1500, \u0026quot;default-gateway\u0026quot;: \u0026quot;10.20.1.1\u0026quot;, \u0026quot;default-gateway-v6\u0026quot;: \u0026quot;2001:db8:abcd::89\u0026quot;, \u0026quot;dns\u0026quot;: [\u0026quot;10.20.1.2\u0026quot;,\u0026quot;10.20.1.3\u0026quot;] } $ service docker restart overlay网络 overlay网络可以实现容器之间的跨主机通信.\ncontainer通过overlay网络实现通信.container能通过service-name/container-ip访问其它container。\n局域网中的node 既不能通过container-servicename也不能通过container-ip(overlay的ip)访问container, 也就是说外部服务只能通过expose port来访问container.\n创建:\n$ docker network create -d overlay ... [name] $ docker network create --attachable --driver=overlay --gateway=172.27.0.1 --subnet=172.27.0.0/24 --ip-range=172.27.0.0/24 --opt com.docker.network.bridge.name=ol0 ol0 macvlan macvlan不仅支持在interface上创建，还支持sub-interface(vlan).\nip link set eth1 promisc on | ifconfig eth1 promisc docker network create -d macvlan --subnet=192.168.100.0/24 --gateway=192.168.100.1 -o parent=eth1 lan0 ",
    "categories": ["CNCF","Network"],
    "tags": ["swarm"]
  },
  {
    "title": "Swarm CSI",
    "permalink": "https://canuxcheng.com/post/swarm_csi/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"csi\"\u003eCSI\u003c/h1\u003e\n\u003cp\u003eCSI: Container Storage Interface\u003c/p\u003e\n\u003cp\u003eCSI提供容器的数据持久化服务.\u003c/p\u003e\n\u003cp\u003e容器管理数据的两种方式：\u003c/p\u003e\n\u003cp\u003e数据卷(Volumes)\u003c/p\u003e\n\u003cp\u003e挂载主机目录(bind mounts)\u003c/p\u003e\n\u003cp\u003e临时文件系统(tmpfs)\u003c/p\u003e\n\u003ch2 id=\"数据存储原理\"\u003e数据存储原理\u003c/h2\u003e\n\u003cp\u003e如果container上目录不存在，docker会自动创建\u003c/p\u003e\n\u003cp\u003e如果container目录存在且有内容，会被host上的目录覆盖掉，但不会被删除.\u003c/p\u003e\n\u003ch2 id=\"volumes\"\u003eVolumes\u003c/h2\u003e\n\u003cp\u003e如果host上目录不存在，docker会自动创建\u003c/p\u003e\n\u003cp\u003evolumes是被设计用来持久化数据的，它的生命周期独立于容器.数据卷通过docker volume命令管理的，位于/var/lib/docker/volumes/下面.\u003c/p\u003e\n\u003cp\u003eDocker不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。\u003c/p\u003e\n\u003cp\u003e创建:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker volume create \u0026lt;volume-name\u0026gt;\n$ docker volume rm \u0026lt;volume-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker run -v/--volume myvolume:/var/lib/app ...\n$ docker run --mount source=myvolume,target=/var/lib/app ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"bind-mount\"\u003eBind mount\u003c/h2\u003e\n\u003cp\u003e如果host上目录不存在会报错，需要提前创建.\u003c/p\u003e\n\u003cp\u003ebind mount就是直接将host路径挂在到docker．\u003c/p\u003e\n\u003cp\u003esource和target都是文件，即可挂载单个文件.\u003c/p\u003e\n\u003cp\u003e使用:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker run -v/--volume /opt/app:/var/lib/app:ro ...\n$ docker run --mount type=bind,source=/opt/app,target=/var/lib/app,readonly ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"tmpfs\"\u003etmpfs\u003c/h2\u003e\n\u003cp\u003etmpfs是临时文件系统，也叫内存文件系统，就是将数据存在内存上。\u003c/p\u003e\n\u003cp\u003etmpfs只能用于linux, 多个容器也不能共享，容器停止数据就销毁。\u003c/p\u003e",
    "content": "CSI CSI: Container Storage Interface\nCSI提供容器的数据持久化服务.\n容器管理数据的两种方式：\n数据卷(Volumes)\n挂载主机目录(bind mounts)\n临时文件系统(tmpfs)\n数据存储原理 如果container上目录不存在，docker会自动创建\n如果container目录存在且有内容，会被host上的目录覆盖掉，但不会被删除.\nVolumes 如果host上目录不存在，docker会自动创建\nvolumes是被设计用来持久化数据的，它的生命周期独立于容器.数据卷通过docker volume命令管理的，位于/var/lib/docker/volumes/下面.\nDocker不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。\n创建:\n$ docker volume create \u0026lt;volume-name\u0026gt; $ docker volume rm \u0026lt;volume-name\u0026gt; 使用：\n$ docker run -v/--volume myvolume:/var/lib/app ... $ docker run --mount source=myvolume,target=/var/lib/app ... Bind mount 如果host上目录不存在会报错，需要提前创建.\nbind mount就是直接将host路径挂在到docker．\nsource和target都是文件，即可挂载单个文件.\n使用:\n$ docker run -v/--volume /opt/app:/var/lib/app:ro ... $ docker run --mount type=bind,source=/opt/app,target=/var/lib/app,readonly ... tmpfs tmpfs是临时文件系统，也叫内存文件系统，就是将数据存在内存上。\ntmpfs只能用于linux, 多个容器也不能共享，容器停止数据就销毁。\n使用\u0026ndash;mount可以指定参数，使用\u0026ndash;tmpfs不能指定参数。\n使用:\n$ docker run --mount type=tmpfs,destination=/tmp/app,tmpfs_size=10G tmpfs_mode=1777 ... $ docker run --tmpfs ... Docker管理volume 查看:\ndocker volume ls # 查看所有卷 创建volume:\ndocker volume create my-volume # mountpoint: /var/lib/docker/volumes/my-volume/_data. docker run -v/--volume my-volume:/container/path # src=/var/lib/docker/volumes/my-volume/_data, dest=/container/path 指定路径作为volume：\ndocker run -v /host/path:/container/path ... # src=/host/path, dest=/container/path 默认随机路径，数据不能持久化：\n# src=/var/lib/docker/volumes/... /_data (on host) docker run -v /path .... docker run --mount ... ",
    "categories": ["CNCF","Storage"],
    "tags": ["swarm"]
  },
  {
    "title": "Monitoring",
    "permalink": "https://canuxcheng.com/post/storage_monitoring/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"monitoring\"\u003eMonitoring\u003c/h1\u003e\n\u003ch2 id=\"diskio\"\u003ediskio\u003c/h2\u003e\n\u003cp\u003eIOPS: Input/Output Per Second. 每秒输入输出量，也叫TPS.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(mean(reads),1s) as \u0026quot;read\u0026quot; FROM \u0026quot;diskio\u0026quot;\nSELECT non_negative_derivative(mean(writes),1s) as \u0026quot;write\u0026quot; FROM \u0026quot;diskio\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethroughput:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(mean(read_bytes),1s) as \u0026quot;read\u0026quot; FROM \u0026quot;diskio\u0026quot;\nSELECT non_negative_derivative(mean(write_bytes),1s) as \u0026quot;write\u0026quot; FROM \u0026quot;diskio\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUtilization:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(last(\u0026quot;io_time\u0026quot;),1ms)\nFROM \u0026quot;diskio\u0026quot;\nWHERE \u0026quot;name\u0026quot; =~ /^(v|s|)d(a|b|c|d)$/\nGROUP BY \u0026quot;host\u0026quot;,\u0026quot;name\u0026quot;,time(_interval)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eQueue length:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(last(\u0026quot;weighted_io_time\u0026quot;,1ms))\nFROM \u0026quot;diskio\u0026quot;\nWHERE \u0026quot;name\u0026quot; =~ /^(v|s|)d(a|b|c|d)$/\nGROUP BY \u0026quot;host\u0026quot;,\u0026quot;name\u0026quot;,time(_interval)\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Monitoring diskio IOPS: Input/Output Per Second. 每秒输入输出量，也叫TPS.\nSELECT non_negative_derivative(mean(reads),1s) as \u0026quot;read\u0026quot; FROM \u0026quot;diskio\u0026quot; SELECT non_negative_derivative(mean(writes),1s) as \u0026quot;write\u0026quot; FROM \u0026quot;diskio\u0026quot; throughput:\nSELECT non_negative_derivative(mean(read_bytes),1s) as \u0026quot;read\u0026quot; FROM \u0026quot;diskio\u0026quot; SELECT non_negative_derivative(mean(write_bytes),1s) as \u0026quot;write\u0026quot; FROM \u0026quot;diskio\u0026quot; Utilization:\nSELECT non_negative_derivative(last(\u0026quot;io_time\u0026quot;),1ms) FROM \u0026quot;diskio\u0026quot; WHERE \u0026quot;name\u0026quot; =~ /^(v|s|)d(a|b|c|d)$/ GROUP BY \u0026quot;host\u0026quot;,\u0026quot;name\u0026quot;,time(_interval) Queue length:\nSELECT non_negative_derivative(last(\u0026quot;weighted_io_time\u0026quot;,1ms)) FROM \u0026quot;diskio\u0026quot; WHERE \u0026quot;name\u0026quot; =~ /^(v|s|)d(a|b|c|d)$/ GROUP BY \u0026quot;host\u0026quot;,\u0026quot;name\u0026quot;,time(_interval) ",
    "categories": ["Storage"],
    "tags": ["monitoring"]
  },
  {
    "title": "Storage",
    "permalink": "https://canuxcheng.com/post/storage/",
    "date": "2018-04-05",
    "summary": "\u003ch1 id=\"storage\"\u003eStorage\u003c/h1\u003e\n\u003ch1 id=\"raid\"\u003eRAID\u003c/h1\u003e\n\u003cp\u003eRAID: redundant array of independent disks, 独立磁盘冗余数组．\u003c/p\u003e\n\u003ch1 id=\"存储方式\"\u003e存储方式\u003c/h1\u003e\n\u003cp\u003eDAS: direct attached storage, 直连式存储，通过SCSI或FC连接服务器．\u003c/p\u003e\n\u003cp\u003eNAS: network attached storage，网络接入存储，通过IP(NFS/CIFS/..).\u003c/p\u003e\n\u003cp\u003eSAN: storage area network, 存储区域网络，有IP或FC两种方式．\u003c/p\u003e\n\u003ch1 id=\"存储接口\"\u003e存储接口\u003c/h1\u003e\n\u003cp\u003eSCSI\u003c/p\u003e\n\u003cp\u003eiSCSI\u003c/p\u003e\n\u003cp\u003eSAS\u003c/p\u003e\n\u003cp\u003eSATA\u003c/p\u003e\n\u003cp\u003eFC\u003c/p\u003e\n\u003cp\u003eFCoE\u003c/p\u003e\n\u003chr\u003e",
    "content": "Storage RAID RAID: redundant array of independent disks, 独立磁盘冗余数组．\n存储方式 DAS: direct attached storage, 直连式存储，通过SCSI或FC连接服务器．\nNAS: network attached storage，网络接入存储，通过IP(NFS/CIFS/..).\nSAN: storage area network, 存储区域网络，有IP或FC两种方式．\n存储接口 SCSI\niSCSI\nSAS\nSATA\nFC\nFCoE\n",
    "categories": ["Storage"],
    "tags": ["storage"]
  },
  {
    "title": "Websocket",
    "permalink": "https://canuxcheng.com/post/websocket/",
    "date": "2018-04-03",
    "summary": "\u003ch1 id=\"websocket\"\u003eWebSocket\u003c/h1\u003e\n\u003cp\u003ewebsocket用于server和browser之间通讯．\u003c/p\u003e\n\u003cp\u003ewebsocket采用特殊报头，使得浏览器和服务器只需要做一个握手的动作．\u003c/p\u003e\n\u003cp\u003e通讯数据以\\x00开头，以\\xFF结尾．\u003c/p\u003e\n\u003cp\u003eurl:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ews://\nwss://\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一个客户端只建立一个tcp连接\u003c/p\u003e\n\u003cp\u003e服务端可以推送/push数据到web客户端\u003c/p\u003e\n\u003cp\u003e有更加亲量级的头，减少数据传送．\u003c/p\u003e",
    "content": "WebSocket websocket用于server和browser之间通讯．\nwebsocket采用特殊报头，使得浏览器和服务器只需要做一个握手的动作．\n通讯数据以\\x00开头，以\\xFF结尾．\nurl:\nws:// wss:// 一个客户端只建立一个tcp连接\n服务端可以推送/push数据到web客户端\n有更加亲量级的头，减少数据传送．\n",
    "categories": ["Network"],
    "tags": ["websocket"]
  },
  {
    "title": "JS BOM",
    "permalink": "https://canuxcheng.com/post/js_bom/",
    "date": "2018-03-15",
    "summary": "\u003ch1 id=\"bom\"\u003eBOM\u003c/h1\u003e\n\u003cp\u003eBrowser Object Model\u003c/p\u003e\n\u003cp\u003e介绍浏览器对象，不过缺乏规范.\u003c/p\u003e\n\u003ch1 id=\"window\"\u003ewindow\u003c/h1\u003e\n\u003cp\u003ewindow对象是最顶层对象，有6大属性,属性本身也是对象.\u003c/p\u003e\n\u003cp\u003ewindow对象的document属性也是对象，document对象有5大属性.\u003c/p\u003e\n\u003cp\u003e引用当前窗口时，可以省略window对象.\u003c/p\u003e\n\u003cp\u003eeg:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewindow.document\ndocument\n\nwindow.alert()\nalert()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对象集合:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eframes[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eattribution:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument # DOM的Document对象\nhistory # History对象\nlocation # Location对象\nNavigator # Navigator对象\nScreen # Screen对象\nwindow # 等价于self\n\nclosed\ndefaultStatus\nstatus\ninnerheight\ninnerwidth\nouterheight\nouterwidth\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ealert() // 弹出警告框\nconfirm() // 和alert差不多，带确定和取消按钮，确定返回true\nprompt() // 输入提示框,返回输入内容\nfind() // 查找\n\n// 子窗口的opener属性反过来引用打开她的那个窗口(父窗口)\nsubwin = open() // 打开一个新窗口, _parent在当前窗口打开, 返回子窗口的window对象.\nsubwin.opener // 表示window\n\nmoveTo()\nmoveBy()\nresizeTo()\nresizeBy()\n\nsetTimeout()\nclearTimeout()\n\nsetInterval()\nclearInterval()\n\nclose()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"location\"\u003elocation\u003c/h1\u003e\n\u003cp\u003eattribution:\u003c/p\u003e",
    "content": "BOM Browser Object Model\n介绍浏览器对象，不过缺乏规范.\nwindow window对象是最顶层对象，有6大属性,属性本身也是对象.\nwindow对象的document属性也是对象，document对象有5大属性.\n引用当前窗口时，可以省略window对象.\neg:\nwindow.document document window.alert() alert() 对象集合:\nframes[] attribution:\ndocument # DOM的Document对象 history # History对象 location # Location对象 Navigator # Navigator对象 Screen # Screen对象 window # 等价于self closed defaultStatus status innerheight innerwidth outerheight outerwidth method:\nalert() // 弹出警告框 confirm() // 和alert差不多，带确定和取消按钮，确定返回true prompt() // 输入提示框,返回输入内容 find() // 查找 // 子窗口的opener属性反过来引用打开她的那个窗口(父窗口) subwin = open() // 打开一个新窗口, _parent在当前窗口打开, 返回子窗口的window对象. subwin.opener // 表示window moveTo() moveBy() resizeTo() resizeBy() setTimeout() clearTimeout() setInterval() clearInterval() close() location attribution:\nhash host hostname href pathname port protocol search methods:\nassign() reload() replace() history attribution:\nlehgth method:\nback() forward() go() navigator 对象集合:\nplugins[] # Plugin对象的数组 navigator.plugins.length # 插件个数 navigator.plugins[i].name # 第i个插件名字 navigator.plugins[i].filename # 第i个插件文件名 attribution:\nappName # 浏览器名称 appVersion # 浏览器版本 userAgent # user-agent 头部信息 platform # win32/ method:\njavaEnabled() taintEnabled() screen attribution:\nwidth height availHeight availWidth ",
    "categories": ["Web"],
    "tags": ["bom"]
  },
  {
    "title": "Brazil",
    "permalink": "https://canuxcheng.com/post/travel_brazil/",
    "date": "2018-03-08",
    "summary": "\u003ch1 id=\"巴西之旅\"\u003e巴西之旅\u003c/h1\u003e\n\u003cp\u003e看照片：\u003c/p\u003e\n\u003ch1 id=\"库里提巴\"\u003e库里提巴\u003c/h1\u003e\n\u003cp\u003e库里提巴（Curitiba）\u003c/p\u003e",
    "content": "巴西之旅 看照片：\n库里提巴 库里提巴（Curitiba）\n",
    "categories": ["Misc"],
    "tags": ["brazil"]
  },
  {
    "title": "AlertManager",
    "permalink": "https://canuxcheng.com/post/metrics_alertmanager/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"alert-manager\"\u003ealert-manager\u003c/h1\u003e\n\u003cp\u003e在Prometheus中支持基于PromQL创建告警规则, prometheus通过push触发alertmanager.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/alertmanager\"\u003ehttps://github.com/prometheus/alertmanager\u003c/a\u003e\u003c/p\u003e",
    "content": "alert-manager 在Prometheus中支持基于PromQL创建告警规则, prometheus通过push触发alertmanager.\nhttps://github.com/prometheus/alertmanager\n",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Exporter",
    "permalink": "https://canuxcheng.com/post/metrics_exporter/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"exporter\"\u003eexporter\u003c/h1\u003e\n\u003cp\u003e广义上讲所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:\u003c/p\u003e\n\u003cp\u003eprometheus通过pull从exporter拉取数据.\u003c/p\u003e\n\u003cp\u003e直接采集:cAdvisor, kubernetes, etcd, gokit等直接内置了用于向prometheus暴露监控数据的端点.\u003c/p\u003e\n\u003cp\u003e间接采集: 通过promethesu的client api编写exporter，例如mysql-exporter, consul-exporter.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"host\"\u003ehost\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/node_exporter\"\u003ehttps://github.com/prometheus/node_exporter\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"k8s\"\u003ek8s\u003c/h1\u003e\n\u003cp\u003ek8s metrics api包括 resource metrics api 和 customer metrics api.\u003c/p\u003e\n\u003cp\u003ecadvisor, metrics-server, kube-state-metrics 等实现了 核心api.\u003c/p\u003e\n\u003cp\u003e一些adapter实现了自定义api.\u003c/p\u003e\n\u003cp\u003ek8s-prometheus-adapter实现了metrics-server的核心api，同时实现了自定义api.\u003c/p\u003e\n\u003ch2 id=\"metrics-server\"\u003emetrics-server \u003c/h2\u003e\n\u003cp\u003e提供了整个集群的资源监控数据\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-sigs/metrics-server\"\u003ehttps://github.com/kubernetes-sigs/metrics-server\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"cadvisor\"\u003ecAdvisor\u003c/h2\u003e\n\u003cp\u003e负责单节点内部的容器和节点资源使用统计，会自动收集本机容器 CPU、内存、网络和文件系统的资源占用情况\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/google/cadvisor\"\u003ehttps://github.com/google/cadvisor\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"kube-state-metrics\"\u003ekube-state-metrics \u003c/h2\u003e\n\u003cp\u003e提供了 Kubernetes 资源对象（如 DaemonSet、Deployments 等）的度量。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes/kube-state-metrics\"\u003ehttps://github.com/kubernetes/kube-state-metrics\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"adapter\"\u003eadapter\u003c/h2\u003e\n\u003cp\u003e同时支持核心api和自定义api.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/DirectXMan12/k8s-prometheus-adapter\"\u003ehttps://github.com/DirectXMan12/k8s-prometheus-adapter\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"blackbox\"\u003eblackbox\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/blackbox_exporter\"\u003ehttps://github.com/prometheus/blackbox_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"wmi\"\u003ewmi\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/martinlindhe/wmi_exporter\"\u003ehttps://github.com/martinlindhe/wmi_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"snmp\"\u003esnmp\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/snmp_exporter\"\u003ehttps://github.com/prometheus/snmp_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"mysql\"\u003emysql\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/mysqld_exporter\"\u003ehttps://github.com/prometheus/mysqld_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"rabbitmq\"\u003erabbitmq\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/deadtrickster/prometheus_rabbitmq_exporter\"\u003ehttps://github.com/deadtrickster/prometheus_rabbitmq_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"mongo\"\u003emongo\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/percona/mongodb_exporter\"\u003ehttps://github.com/percona/mongodb_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"redis\"\u003eredis\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/oliver006/redis_exporter\"\u003ehttps://github.com/oliver006/redis_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"haproxy\"\u003ehaproxy\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/haproxy_exporter\"\u003ehttps://github.com/prometheus/haproxy_exporter\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"consul\"\u003econsul\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/consul_exporter\"\u003ehttps://github.com/prometheus/consul_exporter\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"pushgateway\"\u003epushgateway\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prometheus/pushgateway\"\u003ehttps://github.com/prometheus/pushgateway\u003c/a\u003e\u003c/p\u003e",
    "content": "exporter 广义上讲所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:\nprometheus通过pull从exporter拉取数据.\n直接采集:cAdvisor, kubernetes, etcd, gokit等直接内置了用于向prometheus暴露监控数据的端点.\n间接采集: 通过promethesu的client api编写exporter，例如mysql-exporter, consul-exporter.\nhost https://github.com/prometheus/node_exporter\nk8s k8s metrics api包括 resource metrics api 和 customer metrics api.\ncadvisor, metrics-server, kube-state-metrics 等实现了 核心api.\n一些adapter实现了自定义api.\nk8s-prometheus-adapter实现了metrics-server的核心api，同时实现了自定义api.\nmetrics-server 提供了整个集群的资源监控数据\nhttps://github.com/kubernetes-sigs/metrics-server\ncAdvisor 负责单节点内部的容器和节点资源使用统计，会自动收集本机容器 CPU、内存、网络和文件系统的资源占用情况\nhttps://github.com/google/cadvisor\nkube-state-metrics 提供了 Kubernetes 资源对象（如 DaemonSet、Deployments 等）的度量。\nhttps://github.com/kubernetes/kube-state-metrics\nadapter 同时支持核心api和自定义api.\nhttps://github.com/DirectXMan12/k8s-prometheus-adapter\nblackbox https://github.com/prometheus/blackbox_exporter\nwmi https://github.com/martinlindhe/wmi_exporter\nsnmp https://github.com/prometheus/snmp_exporter\nmysql https://github.com/prometheus/mysqld_exporter\nrabbitmq https://github.com/deadtrickster/prometheus_rabbitmq_exporter\nmongo https://github.com/percona/mongodb_exporter\nredis https://github.com/oliver006/redis_exporter\nhaproxy https://github.com/prometheus/haproxy_exporter\nconsul https://github.com/prometheus/consul_exporter\npushgateway https://github.com/prometheus/pushgateway\n由于Prometheus数据采集基于Pull模型进行设计，因此在网络环境的配置上必须要让Prometheus Server能够直接与Exporter进行通信。 当这种网络需求无法直接满足时，就可以利用PushGateway来进行中转。可以通过PushGateway将内部网络的监控数据主动Push到Gateway当中。而Prometheus Server则可以采用同样Pull的方式从PushGateway中获取到监控数据.\n",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Influxdb",
    "permalink": "https://canuxcheng.com/post/metrics_influxdb/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"influxdb\"\u003eInfluxdb\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/influxdata/influxdb\"\u003ehttps://github.com/influxdata/influxdb\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eScalable datastore for metrics, events, and real-time analytics.\u003c/p\u003e\n\u003cp\u003e支持从opentsdb, graphite, collectd等获取数据\u003c/p\u003e\n\u003cp\u003e默认数据库_internal 用于存储内部运行数据\u003c/p\u003e\n\u003cp\u003e安装配置参考官方文档\u003c/p\u003e\n\u003cp\u003elog\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo journalctl -u influxdb.service\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003econfig:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 开通kapacitor的subscription功能\n[[subscriber]]\nenable = true\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"数据结构\"\u003e数据结构\u003c/h1\u003e\n\u003cp\u003einfluxdb每条记录是一个point.\u003c/p\u003e\n\u003cp\u003epoints包括下面部分：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emeasurement: a measurement, like cpu_load, 相当于表名\ntags: zero or more tag, key=value, eg: host=ip\nfields: zero or more field, key=value, eg: value=0.18\ntime: a timestamp\n\n\u0026lt;measurement\u0026gt;[,\u0026lt;tag-key\u0026gt;=\u0026lt;tag-value\u0026gt;...] \u0026lt;field-key\u0026gt;=\u0026lt;field-value\u0026gt;[,\u0026lt;field2-key\u0026gt;=\u0026lt;field2-value\u0026gt;...] [unix-nano-timestamp]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eseries: 在一个database中,相同的retention policy, measurement, tag set的数据集，叫一个序列．\u003c/p\u003e\n\u003cp\u003eRP: retention policy, autogen是默认的存储策略, 用于设置数据保留时间.\u003c/p\u003e",
    "content": "Influxdb https://github.com/influxdata/influxdb\nScalable datastore for metrics, events, and real-time analytics.\n支持从opentsdb, graphite, collectd等获取数据\n默认数据库_internal 用于存储内部运行数据\n安装配置参考官方文档\nlog\n$ sudo journalctl -u influxdb.service config:\n# 开通kapacitor的subscription功能 [[subscriber]] enable = true 数据结构 influxdb每条记录是一个point.\npoints包括下面部分：\nmeasurement: a measurement, like cpu_load, 相当于表名 tags: zero or more tag, key=value, eg: host=ip fields: zero or more field, key=value, eg: value=0.18 time: a timestamp \u0026lt;measurement\u0026gt;[,\u0026lt;tag-key\u0026gt;=\u0026lt;tag-value\u0026gt;...] \u0026lt;field-key\u0026gt;=\u0026lt;field-value\u0026gt;[,\u0026lt;field2-key\u0026gt;=\u0026lt;field2-value\u0026gt;...] [unix-nano-timestamp] series: 在一个database中,相同的retention policy, measurement, tag set的数据集，叫一个序列．\nRP: retention policy, autogen是默认的存储策略, 用于设置数据保留时间.\nCQ: continuous query, 连续查询，自动定时启动一组语句，将结果放在指定数据表中．\nIFQL: influx query language.\nCLI $ influx --help $ influx -username \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; -h \u0026lt;hostname\u0026gt; $ influx -precision rfc3339 # 显示可读的时间戳 $ influx -database 'test' -host '127.0.0.1' -execute 'select * from \u0026quot;test\u0026quot;.\u0026quot;test\u0026quot;.\u0026quot;test\u0026quot; where time \u0026gt; now() - 30d' -format 'csv' \u0026gt; test.csv database\n$ CREATE DATABASE test $ DROP DATABASE test $ SHOW DATABASES $ USE test measurement(table)\n$ DROP MEASUREMENT \u0026lt;measurement\u0026gt; $ SHOW MEASUREMENTS $ SHOW MEASUREMENTS WHERE \u0026lt;tagkey\u0026gt;=\u0026lt;tagvalue\u0026gt; tags\n$ SHOW TAG KEYS $ SHOW TAG KEYS FROM \u0026lt;measurement\u0026gt; $ SHOW TAG VALUES FROM \u0026lt;measurement\u0026gt; WITH KEY=\u0026lt;tagkey\u0026gt; fileds\n$ SHOW FIELD KEYS $ SHOW FIELD KEYS FROM \u0026lt;measurement\u0026gt; subscription\n$ SHOW SUBSCRIPTIONS $ CREATE SUBSCIPTION \u0026lt;subs_name\u0026gt; ON \u0026lt;db\u0026gt;.\u0026lt;rp\u0026gt; DESTINATIONS (\u0026quot;ANY\u0026quot;|\u0026quot;ALL\u0026quot;) host{\u0026quot;,\u0026quot;, host} $ DROP SUBSCRIPTION \u0026lt;subs_name\u0026gt; ON \u0026lt;db\u0026gt;.\u0026lt;rp\u0026gt; series\n$ SHOW SERIES $ DROP SERIES FROM \u0026lt;measurement\u0026gt; WHERE \u0026lt;tagkey\u0026gt;='\u0026lt;tagvalue\u0026gt;' $ DROP SERIES WHERE \u0026lt;tagkey\u0026gt;='\u0026lt;tagvalue\u0026gt;' # 从所有measurement删除指定节点的所有数据 shared\n$ drop shard \u0026lt;shard_id\u0026gt; HTTP API port = 8086 write create:\ncurl -i -XPOST http://localhost:8086/query --data-urlencode \u0026quot;q=CREATE DATABASE mydb\u0026quot; post /query data = { \u0026quot;q\u0026quot;: \u0026quot;create database \u0026lt;database\u0026gt;\u0026quot; } query show:\ncurl -G 'http://localhost:8086/query' --data-urlencode \u0026quot;q=show databases\u0026quot; get /query params = { \u0026quot;pretty\u0026quot; : True, \u0026quot;q\u0026quot;: \u0026quot;show databases\u0026quot; } influxQL influxql语句按下列关键字顺序排列\ntag_key, field_key, measurement都需要用双引号.\nThe SELECT clause specifies an InfluxQL function.\nselect \u0026quot;\u0026lt;field_key/tag_key\u0026gt;\u0026quot; from \u0026quot;\u0026lt;measurement\u0026gt;\u0026quot; select \u0026quot;\u0026lt;field_key/tag_key\u0026gt;\u0026quot; as \u0026quot;alias\u0026quot; from \u0026quot;\u0026lt;measurement\u0026gt;\u0026quot; The INTO clause writes query results to a user-specified measurement.\nselect \u0026lt;\u0026gt; INTO \u0026quot;\u0026lt;measurement\u0026gt;\u0026quot; from \u0026lt;\u0026gt; The FROM clause specifies a single measurement.\nselect \u0026lt;\u0026gt; from \u0026quot;\u0026lt;measurement\u0026gt;\u0026quot; The WHERE clause specifies the time range for the query.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;condition1\u0026gt; OR/AND \u0026lt;condition2\u0026gt; # string类型的 value必须用单引号． select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026quot;\u0026lt;tag_key/field_key\u0026gt;\u0026quot; \u0026lt;operation\u0026gt; '\u0026lt;tag_value/field_value\u0026gt;' now() : time \u0026gt; now(() - 10m = != \u0026lt; \u0026gt; RE: =~ !~ =~ : /.*ERROR.*|.*CRITICAL.*/ /ERROR|CRITICAL/ The GROUP BY clause groups results by all tags (*) and into 12-minute intervals.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026quot;\u0026lt;tag_key\u0026gt;\u0026quot; fill() time()/time(1ns/u/ms/s/m/h/d/w) The ORDER BY time DESC clause returns results in descending timestamp order.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;time/field_key\u0026gt; select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;time/field_key\u0026gt; desc The LIMIT 2 clause limits the number of points returned to two.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; limit \u0026lt;number\u0026gt; select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; desc limit \u0026lt;number\u0026gt; The OFFSET 2 clause excludes the first two averages from the query results.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; limit \u0026lt;number\u0026gt; offset \u0026lt;\u0026gt; select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; desc limit \u0026lt;number\u0026gt; offset \u0026lt;\u0026gt; The SLIMIT 1 clause limits the number of series returned to one.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; desc limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; The SOFFSET 1 clause paginates the series returned.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; soffzet \u0026lt;\u0026gt; select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; desc limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; soffset\u0026lt;\u0026gt; The tz() clause returns the UTC offset for the specified timezone.\nselect \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; soffzet \u0026lt;\u0026gt; tz(\u0026lt;time_zone\u0026gt;) select \u0026lt;\u0026gt; from \u0026lt;\u0026gt; where \u0026lt;\u0026gt; group by \u0026lt;\u0026gt; order by \u0026lt;\u0026gt; desc limit \u0026lt;\u0026gt; offset \u0026lt;\u0026gt; slimit \u0026lt;\u0026gt; soffset\u0026lt;\u0026gt; tz(\u0026lt;time_zone\u0026gt;) flux influxql的升级版，支持多表查询.\nfunction aggregations count(\u0026lt;fieldkey\u0026gt;) # 统计fieldvalues行数 distinct(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues不重复的值的列表 integral(\u0026lt;fieldkey\u0026gt;) # 积分 mean(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues的算数平均值 median(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues的排序后的中间值 mode(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues出现频率最高的值 spread(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues最值之间的差异 stddev(\u0026lt;fiekdkey\u0026gt;) # 返回fieldvalues的标准偏差 sum(\u0026lt;fieldkey\u0026gt;) # 返回fieldvalues的和 selectors bottom(\u0026lt;fieldkey\u0026gt;, N) # 返回最小的N个fieldvalues first(\u0026lt;fieldkey\u0026gt;) # 返回timestamp最小的fieldvalue last(\u0026lt;fieldkey\u0026gt;) # 返回timestamp最大的fieldvalue max(\u0026lt;fieldkey\u0026gt;) # 返回最大的fieldvalue min(\u0026lt;fieldkey\u0026gt;) # 返回最小的fieldvalue percentile(\u0026lt;fieldkey\u0026gt;, N) # 百分数 sample(\u0026lt;fieldkey\u0026gt;, N) # 返回N个fieldvalue的随即样本 top(\u0026lt;fieldkey\u0026gt;, N) # 返回最大的N个fieldvalue transformations transformations函数的field_key可以是aggregations和selectors函数的返回值\ncumulative_sum(\u0026lt;field_key\u0026gt;) derivative(\u0026lt;field_key\u0026gt;, [\u0026lt;unit\u0026gt;]) # 求单位时间的变化率, (cur-last)/(interval/unit) difference(\u0026lt;field_key\u0026gt;) # 返回连续时间值之间的差异 -\u0026gt; 值的差异 elapsed(\u0026lt;field_key\u0026gt;) # 返回连续时间间隔的差异 -\u0026gt; 时间间隔差异 moving_average() non_negative_derivative() non_negative_difference() predictors holt_winters(function(\u0026lt;field_key\u0026gt;), N, S) RP 数据保存策略.\nautogen是默认RP，duration=infinite\nduration: 存储的数据时间间隔\nreplication: 存储的数据副本数量\nshow retention policies on \u0026quot;\u0026lt;database\u0026gt;\u0026quot; create retention policy \u0026quot;\u0026lt;rp_name\u0026gt;\u0026quot; on \u0026quot;\u0026lt;database\u0026gt;\u0026quot; duration 30d replication 1 default drop retention policy \u0026quot;\u0026lt;rp_name\u0026gt;\u0026quot; on \u0026quot;\u0026lt;database\u0026gt;\u0026quot; CQ 对超过保存策略指定时间的数据，可以做统计采样.(类似于store procedure).\nCQ不能更新，只能删除重建．\nshow continuous queries create continuous query \u0026lt;CQ_name\u0026gt; on \u0026lt;database\u0026gt; begin SELECT \u0026lt;function[s]\u0026gt; INTO \u0026lt;destination_measurement\u0026gt; FROM \u0026lt;measurement\u0026gt; [WHERE \u0026lt;stuff\u0026gt;] GROUP BY time(\u0026lt;interval\u0026gt;)[,\u0026lt;tag_key[s]\u0026gt;] end DROP CONTINUOUS QUERY \u0026lt;cq_name\u0026gt; ON \u0026lt;database_name\u0026gt; Best Practice select 1-(mean(\u0026quot;part\u0026quot;) / mean(\u0026quot;all\u0026quot;)) as \u0026quot;rate\u0026quot; from ( select sum(\u0026quot;value\u0026quot;) as \u0026quot;smart\u0026quot; from \u0026quot;jobs_type\u0026quot; where \u0026quot;type\u0026quot;='smart' and $timeFilter ),( select sum(\u0026quot;value\u0026quot;) as \u0026quot;all\u0026quot; from \u0026quot;jobs_type\u0026quot; where \u0026quot;type\u0026quot;='reversinglab' and $timeFilter ) group by time($__interval) fill(none) ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Kapacitor",
    "permalink": "https://canuxcheng.com/post/metrics_kapacitor/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"kapacitor\"\u003eKapacitor\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/influxdata/Kapacitor\"\u003ehttps://github.com/influxdata/Kapacitor\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eOpen source framework for processing, monitoring, and alerting on time series data\u003c/p\u003e\n\u003cp\u003e可以通过chrongraf创建tickscript/task, 然后通过api/cli导入到kapacitor.\u003c/p\u003e\n\u003cp\u003e配置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehostname = \u0026quot;kapcitor-service\u0026quot;\n\n# 如果从influxdb读取数据需要配置该选项．\n[[influxdb]]\nenabled = true\n\n# 如果从该路径加载tickscript\n[[load]]\nenabled = true\ndir=\u0026quot;/etc/kapacitor/load\u0026quot;\n# tasks, 放到/etc/kapacitor/load/tasks/*.tick,重启kapacitor会自动加载task,并默认enable.\n## 要求，ID和tick文件同名，tickscript开头需要指定dbrp, tickscript里面需要指定batch/stream.\n# templates...\n# handlers...\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"cli\"\u003eCLI\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ kapacitor help\n\n# 创建template(也就是变量可以单独赋值的tickscript)\n$ kapacitor define-template \u0026lt;name\u0026gt; -tick /path/template.tick\n$ kapacitor show-template \u0026lt;name\u0026gt;\n\n# 创建/更新 task, 创建的默认是disable状态.\n# 从tickscript创建task\n$ kapacitor define \u0026lt;name\u0026gt; -tick task.tick -type [stream|batch] -dbrp [database.retentionPolicy]\n# 从template创建task(如果yaml/json中没有指定template需要用-template指定)\n$ kapacitor define \u0026lt;name\u0026gt; -file task.yaml\n$ kapacitor define \u0026lt;name\u0026gt; -file task.json\n\n# 删除task\n$ kapacitor delete [task id/name]\n\n$ kapacitor list tasks/templates\n$ kapacitor reload [task id/name] # 相当于disable \u0026amp; enable.\n$ kapacitor enable [task id/name]\n$ kapaciror disable [task id/name]\n$ kapacitor show [id/name]\n$ kapacitor watch [task id/name]\n\n$ kapacitor list topics\n$ kapacitor delete topics [topic id]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"http-api\"\u003eHttp API\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eport = 9092\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"configuration\"\u003econfiguration\u003c/h2\u003e\n\u003cp\u003e获取所有可以overwrite的参数\u003c/p\u003e",
    "content": "Kapacitor https://github.com/influxdata/Kapacitor\nOpen source framework for processing, monitoring, and alerting on time series data\n可以通过chrongraf创建tickscript/task, 然后通过api/cli导入到kapacitor.\n配置:\nhostname = \u0026quot;kapcitor-service\u0026quot; # 如果从influxdb读取数据需要配置该选项． [[influxdb]] enabled = true # 如果从该路径加载tickscript [[load]] enabled = true dir=\u0026quot;/etc/kapacitor/load\u0026quot; # tasks, 放到/etc/kapacitor/load/tasks/*.tick,重启kapacitor会自动加载task,并默认enable. ## 要求，ID和tick文件同名，tickscript开头需要指定dbrp, tickscript里面需要指定batch/stream. # templates... # handlers... CLI $ kapacitor help # 创建template(也就是变量可以单独赋值的tickscript) $ kapacitor define-template \u0026lt;name\u0026gt; -tick /path/template.tick $ kapacitor show-template \u0026lt;name\u0026gt; # 创建/更新 task, 创建的默认是disable状态. # 从tickscript创建task $ kapacitor define \u0026lt;name\u0026gt; -tick task.tick -type [stream|batch] -dbrp [database.retentionPolicy] # 从template创建task(如果yaml/json中没有指定template需要用-template指定) $ kapacitor define \u0026lt;name\u0026gt; -file task.yaml $ kapacitor define \u0026lt;name\u0026gt; -file task.json # 删除task $ kapacitor delete [task id/name] $ kapacitor list tasks/templates $ kapacitor reload [task id/name] # 相当于disable \u0026amp; enable. $ kapacitor enable [task id/name] $ kapaciror disable [task id/name] $ kapacitor show [id/name] $ kapacitor watch [task id/name] $ kapacitor list topics $ kapacitor delete topics [topic id] Http API port = 9092 configuration 获取所有可以overwrite的参数\nGET /kapacitor/v1/config 获取section/option参数\nGET /kapacitor/v1/config/smtp GET /kapacitor/v1/config/smtp/ GET /kapacitor/v1/config/influxdb GET /kapacitor/v1/config/influxdb/localhost POST /kapacitor/v1/config/smtp/ { \u0026quot;set\u0026quot;:{ \u0026quot;enabled\u0026quot;: true } } 操作task:\n// 修改已存在的task的参数: $ curl -H 'content-type: application/json' -X PATCH -d '{\u0026quot;vars\u0026quot;: {\u0026quot;warn\u0026quot;:{\u0026quot;value\u0026quot;:90, \u0026quot;type\u0026quot;:\u0026quot;int\u0026quot;}}}' http://kapacitor-service:9092/kapacitor/v1/tasks/cpu 操作alert:\n// 列出所有topic: $ curl -H 'content-type: application/json' -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics // 列出指定topic的所有events: $ curl -H 'content-type: application/json' -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics/\u0026lt;topic\u0026gt;/events // 列出指定events $ curl -H 'content-type: application/json' -X GET http://kapacitor-service:9092/kapacitor/v1/alerts/topics/\u0026lt;topic\u0026gt;/events/\u0026lt;event\u0026gt;?min-level=CRITICAL TICKscript 注释:\n// comment tickscript字符串用单引号和三单引号表示.\nvar a = 'test' var b = '''test1 test2''' Keywords:\nTRUE FALSE AND OR lambda var dbrp operator:\n+ - * / 算数运算 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 比较运算 =~ !~ 正则表达式匹配和不匹配 ! AND OR 逻辑运算 chaining operators:\n| chaining method (constructor) . property method (property methods \u0026amp; event handlers) @ User Define Function status:\n0 -\u0026gt; OK 1 -\u0026gt; INFO 2 -\u0026gt; WARN 3 -\u0026gt; CRIT node node是tickscript中的复杂数据结构．\n两个顶级node类型是stream和batch\nbatch是定时查询influxdb.\nstream是通过订阅influxdb,写入到influxdb的数据也会写入kapacitor.\nconstructor调用相应的property methods.\nstream var data = stream |from()... property methods:\nquiet() chaining methods:\nDeadman From Stats batch var data = batch |query()... property methods:\nquiet() chaining methods:\nDeadman Query Stats alert alert有三种类型: threshold, relative, deadman.\nvar alert = data |eval()... |alert() .id('{{ index .Tags \u0026quot;\u0026lt;tag-key\u0026gt;\u0026quot; }}') .message('{{ .ID }} {{ .Level }} {{ index .Fields \u0026quot;\u0026lt;field-key\u0026gt;\u0026quot; }} {{ .Time }}') .details(...) ... constructor:\nalert() property methods:\nid() # 定义alert的ID message() # 相当于email的subject. details() # html格式的警告信息，相当于email的body. info() infoReset() warn() warnReset() crit() critReset() email() log() # 将json格式的alert存放到文件． idTag idField levelTag() levelField() durationField() messageField() post() tcp() all() # period里面所有值都满足条件才alert topic() flapping() history() inhibit(\u0026lt;category\u0026gt;, \u0026lt;tags\u0026gt;) // 忽略一类告警 quiet() noRecoveries() # 不要发恢复(OK)的警告 stateChangesOnly() # 状态改变才发警告,OK/INFO/WARNING/CRITICAL category() message/details event data:\n# 通过property methods定义一些变量 ID -\u0026gt; {{ .ID }} Name -\u0026gt; measurement TaskName -\u0026gt; task name Group -\u0026gt; groupBy Tags -\u0026gt; {{.Tags}} {{index .Tags \u0026quot;\u0026lt;tag_key\u0026gt;\u0026quot;}} Fields -\u0026gt; {{.Fields}} {{index .Fields \u0026quot;\u0026lt;field_key\u0026gt;\u0026quot;}} Message Details Time -\u0026gt; {{ .Time }} Duration -\u0026gt; {{ .Duration }} Level -\u0026gt; {{ .Level }} Data Recoverable query constructor:\nquery(q string) property methods:\nfill() align() alignGroup() groupBy() cron() every() period() quiet() from constructor:\nfrom() property methods:\ndatabase() retentionPolicy() measurement() where() groupBy() round() truncate() quiet() window constructor:\nwindow() property methods:\nevery() period() align() quiet() Log constructor:\nlog() property methods:\nlevel() prefix() quiet() influxDBOut constructor:\ninfluxDBOut() property methods:\ncreate() ... handler handler是用来处理alert的工具, 最常用的是email\nhandler可以调用相应的options.\nemail options:\nto(\u0026quot;\u0026lt;email_address\u0026gt;\u0026quot;) 需要配置smtp\n[smtp] enabled = true host = \u0026quot;localhost\u0026quot; # 一般postfix/mailutils和kapacitor安装到同一台server port = 25 from = \u0026quot;canuxcheng@gmail.com\u0026quot; # 必须配置 to = [\u0026quot;\u0026quot;] # 可以在tickscript中指定, tickscript不指定，就用该配置. global = true # 开启后,tickscript中不用指定handler,默认都是发邮件. log options:\npath mode 写入到log.\nslack post tcp ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Prometheus",
    "permalink": "https://canuxcheng.com/post/metrics_prometheus/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"prometheus\"\u003ePrometheus\u003c/h1\u003e\n\u003cp\u003ePrometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询\u003c/p\u003e\n\u003cp\u003eswarm部署:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/vegasbrianc/prometheus\"\u003ehttps://github.com/vegasbrianc/prometheus\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ek8s部署:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/coreos/kube-prometheus\"\u003ehttps://github.com/coreos/kube-prometheus\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/coreos/prometheus-operator\"\u003ehttps://github.com/coreos/prometheus-operator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/helm/charts/tree/master/stable/prometheus-operator\"\u003ehttps://github.com/helm/charts/tree/master/stable/prometheus-operator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e高可用:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/thanos-io/thanos\"\u003ehttps://github.com/thanos-io/thanos\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eprometheus grafana dashboard:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kubernetes-monitoring/kubernetes-mixin\"\u003ehttps://github.com/kubernetes-monitoring/kubernetes-mixin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/grafana/kubernetes-app\"\u003ehttps://github.com/grafana/kubernetes-app\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"promql\"\u003ePromQL\u003c/h1\u003e\n\u003cp\u003emetrics类型:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecounter计数器\u003c/li\u003e\n\u003cli\u003egauge仪表盘\u003c/li\u003e\n\u003cli\u003ehistogram直方图\u003c/li\u003e\n\u003cli\u003esummary摘要\u003c/li\u003e\n\u003c/ol\u003e",
    "content": "Prometheus Prometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询\nswarm部署:\nhttps://github.com/vegasbrianc/prometheus\nk8s部署:\nhttps://github.com/coreos/kube-prometheus\nhttps://github.com/coreos/prometheus-operator\nhttps://github.com/helm/charts/tree/master/stable/prometheus-operator\n高可用:\nhttps://github.com/thanos-io/thanos\nprometheus grafana dashboard:\nhttps://github.com/kubernetes-monitoring/kubernetes-mixin\nhttps://github.com/grafana/kubernetes-app\nPromQL metrics类型:\ncounter计数器 gauge仪表盘 histogram直方图 summary摘要 ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Telegraf",
    "permalink": "https://canuxcheng.com/post/metrics_telegraf/",
    "date": "2018-01-18",
    "summary": "\u003ch1 id=\"telegraf\"\u003eTelegraf\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/influxdata/telegraf\"\u003ehttps://github.com/influxdata/telegraf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe plugin-driven server agent for collecting \u0026amp; reporting metrics.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"configuartion\"\u003eConfiguartion\u003c/h1\u003e\n\u003cp\u003eagent configuration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterval    所有inputs的默认运行间隔\nround_interval\ncollection_jitter\nprecision    ns/us/ms/s\nflush_interval\nflush_jitter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einput configuration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterval\nname_override # 默认measurements是插件名,修改默认measurements.\nname_prefix\nname_suffix\ntags\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"go-api\"\u003eGo API\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://godoc.org/github.com/influxdata/telegraf#Input\"\u003ehttps://godoc.org/github.com/influxdata/telegraf#Input\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e测试插件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 需要配置文件\n$ telegraf --input-filter \u0026lt;plugin-name\u0026gt; --test\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"build\"\u003eBuild\u003c/h1\u003e\n\u003cp\u003e安装依赖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo apt-get install ruby-dev\nsudo gem install fpm\nsudo apt-get install rpm\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e编译telegraf:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emake telegraf\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成配置文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e./telegraf config \u0026gt; ./etc/telegraf.conf\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e构建deb:\u003c/p\u003e",
    "content": "Telegraf https://github.com/influxdata/telegraf\nThe plugin-driven server agent for collecting \u0026amp; reporting metrics.\nConfiguartion agent configuration:\ninterval 所有inputs的默认运行间隔 round_interval collection_jitter precision ns/us/ms/s flush_interval flush_jitter input configuration:\ninterval name_override # 默认measurements是插件名,修改默认measurements. name_prefix name_suffix tags Go API https://godoc.org/github.com/influxdata/telegraf#Input\n测试插件：\n# 需要配置文件 $ telegraf --input-filter \u0026lt;plugin-name\u0026gt; --test Build 安装依赖：\nsudo apt-get install ruby-dev sudo gem install fpm sudo apt-get install rpm 编译telegraf:\nmake telegraf 生成配置文件：\n./telegraf config \u0026gt; ./etc/telegraf.conf 构建deb:\nmake package Development 修改默认enable的plugin:\n# plugin中相应的sampleConfig中的字段不要用#注释． internal/config/config.go -\u0026gt; 可以修改默认enable的plugin. inputDefaults outputDefaults 调试：\n./telegraf --config ./etc/telegraf.conf --input-filter process --test 添加debugxinxi\nimport \u0026quot;log\u0026quot; log.Printf(\u0026quot;D! key: %v\u0026quot;, value) # \u0026quot;D!\u0026quot; 开头的信息当debug=true才会打印. ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Contribution",
    "permalink": "https://canuxcheng.com/post/go_oss/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"golang-contribution\"\u003eGolang Contribution\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://go.dev/doc/contribute\"\u003ehttps://go.dev/doc/contribute\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"创建google账号\"\u003e创建google账号\u003c/h2\u003e\n\u003cp\u003e推荐申请一个google邮箱。\u003c/p\u003e\n\u003cp\u003e在开发机配置git\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git config --global user.email name@example.com   \n$ git config user.email name@example.com            \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"签cla\"\u003e签CLA\u003c/h2\u003e\n\u003cp\u003e个人开发者需要签署CLA。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://cla.developers.google.com/about/google-individual\"\u003ehttps://cla.developers.google.com/about/google-individual\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"配置git认证\"\u003e配置git认证\u003c/h2\u003e\n\u003cp\u003e点击“Generate Password”， 用google邮箱登陆，根据提示配置git。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://go.googlesource.com/\"\u003ehttps://go.googlesource.com/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"创建gerrit账号\"\u003e创建gerrit账号\u003c/h2\u003e\n\u003cp\u003e用google邮箱登陆即可。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://go-review.googlesource.com/dashboard/self\"\u003ehttps://go-review.googlesource.com/dashboard/self\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装git-codereview\"\u003e安装git-codereview\u003c/h2\u003e\n\u003cp\u003ewindows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get golang.org/x/review/git-codereview@latest\n$ git --exec-path\n\n\u0026gt; copy git-codereview.exe from GOBIN to Git\\mingw64\\libexec\\git-core\n\n$ git codereview help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elinux/mac:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go install golang.org/x/review/git-codereview@latest\n$ git codereview help\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"选取修改的cl\"\u003e选取修改的CL\u003c/h2\u003e\n\u003cp\u003e从github选取一个还没有人提交CL(change log/list)的Issue进行修改。\u003c/p\u003e\n\u003cp\u003eissue三种类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNeedsInvestigation\u003c/li\u003e\n\u003cli\u003eNeedsDecision\u003c/li\u003e\n\u003cli\u003eNeedsFix    选这个里面还没有CL的做\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22\"\u003ehttps://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"提交patch\"\u003e提交patch\u003c/h2\u003e\n\u003cp\u003e支持github或者gerrit提交patch。\u003c/p\u003e",
    "content": "Golang Contribution https://go.dev/doc/contribute\n创建google账号 推荐申请一个google邮箱。\n在开发机配置git\n$ git config --global user.email name@example.com $ git config user.email name@example.com 签CLA 个人开发者需要签署CLA。\nhttps://cla.developers.google.com/about/google-individual\n配置git认证 点击“Generate Password”， 用google邮箱登陆，根据提示配置git。\nhttps://go.googlesource.com/\n创建gerrit账号 用google邮箱登陆即可。\nhttps://go-review.googlesource.com/dashboard/self\n安装git-codereview windows:\n$ go get golang.org/x/review/git-codereview@latest $ git --exec-path \u0026gt; copy git-codereview.exe from GOBIN to Git\\mingw64\\libexec\\git-core $ git codereview help linux/mac:\n$ go install golang.org/x/review/git-codereview@latest $ git codereview help 选取修改的CL 从github选取一个还没有人提交CL(change log/list)的Issue进行修改。\nissue三种类型：\nNeedsInvestigation NeedsDecision NeedsFix 选这个里面还没有CL的做 https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22\n提交patch 支持github或者gerrit提交patch。\ngithub用户直接fork到自己账号，clone下来即可。\ngit clone https://github.com/golang/go.git gerrit用户\ngit clone https://go.googlesource.com/go 创建开发分支并修改代码\ngit checkout -b canux_dev ... git add -A git codereview change ... 本地测试修改\n./all.bash 提交修改，github用户直接去github页面提交PR。\ngerrit用户通过命令行提交：\n$ git codereview mail # send changes to Gerrit commit message格式有严格要求。\nhttps://golang.org/doc/contribute#commit_messages\ncode review 提交之后trybots会自动构建，可以通过build dashboard查看各个平台build结果:\nhttps://build.golang.org/\n查看自己的patch的review情况：\nhttps://go-review.googlesource.com/dashboard/self\n",
    "categories": ["Golang"],
    "tags": ["oss"]
  },
  {
    "title": "Debug",
    "permalink": "https://canuxcheng.com/post/go_debug/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"gdb\"\u003egdb\u003c/h1\u003e\n\u003ch1 id=\"delve\"\u003edelve\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/derekparker/delve\"\u003ehttps://github.com/derekparker/delve\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"debug\"\u003edebug\u003c/h1\u003e",
    "content": "gdb delve https://github.com/derekparker/delve\ndebug ",
    "categories": ["Golang"],
    "tags": ["debug"]
  },
  {
    "title": "Devops",
    "permalink": "https://canuxcheng.com/post/go_devops/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"go\"\u003eGo\u003c/h1\u003e\n\u003cp\u003ego有三种安装方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e源码安装\u003c/li\u003e\n\u003cli\u003e标准包安装\u003c/li\u003e\n\u003cli\u003e第三方工具安装\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eGOROOT:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGOROOT 就是go的安装目录\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewindows标准包安装go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emsi指定安装路径，自动添加%GOROOT%/bin到环境变量\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elinux标准包安装go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e下载.tar.gz包解压到/usr/local/go\nGOROOT=/usr/local/go\nexport PATH=$PATH:/usr/local/go/bin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e验证安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go --help\n$ go version\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第三方工具gvm安装go:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://github.com/moovweb/gvm\"\u003ehttp://github.com/moovweb/gvm\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ gvm install go1.9.2\n$ gvm use go1.9.2\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"gopath\"\u003eGOPATH\u003c/h1\u003e\n\u003cp\u003egopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．\u003c/p\u003e\n\u003cp\u003eGOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGOPATH=$USERPROFILE%go\nGOPATH=$HOME/go\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egopath结构：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esrc    存放源码\npkg    编译后的库文件\nbin    编译后生成的可执行文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egopath有多个值时用冒号分开即可.\u003c/p\u003e\n\u003ch1 id=\"gobin\"\u003eGOBIN\u003c/h1\u003e\n\u003cp\u003e默认值\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGOBIN=$HOME/go/bin\nexport PATH=$PATH:$HOME/go/bin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ego get 和 go install 安装的二进制到GOBIN。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"go命令\"\u003ego命令\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ go help [command]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eget\u003c/p\u003e",
    "content": "Go go有三种安装方式：\n源码安装 标准包安装 第三方工具安装 GOROOT:\nGOROOT 就是go的安装目录 windows标准包安装go:\nmsi指定安装路径，自动添加%GOROOT%/bin到环境变量 linux标准包安装go:\n下载.tar.gz包解压到/usr/local/go GOROOT=/usr/local/go export PATH=$PATH:/usr/local/go/bin 验证安装：\n$ go --help $ go version 第三方工具gvm安装go:\nhttp://github.com/moovweb/gvm\n$ gvm install go1.9.2 $ gvm use go1.9.2 GOPATH gopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．\nGOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:\nGOPATH=$USERPROFILE%go GOPATH=$HOME/go gopath结构：\nsrc 存放源码 pkg 编译后的库文件 bin 编译后生成的可执行文件 gopath有多个值时用冒号分开即可.\nGOBIN 默认值\nGOBIN=$HOME/go/bin export PATH=$PATH:$HOME/go/bin go get 和 go install 安装的二进制到GOBIN。\ngo命令 $ go help [command] get\n下载并安装包和依赖, 也就是安装第三方的库．\n$ go get [...] [packages] \u0026gt; go get安装第三方包如果出现依赖无法安装，可以通过github下载． $ cd golang.org/x $ git clone https://github.com/golang/crypto.git crypto $ go install golang.org/x/crypto/ssh go get -u (without any arguments) now only upgrades the direct and indirect dependencies of your current package, and no longer examines your entire module. go get -u ./... from your module root upgrades all the direct and indirect dependencies of your module, and now excludes test dependencies. go get -u -t ./... is similar, but also upgrades test dependencies. build\n编译包和依赖\n$ go build [-o output] [-i] [build flags] [packages] install\n编译并安装包和依赖\n$ go install [build flags] [packages] run\n编译并运行程序\n$ go run [...] gofiles... [...] fmt\n格式化代码和文档：\n$ go fmt [...] [packages] vet\n检测代码常见错误:\n$ go vet [-n] [-x] [build flags] [vet flags] [packages] test\n测试包:\n$ go test [...] [packages] [...] doc\n查看文档：\n$ go doc [package/symbol] tool\n运行工具:\n$ go tool [-n] command [args...] addr2line asm buildid cgo // 查看汇编代码 compile go tool compile -S pkg.go cover dist doc fix link nm objdump pack pprof test2json trace vet mod\ngo mod init \u0026lt;name\u0026gt; go mod tidy // 添加缺少的，删除多余的. go mod download // 下载包 go mod verify go mod edit go mod graph go mod why go mod vendor env\n// 通过env 设置golang的变量，取代系统环境变量 go env go env -w GOROOT=\u0026quot;/usr/local/go\u0026quot; go env -w GOPATH=\u0026quot;$HOME/go\u0026quot; go env -w GOBIN=\u0026quot;$HOME/go/bin\u0026quot; go env -w GO111MODULE=on clean\ngo clean -cache go clean -modcache 安装第三方包 go get的功能很有限．\ngodep和golide都会被官方的dep取代．\ndep(deprecated) https://github.com/golang/dep\n无法解决GFW的问题.\n安装：\n$ go get -u github.com/golang/dep/cmd/dep go官方包管理器\n# 初始化一个使用dep管理包的项目， # 创建Gopkg.toml, Gopkg.lock, vendor/ $ dep init $ dep status $ dep prune $ dep ensure $ dep ensure -update module vgo已经集成到go1.11\n通过go mod init初始化两个文件.\ngo.mod:\nmodule go require exclude replace // 使用本地module,或使用指定repo里面的module replace github.com/crazy-canux/go-devops =\u0026gt; /path/to/local/github.com/crazy-canux/go-devops go.sum:\ngo env -w GOSUMDB=off 设置相关环境变量:\nGO111MODULE: // auto/on/off go env -w GO111MODULE=on GOPROXY: go env -w GOPROXY=https://goproxy.cn,direct https://proxy.golang.org //默认值 https://goproxy.cn https://goproxy.io https://mirrors.aliyun.com/goproxy/ GOSUMDB: GOPRIVATE GONOPROXY GONOSUMDB 项目结构 cmd: 可执行文件入口 pkg: 核心代码库 api: api的spec, openapi/swagger/json/protocol/grpc hack: 构建/测试相关脚本 plugin: 插件 staging: wip third_party: 第三方工具/代码 vendor: 项目依赖 build test docs 没有子目录包结构：\ngo-devops |- README.md |- doc.go |- grafana.go |- grafana_test.go ... import \u0026quot;go-devops\u0026quot; 有子目录的包结构：\ngo-devops |- README.md |- doc.go // package go_devops |- grafana |- doc.go // package grafana |- grafana.go |- grafana_test.go import \u0026quot;go-devops/grafana\u0026quot; proxy goproxy.io\nhttps://github.com/goproxyio/goproxy\ngoproxy.cn\nhttps://github.com/goproxy/goproxy.cn\n",
    "categories": ["Golang"],
    "tags": ["devops"]
  },
  {
    "title": "Document",
    "permalink": "https://canuxcheng.com/post/go_document/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"document\"\u003eDocument\u003c/h1\u003e\n\u003cp\u003ego文档相关\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godoc.org/\"\u003ehttps://godoc.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ego文档的两种方式:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ego doc\u003c/li\u003e\n\u003cli\u003egodoc\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"go-doc\"\u003ego doc\u003c/h1\u003e\n\u003cp\u003e直接在命令行查看文档\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go doc [package/symbol]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"godoc\"\u003egodoc\u003c/h1\u003e\n\u003cp\u003ego自带的文档命令行接口,在浏览器查看文档\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egodoc package [name ...]\ngodoc -http=:6060\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过github的项目文档在:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttps://godoc.org\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"godev\"\u003ego.dev\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://pkg.go.dev\"\u003ehttps://pkg.go.dev\u003c/a\u003e\u003c/p\u003e",
    "content": "Document go文档相关\nhttps://godoc.org/\ngo文档的两种方式:\ngo doc godoc go doc 直接在命令行查看文档\n$ go doc [package/symbol] godoc go自带的文档命令行接口,在浏览器查看文档\ngodoc package [name ...] godoc -http=:6060 通过github的项目文档在:\nhttps://godoc.org go.dev https://pkg.go.dev\n",
    "categories": ["Golang"],
    "tags": ["document"]
  },
  {
    "title": "Go",
    "permalink": "https://canuxcheng.com/post/go/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"go概述\"\u003eGo概述\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://golang.org/ref/spec\"\u003ehttps://golang.org/ref/spec\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ego语言表达能力强，简洁，清晰，高效．\u003c/p\u003e\n\u003cp\u003ego是一个快速的，静态的，强类型的，编译型语言．\u003c/p\u003e\n\u003cp\u003ego具有高并发和垃圾回收功能.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"go基本语法\"\u003eGo基本语法\u003c/h1\u003e\n\u003cp\u003ego源程序叫*.go\u003c/p\u003e\n\u003cp\u003ego大小写敏感\u003c/p\u003e\n\u003cp\u003ego程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．\u003c/p\u003e\n\u003cp\u003ego中只有首字母大写的名称才能从包中导出．\u003c/p\u003e\n\u003cp\u003ego的类型在变量名后面．\u003c/p\u003e\n\u003cp\u003ego函数外的每个语句都必须以关键字开始.\u003c/p\u003e\n\u003cp\u003ego标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.\u003c/p\u003e\n\u003cp\u003ego使用大括号{}表示一个代码块.\u003c/p\u003e\n\u003cp\u003ego使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．\u003c/p\u003e\n\u003cp\u003ego的包名一般是小写的单个单词(文件所在的最后一层目录名).\u003c/p\u003e\n\u003cp\u003ego一般使用驼峰命名法.\u003c/p\u003e\n\u003cp\u003ego没有逗号操作符.\u003c/p\u003e\n\u003cp\u003ego中++/\u0026ndash;是语句不是表达式．\u003c/p\u003e\n\u003cp\u003ego中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"go注释\"\u003eGo注释\u003c/h1\u003e\n\u003cp\u003e单行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// comment\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/* comment */\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"go关键字\"\u003eGo关键字\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003evar const \nbreak continue for if else switch case default goto fallthrough\nfunc return defer\npackage import\nrange type struct map\ninterface\nselect go chan\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"go运算符和优先级\"\u003eGo运算符和优先级\u003c/h1\u003e\n\u003cp\u003ego中的运算都是从左到右结合．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e^    #\n!    # 逻辑非\n\n*\n/    # 结果取整数\n%\n\u0026lt;\u0026lt;   # 位运算，左移\n\u0026gt;\u0026gt;   # 位运算，右移\n\u0026amp;    # 位运算，　按位与\n\u0026amp;^   #\n\n+\n-\n|    # 位运算,按位或\n^    # 位运算,按位异或\n\n==\n!=\n\u0026lt;\n\u0026lt;=\n\u0026gt;\n\u0026gt;=\n\n\u0026lt;- # chan运算符\n\n\u0026amp;\u0026amp;   # 逻辑与\n||   # 逻辑或\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"go数据类型\"\u003eGo数据类型\u003c/h1\u003e\n\u003ch2 id=\"变量\"\u003e变量\u003c/h2\u003e\n\u003cp\u003e定义/申明变量:\u003c/p\u003e",
    "content": "Go概述 https://golang.org/ref/spec\ngo语言表达能力强，简洁，清晰，高效．\ngo是一个快速的，静态的，强类型的，编译型语言．\ngo具有高并发和垃圾回收功能.\nGo基本语法 go源程序叫*.go\ngo大小写敏感\ngo程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．\ngo中只有首字母大写的名称才能从包中导出．\ngo的类型在变量名后面．\ngo函数外的每个语句都必须以关键字开始.\ngo标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.\ngo使用大括号{}表示一个代码块.\ngo使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．\ngo的包名一般是小写的单个单词(文件所在的最后一层目录名).\ngo一般使用驼峰命名法.\ngo没有逗号操作符.\ngo中++/\u0026ndash;是语句不是表达式．\ngo中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.\nGo注释 单行注释：\n// comment 多行注释：\n/* comment */ Go关键字 var const break continue for if else switch case default goto fallthrough func return defer package import range type struct map interface select go chan Go运算符和优先级 go中的运算都是从左到右结合．\n^ # ! # 逻辑非 * / # 结果取整数 % \u0026lt;\u0026lt; # 位运算，左移 \u0026gt;\u0026gt; # 位运算，右移 \u0026amp; # 位运算，　按位与 \u0026amp;^ # + - | # 位运算,按位或 ^ # 位运算,按位异或 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= \u0026lt;- # chan运算符 \u0026amp;\u0026amp; # 逻辑与 || # 逻辑或 Go数据类型 变量 定义/申明变量:\n通过关键字var在包或函数中申明/定义变量\n在函数或块中定义的变量作用域就是当前函数或当前块。\n在函数外部定义的全局变量作用域是整个包.\n大写字母开头的全局变量能被其它包引用。\n全局变量必须使用var关键字．\n没有初始化的变量在申明的时候赋予零值.\n已经申明但没有使用的变量在编译时会报错．\n通过等号给变量赋值就是定义变量.\n大写字母开头的变量是public, 小写字母开头的是private变量.\n申明变量:\n# 一个变量一种类型 var varname Type # 多个变量一种类型 var varname varname1 ... Type 定义(初始化)变量:\n# 定义的时候初始化 var i, j int = 1, 2 # 初始化使用表达式可以省略类型，从值中获取类型 var i, j = true, \u0026quot;str\u0026quot; # 多个变量多种类型 var ( var1 Type1 = val1 var2 Type2 = val2 # 给类型取别名 variable alias Type = value ... ) 特殊变量：\n_ # 下划线是个特殊变量名，用于忽略一个值. 常量 定义常量：\n通过关键字const在包或函数中定义常量．\n# 常量可以是bool, string, 数值 const Pi float = 3.14 const World = \u0026quot;China\u0026quot; const Truth = true # 定义多个常量 const ( Pi = 3.14 ... ) 枚举:\n# iota内置常量用来统计枚举中的行数 const ( con = val ... ) 常量不能用:=语法来申明。\nbool bool类型变量的零值是false.\nbool类型是值传递．\ntrue false 数值类型 数值类型变量的零值是0.\n数值类型是值传递.\n有符号类型：\nint int8 int16 int32(rune) int64 无符号类型:\nuint uint8(byte) uint16 uint32 uint64 uintptr int, uint, uintptr 在32位系统是32bit, 在64位系统是64bit\n浮点类型：\nfloat32 float64 复数类型：\ncomplex64 complex128 string string类型变量的零值是\u0026quot;\u0026quot;.\nstring类型是值传递.\ngo中的字符串都采用utf-8编码.\ngo中的字符串用双引号 或者　反引号\n# 单行字符串 var str string = \u0026quot;hello\u0026quot; # 多行字符串(原样输出) var str string = `hello world` var str = \u0026quot;hello\u0026quot; // 类型可以通过值确定 go中的字符串是不可变的, 修改字符串：\n# 使用类型转换 var str string = \u0026quot;hello\u0026quot; c := []byte(str) # str转换成 []byte 类型 c[index] = value # 重新赋值 newString := string(c) # []byte 转换成 string # 使用索引运算 s := \u0026quot;hello\u0026quot; s = \u0026quot;str\u0026quot; + s[1:] 字符串运算：\ns1 := \u0026quot;hello\u0026quot; s2 := \u0026quot;world\u0026quot; s3 := s1 + s2 遍历字符串：\nfor index, value := range s {...} for index := range s {...} for _, value := range s {...} 结构体/struct 结构体就是字段的集合．结构体字段通过点操作符来访问．\n结构体是值传递.\n申明一个结构体类型：\ntype StructName struct { var Type var1 Type1 ... } 申明多个结构体类型:\ntype ( StructB struct { ... } StructB struct { } ) 申明一个结构体类型的变量\nvar s StructName 定义结构体变量:\n# 列出全部字段 var s = StructName{val, ...} s := StructName{val, ...} # 使用val: 可以仅列出部分字段, 未列出的字段使用默认值 var s = StructName{ var: val, ... } s := StructName{ var: val, ... } # 给字段赋值 s.var1 = value 结构体指针:\ntype StructName struct { var Type var1 Type1 } var s = \u0026amp;StructName{} s := \u0026amp;StructName{} (*s).Var1 = val1 s.Var1 = val1 // go允许隐士间接引用 s := StructName{val, val1} p := \u0026amp;s # 原本应该通过(*p).var来访问，go允许隐式间接引用． p.var = p.var1 指针/pointer 指针的零值为nil.\ngo的指针保存了值的内存地址, go没有指针运算．\n通过指针实现引用传递.\n申明一个指针变量：\nvar point *int \u0026amp;操作符会生成一个指向其操作数的指针(保存变量的地址)：\npoint = \u0026amp;variable *操作符表示指针指向的数值(读写该地址保存的值：\n*point = value 数组/array 数组通过下标来访问．数组不能改变大小（长度）\n数组是值传递．\n数组的属性有类型和长度,只有长度和类型都相同的才是同类型数组,才能相互赋值.\n数组长度和容量相同．\n申明数组:\nvar ArrayName [number]Type 定义数组：\nvar ArrayName = [number]Type{} ArrayName := [number]Type{val, val1, ...} ArrayName := [number]Type{index: value, ...} // 给指定索引赋值,其余为零值 ArrayName := []Type{val, ...} // 容量也可以由初始化的元素个数决定. ArrayName := [number]*Type{0: new(int), 1: new(string), ...} // 指针数组 数组元素赋值：\nArrayName[0] = val *ArrayName[0] = val // 指针数组 数组赋值（值传递）：\n# 只有类型和长度相同的数组才能赋值 # 非指针数组赋值，会另外开辟地址空间. # 修改newArray的值，不会改变ArrayName的值 newArray = ArrayName # 指针类型的数组赋值，指向的是相同的地址. 多维数组(嵌套数组):\ndoubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6 7, 8}} 遍历数组：\nfor index, value := range a { fmt.Println('%d, %d\\n', index, value) } # 只要索引, 去掉,value即可 for index := range a {...} # 只要值，用_忽略索引 for _, value := range a {...} 切片/slice 切片的零值是nil, nil切片的长度和容量都是０，且没有底层数组．\n切片传递的是地址(引用传递),修改切片的元素值其实就是修改底层数组的对应的元素的值,共享该元素的其它切片的值也相应改变．\n切片的属性包括指向底层数组的指针，切片的长度，切片的容量.\n切片不存储数据，只是描述数组的一段,因此切片不指定大小（长度）.\n# 表示切片类型 []Type 申明切片:\nvar SliceName []Type 定义切片：\n// 通过字面量定义 var SliceName = []Type{} SliceName := []Type{val, val1, ...} SliceName := []Type{index: value} // 索引就表示长度和容量 // 通过make函数创建切片 var SliceName = make([]type, len, cap) SliceName := make([]Type, len, cap) 通过切片定义新切片:\n切片的操作返回新的切片。 NewS := SName[i:j] cap(SName) = k NewS 长度和容量： len = j-i cap = k-i NewS 无法访问指向的底层数组第一个元素之前的元素。 也不能访问超出长度之后的索引,但是可以通过append增加切片长度之后访问. NewS[index] //当index \u0026gt;= j编译器报错 ，超出了NewS 的长度，无法访问。 三索引操作:\nNewS := SName[i:j:k] 三索引表示容量， i:j 表示长度， i:k 表示容量. 容量不能超过可用容量(也就是SName的容量). 切片操作：\n# 半开区间，不包括最后一个下标 s[low:high] s[:high] // low=0, default s[low:] // high=max, default s[:] // s[0:max], default s[:0] // 把切片的长度变为０（清空切片) s[:4] // 扩展为４ s[2:] // 扩展为 arrayname[2:4] 二维切片：\n[][]Type 遍历切片：\n# 切片遍历和数组相同 for index, value := range s { ... } for index := range s {...} for _, value := range s {...} slice作为函数参数:\n切片作为函数参数，传递的其实是值,函数会使用和切片相同的底层数组创建一个新的切片来操作. 所以函数内部修改了切片的值,作为参数的切片的值也被修改了. 映射/map 映射的零值是nil, 既没有键，也不能添加键．\nmap是引用传递．是存储键值对的无序集合.\nmap是无序的，只能通过key索引，没有下标操作.\nmap的key需要支持==或!= 运算，不能是函数，映射，切片\n申明:\n// 申明值为nil的空映射，不能用于存储键值对. var MapName map[keyType]ValueType 定义映射：\nvar MapName = map[keyType]ValueType{} var MapName = map[keyType]ValueType{ key: value, ... } MapName := map[keyType]valueType{} MapName := map[KeyType]ValueType{ \u0026quot;key\u0026quot;: value, ... } # 通过make定义map var MapName = make(map[keyType]ValueType, cap) MapName := make(map[keyType]ValueType, cap) 映射操作：\nm[key] = value value = m[key] # 若key在m中ok为true, 否则为false, 且value是对应类型的零值 value, ok := m[key] 遍历映射：\nfor key, value := range m {...} for key := range m {...} for _, value := range m {...} map作为函数参数:\n不会创建该映射的副本，该函数对映射的修改就是对原始参数指向的映射的修改. 类型转换 go中兼容的类型才能转换，而且必须显示转换．\nValueA [:]= TypeA(ValueB) floatA := float64(uint64Var) others any\ncomparable\nbyte\nerror\nGo控制流 go控制流的左大括号不能另起一行．\ngolang没有内置的while循环。\nfor循环 go只有for可以循环．\nfor i := 0; i \u0026lt; 10; i++ { sum += i } for循环有三种模式：\nfor循环后面没有小括号，代码块必须要大括号．\nfor init; condition; statement { ... } for循环的初始化语句init和后置语句statement可以省略,相当于while．\nfor condition { ... } 无限循环, 相当于for(;;)：\nfor { ... } if条件语句 if后面的小括号不要，但是代码块需要大括号．\nif condition { ... } else if condition { ... } else { ... } switch条件语句 go中的switch-case的variable无需为常量，且取值可以不是整数．\ngo中的只执行匹配的case，相当于默认在每个case后面加了break语句．\ncase匹配到的语句如果只有一行可以和case语句写在同一行\nswitch variable { case value1: ... case value2: expression default: ... } 多个条件可以放到一个case:\nswitch variable { case value1, value2, ...: expression case valuen: fallthrough defalut: ... } 没有条件的switch-case\nswitch { case condition: ... ... } 如果不需要默认的break,需要添加fallthrough:\nfallthrough不会判断后面的case的condition,而是直接执行后面所有的case.\nswitch variable { case val1: ... fallthrough ... } label golang的label不需要缩进:\nLabelName: break break用于跳出for/switch/select循环.\nbreak break也支持label:\nbreak的label可以跳出外层循环.\nbreak [tag] label: for i := 0; i \u0026lt; 1000; i++ { for j :=0; j \u0026lt; 1000; j++ { if j \u0026lt; i { break label // 跳出最外层循环. } } } continue continue语句只能在for循环中使用\ncontinue continue也支持label:\ncontinue的label可以从外层循环继续执行.\ncontinue [tag] next: for outer := 2; outer \u0026lt; 3000; outer++ { for inner :=2; inner \u0026lt; outer; inner++ { if outer%inner == 0 { continue next // 并非继续内存循环，而是从外层循环继续执行. } } } goto goto跳转语句，跳转到指定标签运行．\n标签区分大小写.\nLabel: expression ... goto Label continue LABEL break LABEL ... Go函数 函数的零值是nil.\n函数是引用类型.\n大写字母开头的函数是public, 小写字母开头的是private.\n创建函数：\nfunc FuncName(var Type, var1 Type1) rType { ... return ... } 多值返回：\nfunc FuncName(var Type) (rType, rType1, ...) { ... return ... } 命名返回值(必须用括号)：\n// 一般return后面不带返回值，否则需要返回定义的所有变量 func FuncName(var Type) (rvar rType, rvar1 rType) { ... rvar = ... rvar1 = ... return } 多个变量类型相同时保留最后一个的类型即可：\nfunc FuncName(var, var1 Type) (rvar, rvar1 rType) { ... return ... } 变量作用域：\n函数内部定义的变量是局部变量 函数外定义的变量是全局变量． 局部变量优先使用． 形式参数：\n形式参数的作用域范围和函数体中的局部变量一致． 返回值：\n函数返回值的作用域范围和函数体中的局部变量一致． 实际参数：\n实际参数可以是值传递，也可以是引用传递． 指针参数：\n# 实参必须是指针才能调用该函数 func FuncName(v *Type) rType { ... } 函数中短变量申明(局部变量):\n# 在函数内部，明确值的类型的情况下可以用 := 代替var关键字定义变量 func FuncName() { variable := value var1, var2, ... := val1, val2, ... } 重复申明短变量：\n本次申明与已申明的变量在同一作用域． 在初始化中与已申明的变量类型相同才能赋值． 本次申明中至少另有一个变量是新申明的． defer关键字：\ndefer会将函数推迟到外层函数返回之后执行.\n推迟调用的函数其参数会立即求值，然后压入defer栈中,外层函数返回后按照后进先出的顺序调用．\nfunc FuncOut() { ... defer FuncName() ... } 函数也是值，也可以传递，可以用作函数的参数或返回值：\nfunc FuncName(variable func(Type, ...) rType) rType { ... } FuncName := func(variable Type, ...) rType { .. } 匿名函数:\nfunc(\u0026lt;arguments\u0026gt;) (returns) {}() 可变参数:\nfunc FuncName(vars ...Type) rType {} FuncName(vars..) closures/闭包:\ninit函数:\n# 每个包中可以有任意个init函数. # 这些init函数会在main函数执行之前调用. # init函数不能有参数和返回值 # main中的init最后调用. func init() {} Go文件和输入输出 go的标准库fmt实现了类似于C语言的printf和scanf格式化I/O函数.\n还有io和bufio标准库可用\n输入 输入的本质就是从Stdin读取\nfmt:\nvar input string fmt.Scan*(\u0026amp;input) bufio.Reader:\ninputReader := bufio.NewReader(os.Stdin) inputReader.Read*() 输出 输出的本质就是往os.Stdout写\nfmt:\nfmt.Print*() os.File:\nos.Stdout.Write*(\u0026quot;hello\u0026quot;) bufio.Writer:\noutputWriter := bufio.NewWriter(os.Stdout) outputWriter.Writer*() outputWriter.Flush() 文件 标准库os.File结构的指针用来表示文件句柄\n标准库bufio提供了带缓冲的操作\n读文件\nreadFile, err := os.Open(\u0026quot;filename\u0026quot;) readFile.Read*() inputReader := bufio.NewReader(readFile) inputReader.Read*('\\n') 写文件\nwriteFile, err := os.Create(\u0026quot;filename\u0026quot;) writeFile.Write*() outputWriter := bufio.NewWriter(outputFile) outputWriter.Write*(\u0026quot;string\u0026quot;) outputWriter.Flush() Go错误和异常 go的标准库errors实现了用于错误处理的函数.\n内置函数panic是断言函数，会触发一个异常，用于终止当前的线程(会在defer执行完之后终止线程)\n内置接口定义了error接口类型, error类型都有一个Error方法.\ntype error interface { Error() string } 定义错误:\nvar errName error = errors.New(\u0026quot;error message.\u0026quot;) err := errors.New(\u0026quot;error message.\u0026quot;) err := fmt.Errorf(format string, a ...interface{}) panic:\n相当于抛出一个异常，在运行完defer之后,返回到调用者继续运行defer，直到最外层的defer执行完毕，终止程序.\npanic(v interface{}) panic(\u0026quot;ERROR: command not found\u0026quot;) recover:\n只能用于defer修饰的函数，用于接收panic调用中传递过来的错误值,没有panic返回nil.\n当前函数的后面不会被执行，recover捕获异常之后会返回到调用者继续执行.\n相当于catch一个异常.\nrecover() interface{} defer func() { if err := recover(); err != nil { fmt.Println(e) // \u0026quot;ERROR: command not found\u0026quot; } }() 总结：\n在包内部，总是应该从panic中recover． 总是向包的调用者返回错误值，而不是panic. Go包 创建包：\n包名一般和所在路径的最后一层目录一致．一般是小写的单个单词.\n同一个目录中的代码文件使用同一个包名．\npackage pkg1 单个导入:\nimport \u0026quot;pkg1\u0026quot; import \u0026quot;pkg2\u0026quot; # 导入时创建别名 import alias \u0026quot;pkg\u0026quot; 组合导入:\nimport ( \u0026quot;pkg1\u0026quot; \u0026quot;pkg2\u0026quot; ... ) 包内的函数名首字母大些才能被其它包导入，否则就是私有的．\n命名导入:\nimport ( alias \u0026quot;pkg\u0026quot; # 给包取别名 ) 导入副作用：\n只执行导入包中的init函数并初始化全局变量，不导入其它内容．\n编译时不检查该导入是否使用.也不能通过包名调用其中的导出函数.\nimport _ \u0026quot;path/pkg\u0026quot; import ( _ \u0026quot;path/pkg\u0026quot; ) go包查找顺序:\n$GOROOT/src/... # 安装golang的路径里面的标准库 $GOPATH Go文档 通过注释编写文档，godoc会自动识别．对包，函数，类型，全局变量都可以.\n// this is documents func Fucntion() {} /* This is documents */ type St struct {} 也可以给包写一段文字较多的文档，通过在包内创建doc.go.\n这段文档会显示在所有其它文档之前．\n# vim doc.go /* This docs for package ... */ package pkg # 使用和包一样的名字. ",
    "categories": ["Golang"],
    "tags": ["golang"]
  },
  {
    "title": "Go_Concurrency",
    "permalink": "https://canuxcheng.com/post/go_concurrency/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"并发concurrency\"\u003e并发/concurrency\u003c/h1\u003e\n\u003cp\u003eCSP: communicating sequential processes, 通信顺序进程。\u003c/p\u003e\n\u003cp\u003ego的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.\u003c/p\u003e\n\u003cp\u003econcurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。\u003c/p\u003e\n\u003cp\u003e所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.\u003c/p\u003e\n\u003cp\u003eparallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。\u003c/p\u003e\n\u003cp\u003eprocess: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。\u003c/p\u003e\n\u003cp\u003ethread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。\u003c/p\u003e\n\u003cp\u003eco-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。\u003c/p\u003e\n\u003cp\u003egoroutine: go语言的协程，是并行的，通过channel来通信.\u003c/p\u003e\n\u003cp\u003eGMP: goroutine的实现模型。\u003c/p\u003e\n\u003cp\u003eG: goroutine。\u003c/p\u003e\n\u003cp\u003eM: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。\u003c/p\u003e\n\u003cp\u003eP: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。\u003c/p\u003e\n\u003cp\u003e不要通过共享内存通信，通过通信来共享内存。\u003c/p\u003e\n\u003ch2 id=\"goroutines\"\u003egoroutines\u003c/h2\u003e\n\u003cp\u003ego关键字会启动一个新的goroutine并执行.\u003c/p\u003e\n\u003cp\u003e每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。\u003c/p\u003e\n\u003cp\u003e当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.\u003c/p\u003e\n\u003cp\u003e当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego FuncName(...)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e主进程main结束了，goroutine也结束．\u003c/p\u003e\n\u003ch2 id=\"竟态\"\u003e竟态\u003c/h2\u003e\n\u003cp\u003erace condition: 竞争状态，多个goroutine同时操作同一资源.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 检测竞争状态\n$ go build -race\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以要解决goroutine间的消息传递和同步的问题.\u003c/p\u003e\n\u003cp\u003e通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。\u003c/p\u003e\n\u003cp\u003echannel还是mutex,选择的依据是他们的能力/特性.\u003c/p\u003e\n\u003cp\u003echannel的能力是让数据流动起来，擅长的是数据流动的场景:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e传递数据的所有权，即把某个数据发送给其他协程\u003c/li\u003e\n\u003cli\u003e分发任务，每个任务都是一个数据\u003c/li\u003e\n\u003cli\u003e交流异步结果，结果是一个数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003esync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e缓存\u003c/li\u003e\n\u003cli\u003e状态\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"channel\"\u003echannel\u003c/h2\u003e\n\u003cp\u003egoroutine通过channel来传递消息.\u003c/p\u003e\n\u003cp\u003echannels是引用类型,chan是线程安全的，并且不会有数据冲突。\u003c/p\u003e\n\u003cp\u003echannel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.\u003c/p\u003e\n\u003cp\u003echan通过make来创建，通过close来关闭．\u003c/p\u003e\n\u003cp\u003echan是先进先出的.\u003c/p\u003e\n\u003cp\u003e如果chan指定了容量(有缓存), 就是异步，非阻塞模式．\u003c/p\u003e\n\u003cp\u003e默认是无缓存的，同步的,　阻塞模式.\u003c/p\u003e",
    "content": "并发/concurrency CSP: communicating sequential processes, 通信顺序进程。\ngo的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.\nconcurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。\n所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.\nparallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。\nprocess: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。\nthread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。\nco-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。\ngoroutine: go语言的协程，是并行的，通过channel来通信.\nGMP: goroutine的实现模型。\nG: goroutine。\nM: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。\nP: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。\n不要通过共享内存通信，通过通信来共享内存。\ngoroutines go关键字会启动一个新的goroutine并执行.\n每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。\n当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.\n当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.\ngo FuncName(...) 主进程main结束了，goroutine也结束．\n竟态 race condition: 竞争状态，多个goroutine同时操作同一资源.\n# 检测竞争状态 $ go build -race 所以要解决goroutine间的消息传递和同步的问题.\n通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。\nchannel还是mutex,选择的依据是他们的能力/特性.\nchannel的能力是让数据流动起来，擅长的是数据流动的场景:\n传递数据的所有权，即把某个数据发送给其他协程 分发任务，每个任务都是一个数据 交流异步结果，结果是一个数据 sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:\n缓存 状态 channel goroutine通过channel来传递消息.\nchannels是引用类型,chan是线程安全的，并且不会有数据冲突。\nchannel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.\nchan通过make来创建，通过close来关闭．\nchan是先进先出的.\n如果chan指定了容量(有缓存), 就是异步，非阻塞模式．\n默认是无缓存的，同步的,　阻塞模式.\n申明一个变量:\nvar ChanName chan Type 定义一个chan:\nvar ch = make(chan Type, cap) ch := make(chan Type, cap) 操作chan:\nch \u0026lt;- v # 发送值到ch \u0026lt;- ch # 从ch接收值 v := \u0026lt;- ch # 从ch接收值并赋予Type类型变量v v, ok = \u0026lt;- ch # 从ch接收值，如果ch关闭或没有数据，ok就为false. 无缓冲的chan:\nch := make(chan Type) 无缓冲的chan生产者会阻塞unbuffered，直到消费者接收数据, 也就是说是同步的synchronous.\n只有消费者或者只有生产者的chan会导致死锁，产生panic.\n带缓冲的chan:\n带缓冲的chan，在缓冲区满之前，都不会阻塞buffered，是异步的asynchronous.\n只有通道中没有要接收的值，接收动作才会阻塞.\n只有在通道没有可用缓冲区容纳被发送的值，发送动作才会阻塞．\nch := make(chan Type, cap) // 带缓冲的chan可以通过range遍历 for i := range ch {...} chan的方向：\n默认chan都是双向的，但是也可以指定方向\n只接收的chan无法关闭\nvar recv_only chan\u0026lt;- Type 只发送的chan\nvar send_only \u0026lt;-chan Type 显示关闭chan:\n通道关闭后，不能再向通道发送值，但是已经发送的值可以被接收.\n// 一般在生产者(发送动作)关闭chan close(ch) // 如果chan关闭ok=false, v为零值. v, ok := \u0026lt;-ch sync 通过对资源上锁来保持同步.\ngolang的同步通过sync和sync/atomic两个包实现.\nselect 监听chan的数据流，类似于switch-case, 可用于处理多个chan的情况\n运行规则：\n每次执行select都只会执行一个case或者执行default；当有case可以执行，default不会执行；没有case执行时才执行default。\n当没有case或default可以执行，select阻塞等待。\n当有多个case可以执行，select随机选择一个执行。\ncase后面必须是读或写chan的操作，否则编译出错。\nselect { case condition1: do something case condition2: do something \u0026hellip; default: // default可以省略 do default thing. }\n退出goroutine for-range range能感知channel关闭，当channel被发送数据的goroutine关闭时，range就会结束，然后退出for循环。\ngo func(in \u0026lt;-chan int) { for x := range in { ... } }(inCh) for-select select有多路复用能力，for-select 可以持续处理多路多个channel的能力。但select不能感知channel的关闭.\n通道关闭退出goroutine：\ngo func() { for { select { case x, ok := \u0026lt;-in: if !ok { return } case \u0026lt;-t.C: ... } } } 某个通道关闭，不再处理该通道，但是继续处理其它channel,select不会在nil的通道上进行等待:\ngo func() { for { select { case x, ok := in1: if !ok { in1 = nil 把只读channel设置为nil,select不会在这里阻塞。 } case y, ok :=\u0026lt;-in2: if !ok { in2 = nil } if in1 == nil \u0026amp;\u0026amp; in2 == nil { return } } }() 使用专门channel发送退出信号,只需要在main中关闭channel，所有goroutine都会接收到信号退出:\ngo func() { for { select { case \u0026lt;- stopCh: ... return case \u0026lt;- t.C: ... } } }() ",
    "categories": ["Golang"],
    "tags": ["concurrency"]
  },
  {
    "title": "GSL_builtin",
    "permalink": "https://canuxcheng.com/post/gsl_builtin/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"builtin\"\u003ebuiltin\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://golang.org/pkg/builtin/\"\u003ehttps://golang.org/pkg/builtin/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ego的builtin package.\u003c/p\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etrue\nfalse\niota\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003cp\u003epointer, slice, map, channel, func, interface的零值：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enil\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# 分配并初始化各种类型的对象, 返回一个指针．\nnew(Type) *Type\n\n# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.\nmake(t Type, size ...IntegerType) Type\n\n# 返回容量，　Array/ArrayPointer/Slice/Channel\ncap(v Type) int\n\n# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel\nlen(v Type) int\n\nprint(args ...Type)\n\nprintln(args ...Type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecomplex:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 把两个浮点数构造成一个复数\ncomplex(r, i FloatType) ComplexType\n\n# 返回复数c的实部\nreal(c ComplexType) FloatType\n\n# 返回复数c的虚部\nimag(c ComplexType) FloatType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eslice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 向切片末尾追加元素，返回新的切片．切片长度增加.\n# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．\n# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.\nappend(slice []Type, elems ...Type) []Type\n\n# 复制一个切片, 返回复制的元素的个数\ncopy(dst, src []Type) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emap:\u003c/p\u003e",
    "content": "builtin https://golang.org/pkg/builtin/\ngo的builtin package.\nconstants true false iota variables pointer, slice, map, channel, func, interface的零值：\nnil functions # 分配并初始化各种类型的对象, 返回一个指针． new(Type) *Type # 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象. make(t Type, size ...IntegerType) Type # 返回容量，　Array/ArrayPointer/Slice/Channel cap(v Type) int # 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel len(v Type) int print(args ...Type) println(args ...Type) complex:\n# 把两个浮点数构造成一个复数 complex(r, i FloatType) ComplexType # 返回复数c的实部 real(c ComplexType) FloatType # 返回复数c的虚部 imag(c ComplexType) FloatType slice:\n# 向切片末尾追加元素，返回新的切片．切片长度增加. # 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变． # 在元素不超过1000的情况下，自动创建的底层数组容量翻倍. append(slice []Type, elems ...Type) []Type # 复制一个切片, 返回复制的元素的个数 copy(dst, src []Type) int map:\n# 从映射删除一个键值对 delete(m map[Type]1, key Type) chan:\n# 由发送者关闭一个双向或只发送的信道 close(c chan\u0026lt;- Type) error:\n# 停止当前go程的正常执行(断言函数) panic(v interface{}) # 管理panic过程中的go程 recover() interface{} types bool uint uintptr uint8/byte (0 - 255) uint16 uint32 uint64 int int8 (-128 - 127) int16 int32/rune int64 float32 float64 complex64 complex128 string 文档类型:\nType Type1 IntegerType FloatType ComplexType 错误处理:\nerror // go使用error值来表示错误状态，nil表示成功，非nil表示失败． type error interface { ERROR() string } ",
    "categories": ["Golang"],
    "tags": ["builtin"]
  },
  {
    "title": "GSL_concurrency",
    "permalink": "https://canuxcheng.com/post/gsl_concurrency/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"sync\"\u003esync\u003c/h1\u003e\n\u003cp\u003esync用于goroutine同步.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026quot;sync\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003ch2 id=\"locker\"\u003eLocker\u003c/h2\u003e\n\u003cp\u003e一个可以加锁和解锁的接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Locker interface {\n    Lock()\n    Unlock()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"pool\"\u003ePool\u003c/h2\u003e\n\u003cp\u003ePool是一个可以分别存取的临时对象的集合。\u003c/p\u003e\n\u003ch2 id=\"once\"\u003eOnce\u003c/h2\u003e\n\u003cp\u003e只执行一次动作的对象(单例模式)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Once struct {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 只有第一次调用才执行\nfunc (o *Once) Do(f func())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"mutex\"\u003eMutex\u003c/h2\u003e\n\u003cp\u003e互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.\u003c/p\u003e\n\u003cp\u003eMutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。\u003c/p\u003e\n\u003cp\u003e同一时刻只能有一个线程进入临界区.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Mutex struct {}\n\nMutex\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 加锁，如果已经加锁，阻塞至m解锁．\nfunc (m *Mutex) Lock()\n\n// 解锁，如果没有加锁，导致panic\nfunc (m *Mutex) Unlock()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"rwmutex\"\u003eRWMutex\u003c/h2\u003e\n\u003cp\u003e读写互斥锁,可以由不同的线程加锁和解锁.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype RWMutex struct {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。\nfunc (rw *RWMutex) Lock()\n\n// 解除写入锁定，如果没有加锁，导致panic\nfunc (rw *RWMutex) Unlock()\n\n// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。\nfunc (rw *RWMutex) RLock()\n\n// 解除读取锁，如果没有加锁，导致panic.\nfunc (rw *RWMutex) RUnlock()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"cond\"\u003eCond\u003c/h2\u003e\n\u003cp\u003e条件变量.\u003c/p\u003e",
    "content": "sync sync用于goroutine同步.\nimport \u0026quot;sync\u0026quot; constants variables functions Locker 一个可以加锁和解锁的接口\ntype Locker interface { Lock() Unlock() } Pool Pool是一个可以分别存取的临时对象的集合。\nOnce 只执行一次动作的对象(单例模式)\ntype Once struct {} method:\n// 只有第一次调用才执行 func (o *Once) Do(f func()) Mutex 互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.\nMutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。\n同一时刻只能有一个线程进入临界区.\ntype Mutex struct {} Mutex method:\n// 加锁，如果已经加锁，阻塞至m解锁． func (m *Mutex) Lock() // 解锁，如果没有加锁，导致panic func (m *Mutex) Unlock() RWMutex 读写互斥锁,可以由不同的线程加锁和解锁.\ntype RWMutex struct {} method:\n// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。 func (rw *RWMutex) Lock() // 解除写入锁定，如果没有加锁，导致panic func (rw *RWMutex) Unlock() // 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。 func (rw *RWMutex) RLock() // 解除读取锁，如果没有加锁，导致panic. func (rw *RWMutex) RUnlock() Cond 条件变量.\ntype Cond struct { L Locker } function:\nfunc NewCond(l Locker) *Cond method:\nfunc (c *Cond) Broadcase() func (c *Cond) Signal() func (c *Cond) Wait() WaitGroup 用于等待一组线程结束，父线程用Add方法来设定应等待的线程数量; 每个被等待的线程在结束时应调用Done方法; 同时，主线程应调用Wait方法阻塞至所有线程结束．\nstruct:\ntype WaitGroup sttruct {} functions:\nmethods:\n# 增加计数 func (*WaitGroup) Add(delta int) # 减少计数 func (*WaitGroup) Done() # 阻塞直到计数器为0 func (*WaitGroup) Wait() sync/atomic 提供底层的原子级内存操作，主要用于goroutine同步.\nint32, int64, uint32, uint64, uintptr, pointer.\nfunction func AddInt64(addr *int64, delta int64) (new int64) func AddUint64(addr *uint64, delta uint64) (new uint64) func LoadInt64(addr *int64) (val int64) func LoadUint64(addr *uint64) (val uint64) func StoreInt64(addr *int64, val int64) func StoreUint64(addr *uint64, val uint64) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint64(addr *uint64, new uint64) (old uint64) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) ",
    "categories": ["Golang"],
    "tags": ["concurrency"]
  },
  {
    "title": "GSL_cryptographic",
    "permalink": "https://canuxcheng.com/post/gsl_cryptographic/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"crypto\"\u003ecrypto\u003c/h1\u003e\n\u003cp\u003e收集了常用的密码常量\u003c/p\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eRegisterHash(h Hash, f func() hash.Hash)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"publickey\"\u003ePublicKey\u003c/h2\u003e\n\u003cp\u003einterface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype PublicKey interface{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"privatekey\"\u003ePrivateKey\u003c/h2\u003e\n\u003cp\u003einterface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype PrivateKey interface{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"hash\"\u003eHash\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etype Hash uint\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (h Hash) Avaliable() bool\nfunc (h Hash) Size() int\nfunc (h Hash) New() hash.Hash\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"cryptocipher\"\u003ecrypto/cipher\u003c/h1\u003e\n\u003cp\u003e用于包装底层块加密算法的实现.\u003c/p\u003e\n\u003ch2 id=\"block\"\u003eBlock\u003c/h2\u003e\n\u003cp\u003e代表一个使用特定密钥的底层　加／解密器．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Block interface {\n    BlockSize() int\n    Encrypt(dst, src []byte)\n    Decrypt(dst, src []byte)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"blockmode\"\u003eBlockMode\u003c/h2\u003e\n\u003cp\u003e代表一个工作在块模式(CBC, ECB等)的加／解密器\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype BlockMode interface {\n    BlockSize() int\n    CryptBlocks(dst, src []byte)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunction:\u003c/p\u003e",
    "content": "crypto 收集了常用的密码常量\nfunctions RegisterHash(h Hash, f func() hash.Hash) PublicKey interface:\ntype PublicKey interface{} PrivateKey interface:\ntype PrivateKey interface{} Hash type Hash uint method:\nfunc (h Hash) Avaliable() bool func (h Hash) Size() int func (h Hash) New() hash.Hash crypto/cipher 用于包装底层块加密算法的实现.\nBlock 代表一个使用特定密钥的底层　加／解密器．\ntype Block interface { BlockSize() int Encrypt(dst, src []byte) Decrypt(dst, src []byte) } BlockMode 代表一个工作在块模式(CBC, ECB等)的加／解密器\ntype BlockMode interface { BlockSize() int CryptBlocks(dst, src []byte) } function:\n// 返回一个BlockMode接口，底层用b加密，初始向量长度等于b的块尺寸. func NewCBCEncrypter(b Block, iv []byte) BlockMode // 返回一个BlockMode接口，底层用b解密，初始向量长度等于b的块尺寸. func NewCBCDecrypter(b Block, iv []byte) BlockMode Stream stream接口表示一个流模式的加／解密器．\ntype Stream interface { XORKeyStream(dst, src []byte) } function:\nfunc NewCFBEncrypter(block Block, iv []byte) Stream func NewCFBDecrypter(block Block, iv []byte) Stream func NewOFB(b Block, iv []byte) Stream func NewCTR(b Block, iv []byte) Stream crypto/rand 用于加解密的更安全的随机数生成器.\ncrypto/aes 对称加密算法,aes加密算法用于取代des算法.\nconstants const BlockSize = 16 function // 创建一个cipher.Block接口, key为密钥，长度只能是16(aes-128),24(aes-192),32(aes-256)字节. func NewCipher(key []byte) (cipher.Block, error) crypto/dsa 非对称，数字签名算法dsa.\ncrypto/rsa 非对称加密算法rsa.\ncrypto/md5 constants const BlockSize = 64 const Size = 16 function // 返回data的ms5检验和 func Sum(data []byte) [Size]byte func New() hash.Hash crypto/sha1 constants // SHA1块大小 const BlockSize = 64 // SHA1校验和的字节数 const Size = 20 functions // 返回数据data的SHA1校验和 func Sum(data []byte) [Size]byte // 返回一个使用新的SHA1校验的hash.Hash接口 func New() hash.Hash crypto/sha256 crypto/sha512 hash Hash 被所有hash函数实现的公共接口\ninterface:\ntype Hash interface { io.Writer Sum(b []byte) []byte Reset() Size() int BlockSize() int } Hash32 被所有32位hash函数实现的公共接口\ninterface:\ntype Hash32 interface { Hash Sum32() uint32 } Hash64 被所有64位hash函数实现的公共接口\ninterface:\ntype Hash64 interface { Hash Sum64() uint64 } hash/adler32 hash/crc32 hash/crc64 hash/fnv ",
    "categories": ["Golang"],
    "tags": ["cryptographic"]
  },
  {
    "title": "GSL_data",
    "permalink": "https://canuxcheng.com/post/gsl_data/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"time\"\u003etime\u003c/h1\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cp\u003econst:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst (\n    ANSIC       = \u0026quot;Mon Jan _2 15:04:05 2006\u0026quot;\n    Unixdate    = \u0026quot;Mon Jan _2 15:04:05 MST 2006\u0026quot;\n    RFC3339     = \u0026quot;2006-01-02T15:04:05Z07:00\u0026quot;\n    ...\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 阻塞go程d代表的时间段\nfunc Sleep(d Duration)\n\nfunc After(d Duration) \u0026lt;- chan Time\n\nfunc Tick(d Duration) \u0026lt;- chan Time\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"time-1\"\u003eTime\u003c/h2\u003e\n\u003cp\u003e代表一个纳秒精度的时间点.\u003c/p\u003e\n\u003cp\u003e零值是January 1, year 1, 00:00:00.000000000 UTC.\u003c/p\u003e\n\u003cp\u003estruct:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype  Time struct {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST\nfunc date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\n\n// 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301\nfunc Now() Time\n\nfunc Parse(layout, value s tring) (Time, error)\n\nfunc ParseInLocation(layout, value string, loc *Location) (Time, error)\n\nfunc Unix(sec int64, nsec int64) Time\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethods:\u003c/p\u003e",
    "content": "time constants const:\nconst ( ANSIC = \u0026quot;Mon Jan _2 15:04:05 2006\u0026quot; Unixdate = \u0026quot;Mon Jan _2 15:04:05 MST 2006\u0026quot; RFC3339 = \u0026quot;2006-01-02T15:04:05Z07:00\u0026quot; ... ) functions // 阻塞go程d代表的时间段 func Sleep(d Duration) func After(d Duration) \u0026lt;- chan Time func Tick(d Duration) \u0026lt;- chan Time Time 代表一个纳秒精度的时间点.\n零值是January 1, year 1, 00:00:00.000000000 UTC.\nstruct:\ntype Time struct {} functions:\n// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST func date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time // 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301 func Now() Time func Parse(layout, value s tring) (Time, error) func ParseInLocation(layout, value string, loc *Location) (Time, error) func Unix(sec int64, nsec int64) Time methods:\n// 返回T的地点和时区信息 func (t Time) Location() *Location // 返回t的时区规范名和相对于UTC的偏移量 func (t Time) Zone() (name string, offset int) func (t Time) IsZero() bool func (t Time) Local() Time func (t Time) UTC() Time func (t Time) In(loc *Location) Time func (t Time) Unix() int64 func (t Time) UnixNano() int64 // 比较两个时间 func (t Time) Equal(u Time) bool // t \u0026gt; u 返回true func (t Time) Before(u Time) bool // t \u0026lt; u 返回true func (t Time) After(u Time) bool // 返回t的年月日. func (t Time) date() (year int, month Month, day int) // 返回t对应的时分秒 func (t Time) Clock() (hour, min, sec int) // 返回t对应的年 func (t Time) Year() int // 返回t对应的月 func (t Time) Month() Month func (t Time) ISOWeek() (year, week int) // 返回t对应的当年的第几天 func (t Time) YearDay() int // 返回t对应的当月的第几天 func (t Time) Day() int // 返回t对应的星期几 func (t Time) Weekday() Weekday // 返回t对应的第几小时 func (t Time) Hour() int // 返回t对应的分钟 func (t Time) Minute() int // 返回t对应的秒 func (t Time) Second() int // 返回t对应的纳秒偏移量 func (t Time) Nanosecond() int func (t Time) Add(d Duration) Time func (t Time) Adddate(years int, months int, days int) Time func (t Time) Sub(u Time) Duration func (t Time) Round(d duration) Time func (t Time) Truncate(d Duration) Time func (t Time) Format(layout string) string func (t Time) String(layout string) string Weekday type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) methods:\n// 返回d对应的英文名 func (d Weekday) String() string Month type Month int const ( January Month = 1 + iota February March April May June July August September October November December ) methods:\n// 返回m对应的英文名 func (m Month) String() string Location struct:\ntype Location struct {} functions:\n// 返回使用给定名字创建的Location // name == \u0026quot;\u0026quot; 或　name == \u0026quot;UTC\u0026quot;, 返回UTC // name == \u0026quot;Local\u0026quot;, fanhui1Local // 其它时间数据库的值 func LoadLocation(name string) (*Location, error) // 使用给定的名称和偏移量创建一个Location func FixedZone(name string, offset int) *Location methods:\n// 返回对时区信息的描述 func (l *Location) String() string Duration Timer Ticker container/heap container/list container/ring compress/bzip2 compress/flate compress/gzip compress/lzw compress/zlib archive ",
    "categories": ["Golang"],
    "tags": ["data"]
  },
  {
    "title": "GSL_database",
    "permalink": "https://canuxcheng.com/post/gsl_database/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"databasesql\"\u003edatabase/sql\u003c/h1\u003e\n\u003cp\u003e使用该包，必须提供一个数据库驱动\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/golang/go/wiki/SQLDrivers\"\u003ehttps://github.com/golang/go/wiki/SQLDrivers\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003emssql driver:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/denisenkom/go-mssqldb\"\u003ehttps://github.com/denisenkom/go-mssqldb\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003emysql driver:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/go-sql-driver/mysql\"\u003ehttps://github.com/go-sql-driver/mysql\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003epostgresql driver:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/lib/pq\"\u003ehttps://github.com/lib/pq\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jackc/pgx\"\u003ehttps://github.com/jackc/pgx\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量\nvar ErrNoRows = errors.New(\u0026quot;sql: no rows in result set\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 注册并命名一个数据库，在Open中使用该命名启用该驱动\n// 如果注册同一名称两次或者driver参数为nil, 会导致panic.\nRegister(name string, driver driver.Driver)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"db\"\u003eDB\u003c/h2\u003e\n\u003cp\u003eDB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．\u003c/p\u003e\n\u003cp\u003e可以安全的被多个go程同时使用．\u003c/p\u003e\n\u003cp\u003estruct:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype DB struct {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 验证数据库驱动和参数,并不创建和数据库的连接．\n// driverName: mssql, mysql, postgres\n// mssql dataSourceName: \u0026quot;server=%s;port=%d;database=%s;user id=%s;password=%s\u0026quot;\n// mysql dataSourceName: \u0026quot;user:password@tcp(server:port)/database\u0026quot;\nOpen(driverName, dataSourceName string) (*DB, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethods:\u003c/p\u003e",
    "content": "database/sql 使用该包，必须提供一个数据库驱动\nhttps://github.com/golang/go/wiki/SQLDrivers\nmssql driver:\nhttps://github.com/denisenkom/go-mssqldb\nmysql driver:\nhttps://github.com/go-sql-driver/mysql\npostgresql driver:\nhttps://github.com/lib/pq\nhttps://github.com/jackc/pgx\nvariables // QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量 var ErrNoRows = errors.New(\u0026quot;sql: no rows in result set\u0026quot;) functions // 注册并命名一个数据库，在Open中使用该命名启用该驱动 // 如果注册同一名称两次或者driver参数为nil, 会导致panic. Register(name string, driver driver.Driver) DB DB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．\n可以安全的被多个go程同时使用．\nstruct:\ntype DB struct {} functions:\n// 验证数据库驱动和参数,并不创建和数据库的连接． // driverName: mssql, mysql, postgres // mssql dataSourceName: \u0026quot;server=%s;port=%d;database=%s;user id=%s;password=%s\u0026quot; // mysql dataSourceName: \u0026quot;user:password@tcp(server:port)/database\u0026quot; Open(driverName, dataSourceName string) (*DB, error) methods:\n// 返回数据库下层驱动 func (db *DB) Driver() driver.Driver // 创建和数据库的连接,检查连接是否有效 func (db *DB) Ping() error // 关闭数据库，释放资源 func (db *DB) Close() error // 设置与数据库建立连接的最大数目, 默认０表示无限制. func (db *DB) SetMaxOpenConns(n int) // 设置连接池中的最大闲置连接数 func (db *DB) SetMaxIdleConns(n int) // 执行命令但是不返回执行结果,一般用于(insert/update/delete) func (db *DB) Exec(query string, args ...interface{}) (Result, error) // 执行命令返回多行结果（一般用于select) func (db *DB) Query(query string, args ...interface{}) (*Rows, error) // 执行命令最多返回一行结果 // 总是返回非nil值，直到返回值的Scan方法被调用，才会返回被延迟的错误. func (db *DB) QueryRow(query string, args ...interface{}) *Row // 创建一个准备好的状态用于之后的命令 func (db *DB) Prepare(query string) (*Stmt, error) // 开始一个事务 func (db *DB) Begin() (*Tx, error) Stmt stmt是准备好的状态，可以安全的被多个go程同时使用．\nstruct:\ntype Stmt struct {} methods:\nfunc (s *Stmt) Exec(args ...interface{}) (Result, error) func (s *Stmt) Query(args ...interface{}) (*Rows, error) func (s *Stmt) QueryRow(args ...interface{}) *Row func (s *Stmt) Close() error Tx Tx表示一个进行中的数据库事务．\n一次事务必须以对Commit或Rollback的调用结束．\n事务结束后，所有的操作都会失败并返回ErrTxDone.\nstruct:\ntype Tx struct {} methods:\nfunc (tx *Tx) Exec(query string, args ...interface{}) (Result, error) func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error) func (tx *Tx) QueryRow(query string, args ...interface{}) *Row func (tx *Tx) Prepare(query string) (*Stmt, error) // 使用已存在的状态生成一个特定的状态． func (tx *Tx) Stmt(stmt *Stmt) *Stmt // 提交事务 func (tx *Tx) Commit() error // 回滚事务 func (tx *Tx) Rollback() error Scanner interface:\ntype Scanner interface { Scan(src interface{}) error } Result Exec方法返回Result.\ntype Result interface { LastInsertId() (int64, error) RowsAffected() (int64, error) } Row QueryRow方法返回Row, 表示单行查询结果．\nstruct:\ntype Row struct {} methods:\n// 将该行查询结果各列分别保存进dest参数指定的值中． // 如果匹配多行，只取第一行，如果没有匹配行，返回ErrNoRows. func (r *Row) Scan(dest ...interface{}) error Rows Query方法返回Rows, 表示查询的结果集，它的游标指向第０行，使用Next方法遍历该结果集．\nstruct:\ntype Rows struct {} methods:\n// 返回列名 func (rs *Rows) Columns() ([]string, error) // 将当前行的各列结果填充进dest func (rs *Rows) Scan(dest ...interface{}) error // 准备用于Scan的下一行结果，每次调用Scan都要先调用Next func (rs *Rows) Next() bool func (rs *Rows) Close() error func (rs *Rows) Err() error database/sql/driver ",
    "categories": ["Golang"],
    "tags": ["database"]
  },
  {
    "title": "GSL_file",
    "permalink": "https://canuxcheng.com/post/gsl_file/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"path\"\u003epath\u003c/h1\u003e\n\u003ch2 id=\"function\"\u003efunction\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efunc IsAbs(path string) bool\nfunc Join(elem ...string) string\nfunc Split(path string) (dir, file string)\nfunc Join(elem ...string) string\nfunc Dir(path string) string\nfunc Base(path string) string\nfunc Ext(path string) string \n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"pathfilepath\"\u003epath/filepath\u003c/h1\u003e\n\u003ch2 id=\"constants\"\u003eConstants\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003econst (\n    Separator = os.PathSeparator\n    ListSeparator = os.PathListSeparator\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variable\"\u003eVariable\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar ErrBadPattern = errors.New(\u0026quot;Syntax error in pattern\u0026quot;)\n\nvar SkipDir = errors.New(\u0026quot;skip this diractory\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"function-1\"\u003efunction\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efunc IsAbs(path string) bool\nfunc Abs(path string) (string, error)\n\n// 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名.\nfunc Rel(basepath, targpath string) (string, error)\n\nfunc Split(path string) (dir, file string)\nfunc Join(elem ...string) string\nfunc Dir(path string) string\nfunc Base(path string) string\nfunc Ext(path string) string) // 包括小数点\nfunc Walk(root string, walkFn WalkFunc) error\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"walkfunc\"\u003eWalkFunc\u003c/h2\u003e\n\u003cp\u003e调用Walk时会对每个目录和文件调用该函数.\u003c/p\u003e",
    "content": "path function func IsAbs(path string) bool func Join(elem ...string) string func Split(path string) (dir, file string) func Join(elem ...string) string func Dir(path string) string func Base(path string) string func Ext(path string) string ... path/filepath Constants const ( Separator = os.PathSeparator ListSeparator = os.PathListSeparator ) Variable var ErrBadPattern = errors.New(\u0026quot;Syntax error in pattern\u0026quot;) var SkipDir = errors.New(\u0026quot;skip this diractory\u0026quot;) function func IsAbs(path string) bool func Abs(path string) (string, error) // 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名. func Rel(basepath, targpath string) (string, error) func Split(path string) (dir, file string) func Join(elem ...string) string func Dir(path string) string func Base(path string) string func Ext(path string) string) // 包括小数点 func Walk(root string, walkFn WalkFunc) error WalkFunc 调用Walk时会对每个目录和文件调用该函数.\n如果该函数返回错误，Walk函数会中止.\n如果该函数返回SkipDir, Walk会掉过处理该目录，继续处理其它内容.\ntype WalkFunc func(path string, info os.FileInfo, err error) error encoding 定义了供其它包使用的在字节和文本之间转换数据的接口.\nimport \u0026quot;encoding\u0026quot; encoding/json go和json数据类型对应关系，参考WEB/JSON.\n在线获取json的go数据结构:\nhttps://github.com/mholt/json-to-go\nhttps://mholt.github.io/json-to-go\nchan/complex/func类型不能编码为json.\nimport \u0026quot;encoding/json\u0026quot; constants variables functions # 返回golang对象v的json编码(将go的对象转换为json对象), 可以打tag. \u0026gt; \u0026quot;-\u0026quot; 该字段不会输出到json \u0026gt; myName 在json中的名字 \u0026gt; omitempty 允许json中没有该字段 \u0026gt; Type 如果指定类型，会转换成指定的类型出现在json json.Marshal(v interface{}) ([]byte, error) # 具有缩进功能 json.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) # 将json对象data转换成go对象，存入v # 只有可导出字段才会在json中找到. \u0026gt; Bool 对应JSON布尔类型 \u0026gt; float64 对应JSON数字类型 \u0026gt; string 对应JSON字符串类型 \u0026gt; []interface{} 对应JSON数组 \u0026gt; map[string]interface{} 对应JSON对象 \u0026gt; nil 对应JSON的null json.Unmarshal(data []byte, v interface{}) error // 将json格式的src中的无用的空白字符剔除后写入dst. func Compact(dst *bytes.Buffer, src []byte) error // 格式化json，以便json编码能安全的嵌入html的\u0026lt;script\u0026gt;标签 func HTMLEscape(dst *bytes.Buffer, src []byte) // func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error Marshaler interface:\ntype Marshaler interface { MarshalJSON() ([]byte, error) } Unmarshaler interface:\ntype Unmarshaler interface { UnmarshalJSON([] byte) error } Decoder 从输入流解码json对象\nstruct:\ntype Decoder struct {} function:\nfunc NewDecoder(r io.Reader) *Decoder method:\n// 从dec读取下一个对象存入v. func (dec *Decoder) Decode(v interface{}) error Encoder encoding/csv encoding/gob go binary, go的数据持久化包，用于编码器和解码器之间交换二进制数据.\nfunctions func Register(value interface{}) func RegisterName(name string, value interface{}) GobDecoder GobEncoder Decoder 管理从远端读取数据的类型和信息的解码操作.\nstruct:\ntype Decoder struct {} functions:\n// 返回一个从r读取数据的Decoder func NewDecoder(r io.Reader) *Decoder methods:\n# 从dec读取下一个值并存入e func (dec *Decoder) Decode(e interface{}) error func (dec *Decoder) DecodeValue(v reflect.Value) error Encoder 管理数据类型和信息编码后发送到远端的操作.\nstruct:\ntype Encoder struct {} functions:\n// 返回一个将编码后数据写入w的Encoder func NewEncoder(w io.Writer) *Encoder methods:\n// 将e编码后发送到enc func (enc *Encoder) Encode(e interface{}) error func (enc *Encoder) EncodeValue(value reflect.Value) error CommonType type CommonType struct { Name string Id typeId } text/template text/template/parse text/scanner text/tabwriter html 提供了用于转义和解转义html文本的函数．\nimport \u0026quot;net\u0026quot; functions // 将　\u0026lt;, \u0026gt;, \u0026amp;, ', \u0026quot; 转义为字符实体 \u0026amp;lt, \u0026amp;gt, \u0026amp;#39, func EscapeString(s string) string func UnescapeString(s string) string html/template 实现了数据驱动模板，用于生成可对抗代码注入的安全html输出．\nfunctions // 将b转义后写入w． func HTMLEscape(w io.Writer, b []byte) // 转义s之后,返回结果字符串. func HTMLEscapeString(s string) string // 转义多个字符串，返回结果字符串. func HTMLEscaper(args ...interface{}) string FuncMap 定义函数名字符串到函数的映射，每个函数必须要1到2个返回值．\ntype FuncMap map[string]interface{} Template type Template struct { Tree *parse.Tree } function:\n// 创建名为name的模板 func New(name string) *Template // 在err非nil时panic, 检测模板是否正确． // 通过template.New().Parse() 返回值作为参数. func Must(t *Template, err error) *Template // 创建一个模板，并解析filenames作为模板内容 // 第一个文件名为模板名字(不包括扩展名) func ParseFiles(filenames ...string) (*Template, error) // 创建一个模板，并解析匹配pattern的文件． // 匹配的第一个文件名为模板名字(不包括扩展名) func ParseGlob(pattern string) (*Template, error) methods:\n// 将字符串str解析为模板 func (t *Template) Parse(str string) (*Template, error) // 将文件解析为模板 func (t *Template) ParseFiles(filenames ...string) (*Template, error) // func (t *Template) ParseGlob(pattern string) (*Template, error) // 将解析好的模板应用到data上，并将输出写入wr. func (t *Template) Execute(wr io.Writer, data interface{}) (err error) // 使用和t关联的名为name的模板 func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error // 注册函数到模板t, funcMap的key是模板中调用的函数名，value是实际的函数 func (t *Template) Funcs(funcMap FuncMap) *Template yaml https://github.com/go-yaml/yaml\ntoml https://github.com/toml-lang/toml\nhttps://github.com/BurntSushi/toml\n",
    "categories": ["Golang"],
    "tags": ["file"]
  },
  {
    "title": "GSL_golang",
    "permalink": "https://canuxcheng.com/post/gsl_golang/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"runtime\"\u003eruntime\u003c/h1\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 指定编译器\nconst Compiler = \u0026quot;gc\u0026quot;/\u0026quot;gccgo\u0026quot;\n\n// 处理器架构: 386/amd64/arm\nconst GOARCH string = theGoarch\n\n// 操作系统: linux/freebsd/darwin/win\nconst GOOS string = theGoos\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar MemProfileRate int = 512 * 1024\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efunc GOROOT() string\nfunc Version() string\n\n// 返回本地机器的逻辑cpu个数\nfunc NumCPU() int\n\n//更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu.\nfunc GOMAXPROCS(n int) int\n\n// 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行.\n// 当前goroutine放回队列等待继续执行.\nfunc Gosched()\n\n// 终止当前goroutine,终止前执行所有defer.\nfunc Goexit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"runtimedebug\"\u003eruntime/debug\u003c/h1\u003e\n\u003ch2 id=\"function\"\u003efunction\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 设置最大线程数，默认1000.\nfunc SetMaxThreads(threads int) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"runtimecgo\"\u003eruntime/cgo\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"runtimepprof\"\u003eruntime/pprof\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"runtimerace\"\u003eruntime/race\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"runtimetrace\"\u003eruntime/trace\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"go\"\u003ego\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"expvar\"\u003eexpvar\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"context\"\u003econtext\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"unsafe\"\u003eunsafe\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"errors\"\u003eerrors\u003c/h1\u003e\n\u003ch2 id=\"function-1\"\u003efunction\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 使用字符串创建一个错误, 返回一个error\nfunc New(text string) error\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "runtime constants // 指定编译器 const Compiler = \u0026quot;gc\u0026quot;/\u0026quot;gccgo\u0026quot; // 处理器架构: 386/amd64/arm const GOARCH string = theGoarch // 操作系统: linux/freebsd/darwin/win const GOOS string = theGoos variables var MemProfileRate int = 512 * 1024 functions func GOROOT() string func Version() string // 返回本地机器的逻辑cpu个数 func NumCPU() int //更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu. func GOMAXPROCS(n int) int // 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行. // 当前goroutine放回队列等待继续执行. func Gosched() // 终止当前goroutine,终止前执行所有defer. func Goexit() runtime/debug function // 设置最大线程数，默认1000. func SetMaxThreads(threads int) int runtime/cgo runtime/pprof runtime/race runtime/trace go expvar context unsafe errors function // 使用字符串创建一个错误, 返回一个error func New(text string) error ",
    "categories": ["Golang"],
    "tags": ["golang"]
  },
  {
    "title": "GSL_math",
    "permalink": "https://canuxcheng.com/post/gsl_math/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"math\"\u003emath\u003c/h1\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"mathbig\"\u003emath/big\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"mathcmplx\"\u003emath/cmplx\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"mathrand\"\u003emath/rand\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"sort\"\u003esort\u003c/h1\u003e\n\u003ch2 id=\"functions-1\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efunc Ints(a []int)\nfunc IntAreSorted(a []int) bool\nfunc SearchInts(a []int, x int) int\n\nfunc Float64s(a []float64)\nfunc Float64sArerSorted(a []float64) bool\nfunc SearchFloat64s(a []float64, x float64) int\n\nfunc Strings(a []string)\nfunc StringsAreSorted(a []string) bool\nfunc SearchStrings(a []string, x string) int\n\nfunc Sort(data Interface)\nfunc Stable(data Interface)\nfunc IsSorted(data Interface) bool\nfunc Reverse(data Interface) Interface\n// 二分查找\nfunc Search(n int, f func(int) bool) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"interface\"\u003eInterface\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"initslice\"\u003eInitSlice\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etype InitSlice []int\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"float64slice\"\u003eFloat64Slice\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etype Float64Slice []float64\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"stringslice\"\u003eStringSlice\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etype StringSlice []string\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e",
    "content": "math constants variables functions math/big math/cmplx math/rand sort functions func Ints(a []int) func IntAreSorted(a []int) bool func SearchInts(a []int, x int) int func Float64s(a []float64) func Float64sArerSorted(a []float64) bool func SearchFloat64s(a []float64, x float64) int func Strings(a []string) func StringsAreSorted(a []string) bool func SearchStrings(a []string, x string) int func Sort(data Interface) func Stable(data Interface) func IsSorted(data Interface) bool func Reverse(data Interface) Interface // 二分查找 func Search(n int, f func(int) bool) int Interface type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } InitSlice type InitSlice []int Float64Slice type Float64Slice []float64 StringSlice type StringSlice []string ",
    "categories": ["Golang"],
    "tags": ["math"]
  },
  {
    "title": "GSL_multimedia",
    "permalink": "https://canuxcheng.com/post/gsl_multimedia/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"image\"\u003eimage\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"mime\"\u003emime\u003c/h1\u003e",
    "content": "image mime ",
    "categories": ["Golang"],
    "tags": ["multimedia"]
  },
  {
    "title": "GSL_network",
    "permalink": "https://canuxcheng.com/post/gsl_network/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"net\"\u003enet\u003c/h1\u003e\n\u003cp\u003e网络IO接口，包括TCP/IP, UDP, SOCKET, DNS\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026quot;net\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003econst (\n    IPv4len = 4\n    IPv6len = 16\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003ch2 id=\"addr\"\u003eAddr\u003c/h2\u003e\n\u003cp\u003e代表一个网络终端地址．\u003c/p\u003e\n\u003cp\u003eTCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Addr interface {\n    Network() string\n    String() string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"tcpaddr\"\u003eTCPAddr\u003c/h2\u003e\n\u003cp\u003efunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ResolveTCPAddr(net, addr string) (*TCPAddr, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"udpaddr\"\u003eUDPAddr\u003c/h2\u003e\n\u003cp\u003efunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ResolveUDPAddr(net, addr string) (*UDPAddr, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ipaddr\"\u003eIPAddr\u003c/h2\u003e\n\u003cp\u003efunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ResolveIPAddr(net, addr string) (*IPAddr, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"unixaddr\"\u003eUnixAddr\u003c/h2\u003e\n\u003cp\u003efunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ResolveUnixAddr(net, addr string) (*UnixAddr, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conn\"\u003eConn\u003c/h2\u003e\n\u003cp\u003e该接口代表通用的面向流的网络连接．\u003c/p\u003e",
    "content": "net 网络IO接口，包括TCP/IP, UDP, SOCKET, DNS\nimport \u0026quot;net\u0026quot; constants const ( IPv4len = 4 IPv6len = 16 ) variables functions Addr 代表一个网络终端地址．\nTCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口\ntype Addr interface { Network() string String() string } TCPAddr function:\nfunc ResolveTCPAddr(net, addr string) (*TCPAddr, error) UDPAddr function:\nfunc ResolveUDPAddr(net, addr string) (*UDPAddr, error) IPAddr function:\nfunc ResolveIPAddr(net, addr string) (*IPAddr, error) UnixAddr function:\nfunc ResolveUnixAddr(net, addr string) (*UnixAddr, error) Conn 该接口代表通用的面向流的网络连接．\ntype Conn interface { Read() Write() Close() LocalAddr() RemoteAddr() SetDeadline() SetReadDeadline() setWriteDeadline() } function:\n// tcp: \u0026quot;tcp\u0026quot;、\u0026quot;tcp4\u0026quot;、\u0026quot;tcp6\u0026quot;、 // unix: \u0026quot;unix\u0026quot;, \u0026quot;unixpacket\u0026quot; // unix: \u0026quot;unixgramh\u0026quot; // udp: \u0026quot;udp\u0026quot;、\u0026quot;udp4\u0026quot;、\u0026quot;udp6\u0026quot;、 // ip: \u0026quot;ip\u0026quot;、\u0026quot;ip4\u0026quot;、\u0026quot;ip6\u0026quot;、 func Dail(network, address string) (Conn, error) func DialTimeout(network, address string, timeout time.Duration) (Conn, error) func Pipe() (Conn, Conn) PacketConn 该接口代表通用的面向数据包的网络连接．\ntype PacketConn interface { ReadDrom() WriteTo() Close() LocalAddr() SetDeadline() SetReadDeadline() SetWriteDeadline() } function:\n// ip: \u0026quot;ip\u0026quot;、\u0026quot;ip4\u0026quot;、\u0026quot;ip6\u0026quot;、 // udp: \u0026quot;udp\u0026quot;、\u0026quot;udp4\u0026quot;、\u0026quot;udp6\u0026quot;、 // unix: \u0026quot;unixgram\u0026quot; func ListenPacket(net, laddr string) (PacketConn, error) Listener 通用的面向流的网络协议的公用的网络监听接口．\ntype Listener interface { Addr() addr Accept() (c Conn, err error) Close() error } function:\n// tcp: \u0026quot;tcp\u0026quot;、\u0026quot;tcp4\u0026quot;、\u0026quot;tcp6\u0026quot;、 // unix: \u0026quot;unix\u0026quot;, \u0026quot;unixpacket\u0026quot; func Listen(net, laddr string) (Listener, error) IPConn 实现了Conn和PacketConn接口．\nfunction:\nfunc DilIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error) func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error) method:\nUDPConn 实现了Conn和PacketConn接口.\nfunction:\nfunc DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) func ListenDUP(net string, laddr *UDPAddr) (*UDPConn, error) method:\nTCPConn 实现了Conn接口.\nfunction:\nfunc DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) method:\nTCPListener function:\nfunc ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) method:\nfunc (l *TCPListener) Accept() (Conn, error) UnixConn 实现了Conn和PacketConn接口.\nfunction:\nfunc DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error) func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) method:\nUnixListener function:\nfunc ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) method:\nfunc (l *UnixListener) Accept() (c Conn, err error) func (l *UnixListener) AcceptUnix() (*UnixConn, error) net/http http协议客户端和服务器的实现\nimport \u0026quot;net/http\u0026quot; constants const ( MethodGet = \u0026quot;GET\u0026quot; MethodHead = \u0026quot;HEAD\u0026quot; MethodPost = \u0026quot;POST\u0026quot; MethodPut = \u0026quot;PUT\u0026quot; MethodPatch = \u0026quot;PATCH\u0026quot; MethodDelete = \u0026quot;DELETE\u0026quot; MethodConnect = \u0026quot;CONNECT\u0026quot; MethodOptions = \u0026quot;OPTIONS\u0026quot; MethodTrace = \u0026quot;TRACE\u0026quot; ) variables functions // 在w的header中添加Set-Cookie头． func SetCookie(w ResponseWriter, cookie *Cookie) func Handle(pattern string, handler Handler) // 注册一个handler和对应的pattern 到DefaultServeMux. func HandlerFunc(pattern string, handler func(ResponseWriter, *Request)) // 为监听器收到的每个连接创建一个新的goroutine． // goroutine 会读取请求并调用handler回复该请求． func Serve(l net.Listener, handler Handler) error // 监听tcp地址addr, 使用handler参数调用Serve函数处理连接． // handler = nil 相当于DefaultServeMux func ListenAndServe(addr string, handler Handler) error File type File interface { io.Closer io.Reader Readdir(count int) ([]os.FileInfo, error) Seek(offset int64, whence int) (int64, error) Stat() (os.FileInfo, error) } FileSystem type FileSystem interface { Open(name string) (File, error) } Dir type Dir string method:\nfunc (d Dir) Open(name string) (File, error) Handler 实现Handler接口的对象可以被注册为http的服务函数\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } function:\n// 对每个请求回复\u0026quot;404 page not found\u0026quot; func NotFoundHandler() Handler // 对每个请求使用状态码code重定向到url. func RedirectHandler(url string, code int) Handler func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler // 将请求的URL.Path中的前缀prefix去除后再给h. func StripPrefix(prefix string, h Handler) Handler func FileServer(root FileSystem) Handler HandlerFunc 将普通函数转换成http的服务函数\ntype HandlerFunc func(ResponseWriter, *Request) method:\n// ServeHTTP会调用f(w, r) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) ServeMux ServeMux是http请求的多路转接器．\ntype ServeMux struct {} function:\n// 创建并返回一个新的*ServeMux func NewServeMux() *ServeMux method:\n// func (mux *ServeMux) Handle(pattern string, handler Handler) func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) Server 定义了运行http服务端的参数．\ntype Server struct { Addr string Handler Handler ReadTimeout time.Duration WriteTimeout time.Duration MaxHeaderBytes int TLSConfig *tls.Config TLSNextProto map[string]func(*Server, *tls.Conn, Handler) ConnState func(net.Conn, ConnState) ErrorLog *log.Logger } method:\nfunc (s *Server) SetKeepAlivesEnabled(v bool) func (s *Server) Serve(l net.Listener) error func (s *Server) ListenAndServe() error func (s *Server) ListenAndServeTLS(certFile, keyFile string) error Client 代表一个http客户端.\ntype Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.Duration } Header 代表http的头部.\ntype Header map[string][]string method:\nfunc (h Header) Get(key string) string func (h Header) Set(key, value string) ... Cookie 代表一个http回复的头部中SetCookie头的值，或http请求的头部里面的cookie值．\ntype Cookie struct { Name string Value string Path string Domain string Expires time.Time RawExpires string MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string } method:\n// 返回cookie序列化的结果 func (c *Cookie) String() string Request 代表一个服务端接收的或客户端发送的http请求.\ntype Request struct { Method string URL *url.URL Proto string // \u0026quot;HTTP/1.0\u0026quot; ProtoMajor int // 1 ProtoMinor int // 0 Header Header Body io.ReadCloser ContentLength int64 TransferEncoding []string Close bool Host string Form url.Values PostForm url.Values MultipartForm *multipart.Form Trailer Header RemoteAddr string RequestURI string TSL *tls.ConnectionState } function:\nfunc NewRequest(method, urlStr string, body io.Reader) (*Request, error) func ReadRequest(b *bufio.Reader) (req *Request, err error) method:\n// 解析并返回该请求r的header设置的cookie func (r *Request) Cookies() []*Cookie // 返回请求r中命名为name的cookie,如果未找到返回nil, ErrNoCookie. func (r *Request) Cookie(name string) (*cookie, error) //解析r.URL中的查询字符串，并将解析结果更新到r.Form字段. // post和put的body会同时更新到r.PostForm和r.Form. func (r *Request) ParseForm() error // 将请求的主体作为multipart/form-data解析. func (r *Request) ParseMultipartForm(maxMemory int64) error Response 代表一个http请求的回复r\ntype Response struct { Status string StatusCode int Proto string ProtoMajor int ProtoMinor int Header Header Body io.ReadCloser ContentLength int64 TransferEncoding []string Close bool Trailer Header Request *Request TLS *tls.ConnectionState } functions:\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error) func Head(url string) (resp *Response, err error) func Get(url string) (resp *Response, err error) func Post(url string, bodyType string, boyd io.Reader) (resp *Response, err error) func PostForm(url string, data url.Values) (resp *Response, err error) methods:\nfunc (r *Response) ProtoAtLeast(major, minor int) bool // 获取相应中的Set-Cookie设置的cookie func (r *Response) Cookies() []*Cookie ResponseWriter 用于构造http回复.\ntype ResponseWriter interface { Header() Header WriteHeader(int) Write([]byte) (int, error) } net/mail net/smtp net/rpc function:\n// 在DefaultServer注册并公布rcvr方法. func Register(rcvr interface{}) error // 接收连接，将每个连接交给DefaultServer服务.会阻塞. func Accept(lis net.Listener) // 在单个连接执行DefaultServer,会阻塞. func ServceConn(conn io.ReadWriteCloser) func HandleHTTP() Call 代表一个执行中或执行完毕的会话．\ntype Call struct { ServiceMethod string Args interface{} Reply interface{} Error error Done chan *Call } Client rpc客户端\ntype client struct {} function:\nfunc NewClient(conn io.ReadWriteCloser) *Client func Dial(network, address string) (*Client, error) func DialHTTP(network, address string) (*Client, error) method:\n// 调用指定的方法，等待返回，将结果写入reply. func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call func (client *Client) Close() error net/textproto net/url scheme://[userinfo@]host/path[?query][#fragment] URL type URL struct { Scheme string Opaque string User *Userinfo Host string // host or host:port Path string RawQuery string Fragment string } function:\nfunc Parse(rawurl string) (url *URL, err error) func ParseRequestURI(rawurl string) (url *URL, err error) methods:\nUserinfo VAlues ",
    "categories": ["Golang","Network"],
    "tags": ["network"]
  },
  {
    "title": "GSL_oop",
    "permalink": "https://canuxcheng.com/post/gsl_oop/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"reflect\"\u003ereflect\u003c/h1\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cp\u003econst:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst (\n    SelectSend\n    SelectRecv\n    SelectDefault\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 将src拷贝到dst, 直到src被耗尽或dst被装满.\nfunc Copy(dst, src Value) int\n\n// 判断两个值是否深度一致\nfunc DeepEqual(a1, a2 interface{}) bool\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"kind\"\u003eKind\u003c/h2\u003e\n\u003cp\u003e表示Type类型值表示的具体分类.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Kind uint\n\nconst (\n    Invalid Kind = iota\n    Bool\n    Int\n    ...\n    Uint\n    ...\n    Float...\n    Complex...\n    Array\n    Chan\n    Func\n    Interface\n    Map\n    Ptr\n    Slice\n    String\n    Struct\n    UnsafePointer\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (k Kind) String() string\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"stringheader\"\u003eStringHeader\u003c/h2\u003e\n\u003ch2 id=\"sliceheader\"\u003eSliceHeader\u003c/h2\u003e\n\u003ch2 id=\"structfield\"\u003eStructField\u003c/h2\u003e\n\u003ch2 id=\"structtag\"\u003eStructTag\u003c/h2\u003e\n\u003ch2 id=\"chandir\"\u003eChanDir\u003c/h2\u003e\n\u003ch2 id=\"selectdir\"\u003eSelectDir\u003c/h2\u003e\n\u003ch2 id=\"selectcase\"\u003eSelectCase\u003c/h2\u003e\n\u003ch2 id=\"method\"\u003eMethod\u003c/h2\u003e\n\u003ch2 id=\"type\"\u003eType\u003c/h2\u003e\n\u003cp\u003e用来表示一个go类型.\u003c/p\u003e",
    "content": "reflect constants const:\nconst ( SelectSend SelectRecv SelectDefault ) functions // 将src拷贝到dst, 直到src被耗尽或dst被装满. func Copy(dst, src Value) int // 判断两个值是否深度一致 func DeepEqual(a1, a2 interface{}) bool Kind 表示Type类型值表示的具体分类.\ntype Kind uint const ( Invalid Kind = iota Bool Int ... Uint ... Float... Complex... Array Chan Func Interface Map Ptr Slice String Struct UnsafePointer ) method:\nfunc (k Kind) String() string StringHeader SliceHeader StructField StructTag ChanDir SelectDir SelectCase Method Type 用来表示一个go类型.\ninterface:\ntype Type interface { Kind() Kind Name() string PkgPath() string String() string Size() uintptr ... } functions:\n// 返回接口中保存的值的类型 func TypeOf(i interface{}) Type // 返回类型t的指针的类型 func PtrTo(t Type) Type // 返回类型t的slice的类型 func SliceOf(t Type) Type // 返回一个键类型为key, 值类型为elem的map类型 func MapOf(key, elem Type) Type // 返回元素类型为t, 方向为dir的chan类型 func ChanOf(dir ChanDir, t Type) Type Value 为go值提供反射接口.\nstruct:\ntype Value struct {} functions:\n// 返回一个接口i保存的具体值的Value func ValueOf(i interface{}) Value // 返回一个类型typ的零值的Value func Zero(typ Type) Value ... methods:\n// 如果v是否持有值，如果v是Value零值，返回false. func (v Value) IsValid() bool func (v Value) IsNil() bool // 返回v持有值的分类，如果v是Value零值，返回Invalid func (v Value) Kind() Kind // 返回v持有的值的类型Type. func (v Value) Type() Type ... ",
    "categories": ["Golang"],
    "tags": ["oop"]
  },
  {
    "title": "GSL_string",
    "permalink": "https://canuxcheng.com/post/gsl_string/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"strings\"\u003estrings\u003c/h1\u003e\n\u003cp\u003e实现了用于操作字符的函数.\u003c/p\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003efunc EqualFold(s, t string) bool\n\nfunc HasPrefix(s, prefix string) bool\nfunc HasSuffix(s, suffix string) bool\n\nfunc Count(s, sep string) int\n\nfunc Contains(s, substr string) bool\n...\n\nfunc Index(s, sep string) int\n...\n\nfunc LastIndex(s, sep string) int\n...\n\nfunc title(s string) string\n\nfunc ToLower(s string) string\n...\n\n// 返回count个string\nfunc Repeat(s string, count int) string\n\nfunc Replace(s, old, new string, n int) string\n\nfunc Map(mapping func(rune) rune, s string) string\n\nfunc Trim(s string, cutset string) string\n...\n\n// 返回将字符串按照空白分割的多个字符串\nfunc Fields(s string) []string\n// 按照f作为分隔符来分割字符串，返回切片\nfunc FieldsFunc(s string, f func(rune) bool) []string\n\nfunc Split(s, sep string) []string\n...\n\n// 将一系列字符串连接为一个字符串，之间用sep来分割.\nfunc Join(a []string, sep string) string\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reader\"\u003eReader\u003c/h2\u003e\n\u003ch2 id=\"replacer\"\u003eReplacer\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"bytes\"\u003ebytes\u003c/h1\u003e\n\u003cp\u003e实现了操作[]bytes的常用函数.\u003c/p\u003e",
    "content": "strings 实现了用于操作字符的函数.\nfunctions func EqualFold(s, t string) bool func HasPrefix(s, prefix string) bool func HasSuffix(s, suffix string) bool func Count(s, sep string) int func Contains(s, substr string) bool ... func Index(s, sep string) int ... func LastIndex(s, sep string) int ... func title(s string) string func ToLower(s string) string ... // 返回count个string func Repeat(s string, count int) string func Replace(s, old, new string, n int) string func Map(mapping func(rune) rune, s string) string func Trim(s string, cutset string) string ... // 返回将字符串按照空白分割的多个字符串 func Fields(s string) []string // 按照f作为分隔符来分割字符串，返回切片 func FieldsFunc(s string, f func(rune) bool) []string func Split(s, sep string) []string ... // 将一系列字符串连接为一个字符串，之间用sep来分割. func Join(a []string, sep string) string Reader Replacer bytes 实现了操作[]bytes的常用函数.\nconstants variables functions Reader Buffer Buffer是一个实现了读写方法的可变大小的字节缓冲.\n零值是一个空的可用于读写的缓冲.\nstruct:\ntype Buffer struct {} functions:\nfunc NewBuffer(buf []byte) *Buffer func NewBufferString(s string) *Buffer methods:\nfunc (b *Buffer) String() string func (b *Buffer) Read(p []byte) (n int, err error) func (b *Buffer) Write(p []byte) (n int, err error) strconv 实现了基本数据类型和字符串的相互转换.\nconstants const InitSize = intSize Variables var ErrRange = errors.New(\u0026quot;value out of range\u0026quot;) var ErrSyntax = errors.New(\u0026quot;invalid syntax\u0026quot;) functions // 返回一个字符是否是可打印的 func IsPrint(r rune) bool // 返回字符串s是否可以不被修改的表示为一个反引号字符串 func CanBackquote(s string) bool func Quote(s string) string ... func Unquote(s string) (t string, err error) ... func AppendInt(dst []byte, i int64, base int) []byte ... // 字符串转换成其他类型 func ParseInt(s string, base int, bitSize int) (i int64, err error) ... // 其他类型转换为字符串 func FormatInt(i int64, base int) string ... // ParseInt(s, 10, 0)的简写, string -\u0026gt; int func Atoi(s string) (i int, err error) // FormatInt(i, 10)的简写, int -\u0026gt; string func Itoa(i int) string NumError 表示一次失败的转换\nstruct:\ntype NumError struct { Func string Num string Err error } methods:\nfunc (e *NumError) Error() string unicode regexp 实现了正则表达式搜索\nfunctions Regexp Regexp代表一个编译好的正则表达式．\ntype Regexp struct {} functions:\nfunc Compile(expr string) (*Regexp, error) func CompilePOSIX(expr string) (*Regexp, error) func MustCompile(str string) *Regexp func MustCompilePOSIX(str string) *Regexp methods:\nregexp/syntax index/suffixarray ",
    "categories": ["Golang"],
    "tags": ["string"]
  },
  {
    "title": "GSL_system",
    "permalink": "https://canuxcheng.com/post/gsl_system/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"os\"\u003eos\u003c/h1\u003e\n\u003cp\u003e提供了操作系统的不依赖平台的接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026quot;os\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# flag 参数\nconst (\n    O_RDONLY int = syscall.O_RDONLY\n    O_WRONLY int = syscall.O_WRONLY\n    O_RDWR int = syscall.O_RDWR\n    O_CREATE int = syscall.O_CREATE # 不存在就创建\n    O_APPEND int = syscall.O_APPEND # 追加写入\n    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件\n    O_EXCL int = syscall.O_EXCL\n    O_SYNC int = syscall.O_SYNC\n)\n\nconst (\n    SEEK_SET int = 0\n    SEEK_CUR int = 1\n    SEEK_END int = 2\n)\n\nconst (\n    // 操作系统指定的路径分隔符\n    PathSeperator = '/'\n    // 操作系统指定的表分隔符\n    PathListSeparator = ':'\n)\n\n// 操作系统空设备的名字\nconst DevNull = \u0026quot;/dev/null\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003evar (\n    ErrInvalid = errors.New(\u0026quot;invalid argument\u0026quot;)\n    ...\n)\n\n// 指向标准输入／输出／错误的文件描述符\nvar (\n    Stdin = NewFile(uintptr(syscall.Stdin), \u0026quot;/dev/stdin\u0026quot;)\n    Stdout = NewFile(uintptr(syscall.Stdout), \u0026quot;/dev/stdout\u0026quot;)\n    Stderr = NewFile(uintptr(syscall.Stderr), \u0026quot;/dev/stderr\u0026quot;)\n)\n\n// 保存了命令行参数，第一个是程序名\nvar Args []string\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 返回内核提供的主机名\nfunc Hostname() (name string, err error)\n\n// 当前程序以给出的状态码马上退出，defer不会执行\nfunc Exit(code int)\n\n// 返回key=value格式的环境变量的字符串的切片拷贝\nfunc Environ() []string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文件相关的操作\u003c/p\u003e",
    "content": "os 提供了操作系统的不依赖平台的接口\nimport \u0026quot;os\u0026quot; constants # flag 参数 const ( O_RDONLY int = syscall.O_RDONLY O_WRONLY int = syscall.O_WRONLY O_RDWR int = syscall.O_RDWR O_CREATE int = syscall.O_CREATE # 不存在就创建 O_APPEND int = syscall.O_APPEND # 追加写入 O_TRUNC int = syscall.O_TRUNC # 打开时清空文件 O_EXCL int = syscall.O_EXCL O_SYNC int = syscall.O_SYNC ) const ( SEEK_SET int = 0 SEEK_CUR int = 1 SEEK_END int = 2 ) const ( // 操作系统指定的路径分隔符 PathSeperator = '/' // 操作系统指定的表分隔符 PathListSeparator = ':' ) // 操作系统空设备的名字 const DevNull = \u0026quot;/dev/null\u0026quot; variables var ( ErrInvalid = errors.New(\u0026quot;invalid argument\u0026quot;) ... ) // 指向标准输入／输出／错误的文件描述符 var ( Stdin = NewFile(uintptr(syscall.Stdin), \u0026quot;/dev/stdin\u0026quot;) Stdout = NewFile(uintptr(syscall.Stdout), \u0026quot;/dev/stdout\u0026quot;) Stderr = NewFile(uintptr(syscall.Stderr), \u0026quot;/dev/stderr\u0026quot;) ) // 保存了命令行参数，第一个是程序名 var Args []string functions // 返回内核提供的主机名 func Hostname() (name string, err error) // 当前程序以给出的状态码马上退出，defer不会执行 func Exit(code int) // 返回key=value格式的环境变量的字符串的切片拷贝 func Environ() []string 文件相关的操作\nfunc IsExist(err error) bool // 文件存在返回true func IsNotExist(err error) bool // 文件不存在返回true func IsPathSeparator(c uint8) bool ... func SameFile(fi1, fi2 FileInfo) bool func Getwd() (dir string, err error) func Chdir(dir string) error func Chmod(name string, mode FileMode) error func Chown(name string, uid, gid int) error ... func Mkdir(name string, perm FileMode) error // 创建单个目录 func MkdirAll(path string, perm FileMode) error // 创建多级目录 func Rename(oldpath, newpath string) error func Truncate(name string, size int64) error func Remove(name string) error func RemoveAll(path string) error func Readlink(name string) (string, error) func Symlink(oldname, newname string) error // 创建符号连接 func Link(oldname, newname string) error // 创建硬连接 func TempDir() string // 返回一个用于保管临时文件的默认目录 // 从filename指定的文件读取数据并返回, 成功返回文件内容和nil func ReadFile(filename string) ([]byte, error) // 向filename指定文件写入数据，如果文件存在先清空文件，如果不存在创建文件. func WriteFile(filename string, data []byte, perm os.FileMode) error Signal interface:\ntype Signal interface { String() string Signal() } variable:\nvar ( Interrupt Signal = syscall.SIGINT Kill Signal = syscall.SIGKILL ) FileMode 代表文件模式和权限位．\ntype FileMode uint32 constant:\nconst ( ModeDir FileMode = 1 \u0026lt;\u0026lt; (32 - 1 - iota) // d: 目录 ... ModeType = ModeDir | ModeSymlink | ModeNamePipe | ModeSocket | ModeDevice ModePerm FileMode = 0777 ) methods:\nfunc (m FileMode) IsDir() bool func (m FileMode) IsRegular() bool FileInfo 用来描述一个文件对象\ntype FileInfo interface { Name() string Size() int64 Mode() FileMode ModeTime() time.Time IsDir() bool Sys() interface{} } function:\n// 获取一个文件对象 func Stat(name string) (fi FileInfo, err error) func Lstat(name string) (fi FileInfo, err error) File 表示一个打开的文件对象\nstruct:\ntype File struct {} functions:\n// 采用flag=os.O_RDWR和perm=0666模式创建一个名为name的文件, 返回读写文件句柄 // 文件已存在就截断 func Create(name string) (file *File, err error) // 打开指定文件，返回只读文件句柄, flag=os.O_RDONLY func Open(name string) (file *File, err error) // 指定flag和perm创建／打开文件 func OpenFile(name string, flag int, perm FileMode) (file *File, err error) // 使用给定的文件描述服和名称创建一个文件. func NewFile(fd uintptr, name string) *File // 返回一对关联的文件对象 func Pipe() (r *File, w *File, err error) methods:\n// 从文件f中最多读取len(b)字节数据写入b, 返回读取的字节数 // 返回0, io.EOF, 表示读取0个字节,文件终止． func (f *File) Read(b []byte) (n int, err error) func (f *File) ReadAt(b []byte, off int64) (n int, err error) // 向文件f写入len(b)字节数据b，返回写入字节数 func (f *File) Write(b []byte) (n int, err error) func (f *File) WriteAt(b []byte, off int64) (ret int, err error) func (f *File) WriteString(s string) (ret int, err error) func (f *File) Close() error Process 保存一个被StarProcess创建的进程的信息\nstruct:\ntype Process struct { Pid int } functions:\n// 启动一个新进程 func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) // 查找一个运行中的进程 func FindProcess(pid int) (p *Process, err error) methods:\n// 向进程发送信号 func (p *Process) Signal(sig Signal) error // 阻塞直到进程退出 func (p *Process) Wait() (*ProcessState, error) // 让进程立刻退出 func (p *Process) Kill() error // 释放进程绑定的资源 func (p *Process) Release() error ProcessState 保管Wait函数报告的某个已退出进程的信息．\nstruct:\ntype ProcessState struct {} methods:\n// 返回一个已退出的进程的id func (p *ProcessState) Pid() int // 报告进程是否已退出 func (p *ProcessState) Exited() bool // 报告进程是否成功退出 func (p *ProcessState) Success() bool // 返回已退出进程及其子进程耗费的系统cpu时间 func (p *ProcessState) SystemTime() time.Duration // 返回已退出进程及其子进程耗费的用户cpu时间 func (p *ProcessState) UserTime() time.Duration func (p *ProcessState) Sys() interface{} func (p *ProcessState) SysUsage() interface{} func (p *ProcessState) String() string ProcAttr 保存被StratProcess启动的新进程的属性\nstruct:\ntype ProcAttr struct { Dir string Env []string Files []*File Sys *syscall.SysProcAttr } os/exec 执行外部命令，包装了os.StartProcess函数，提供更高级的接口.\nvariable var ErrNotFound = errors.New(\u0026quot;executable file not found in $PATH\u0026quot;) functions // 在环境变量指定的目录中搜索可执行文件file func LookPath(file string) (string, error) Cmd 表示一个准备执行或执行中的外部命令\nstruct:\ntype Cmd struct { Path string Args []string Env []string Dir string stdin io.Reader Stdout io.Writer Stderr io.Writer ExtraFiles []*os.File SysProcAttr *syscall.SysProcAttr Process *os.Process ProcessState *os.ProcessState } functions:\n// 返回*Cmd func Command(name string, arg ***string) *Cmd methods:\n// 同步：执行命令，并阻塞直到完成 func (c *Cmd) Run() error // 异步：开始执行命令，不阻塞直接返回， func (c *Cmd) Start() error // 阻塞通过Start执行的命令直到完成，设置状态码并释放资源． func (c *Cmd) Wait() error func (c *Cmd) StdinPipe() (io.WriteCloser, error) func (c *Cmd) StdoutPipe() (io.ReadCloser, error) func (c *Cmd) StderrPipe() (io.ReadCloser, error) // 执行命令并返回stdout的切片 func (c *Cmd) Output() ([]byte, error) // 执行命令并返回stdout和stderr合并后的切片 func (c *Cmd) CombinedOutput() ([]byte, error) os/signal os/user syscall 提供了操作系统级别的调用．\nimport \u0026quot;syscall\u0026quot; constants const ( AF_ALG = 0x26 ... ) // 定义异常 const ( E2BIG = Errno(0x70) ... ) // 定义信号 const ( SIGABRT = Signal(0x6) ... ) const ( SYS_READ = 0 ... ) const ( SizeofSockaddrInet4 = 0x10 ... ) const ( IFA_UNSPEC = 0x0 ... ) const ( SizeofSockFilter = 0x8 ... ) const ( VINTR = 0x0 ... ) const ImplementsGetwd = true const PathMax = 0x1000 const SizeofInotifyEvent = 0x10 variables var ( Stdin = 0 Stdout = 1 Stderr = 2 ) var ForkLock sync.RWMutex var SocketDisableIPv6 bool others 参考文档\nio 提供了对IO原语的基本接口\ngo1.16 删除了io/ioutil\nimport \u0026quot;io\u0026quot; variables // 放无法获取更多输入时Read方法返回os.EOF var EOF = errors.New(\u0026quot;EOF\u0026quot;) functions func ReadAll(r io.Reader) ([]byte, error) func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) func ReadFull(r Reader, buf []byte) (n int, err error) // 将src数据拷贝到dst, 直到EOF或出错，返回拷贝的字节数 func Copy(dst Writer, src Reader) (written int64, err error) // 类似Copy，不过只拷贝n个字节. func CopyN(dst Writer, src Reader, n int64) (written int64, err error) func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) // 将字符串s写入w func WriteString(w Writer, s string) (n int, err error) Reader 用于包装基本的读取方法\nos.File(os.Stdout, os.Stdin. os.Stderr), bytes.Buffer 和 bufio.Reader 都是io.Reader接口\ninterface:\ntype Reader interface { Read(p []byte) (n int, err error) } Writer 用于包装基本的写入方法\nos.File(os.Stdin, os.Stderr, os.Stdin), bytes.Buffer 和 bufio.Writer, net/http.ResponseWriter 都是io.Writer接口\ninterface:\ntype Writer interface { Write(p []byte) (n int, err error) } Closer 用于包装基本的关闭方法\ninterface:\ntype Closer interface { Close() error } Seeker 用于包装基本的移位方法\ninterface:\ntype Seeker interface { Seek(offset int64, whence int) (int64, error) } ReadWriter interface:\ntype ReadWriter interface { Reader Writer } bufio bufio实现了有缓冲的IO\nconstants const ( // 用于缓冲一个token MaxScanTokenSize = 64 * 1024 ) variables // 会被Scanner返回的错误 var ( ErrInvalidUnreadByte = errors.New(\u0026quot;bufio: invalid use of UnreadByte\u0026quot;) ... ) functions func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error) func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error) func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error) // 将每一行文本去掉末尾的换行标记，然后作为一个token返回 func ScanLines (data []byte, atEOF bool) (advance int, token []byte, err error) Reader 给io.Reader接口对象附加缓冲\nstruct:\ntype Reader struct {} functions:\nfunc NewReader(rd io.Reader) *Reader func NewReaderSize(rd io.Reader, size int) *Reader methods:\nfunc (b *Reader) Read(p []byte) (n int, err error) // 读取直到第一次遇到delim字节，返回一个包含已读取数据和delim字节的字符串 // 当且仅当返回的切片不以delim结尾时，返回非nil错误 func (b *Reader) ReadString(delim byte) (line string, err error) func (b *Reader) ReadBytes(delim byte) (line []byte, err error) func (b *Reader) ReadSlice(delim byte) (line []byte, err error) func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) func (b *Reader) ReadByte() (c byte, err error) func (b *Reader) ReadRune() (r rune, size int, err error) Writer 给io.Writer接口对象提供缓冲\nstruct:\ntype Writer struct {} functions:\nfunc NewWriter(w io.Writer) *Writer func NewWriterSize(w io.Writer, size int) *Writer methods:\nfunc (b *Writer) Write(p []byte) (nn int, err error) func (b *Writer) WriteString(s string) (int, error) func (b *Writer) WriteByte(c byte) error func (b *Writer) WriteRune(r rune) (size int, err error) func (b *Writer) Flush() error ReadWriter struct:\ntype ReadWriter struct { *Reader *Writer } functions:\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWriter Scanner 提供了方便的读取数据接口\nstruct:\ntype Scanner struct {} functions:\n// 创建并返回一个从r读取数据的Scanner，默认分割函数是ScanLines func NewScanner(r io.Reader) *Scanner methods:\n// 设置s的分割函数 func (s *Scanner) Split(split SplitFunc) // 获取当前位置的token, 并让Scanner的扫描位置移动到下一个token. func (s *Scanner) Scan() bool // 返回最近一次Scan调用生成的token. func (s *Scanner) Bytes() []byte // 创建一个字符串保存Bytes返回的token,并返回 func (s *Scanner) Text() string // 返回Scanner遇到的第一个非EOF错误 func (s *Scanner) Err() error SplitFunc type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error) fmt 实现了类似于C的printf/scanf的格式化IO.\nimport \u0026quot;fmt\u0026quot; 通用占位符:\n%v 相应值的默认格式 %+v 同时打印结构体的字段名 %#v 相应值的go语法表示 %T 相应值的类型的go语法表示 %% 字面上的百分号 布尔类型：\n%t true/false 整数类型：\n%b 二进制表示 %c 相应的unicode码点所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号包围的字符字面值 %x 十六进制(字母小写) %X 十六进制(字母大写) %U unicode格式 浮点数类型：\n%b 无小数部分的，指数为二的幂的科学计数法． %e 科学计数法 %E 科学计数法 %f 有小数点，而无指数 %g 根据情况选择%e 或 %f %G 根据情况选择E% 或 %f %[宽度]Type %.[精度]Type %[宽度].[精度]Type 字符串与字节切片：\n%s 字符串或切片的字节 %q 双引号包围的字符串 %x 十六进制(小写字母) %X 十六进制(大写字母) 指针：\n%p 十六进制表示(0x) functions // 返回一个包含该格式化字符串的错误 func Errorf(format string, a ...interface{}) error // 写入到STDOUT, 返回写入字节数 // 默认格式化 func Print(a ...interface{}) (n int, err error) // 默认格式化，自动结尾添加换行符 func Println(a ...interface{}) (n int, err error) // 指定格式化 func Printf(format string, a ...interface{}) (n int, err error) // 写入到w, 返回写入字节数 // w: os.File bufio.Writer func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) // 返回该字符串 func Sprint(a ...interface{}) string func Sprintln(a ...interface{}) string func Sprintf(format string, a ...interface{}) string // 从STDIN扫描文本存入a,返回成功扫描的个数 // 换行视为空白，获取len(a)个条目才停止扫描 func Scan(a ...interface{}) (n int, err error) // 换行才停止扫描 func Scanln(a ...interface{}) (n int, err error) // 根据空格分割的条目格式化写入指定参数a func Scanf(format string, a ...interface{}) (n int, err error) // 从r扫描文本存入a, 返回成功扫描的条目 // r: os.File bufio.Reader func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) // 从字符串str扫描文本存入a, 返回扫描成功的条目 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) Stringer interface:\ntype Stringer initerface { String() string } GoStringer interface:\ntype GoStringer interface { GoString() string } State interface:\ntype State interface { Write(b []byte) (ret int, err error) Width() (wid int, ok bool) Precision() (prec int, ok bool) Flag(c int) bool } Formatter interface:\ntype Formatter interface { Format(f State, c rune) } ScanState interface:\ntype ScanState interface { ReadRune() (r rune, size int, err error) UnreadRune() error SkipSpace() Token(skipSpace bool, f func(rune) bool) (token []byte, err error) Width() (wid int, ok bool) Read(buf []byte) (n int, err error) } Scanner interface:\ntype Scanner interface { Scan(state ScanState, verb rune) error } log 实现了简单的日志服务.\nConstants const ( Ldate = 1 \u0026lt;\u0026lt; iota // 日期 Ltime // 时间 Lmicroseconds // 微秒 Llongfile // 绝对文件名和行好 /path/to/file.go:13 Lshortfile // 文件名和行好, 覆盖上面字段 file.go:13 LstdFlags = Ldate | Ltime // 标准logger的初始值 ) functions func Printf(format string, v ...interface{}) func Print(v ...interface{}) func Println(v ...interface{}) // 下列函数在Print...函数基础上再调用os.Exit(1) func Fatalf(format string, v ...interface{}) func Fatal(v ...interface{}) func Fatalln(v ...interface{}) // 下列函数在Print...函数基础上再调用panic(...) // panic会执行当前函数的defer, 然后退出当前函数，返回到调用者， // 调用函数会执行defer, 直到应用程序退出.最后panic. func Panicf(format string, v ...interface{}) func Panic(v ...interface{}) func Panicln(v ...interface{}) Logger struct:\ntype Logger struct {} function:\n// 创建一个Logger. func New(out io.Writer, prefix string, flag int) *Logger methods:\nfunc (l *Logger) Flags() int flag 实现了命令行参数解析\n第三方包:\nhttps://github.com/alecthomas/kingpin\nvariables var CommandLine = NewFlagSet(os.Args[0], ExitOnError) // var ErrHelp = errors.New(\u0026quot;flag: help requested\u0026quot;) // var Usage = func() { fmt.Fprintf(os.Stderr, \u0026quot;Usage of %s:\\n\u0026quot;, os.Args[0]) PrintDefaults() } functions // 返回已被设置的flag数量 func NFlag() int // 返回已注册flag的结构体指针 func Lookup(name string) *Flag // 非flag参数不能在flag参数前面指定，否则flag参数不会被解析． // 返回非flag参数个数 func NArg() int // 返回所有非flag参数 func Args() []string // 返回第i个非flag参数, i=0 就是第一个参数，而不是程序名称 func Arg(i int) string // 向Stderr写入所有注册好的flag的默认值 func PrintDefaults() // 从os.Args[1:] 中解析注册的flag. func Parse() // 返回是否Parse是否被调用过 func Parsed() bool // 按照字典顺序遍历flag，并对每个flag调用fn, 只针对解析时设置了的flag func Visit(fn func(*Flag)) // 按照字典顺序遍历flag,　并对每个flag调用fn, 针对所有flag. func VisitAll(fn func(*Flag)) // 用指定的名称，默认值，帮助信息注册一个bool类型的flag // 返回一个保存了该flag的值的指针 func Bool(name string, value bool, usage string) *bool // 用指定的名称，默认值，帮助信息注册一个bool类型的flag // 将flag值保存到指针p指向的变量 func BoolVar(p *bool, name string, value bool, usage string) func Int func IntVar func Int64 func Int64Var func Uint func UintVar func Uint64 func Uint64Var func Float64 func Float64Var func String func StringVar // time.Duration类型 func Duration func DurationVar // 用指定的名字，帮助信息，注册一个flag，类型由value决定 func Var(value Value, name string, usage string) // 设置已注册的flag的值 func Set(name, value string) error ErrorHandling 定义如何处理flag解析错误\ntype ErrorHandling int const ( ContinueOnError ErrorHandling = iota ExitOnError PanicOnError ) Flag 定义一个flag\nstruct:\ntype Flag struct { Name string Usage string Value Value DefValue string } FlagSet 代表一个已注册flag集合.\nFlagSet零值没有名字，默认采用ContinueOnError.\nstruct:\ntype FlagSet struct { Usage func() } functions:\n// 创建一个新的FlagSet叫name，采用errorHandling为错误处理策略 func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet methods:\n// 设置f的名字和错误处理策略. func (f *FlagSet) Init(name string, errorHandling ErrorHandling) Value 用于将动态值保存在flag里.\ninterface:\ntype Value interface { String() string Set(string) error } Getter logrus https://github.com/sirupsen/logrus\ncobra https://github.com/spf13/cobra\n",
    "categories": ["Golang"],
    "tags": ["system"]
  },
  {
    "title": "GSL_test",
    "permalink": "https://canuxcheng.com/post/gsl_test/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"testing\"\u003etesting\u003c/h1\u003e\n\u003cp\u003ego的测试由go test命令和testing包组成．\u003c/p\u003e\n\u003cp\u003e测试程序命名：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eXXX.go # 测试文件和源码放在一个包中\nXXX_test.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e测试程序结构：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026quot;testing\u0026quot;\n\n# 单元测试\n# go test 会自动执行\nfunc TestXXX(t *testing.T) {}\n\n# 性能测试\n# go test XXX_test.go -test.bench=\u0026quot;.*\u0026quot;  压力测试需要指定才能执行\nfunc BenchmarkXXX(b *testing.B) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constants\"\u003econstants\u003c/h2\u003e\n\u003ch2 id=\"variables\"\u003evariables\u003c/h2\u003e\n\u003ch2 id=\"functions\"\u003efunctions\u003c/h2\u003e\n\u003ch2 id=\"t\"\u003eT\u003c/h2\u003e\n\u003cp\u003e管理测试状态并支持格式化测试的日志．\u003c/p\u003e\n\u003cp\u003estruct:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype T struct {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethods:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 将当前测试标识为失败，但继续执行该文件剩下的测试\nfunc (c *T) Fail()\n\n// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.\nfunc (c *T) FailNow()\n\n// 用于报告测试函数是否失败\nfunc (c *T) Failed() bool\n\nfunc (c *T) Log(args ...interface{})\nfunc (c *T) Logf(format string, args ...interface{})\n\n# 相当于Log/Logf之后调用Fail.(当前case失败)\nfunc (c *T) Error(args ...interface{})\nfunc (c *T) Errorf(format string, args ...interface{})\n\n# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)\nfunc (c *T) Fatal(args ...interface{})\nfunc (c *T) Fatalf(format string, args ...interface{})\n\nfunc (c *T) Skip(args ...interface{})\nfunc (c *T) SkipNow()\nfunc (c *T) Skipf(format string, args ...interface{})\nfunc (c *T) Skipped() bool\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"b\"\u003eB\u003c/h2\u003e\n\u003cp\u003e管理基准测试的计时行为，并指示应该迭代的运行测试多少次.\u003c/p\u003e",
    "content": "testing go的测试由go test命令和testing包组成．\n测试程序命名：\nXXX.go # 测试文件和源码放在一个包中 XXX_test.go 测试程序结构：\nimport \u0026quot;testing\u0026quot; # 单元测试 # go test 会自动执行 func TestXXX(t *testing.T) {} # 性能测试 # go test XXX_test.go -test.bench=\u0026quot;.*\u0026quot; 压力测试需要指定才能执行 func BenchmarkXXX(b *testing.B) {} constants variables functions T 管理测试状态并支持格式化测试的日志．\nstruct:\ntype T struct {} methods:\n// 将当前测试标识为失败，但继续执行该文件剩下的测试 func (c *T) Fail() // 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件. func (c *T) FailNow() // 用于报告测试函数是否失败 func (c *T) Failed() bool func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args ...interface{}) # 相当于Log/Logf之后调用Fail.(当前case失败) func (c *T) Error(args ...interface{}) func (c *T) Errorf(format string, args ...interface{}) # 相当于Log/Logf之后调用FailNow.(当前测试文件失败) func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Skip(args ...interface{}) func (c *T) SkipNow() func (c *T) Skipf(format string, args ...interface{}) func (c *T) Skipped() bool B 管理基准测试的计时行为，并指示应该迭代的运行测试多少次.\nstruct:\ntype B struct { N int } methods:\nfunc (c *B) Fail() func (c *B) FailNow() func (c *B) Failed() bool func (c *B) Error(args ...interface{}) func (c *B) Errorf(format string, args ...interface{}) func (c *B) Fatal(args ...interface{}) func (c *B) Fatalf(format string, args ...interface{}) func (c *B) Log(args ...interface{}) func (c *B) Logf(format string, args ...interface{}) func (c *B) Skip(args ...interface{}) func (c *B) SkipNow() func (c *B) Skipf(format string, args ...interface{}) func (c *B) Skipped() bool testing/iotest testing/quick gotests 通过源代码自动生成测试代码，可以用命令行，也可以用goland等的插件．\nhttps://github.com/cweill/gotests\ngo get -u github.com/cweill/gotests/... ",
    "categories": ["Golang"],
    "tags": ["test"]
  },
  {
    "title": "OOP",
    "permalink": "https://canuxcheng.com/post/go_oop/",
    "date": "2018-01-01",
    "summary": "\u003ch1 id=\"go面向对象\"\u003eGo面向对象\u003c/h1\u003e\n\u003cp\u003egolang通过方法和接口实现面向对象.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"方法method\"\u003e方法/method\u003c/h1\u003e\n\u003cp\u003ego中没有类，但是可以为结构体定义方法．\u003c/p\u003e\n\u003cp\u003e方法就是一类带有特殊的　接收者参数　的函数．\u003c/p\u003e\n\u003cp\u003e只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．\u003c/p\u003e\n\u003cp\u003e除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．\u003c/p\u003e\n\u003cp\u003e方法有两种接收者,值接收者和指针接收者.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Vertex struct {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e值接收者:\u003c/p\u003e\n\u003cp\u003e值接收者操作的是值的副本.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (v Vertex) MethodName() rType {\n    ...\n}\n\nvar v Vertex\nv.MethodName() // 操作值的副本\n\n# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换\nvp := new(Vertex)\nvp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e指针接收者：\u003c/p\u003e\n\u003cp\u003e指针接收者，调用方法的时候操作的是该指针指向的值.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 指针接收者的方法可以修改接收者指向的值\nfunc (v *Vertex) MethodName() rType {\n    ...\n}\n\nvp := new(Vertex)\nvp.MethodName() // 操作实际的值\n\n# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.\nvar v Vertex\nv.MethodName() // (\u0026amp;v).MethodName() , 操作的是实际的值\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"接口interface\"\u003e接口/Interface\u003c/h1\u003e\n\u003cp\u003e接口是引用类型.\u003c/p\u003e",
    "content": "Go面向对象 golang通过方法和接口实现面向对象.\n方法/method go中没有类，但是可以为结构体定义方法．\n方法就是一类带有特殊的　接收者参数　的函数．\n只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．\n除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．\n方法有两种接收者,值接收者和指针接收者.\ntype Vertex struct { ... } 值接收者:\n值接收者操作的是值的副本.\nfunc (v Vertex) MethodName() rType { ... } var v Vertex v.MethodName() // 操作值的副本 # 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换 vp := new(Vertex) vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本. 指针接收者：\n指针接收者，调用方法的时候操作的是该指针指向的值.\n# 指针接收者的方法可以修改接收者指向的值 func (v *Vertex) MethodName() rType { ... } vp := new(Vertex) vp.MethodName() // 操作实际的值 # 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换. var v Vertex v.MethodName() // (\u0026amp;v).MethodName() , 操作的是实际的值 接口/Interface 接口是引用类型.\n接口类型是由一组方法签名定义的集合．\n接口类型的值可以保存任何实现了这些方法的值．\n某个类型实现了该接口的所有方法签名，就算实现了该接口,无需显示申明实现了哪个接口.\n接口可以匿名嵌入其它接口，或嵌入到结构中．\n一般只有一个方法的接口命名为MethodName + \u0026rsquo;er'.\n接口存储两个数据接口：\niTable, 包含存储值的类型信息以及和该值关联的方法. 指向存储的值的指针. 定义接口：\ntype IName interface { MethodName() ... } type SName struct { ... } 值接收者方法:\n接口类型的值为值或指针都可以调用该方法.\nfunc (s SName) MethodName() {} 指针接收者方法:\n接口类型的值必须为指针才能调用该方法.\nfunc (s *SName) MethodName() { ... } s := \u0026amp;SName{...} // i = \u0026amp;SName{...} //接口变量能保存实现了该接口的任意类型的对象 i = s i.MethodName() # 接口类型为值时，调用失败 var s SName i = s i.MethodName() // 调用失败 底层值为nil的接口值:\nvar i IName var s SName i = s # 接口值为nil 空接口：\n所有类型都实现了空接口.\n指定了零个方法的接口值被称为空接口,一般用来处理未知类型的值.\n当接口储存的类型和对象都为nil，接口才为nil\n以空接口为参数的函数可以接收任意类型的值作为参数.\n如果一个函数返回空接口就可以返回任意类型的值.\n# 空接口可以保存任何类型的值 var i interface{} # 空接口作为形参 func FuncName(i interface{}) {} 指针的类型断言/comma-ok断言：\n断言接口值i保存了具体类型Type, 并将底层类型为Type的值赋予变量t.\n只返回一个值，断言失败会触发panic. t := i.(Type) 返回两个值，断言成功返回true, 失败返回false. t, ok := i.(Type) 指针的类型选择/switch测试：\n// i.(type) 是固定写法 switch TypeValue := i.(type) { case Type1: ... case Type2: ... ... default: ... } 嵌入接口:\n接口中可以嵌入其它接口，这样实现了该接口的对象就隐式包含嵌入接口的所有方法.\ntype Interface interface {} 封装 小写字母开头的标识符（类型/属性/方法\u0026hellip;)是未公开的，只能在当前包引用，不能在其它包引用。\n可以通过创建工厂函数对外暴露未公开的标识符:\n标识符才有公开或未公开属性，值没有 短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量；显示声明的变量不能引用未公开类型。 通过工厂函数返回未公开类型的值:\n# packageA type privateType Type func New(args) privateType { return privateType(args) } # packageB import packageA func main() { b := packageA.New(args) // 返回一个值，而不是标识符 } 公开类型的未公开属性:\n# packageA type Public struct { private Type } # packageB import packageA func main() { b := packageA.Public{ private: value, // panic, 公开类型的未公开属性不能通过字面量直接赋值 } } 类型嵌套中的未公开类型的公开属性会提升到外部类型:\n# packageA type inner struct { // inner private In Type // In public } type Outer struct { inner Out Type } # packageB import packageA func main() { b := packageA.Outer{ Out: value, // 外部类型中的未公开内部类型不能通过字面量直接赋值 } b.In = value // 内部类型的公开属性提升到外部类型。 } 多态 形式参数是接口的函数，叫做多态函数.\nfunc FuncName(iVar IName) {} 所有实现了接口的方法的实体类型，就可以作为参数传给多态函数.\n继承 通过类型嵌套实现继承，外部类型可以访问内部类型的属性和方法\n如果外部类型实现同名的属性或方法，就会覆盖内部类型的属性或方法（不过内部类型的属性和方法还在，可以通过内部类型访问）\n内部类型实现的接口，也会自动提升到外部类型。只要内部类型实现了某接口，外部类型相当于也实现了该接口。\n如果匿名字段实现了一个方法，那么包含这个匿名字段的结构也可以调用该方法.\ntype Inner struct { in Type } func (i *Inner) InnerMethod() {} type Outer struct { Inner // 只需要类型名称，不需要声明变量 out Type ... } outer := Outer{} outer.Inner.InnerMethod() //始终可以访问内部类型的方法，即使外部类型实现同名方法 outer.Inner.in // 同上 outer.InnerMethod() //如果外部类型没有实现同名方法，就是内部类型方法，否则是外部类型方法 outer.in // 同上 反射/reflact 反射就是检查程序在运行时的状态.\n使用反射一般使用标准库reflect.\n",
    "categories": ["Golang"],
    "tags": ["oop"]
  },
  {
    "title": "Rabbitmq",
    "permalink": "https://canuxcheng.com/post/rabbitmq/",
    "date": "2017-09-25",
    "summary": "\u003ch1 id=\"amqp\"\u003eAMQP\u003c/h1\u003e\n\u003cp\u003eAMQP: Advanced Message Queuing Protocol,高级消息队列协议\u003c/p\u003e\n\u003cp\u003e常用的开源AMQP框架：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rabbitmq\"\u003ehttps://github.com/rabbitmq\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/kafka\"\u003ehttps://github.com/apache/kafka\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/activemq\"\u003ehttps://github.com/apache/activemq\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"mqtt\"\u003eMQTT\u003c/h1\u003e\n\u003cp\u003eMQTT: Message Queuing Telemetry Transport,消息队列遥测传输协议\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"rabbitmq\"\u003eRabbitmq\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rabbitmq\"\u003ehttps://github.com/rabbitmq\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRabbitMQ是一个erlang开发的符合AMQP和MQTT的开源项目．\u003c/p\u003e\n\u003cp\u003erabbitmq-server也叫broker server\u003c/p\u003e\n\u003cp\u003erabbitmq的三个组件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eexchange,　交换器，发送消息的实体\u003c/li\u003e\n\u003cli\u003ebinding, 绑定器，连接交换器和队列，并且封装消息的路由信息\u003c/li\u003e\n\u003cli\u003equeue,　队列，接受消息的实体\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eworkflow:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eproducer(publish-message) =\u0026gt;\n\nrabbitmq-server =\u0026gt; exchange -\u0026gt; binding -\u0026gt; queue =\u0026gt;\n\n=\u0026gt; comsumer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eproducer: 生产message并且publish到rabbitmq-server.\u003c/p\u003e\n\u003cp\u003econsumer: 连接到rabbitmq-server并且subscribe一些queue.\u003c/p\u003e\n\u003cp\u003econnection: producer和consumer都是通过tcp连接到rabbitmq-server.\u003c/p\u003e\n\u003cp\u003echannels: 建立在tcp连接中的虚拟连接，用于处理数据流动.\u003c/p\u003e\n\u003cp\u003equeue:　生产者和消费者都应该创建queue.(只能通过exchange接收message)\u003c/p\u003e\n\u003cp\u003eexchanges类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efanout: 所有绑定到此exchange的queue都可以接收消息\u003c/li\u003e\n\u003cli\u003edirect: 通过routingKey和exchange决定的那个唯一的queue可以接收消息\u003c/li\u003e\n\u003cli\u003etopic：所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emessage类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emessages: 生产者产生的总消息数．\u003c/li\u003e\n\u003cli\u003emessages_ready: 等待deliver给消费者的消息．\u003c/li\u003e\n\u003cli\u003emessages_unack: 已经被consumer处理，但是没有被ack的消息．\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003evirtual hosts: 本质就是一个rabbitmq server,拥有独立的exchange,queue.默认是/(%2F).\u003c/p\u003e\n\u003cp\u003eround-robin dispatch: 循环分发，按顺序分发message到consumer,如果message被consumer正确接收，就会从queue中移除．\u003c/p\u003e",
    "content": "AMQP AMQP: Advanced Message Queuing Protocol,高级消息队列协议\n常用的开源AMQP框架：\nhttps://github.com/rabbitmq\nhttps://github.com/apache/kafka\nhttps://github.com/apache/activemq\nMQTT MQTT: Message Queuing Telemetry Transport,消息队列遥测传输协议\nRabbitmq https://github.com/rabbitmq\nRabbitMQ是一个erlang开发的符合AMQP和MQTT的开源项目．\nrabbitmq-server也叫broker server\nrabbitmq的三个组件：\nexchange,　交换器，发送消息的实体 binding, 绑定器，连接交换器和队列，并且封装消息的路由信息 queue,　队列，接受消息的实体 workflow:\nproducer(publish-message) =\u0026gt; rabbitmq-server =\u0026gt; exchange -\u0026gt; binding -\u0026gt; queue =\u0026gt; =\u0026gt; comsumer producer: 生产message并且publish到rabbitmq-server.\nconsumer: 连接到rabbitmq-server并且subscribe一些queue.\nconnection: producer和consumer都是通过tcp连接到rabbitmq-server.\nchannels: 建立在tcp连接中的虚拟连接，用于处理数据流动.\nqueue:　生产者和消费者都应该创建queue.(只能通过exchange接收message)\nexchanges类型:\nfanout: 所有绑定到此exchange的queue都可以接收消息 direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息 topic：所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息 message类型:\nmessages: 生产者产生的总消息数． messages_ready: 等待deliver给消费者的消息． messages_unack: 已经被consumer处理，但是没有被ack的消息． virtual hosts: 本质就是一个rabbitmq server,拥有独立的exchange,queue.默认是/(%2F).\nround-robin dispatch: 循环分发，按顺序分发message到consumer,如果message被consumer正确接收，就会从queue中移除．\nno-ack: 每次consumer接收数据后，不管是否处理完成，就标记为ack,然后从queue中删除．但是如果处理过程异常，数据就会丢失．\nack: ack方式就是数据处理完成后发送ack,保证数据被处理再从queue删除，如果异常，会dispatch到别的consumer.\ndurable: 消息持久化，如果rabbitmq-server异常退出或服务器重启，为了保证数据还在，需要做数据持久化.\n消息的状态信息：\ndeliver: 消息投递给消费着． redeliver:　消息重新投递给消费者． publish/subscribe: 将同一个消息deliver到多个consumer叫publish或subscribe. ack: 已经处理完成的消息 安装\n$ sudo apt-get install rabbitmq-server 配置\nrabbitmq-3.7 开始配置文件格式为sysctl，同时也兼容旧的erlang格式。\nerlang格式：\n[ {rabbit, [ {heartbeat, 8000} ] } ]. sysctl格式:\nkey = value rabbitmqctl 命令 $ sudo rabbitmqctl [-n node] [-t timeout] [-q] \u0026lt;commands\u0026gt; [command options] 添加用户并授权：\n# 默认的guest/guest只能用于localhost. $ add_user [username] [password] $ delete_user \u0026lt;username\u0026gt; $ change_password \u0026lt;username\u0026gt; \u0026lt;newpassword\u0026gt; $ clear_password \u0026lt;username\u0026gt; $ set_user_tags [username] administrator $ list_users 权限管理:\nadd_vhost \u0026lt;vhostpath\u0026gt; delete_vhost \u0026lt;vhostpath\u0026gt; list_vhosts [\u0026lt;vhostinfoitem\u0026gt; ...] set_permissions [-p \u0026lt;vhostpath\u0026gt;] \u0026lt;user\u0026gt; \u0026lt;conf\u0026gt; \u0026lt;write\u0026gt; \u0026lt;read\u0026gt; clear_permissions [-p \u0026lt;vhostpath\u0026gt;] \u0026lt;username\u0026gt; list_permissions [-p \u0026lt;vhostpath\u0026gt;] list_user_permissions \u0026lt;username\u0026gt; list_queues [-p \u0026lt;vhostpath\u0026gt;] [\u0026lt;queueinfoitem\u0026gt; ...] list_exchanges [-p \u0026lt;vhostpath\u0026gt;] [\u0026lt;exchangeinfoitem\u0026gt; ...] list_bindings [-p \u0026lt;vhostpath\u0026gt;] [\u0026lt;bindinginfoitem\u0026gt; ...] list_connections [\u0026lt;connectioninfoitem\u0026gt; ...] list_channels [\u0026lt;channelinfoitem\u0026gt; ...] list_consumers [-p \u0026lt;vhostpath\u0026gt;] status environment report eval \u0026lt;expr\u0026gt; rabbitmq-plugins 插件管理 启动web-gui:\n$ rabbitmq-plugins enable rabbitmq_management # http://localhost:15672 guest/guest HAProxy rabbitmq-cluster部署：\n在所有node上安装rabbitmq-server.\n修改所有node的/etc/hosts，配置ip和hostname.\n同步所有node的cookie(/var/lib/rabbitmq/.erlang.cookie).\n启动所有node上的rabbitmq-server.\n# rabbitmq-server -detached 将所有slave node添加manager组成cluster.\n# rabbitmqctl stop_app # rabbitmqctl reset # rabbitmqctl join_cluster rabbit@manager # rabbitmqctl start_app 检查cluster状态\n# rabbitmqctl cluster_status 设置policy\n# rabbitmqctl set_policy ha-all \u0026quot;\u0026quot; '{\u0026quot;ha-mode\u0026quot;:\u0026quot;all\u0026quot;,\u0026quot;ha-sync-mode\u0026quot;:\u0026quot;automatic\u0026quot;}' haproxy-server部署:\n在haproxy server安装haproxy\n配置haproxy\n# sudo vim /etc/haproxy/haproxy.cfg global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy user haproxy group haproxy daemon defaults log global mode tcp maxconn 10000 timeout connect 3000 timeout client 1000s timeout server 1000s frontend rabbitmq_front bind \u0026lt;haproxy-ip\u0026gt;:5672 reqadd X-Forwarded-Proto:\\ amqp default_backend rabbitmq_backend backend rabbitmq_backend balance roundrobin server rabbitmq-master \u0026lt;master-ip\u0026gt;:5672 check server rabbitmq-slave \u0026lt;slave-ip\u0026gt;:5672 check bind 0.0.0.0:15672 server \u0026lt;master-hostname\u0026gt; \u0026lt;master-ip\u0026gt;:15672 check server \u0026lt;slave-hostname\u0026gt; \u0026lt;slave-ip\u0026gt;:15672 check 重启haproxy service.\nCelery https://github.com/celery\n可用配置，django需要加namespace作为前缀。\nhttps://docs.celeryproject.org/en/stable/userguide/configuration.html#new-lowercase-settings\ndjango中的celery配置\nCELERY_BROKER_URL = \u0026quot;amqp://user:pw@amqp:5672\u0026quot; CELERY_ACCEPT_CONTENT = ['json'] CELERY_RESULT_SERIALIZER = 'json' CELERY_EVENT_SERIALIZER = 'json' CELERY_TIMEZONE = 'UTC' CELERY_ENABLE_UTC = True CELERY_WORKER_PREFETCH_MULTIPLIER = 4 CELERY_TASK_ACKS_LATE = False CELERY_TASK_SERIALIZER = 'json' CELERY_TASK_QUEUES = ( Queue('queue1', Exchange('exchange1', type='direct'), routing_key='default', queue_arguments={'x-max-priority': 100}), Queue('queue2', Exchange('exchange2', type='direct'), routing_key='default', queue_arguments={'x-max-priority': 100}), ) CELERY_TASK_DEFAULT_QUEUE = 'default' CELERY_TASK_DEFAULT_EXCHANGE = 'default' CELERY_TASK_DEFAULT_EXCHANGE_TYPE = 'direct' CELERY_TASK_DEFAULT_DELIVERY_MODE = 'persistent' CELERY_TASK_DEFAULT_ROUTING_KEY = 'default' CELERY_TASK_ROUTES = ( { \u0026quot;proj.app1.tasks.task1\u0026quot;: { \u0026quot;queue\u0026quot;: \u0026quot;queue1\u0026quot;, \u0026quot;routing_key\u0026quot;: \u0026quot;default\u0026quot; } }, { \u0026quot;proj.app2.tasks.task2\u0026quot;: { \u0026quot;queue\u0026quot;: \u0026quot;queue2\u0026quot;, \u0026quot;routing_key\u0026quot;: \u0026quot;default\u0026quot; } }, ) 在project中创建celery的app:\nimport os from celery import Celery # set the default Django settings module for the 'celery' program. os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'site_main.settings') app = Celery('proj') // namespace就会去django的配置找前缀为celery的参数. app.config_from_object('django.conf:settings', namespace='CELERY') app.autodiscover_tasks() celery选项:\ncelery [options] command [args] -A, --app \u0026lt;app\u0026gt;¶ -b, --broker \u0026lt;broker\u0026gt; --result-backend \u0026lt;result_backend\u0026gt; --loader \u0026lt;loader\u0026gt; --config \u0026lt;config\u0026gt; --workdir \u0026lt;workdir\u0026gt; -C, --no-color -q, --quiet --version worker选项:\n-n, --hostname -D, --detach -l, --loglevel -O default|fair // 默认的concurrency是cpu的个数，如果是container运行就是host的cpu个数，不是resourcelimit的cpu个数. -c, --concurrency // cpu密集型任务最好用prefork, IO密集最好用eventlet/gevent. -P, --poo prefork(default)|eventlet|gevent|solo -E, --task-events, --events -Q, --queues -B, --beat beat选项:\n--detach -s, --schedule -S, --scheduler -l, --loglevel inspect选项:\n-t, --timeout -d, --destination -j, --json ",
    "categories": ["Network"],
    "tags": ["rabbitmq"]
  },
  {
    "title": "Rpc",
    "permalink": "https://canuxcheng.com/post/rpc/",
    "date": "2017-09-03",
    "summary": "\u003ch1 id=\"rpc\"\u003eRPC\u003c/h1\u003e\n\u003cp\u003eRemote Procedure Call Protocol: 远程过程调用.\u003c/p\u003e\n\u003cp\u003egoogle的rpc框架，支持多语言:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/grpc/grpc\"\u003ehttps://github.com/grpc/grpc\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003efacebook的rpc框架，贡献给了apache, 支持多语言:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/thrift\"\u003ehttps://github.com/apache/thrift\u003c/a\u003e\u003c/p\u003e",
    "content": "RPC Remote Procedure Call Protocol: 远程过程调用.\ngoogle的rpc框架，支持多语言:\nhttps://github.com/grpc/grpc\nfacebook的rpc框架，贡献给了apache, 支持多语言:\nhttps://github.com/apache/thrift\n",
    "categories": ["Network"],
    "tags": ["rpc"]
  },
  {
    "title": "Germany",
    "permalink": "https://canuxcheng.com/post/travel_germany/",
    "date": "2017-05-08",
    "summary": "\u003ch1 id=\"德国之旅\"\u003e德国之旅\u003c/h1\u003e\n\u003cp\u003e看照片：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://user.qzone.qq.com/1085694641/4\"\u003ehttp://user.qzone.qq.com/1085694641/4\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e德国是汽车之都。\u003c/p\u003e\n\u003cp\u003e德国有16个州。\u003c/p\u003e\n\u003ch1 id=\"城市州\"\u003e城市州\u003c/h1\u003e\n\u003cp\u003e德国16个州中的三个城市州\u003c/p\u003e\n\u003ch2 id=\"柏林\"\u003e柏林\u003c/h2\u003e\n\u003cp\u003e德国首都。\u003c/p\u003e\n\u003cp\u003e德国第一大城市。\u003c/p\u003e\n\u003ch2 id=\"汉堡\"\u003e汉堡\u003c/h2\u003e\n\u003cp\u003e德国第二大城市。\u003c/p\u003e\n\u003ch2 id=\"不来梅\"\u003e不来梅\u003c/h2\u003e\n\u003ch1 id=\"巴伐利亚州拜仁洲\"\u003e巴伐利亚州(拜仁洲)\u003c/h1\u003e\n\u003cp\u003e慕尼黑是首府。\u003c/p\u003e\n\u003ch2 id=\"慕尼黑\"\u003e慕尼黑\u003c/h2\u003e\n\u003cp\u003e慕尼黑的奥特莱斯位于Ingolstadt Village。\u003c/p\u003e\n\u003cp\u003e奥迪的总部位于慕尼黑的Ingolstadt。\u003c/p\u003e\n\u003cp\u003e宝马总部位于慕尼黑。\u003c/p\u003e\n\u003cp\u003e德国第三大城市。\u003c/p\u003e\n\u003ch2 id=\"纽伦堡\"\u003e纽伦堡\u003c/h2\u003e\n\u003ch2 id=\"奥格斯堡\"\u003e奥格斯堡\u003c/h2\u003e\n\u003ch2 id=\"非森\"\u003e非森\u003c/h2\u003e\n\u003cp\u003e天鹅堡的所在地Fussen。\u003c/p\u003e\n\u003ch1 id=\"巴登符腾堡州\"\u003e巴登符腾堡州\u003c/h1\u003e\n\u003cp\u003e斯图加特是首府。\u003c/p\u003e\n\u003ch2 id=\"斯图加特\"\u003e斯图加特\u003c/h2\u003e\n\u003cp\u003e斯图加特的奥特莱斯位于Metzingen Village。\u003c/p\u003e\n\u003cp\u003e保时捷的总部。\u003c/p\u003e\n\u003cp\u003e奔驰的总部。\u003c/p\u003e\n\u003ch1 id=\"黑森州\"\u003e黑森州\u003c/h1\u003e\n\u003cp\u003e威斯巴登是首府。\u003c/p\u003e\n\u003ch2 id=\"威斯巴登\"\u003e威斯巴登\u003c/h2\u003e\n\u003ch2 id=\"法兰克福\"\u003e法兰克福\u003c/h2\u003e\n\u003cp\u003e该州最大城市,法国第五大城市。\u003c/p\u003e\n\u003cp\u003e法兰克福的奥特莱斯位于Wertheim Village。\u003c/p\u003e\n\u003ch1 id=\"北莱茵-威斯特法伦州\"\u003e北莱茵-威斯特法伦州\u003c/h1\u003e\n\u003cp\u003e杜塞尔多夫是首府。\u003c/p\u003e\n\u003ch2 id=\"杜塞尔多夫\"\u003e杜塞尔多夫\u003c/h2\u003e\n\u003ch2 id=\"科隆\"\u003e科隆\u003c/h2\u003e\n\u003cp\u003e该州最大城市，德国第四大城市。\u003c/p\u003e\n\u003ch1 id=\"下萨克森州\"\u003e下萨克森州\u003c/h1\u003e\n\u003cp\u003e汉诺威是首府。\u003c/p\u003e\n\u003ch2 id=\"汉诺威\"\u003e汉诺威\u003c/h2\u003e\n\u003ch2 id=\"沃尔夫斯堡\"\u003e沃尔夫斯堡\u003c/h2\u003e\n\u003cp\u003e大众总部。\u003c/p\u003e",
    "content": "德国之旅 看照片：\nhttp://user.qzone.qq.com/1085694641/4\n德国是汽车之都。\n德国有16个州。\n城市州 德国16个州中的三个城市州\n柏林 德国首都。\n德国第一大城市。\n汉堡 德国第二大城市。\n不来梅 巴伐利亚州(拜仁洲) 慕尼黑是首府。\n慕尼黑 慕尼黑的奥特莱斯位于Ingolstadt Village。\n奥迪的总部位于慕尼黑的Ingolstadt。\n宝马总部位于慕尼黑。\n德国第三大城市。\n纽伦堡 奥格斯堡 非森 天鹅堡的所在地Fussen。\n巴登符腾堡州 斯图加特是首府。\n斯图加特 斯图加特的奥特莱斯位于Metzingen Village。\n保时捷的总部。\n奔驰的总部。\n黑森州 威斯巴登是首府。\n威斯巴登 法兰克福 该州最大城市,法国第五大城市。\n法兰克福的奥特莱斯位于Wertheim Village。\n北莱茵-威斯特法伦州 杜塞尔多夫是首府。\n杜塞尔多夫 科隆 该州最大城市，德国第四大城市。\n下萨克森州 汉诺威是首府。\n汉诺威 沃尔夫斯堡 大众总部。\n",
    "categories": ["Misc"],
    "tags": ["germany"]
  },
  {
    "title": "Hadoop MapReduce",
    "permalink": "https://canuxcheng.com/post/hadoop_mapreduce/",
    "date": "2017-05-03",
    "summary": "\u003ch1 id=\"map-reduce\"\u003eMap-Reduce\u003c/h1\u003e\n\u003cp\u003e一种基于YARN的大型数据并行处理系统．主要处理离线数据．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"mapreduce-commands\"\u003emapreduce commands\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003emapred [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euser commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mapred archive\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eadmin commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mapred historyserver\n\n$ mapred hsadmin\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e",
    "content": "Map-Reduce 一种基于YARN的大型数据并行处理系统．主要处理离线数据．\nmapreduce commands mapred [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS] user commands:\n$ mapred archive ... admin commands:\n$ mapred historyserver $ mapred hsadmin ",
    "categories": ["BigData"],
    "tags": ["hadoop"]
  },
  {
    "title": "Redis",
    "permalink": "https://canuxcheng.com/post/redis/",
    "date": "2017-05-03",
    "summary": "\u003ch1 id=\"redis\"\u003eRedis\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://redisdoc.com/\"\u003ehttp://redisdoc.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eredis在key-value存储上性能比memcached更好．\u003c/p\u003e\n\u003cp\u003e安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# redis-cli, redis-sentinel, redis-server\n$ sudo apt-get install redis-server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只安装redis-cli:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install redis-tools\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eredis-server监听端口6379.\u003c/p\u003e\n\u003cp\u003eredis-sentinel端口26379.\u003c/p\u003e\n\u003cp\u003eredis gui:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/qishibo/AnotherRedisDesktopManager\"\u003ehttps://github.com/qishibo/AnotherRedisDesktopManager\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/luin/medis\"\u003ehttps://github.com/luin/medis\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eredis HA:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/CodisLabs/codis\"\u003ehttps://github.com/CodisLabs/codis\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"redis的命令\"\u003eredis的命令\u003c/h1\u003e\n\u003cp\u003eserver:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eredis-server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclient:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eredis-client\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etest:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eredis-benchmark\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esentinel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eredis-sentinel\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"cli\"\u003eCLI\u003c/h1\u003e\n\u003cp\u003eredis-cli 进入命令行模式\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; command    # 查看所有可用命令\n\n\u0026gt; info    # 查看redis服务器信息\n\n\u0026gt; monitor\n\n\u0026gt; select 1 # 选中数据库1\n\u0026gt; keys *  # 显示所有key\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"数据类型\"\u003e数据类型\u003c/h1\u003e\n\u003cp\u003estring\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\n\u0026gt; get \u0026lt;key\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elist\u003c/p\u003e",
    "content": "Redis http://redisdoc.com/\nredis在key-value存储上性能比memcached更好．\n安装：\n# redis-cli, redis-sentinel, redis-server $ sudo apt-get install redis-server 只安装redis-cli:\n$ sudo apt-get install redis-tools redis-server监听端口6379.\nredis-sentinel端口26379.\nredis gui:\nhttps://github.com/qishibo/AnotherRedisDesktopManager\nhttps://github.com/luin/medis\nredis HA:\nhttps://github.com/CodisLabs/codis\nredis的命令 server:\nredis-server client:\nredis-client test:\nredis-benchmark sentinel:\nredis-sentinel CLI redis-cli 进入命令行模式\n\u0026gt; command # 查看所有可用命令 \u0026gt; info # 查看redis服务器信息 \u0026gt; monitor \u0026gt; select 1 # 选中数据库1 \u0026gt; keys * # 显示所有key 数据类型 string\n\u0026gt; set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; \u0026gt; get \u0026lt;key\u0026gt; list\n\u0026gt; lset \u0026lt;key\u0026gt; \u0026lt;index\u0026gt; \u0026lt;value\u0026gt; \u0026gt; lindex \u0026lt;key\u0026gt; \u0026lt;index\u0026gt; \u0026gt; rpop \u0026gt; lpop \u0026lt;key\u0026gt; \u0026gt; rpush \u0026gt; lpush hash\n\u0026gt; hset \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt; \u0026gt; hget \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; set\n\u0026gt; sadd \u0026lt;key\u0026gt; \u0026lt;member\u0026gt; \u0026gt; spop \u0026lt;key\u0026gt; \u0026gt; srem \u0026lt;key\u0026gt; \u0026lt;memeber\u0026gt; sorted set\n\u0026gt; zadd \u0026lt;key\u0026gt; \u0026lt;score\u0026gt; \u0026lt;member\u0026gt; \u0026gt; zrem \u0026lt;key\u0026gt; \u0026lt;member\u0026gt; Monitoring 通过redis-cli\u0026gt; info查看\n其它指标参考grafana dashboard. Redis_mode: cluster/standalone \u0026gt;\u0026gt;\u0026gt; replication (master/slave) Connected_slaves: 连接的slave实例个数 \u0026gt;\u0026gt;\u0026gt; persistence （rdb和aof的持久化信息） ",
    "categories": ["Database"],
    "tags": ["redis"]
  },
  {
    "title": "Smtp",
    "permalink": "https://canuxcheng.com/post/smtp/",
    "date": "2017-04-26",
    "summary": "\u003ch1 id=\"email\"\u003eEmail\u003c/h1\u003e\n\u003cp\u003eMTA: Mail Transfer Agent\u003c/p\u003e\n\u003cp\u003eMUA: Mail User Agent\u003c/p\u003e\n\u003cp\u003epython邮件服务器MTA：smtp协议\u003c/p\u003e\n\u003cp\u003epython客户端MUA：本地协议pop3, 远程协议imap\u003c/p\u003e\n\u003ch2 id=\"mailutils\"\u003emailutils:\u003c/h2\u003e\n\u003cp\u003emailutils默认安装postfix,如果已经安装其它MTA就使用已经安装的．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install mailutils\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非交互安装mailutils:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 这里不用配置任何参数．\n$ sudo debconf-set-selections \u0026lt;\u0026lt;\u0026lt; \u0026quot;postfix postfix/mailname string \u0026quot;\n$ sudo debconf-set-selections \u0026lt;\u0026lt;\u0026lt; \u0026quot;postfix postfix/main_mailer_type string 'Internet Site'\u0026quot;\n$ sudo apt-get install -y mailutils\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e测试：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ echo \u0026quot;test mail body\u0026quot; | mail -s \u0026quot;test mail title\u0026quot; canuxcheng@gmail.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"sendmail\"\u003esendmail\u003c/h1\u003e\n\u003cp\u003e开源的smtp服务器．\u003c/p\u003e\n\u003cp\u003e安装sendmail:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install sendmail\n$ sudo apt-get install sendmail-cf\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置：\u003c/p\u003e",
    "content": "Email MTA: Mail Transfer Agent\nMUA: Mail User Agent\npython邮件服务器MTA：smtp协议\npython客户端MUA：本地协议pop3, 远程协议imap\nmailutils: mailutils默认安装postfix,如果已经安装其它MTA就使用已经安装的．\n$ sudo apt-get install mailutils 非交互安装mailutils:\n# 这里不用配置任何参数． $ sudo debconf-set-selections \u0026lt;\u0026lt;\u0026lt; \u0026quot;postfix postfix/mailname string \u0026quot; $ sudo debconf-set-selections \u0026lt;\u0026lt;\u0026lt; \u0026quot;postfix postfix/main_mailer_type string 'Internet Site'\u0026quot; $ sudo apt-get install -y mailutils 测试：\n$ echo \u0026quot;test mail body\u0026quot; | mail -s \u0026quot;test mail title\u0026quot; canuxcheng@gmail.com sendmail 开源的smtp服务器．\n安装sendmail:\n$ sudo apt-get install sendmail $ sudo apt-get install sendmail-cf 配置：\n$ sudo vim /etc/hosts 127.0.0.1 localhost.localdomain localhost hostname $ sudo vim /etc/mail/sendmail.mc modify 127.0.0.1 to 0.0.0.0, 才能发送给其它机器，否则只能发给本机． DAEMON_OPTIONS('..., Port=smtp, Addr=127.0.0.1')dnl # mv sendmail.cf sendmail.cf.old # m4 sendmail.mc \u0026gt; sendmail.cf postfix 比sendmail更友好的smtp服务器．\n安装：\n$ sudo apt-get install postfix # general type of mail configuration -\u0026gt; Internet site # system mail name -\u0026gt; 空着 配置：\n# 使用默认值即可. $ sudo vim /etc/postfix/main.cf inet_interfaces = all mydestination = localhost, $hostname, localhost.localdomain, localhost Python的email标准库 服务端：\nsmtpd 客户端：\nsmtplib poplib imaplib ",
    "categories": ["Network"],
    "tags": ["smtp"]
  },
  {
    "title": "HAWQ",
    "permalink": "https://canuxcheng.com/post/hawq/",
    "date": "2017-04-24",
    "summary": "\u003ch1 id=\"hawq\"\u003eHAWQ\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://hawq.incubator.apache.org/\"\u003ehttp://hawq.incubator.apache.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/incubator-hawq\"\u003ehttps://github.com/apache/incubator-hawq\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHAWQ是在Pivotal Greenplum和PostgreSQL基础上开发而来．\u003c/p\u003e\n\u003cp\u003eHAWQ也就是Pivotal HDB.\u003c/p\u003e\n\u003cp\u003eHAWQ和Pivotal　HDB是一个项目．\u003c/p\u003e\n\u003cp\u003eHortonworks公司的HDP集成了HAWQ.\u003c/p\u003e\n\u003cp\u003eHAWQ可以通过HDFS在本机快速，交互查询hadoop数据．\u003c/p\u003e\n\u003cp\u003ehawq的交互式命令行接口, 类似于postgresql, 参考postgresql.\u003c/p\u003e\n\u003cp\u003ehawq的client: psql (参考postgresql)\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"psql\"\u003epsql\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ psql\n$ PGPASSWORD='password';psql -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;username\u0026gt; -d [database] -c \u0026quot;[psql command]\u0026quot;\n$ psql -l # 查看所有database\n\n# jdbc\n$ jdbc:pivotal:greenplum://hdm1:5432;DatabaseName=getstartdb;User=hdbuser;Password=hdbpass\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"sql\"\u003esql\u003c/h1\u003e\n\u003cp\u003eAO(append only) table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparquet table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type2) WITH (appendonly=true, orientation=parquet);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAO table distributed by specified column and partitioned by range:\u003c/p\u003e",
    "content": "HAWQ http://hawq.incubator.apache.org/\nhttps://github.com/apache/incubator-hawq\nHAWQ是在Pivotal Greenplum和PostgreSQL基础上开发而来．\nHAWQ也就是Pivotal HDB.\nHAWQ和Pivotal　HDB是一个项目．\nHortonworks公司的HDP集成了HAWQ.\nHAWQ可以通过HDFS在本机快速，交互查询hadoop数据．\nhawq的交互式命令行接口, 类似于postgresql, 参考postgresql.\nhawq的client: psql (参考postgresql)\npsql $ psql $ PGPASSWORD='password';psql -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;username\u0026gt; -d [database] -c \u0026quot;[psql command]\u0026quot; $ psql -l # 查看所有database # jdbc $ jdbc:pivotal:greenplum://hdm1:5432;DatabaseName=getstartdb;User=hdbuser;Password=hdbpass sql AO(append only) table:\n\u0026gt; create table {table_name} (var type, var1 type1); parquet table:\n\u0026gt; create table {table_name} (var type, var1 type2) WITH (appendonly=true, orientation=parquet); AO table distributed by specified column and partitioned by range:\n\u0026gt; create table {table_name} (var type, var1 type1) distributed by range(var) partition by range(var1) (start val end val1 every val2); AO table distributed by randomly and partitioned by range:\n\u0026gt; create table {table_name} (var type, var1 type1) distributed randomly partition by range (var) (start(val) end (val1) every(val2)); parquet table distributed by specified column and partitoned by list:\n\u0026gt; create table {table_name} (var type, var1 type1) WITH (appendonly=true, orientation=parquet) distributed by (var) partition by list (var1) (partition name values (val), partition name1 values (val1)); parquet table distributed by randomly and partitioned by list:\n\u0026gt; create table {table_name} (var type, var1 type1) WITH (appendonly=true, orientation=parquet) distributed randomly partiton by list (var1) (partition name values (val), partition name1 values (val)); ",
    "categories": ["BigData"],
    "tags": ["hawq"]
  },
  {
    "title": "Hive",
    "permalink": "https://canuxcheng.com/post/hive/",
    "date": "2017-04-24",
    "summary": "\u003ch1 id=\"hive\"\u003eHive\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/hive\"\u003ehttps://github.com/apache/hive\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://hive.apache.org/\"\u003ehttp://hive.apache.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHive2数据仓库用于读取，写入和管理使用SQL的大型分布式数据集．\u003c/p\u003e\n\u003cp\u003ehive2的client: beeline(hive命令的升级版)\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"hivebeeline\"\u003ehive/beeline\u003c/h1\u003e\n\u003cp\u003ehive\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ hive --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebeeline\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ beeline --silent=true\nbeeline\u0026gt; !connect jdbc:hive2://[ip]:[port]/[database] [username] [password]\n\n$ beeline -u \u0026quot;jdbc:hive2://[ip]:10000[/database]\u0026quot; -n [username] -p [password] -e \u0026quot;USE [database]; ...\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"sql\"\u003esql\u003c/h1\u003e\n\u003cp\u003enormal table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table tablename (var type, var1 type1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparquet table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type1) STORED AS PARQUET;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epartition table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2);\n\u0026gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparquet partition table:\u003c/p\u003e",
    "content": "Hive https://github.com/apache/hive\nhttp://hive.apache.org/\nHive2数据仓库用于读取，写入和管理使用SQL的大型分布式数据集．\nhive2的client: beeline(hive命令的升级版)\nhive/beeline hive\n$ hive --help beeline\n$ beeline --silent=true beeline\u0026gt; !connect jdbc:hive2://[ip]:[port]/[database] [username] [password] $ beeline -u \u0026quot;jdbc:hive2://[ip]:10000[/database]\u0026quot; -n [username] -p [password] -e \u0026quot;USE [database]; ...\u0026quot; sql normal table:\n\u0026gt; create table tablename (var type, var1 type1); parquet table:\n\u0026gt; create table {table_name} (var type, var1 type1) STORED AS PARQUET; partition table:\n\u0026gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2); \u0026gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values}; parquet partition table:\n\u0026gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2) STORED AS PARQUET; \u0026gt; insert into {table_name} PARTITION (var2 = {pid}) VALUES {values}; ",
    "categories": ["BigData"],
    "tags": ["hive"]
  },
  {
    "title": "Impala",
    "permalink": "https://canuxcheng.com/post/impala/",
    "date": "2017-04-24",
    "summary": "\u003ch1 id=\"impala\"\u003eImpala\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/incubator-impala\"\u003ehttps://github.com/apache/incubator-impala\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://impala.apache.org/\"\u003ehttps://impala.apache.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eimpala的client: impala-shell\u003c/p\u003e\n\u003cp\u003eCloudera公司的CDH集成了Impala.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"impala-shellbeeline\"\u003eimpala-shell/beeline\u003c/h1\u003e\n\u003cp\u003eimpala-shell\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ impala-shell\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebeeline\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ beeline --silent=true\nbeeline\u0026gt; !connect jdbc:hive2://[ip]:21050[/database];auth=noSasl [username] [password]\n\n$ beeline -u \u0026quot;jdbc:hive2://[ip]:21050[/database];auth=noSasl\u0026quot; -n [username] -p [password] -e \u0026quot;USE [database]; ...\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"sql\"\u003esql\u003c/h1\u003e\n\u003cp\u003enormal table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparquet table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; crate table {table_name} (var type, var1 type1) STORED AS PARQUET;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epartition table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2);\n\u0026gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparquet partition table:\u003c/p\u003e",
    "content": "Impala https://github.com/apache/incubator-impala\nhttps://impala.apache.org/\nimpala的client: impala-shell\nCloudera公司的CDH集成了Impala.\nimpala-shell/beeline impala-shell\n$ impala-shell beeline\n$ beeline --silent=true beeline\u0026gt; !connect jdbc:hive2://[ip]:21050[/database];auth=noSasl [username] [password] $ beeline -u \u0026quot;jdbc:hive2://[ip]:21050[/database];auth=noSasl\u0026quot; -n [username] -p [password] -e \u0026quot;USE [database]; ...\u0026quot; sql normal table:\n\u0026gt; create table {table_name} (var type, var1 type1); parquet table:\n\u0026gt; crate table {table_name} (var type, var1 type1) STORED AS PARQUET; partition table:\n\u0026gt; create table {table_name} (var type, var1 type1) PARTITIONED BY (var2 type2); \u0026gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1) parquet partition table:\n\u0026gt; create table {table_name} (var type, var1 type1) PARTITION BY (var2 type2) STORED AS PARQUET; \u0026gt; insert into {table_name} PARTITION (var2 = val2) values (val, val1) ",
    "categories": ["BigData"],
    "tags": ["impala"]
  },
  {
    "title": "Presto",
    "permalink": "https://canuxcheng.com/post/presto/",
    "date": "2017-04-24",
    "summary": "\u003ch1 id=\"presto\"\u003ePresto\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/prestodb\"\u003ehttps://github.com/prestodb\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://prestodb.io/\"\u003ehttps://prestodb.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003epresto的client: presto-cli(rename to presto)\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"presto-cli\"\u003epresto-cli\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ presto --server localhost:8080 --catalog hive --schema default\n\n# jdbc for presto\n$ jdbc:presto://host:port/catalog/schema\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Presto https://github.com/prestodb\nhttps://prestodb.io/\npresto的client: presto-cli(rename to presto)\npresto-cli $ presto --server localhost:8080 --catalog hive --schema default # jdbc for presto $ jdbc:presto://host:port/catalog/schema ",
    "categories": ["BigData"],
    "tags": ["presto"]
  },
  {
    "title": "MongoDB",
    "permalink": "https://canuxcheng.com/post/mongodb/",
    "date": "2017-04-16",
    "summary": "\u003ch1 id=\"mongodb\"\u003eMongoDB\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mongodb/mongo\"\u003ehttps://github.com/mongodb/mongo\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003emongodb是一种开源的文档数据库，高性能，高可用性，自动裁剪．\u003c/p\u003e\n\u003cp\u003emongodb的database和关系数据库中的database一样．\u003c/p\u003e\n\u003cp\u003emongodb将BSON(mongo的JSON)文档存储在集合(collections)中，集合相当于关系数据库中的表table．\u003c/p\u003e\n\u003cp\u003emongodb的collections中的域(field)，相当于关系数据库中的字段column.\u003c/p\u003e\n\u003cp\u003emongodb的collections中的文档(document)，相当于关系数据库中的记录行row.\u003c/p\u003e\n\u003cp\u003emongodb也支持index索引和primary key主键，但是不支持table joins表连接．\u003c/p\u003e\n\u003cp\u003eubuntu安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv0C49F3730359A14518585931BC711F9BA15703C6\n$ echo \u0026quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4multiverse\u0026quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list\n$ sudo apt-get update\n$ sudo apt-get install -y mongodb-org\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eubuntu启动:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo service mongod start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装完成默认的数据库是test.另外db, admin, local是保留的数据库名称．\u003c/p\u003e\n\u003cp\u003emongod的默认端口是27017.\u003c/p\u003e\n\u003cp\u003emongo web-gui:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Studio3T/robomongo\"\u003ehttps://github.com/Studio3T/robomongo\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"mongo的命令\"\u003emongo的命令\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003emongo [options] [db address] [file names (ending in .js)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emongo shell进入到指定数据库:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mongo [db_name]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e本地命令行执行sql语句：\u003c/p\u003e",
    "content": "MongoDB https://github.com/mongodb/mongo\nmongodb是一种开源的文档数据库，高性能，高可用性，自动裁剪．\nmongodb的database和关系数据库中的database一样．\nmongodb将BSON(mongo的JSON)文档存储在集合(collections)中，集合相当于关系数据库中的表table．\nmongodb的collections中的域(field)，相当于关系数据库中的字段column.\nmongodb的collections中的文档(document)，相当于关系数据库中的记录行row.\nmongodb也支持index索引和primary key主键，但是不支持table joins表连接．\nubuntu安装:\n$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv0C49F3730359A14518585931BC711F9BA15703C6 $ echo \u0026quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4multiverse\u0026quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list $ sudo apt-get update $ sudo apt-get install -y mongodb-org ubuntu启动:\n$ sudo service mongod start 安装完成默认的数据库是test.另外db, admin, local是保留的数据库名称．\nmongod的默认端口是27017.\nmongo web-gui:\nhttps://github.com/Studio3T/robomongo\nmongo的命令 mongo [options] [db address] [file names (ending in .js)] mongo shell进入到指定数据库:\n$ mongo [db_name] 本地命令行执行sql语句：\n$ mongo [database] -e/--eval [javascript] 远程执行sql语句:\n$ mongo -u [username] -p [password] [ip]:[port]/[datbase] -e/--eval [javascript] CLI 先用mongo命令进入mongo命令行\nhelp # 查看所有命令 exit # 退出mongo shell db # 显示当前数据库 use \u0026lt;db_name\u0026gt; # 切换到指定数据库, 不存在则创建． show dbs # 查看所有数据库 show collections # 查看当前database的collections show users show profile show logs show log [name] sh.help() rs.help() db.help() # 查看所有database的方法 db.hostInfo() db.serverStatus() db.mycoll.help() # 查看所有collections的方法 数据类型 CURD mongo的CURD操作就相当于关系数据库中的sql操作．\nCURD: create update read delete.\n\u0026gt; use \u0026lt;database_name\u0026gt; # 切换/创建数据库 \u0026gt; db.createCollection(collection_name) # 在当前数据库创建集合 \u0026gt; db.dropDatabase() # 删除当前数据库 \u0026gt; db.getCollectionNames() # 获取当前数据库的所有集合 \u0026gt; db.mycoll.insert(obj) #　往集合mycollection中插入JSON对象obj. \u0026gt; db.mycoll.find([query],[fields]) # 查询文档 \u0026gt; db.mycoll.remove(query) # 删除文档 \u0026gt; db.mycoll.save(obj) # 替换已有的文档 \u0026gt; db.mycoll.update( query, object[, upsert_bool, multi_bool] ) # 更新已有的文档 \u0026gt; db.mycoll.drop() # 删除当前集合 # 释放内存 \u0026gt; use admin \u0026gt; db.runCommand({closeAllDatabases:1}) Monitoring 通过mongo\u0026gt; serverStatus()查看\n其它指标参考grafana dashboard.\n",
    "categories": ["Database"],
    "tags": ["mongodb"]
  },
  {
    "title": "Xml",
    "permalink": "https://canuxcheng.com/post/xml/",
    "date": "2017-04-07",
    "summary": "\u003ch1 id=\"xml\"\u003eXML\u003c/h1\u003e\n\u003chr\u003e",
    "content": "XML ",
    "categories": ["Web"],
    "tags": ["xml"]
  },
  {
    "title": "Xpath",
    "permalink": "https://canuxcheng.com/post/xpath/",
    "date": "2017-04-07",
    "summary": "\u003ch1 id=\"xpath\"\u003eXPath\u003c/h1\u003e\n\u003cp\u003eXPath是一门在XML文档中查找信息的语言．\u003c/p\u003e\n\u003cp\u003expath定位有绝对定位和相对定位，推荐使用相对定位．\u003c/p\u003e\n\u003cp\u003e绝对的XPath定位包含了从HTML根节点起的所有元素，并且一些轻微的改变就会失效。\u003c/p\u003e\n\u003cp\u003e相对的XPath用id或者name属性来找到一个靠近的元素(比较理想的是父元素)，这样你就可以依靠他们的相对关系来确定目标元素的位置。\u003c/p\u003e\n\u003ch1 id=\"firefox\"\u003efirefox\u003c/h1\u003e\n\u003cp\u003efirebug + firepath\u003c/p\u003e\n\u003cp\u003efirefox通过两者结合来获取xpath\u003c/p\u003e\n\u003ch1 id=\"chrome\"\u003echrome\u003c/h1\u003e\n\u003cp\u003echrome的开发者工具(F12)可以直接copy xpath.\u003c/p\u003e",
    "content": "XPath XPath是一门在XML文档中查找信息的语言．\nxpath定位有绝对定位和相对定位，推荐使用相对定位．\n绝对的XPath定位包含了从HTML根节点起的所有元素，并且一些轻微的改变就会失效。\n相对的XPath用id或者name属性来找到一个靠近的元素(比较理想的是父元素)，这样你就可以依靠他们的相对关系来确定目标元素的位置。\nfirefox firebug + firepath\nfirefox通过两者结合来获取xpath\nchrome chrome的开发者工具(F12)可以直接copy xpath.\n",
    "categories": ["Web"],
    "tags": ["xpath"]
  },
  {
    "title": "Kvm",
    "permalink": "https://canuxcheng.com/post/kvm/",
    "date": "2017-04-05",
    "summary": "\u003ch1 id=\"kvm\"\u003eKVM\u003c/h1\u003e\n\u003cp\u003eKernel-based Virtual Machine.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"qemu\"\u003eQemu\u003c/h1\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install qemu-system qemu-kvm\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e",
    "content": "KVM Kernel-based Virtual Machine.\nQemu 安装:\n$ sudo apt-get install qemu-system qemu-kvm ",
    "categories": ["Virtualization"],
    "tags": ["kvm"]
  },
  {
    "title": "Libvirt",
    "permalink": "https://canuxcheng.com/post/libvirt/",
    "date": "2017-04-05",
    "summary": "\u003ch1 id=\"libvirt\"\u003eLibvirt\u003c/h1\u003e\n\u003cp\u003e支持多种虚拟化平台的库\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://libvirt.org/\"\u003ehttps://libvirt.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install libvirt-bin (包含virsh命令和libvirtd daemon)\n// libvirtd在container中无法运行；在container中安装libvirt-bin可以获取virsh命令远程访问libvirt-bin server.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elibvirt-bin拆分成了两个包：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elibvirt-daemon-system\nlibvirt-clients\n\n$ sudo apt-get install libvirt-dev # 库, python/go client依赖该库\n\n$ sudo apt-get install virt-manager # windows管理工具\n\n$ sudo apt-get install virt-view # ...\n\n$ sudo service libvirt-bin restart\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"virsh\"\u003evirsh\u003c/h1\u003e\n\u003cp\u003elibvirt的命令行工具\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ virsh list --all    # 查看所有虚拟机\n$ virsh list --all --name # 只看domain name.\n\n$ virsh define /path/to/X.xml    # 从xml配置文件定义一个domain\n$ virsh start     # 启动虚拟机\n$ virsh reboot    # 重启虚拟机\n$ virsh shutdown   # 关闭虚拟机\n$ virsh destroy    # 强制关闭虚拟机\n$ virsh undefine   # 移除虚拟机\n$ virsh vncdisplay # 查看虚拟机的vnc信息，可以通过vnc访问.\n\n$ virsh net-list --all # 查看所有网络\n$ virsh net-define default.xml\n$ virsh net-autostart default\n$ virsh net-start default\n$ virsh net-undefine default\n$ virsh net-destroy default\n\n# 批量操作vm\n$ for vm in `virsh list --all --name`; do virsh undefine/destroy ${vm}; done\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"qemu-img\"\u003eqemu-img\u003c/h1\u003e\n\u003cp\u003e创建虚拟机的镜像文件:\u003c/p\u003e",
    "content": "Libvirt 支持多种虚拟化平台的库\nhttps://libvirt.org/\n安装:\n$ sudo apt-get install libvirt-bin (包含virsh命令和libvirtd daemon) // libvirtd在container中无法运行；在container中安装libvirt-bin可以获取virsh命令远程访问libvirt-bin server. libvirt-bin拆分成了两个包：\nlibvirt-daemon-system libvirt-clients $ sudo apt-get install libvirt-dev # 库, python/go client依赖该库 $ sudo apt-get install virt-manager # windows管理工具 $ sudo apt-get install virt-view # ... $ sudo service libvirt-bin restart virsh libvirt的命令行工具\n$ virsh list --all # 查看所有虚拟机 $ virsh list --all --name # 只看domain name. $ virsh define /path/to/X.xml # 从xml配置文件定义一个domain $ virsh start # 启动虚拟机 $ virsh reboot # 重启虚拟机 $ virsh shutdown # 关闭虚拟机 $ virsh destroy # 强制关闭虚拟机 $ virsh undefine # 移除虚拟机 $ virsh vncdisplay # 查看虚拟机的vnc信息，可以通过vnc访问. $ virsh net-list --all # 查看所有网络 $ virsh net-define default.xml $ virsh net-autostart default $ virsh net-start default $ virsh net-undefine default $ virsh net-destroy default # 批量操作vm $ for vm in `virsh list --all --name`; do virsh undefine/destroy ${vm}; done qemu-img 创建虚拟机的镜像文件:\n$ qemu-img create -f qcow2 /path/to/name.qcow2 100G libvirt-qemu libvirt操作qemu/kvm.\n本地:\nqemu:///system qemu:///session qemu+unix:///system qemu+unix:///session ssh远程:\n# libvirt-bin server上需要安装nc和libvirt-bin $ sudo apt-get install netcat-openbsd $ sudo update-alternatives --config nc // netcat-traditional避免使用默认安装 # ssh用户需要在libvirt和kvm组里 $ adduser username libvirtd $ adduser username kvm $ sudo apt-get install sshpass // 免密码访问 # client上需要安装openssh-clients $ sshpass -p password virsh -c qemu+ssh://user@127.0.0.1/system list tcp远程:\n$ vim /etc/libvirt/libvirtd.conf: listen_tls = 0　#禁用tls登录 listen_tcp = 1　#启用tcp方式登录 tcp_port = \u0026quot;16509\u0026quot;　#tcp端口16509 listen_addr = \u0026quot;0.0.0.0\u0026quot; # 允许任意ip访问 auth_tcp = \u0026quot;none\u0026quot;　#TCP不使用认证 $ vim /etc/default/libvirt-bin start_libvirtd=\u0026quot;yes\u0026quot; libvirtd_opts=\u0026quot;-l --config /etc/libvirt/libvirtd.conf\u0026quot; $ sudo service libvirt-bin restart $ virsh -c qemu+tcp://127.0.0.1:16509/system list libvirtd配置 配置libvirtd：\n$ vim /etc/libvirt/libvirtd.conf max_clients = 1024　#最大总的连接客户数1024 min_workers = 50　#libvirtd启动时，初始的工作线程数目 max_workers = 200　#同上，最大数目 max_requests = 1000　#最大同时支持的RPC调用，必须大于等于max_workers max_client_requests = 200　#每个客户端支持的最大连接数 ",
    "categories": ["Virtualization"],
    "tags": ["libvirt"]
  },
  {
    "title": "IDE",
    "permalink": "https://canuxcheng.com/post/devops_ide/",
    "date": "2017-04-02",
    "summary": "\u003ch1 id=\"jetbrains\"\u003eJetBrains\u003c/h1\u003e\n\u003cp\u003eIntelliJ: Java的IDE, 安装Python的插件也支持python.\u003c/p\u003e\n\u003ch2 id=\"pycharm\"\u003ePyCharm\u003c/h2\u003e\n\u003cp\u003ePyCharm: Python的IDE.\u003c/p\u003e\n\u003ch2 id=\"goland\"\u003eGoland\u003c/h2\u003e\n\u003cp\u003eGoland: golang的IDE.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"vscode\"\u003eVSCode\u003c/h1\u003e\n\u003ch2 id=\"intellisense--code-navigation\"\u003eIntelliSense \u0026amp; Code Navigation\u003c/h2\u003e\n\u003cp\u003eGo to Definition: F12, 跳转到定义.\u003c/p\u003e\n\u003cp\u003ePeek Definition: Alt + F12， 速览定义，不跳转.\u003c/p\u003e\n\u003cp\u003eGo to references: Shift + F12, 转到引用.\u003c/p\u003e\n\u003ch2 id=\"frontend\"\u003efrontend\u003c/h2\u003e\n\u003ch3 id=\"vs-js-debug\"\u003evs-js-debug\u003c/h3\u003e\n\u003cp\u003evscode内置了js/ts/node的debugger.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/microsoft/vscode-js-debug\"\u003ehttps://github.com/microsoft/vscode-js-debug\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"live-server\"\u003elive server\u003c/h3\u003e\n\u003cp\u003elive preview(html, svg\u0026hellip;)\u003c/p\u003e\n\u003cp\u003e如果用remote-ssh开启live server就是在远程机器上开启5500端口，webroot就是vscode打开的目录.\u003c/p\u003e\n\u003cp\u003e如果是remote-ssh开发html，用这个preview很方便.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ritwickdey/vscode-live-server\"\u003ehttps://github.com/ritwickdey/vscode-live-server\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"vscode-chrome-debug\"\u003evscode-chrome-debug\u003c/h3\u003e\n\u003cp\u003e打开的是安装vscode的机器上的chrome。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/microsoft/vscode-chrome-debug\"\u003ehttps://github.com/microsoft/vscode-chrome-debug\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e通过live server监听remote-ssh机器上的5500，可以通过chrome远程调试静态站点。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;,\n    \u0026quot;configurations\u0026quot;: [\n        {\n            \u0026quot;name\u0026quot;: \u0026quot;angularjs\u0026quot;,\n            \u0026quot;type\u0026quot;: \u0026quot;chrome\u0026quot;,\n            \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;,\n            \u0026quot;url\u0026quot;: \u0026quot;http://remote-ssh-server:5500/path/to/index.html\u0026quot;,\n            \u0026quot;webRoot\u0026quot;: \u0026quot;${workspaceFolder}/path/to/\u0026quot;,\n        },\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2 id=\"python\"\u003epython\u003c/h2\u003e\n\u003cp\u003edebuging:\u003c/p\u003e",
    "content": "JetBrains IntelliJ: Java的IDE, 安装Python的插件也支持python.\nPyCharm PyCharm: Python的IDE.\nGoland Goland: golang的IDE.\nVSCode IntelliSense \u0026amp; Code Navigation Go to Definition: F12, 跳转到定义.\nPeek Definition: Alt + F12， 速览定义，不跳转.\nGo to references: Shift + F12, 转到引用.\nfrontend vs-js-debug vscode内置了js/ts/node的debugger.\nhttps://github.com/microsoft/vscode-js-debug\nlive server live preview(html, svg\u0026hellip;)\n如果用remote-ssh开启live server就是在远程机器上开启5500端口，webroot就是vscode打开的目录.\n如果是remote-ssh开发html，用这个preview很方便.\nhttps://github.com/ritwickdey/vscode-live-server\nvscode-chrome-debug 打开的是安装vscode的机器上的chrome。\nhttps://github.com/microsoft/vscode-chrome-debug\n通过live server监听remote-ssh机器上的5500，可以通过chrome远程调试静态站点。\n{ \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;angularjs\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;chrome\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;http://remote-ssh-server:5500/path/to/index.html\u0026quot;, \u0026quot;webRoot\u0026quot;: \u0026quot;${workspaceFolder}/path/to/\u0026quot;, }, ] } python debuging:\nhttps://code.visualstudio.com/docs/python/debugging\ndebug current file:\n{ \u0026quot;name\u0026quot;: \u0026quot;current file\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;python\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${file}\u0026quot;, \u0026quot;console\u0026quot;: \u0026quot;integratedTerminal\u0026quot;, } debug with module:\n{ \u0026quot;name\u0026quot;: \u0026quot;module\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;python\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;module\u0026quot;: \u0026quot;module-name\u0026quot;, \u0026quot;console\u0026quot;: \u0026quot;integratedTerminal\u0026quot;, } debug with attach:\n// create ssh tunnel ssh -2 -L sourceport:localhost:5678 -i identifyfile user@remoteaddress { \u0026quot;name\u0026quot;: \u0026quot;Python: Attach\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;python\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;attach\u0026quot;, \u0026quot;port\u0026quot;: 5678, \u0026quot;host\u0026quot;: \u0026quot;localhost\u0026quot;, \u0026quot;pathMappings\u0026quot;: [ { \u0026quot;localRoot\u0026quot;: \u0026quot;${workspaceFolder}\u0026quot;, \u0026quot;remoteRoot\u0026quot;: \u0026quot;.\u0026quot;, } ] } testing:\nhttps://code.visualstudio.com/docs/python/testing\nunittest:\n{ \u0026quot;python.testing.autoTestDiscoverOnSaveEnabled\u0026quot;: true, \u0026quot;python.testing.unittestArgs\u0026quot;: [ \u0026quot;-v\u0026quot;, \u0026quot;-s\u0026quot;, \u0026quot;./tests\u0026quot;, \u0026quot;-p\u0026quot;, \u0026quot;test_*.py\u0026quot; ], \u0026quot;python.testing.pytestEnabled\u0026quot;: false, \u0026quot;python.testing.nosetestsEnabled\u0026quot;: false, \u0026quot;python.testing.unittestEnabled\u0026quot;: true, \u0026quot;restructuredtext.confPath\u0026quot;: \u0026quot;${workspaceFolder}/docs\u0026quot;, } django https://code.visualstudio.com/docs/python/tutorial-django\ndebugging:\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Python: Django\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;python\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${workspaceFolder}/path/to/manage.py\u0026quot;, \u0026quot;console\u0026quot;: \u0026quot;integratedTerminal\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;runserver\u0026quot;, \u0026quot;0:8888\u0026quot; ], \u0026quot;django\u0026quot;: true, \u0026quot;env\u0026quot;: { } } ] } golang https://github.com/golang/vscode-go/blob/master/docs/debugging.md\ndebugging:\n{ \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;golang file\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;go\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;auto\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${file}\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;gin debug\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;go\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;auto\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${workspaceFolder}/backend/main.go\u0026quot; }, ] } rest client 调试rest API\nhttps://github.com/Huachao/vscode-restclient\nexample.api:\n@api = http://hostname:port/api/v0 @Authorization = Basic a2FpemVuOkFybUFkbWluMSE= @Content-Type = application/json ### GET {{api}}/users HTTP/1.1 Authorization: {{Authorization}} Content-Type: {{Content-Type}} ### POST {{api}}/groupus HTTP/1.1 Authorization: {{Authorization}} Content-Type: {{Content-Type}} { key: value } record vscode录制.\nhttps://github.com/microsoft/codetour\nhttps://github.com/arciisine/vscode-chronicler\n支持远程debug的时候在本地录制，也就是本地是windows，只需要本地安装ffmpeg和chroicler。\nMCP \u0026ldquo;\u0026hellip;/Code/User/settings.json\u0026rdquo;\nhttps://github.com/GLips/Figma-Context-MCP https://github.com/modelcontextprotocol/servers\n{ \u0026quot;servers\u0026quot;: { \u0026quot;postgres\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@modelcontextprotocol/server-postgres\u0026quot;, \u0026quot;postgresql://server?ssl=true\u0026amp;sslmode=require\u0026amp;rejectUnauthorized=false\u0026quot; ] }, \u0026quot;redis\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@modelcontextprotocol/server-redis\u0026quot;, \u0026quot;redis://localhost:6379\u0026quot; ] }, \u0026quot;playwright\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;@playwright/mcp@latest\u0026quot; ] }, \u0026quot;Azure MCP Server\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@azure/mcp@latest\u0026quot;, \u0026quot;server\u0026quot;, \u0026quot;start\u0026quot; ] }, \u0026quot;memory\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@modelcontextprotocol/server-memory\u0026quot; ] }, \u0026quot;sequential-thinking\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@modelcontextprotocol/server-sequential-thinking\u0026quot; ] }, \u0026quot;git\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;docker\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;run\u0026quot;, \u0026quot;--rm\u0026quot;, \u0026quot;-i\u0026quot;, \u0026quot;--mount\u0026quot;, \u0026quot;type=bind,src=${workspaceFolder},dst=/workspace\u0026quot;, \u0026quot;mcp/git\u0026quot; ] }, \u0026quot;filesystem\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;@modelcontextprotocol/server-filesystem\u0026quot;, \u0026quot;${workspaceFolder}\u0026quot; ] }, \u0026quot;fetch\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;docker\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;run\u0026quot;, \u0026quot;-i\u0026quot;, \u0026quot;--rm\u0026quot;, \u0026quot;mcp/fetch\u0026quot; ] }, \u0026quot;kubernetes\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;npx\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-y\u0026quot;, \u0026quot;mcp-server-kubernetes\u0026quot; ] } } } ",
    "categories": ["DevOps"],
    "tags": ["ide"]
  },
  {
    "title": "Cryptographic",
    "permalink": "https://canuxcheng.com/post/sec_cryptographic/",
    "date": "2017-03-27",
    "summary": "\u003ch1 id=\"pgp\"\u003ePGP\u003c/h1\u003e\n\u003cp\u003ePGP: Pretty Good Privacy。\u003c/p\u003e\n\u003cp\u003e用于签名和加密解密。\u003c/p\u003e\n\u003ch2 id=\"pgp-1\"\u003ePGP\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Pretty_Good_Privacy\"\u003ehttps://en.wikipedia.org/wiki/Pretty_Good_Privacy\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"openpgp\"\u003eOpenPGP\u003c/h2\u003e\n\u003cp\u003eOpenPGP是PGP的标准,也有很多实现。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://openpgp.org/\"\u003ehttp://openpgp.org/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"gnupg\"\u003eGnuPG\u003c/h2\u003e\n\u003cp\u003eGunPG: Gun Privacy Guard, 是基于openPGP的实现。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gnupg.org/\"\u003ehttps://gnupg.org/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ gpg --help\n\n$ 快速生成签名密钥对\ngpg --quick-generate-key \u0026quot;Canux\u0026quot;\n// 查看公钥\ngpg --list-keys\n// 查看私钥\ngpg --list-secret-keys\n// 删除私钥\ngpg --delete-secret-keys \u0026quot;Canux\u0026quot;\n// 删除公钥\ngpg --delete-keys \u0026quot;Canux\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGPGME: GPG Made Easy, 是一个让应用程序使用GPG更容易的库．\u003c/p\u003e\n\u003ch1 id=\"openssl\"\u003eOpenSSL\u003c/h1\u003e\n\u003cp\u003e网络安全和密码工具。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.openssl.org/\"\u003ehttps://www.openssl.org/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ openssl --help\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"单向哈希加密\"\u003e单向哈希加密\u003c/h1\u003e\n\u003cp\u003emd5和shaX都是常用的存储密码的加密方法.\u003c/p\u003e\n\u003cp\u003erainbow table可以破解单向加密.\u003c/p\u003e\n\u003cp\u003esalt方法可以防止rainbow table破解.\u003c/p\u003e\n\u003cp\u003escrypt是最难破解的加密方案.\u003c/p\u003e\n\u003ch2 id=\"md5\"\u003emd5\u003c/h2\u003e\n\u003ch2 id=\"sha1\"\u003esha1\u003c/h2\u003e\n\u003ch2 id=\"sha256\"\u003esha256\u003c/h2\u003e\n\u003ch2 id=\"sha512\"\u003esha512\u003c/h2\u003e\n\u003ch2 id=\"hmac\"\u003ehmac\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"symmetric-cryptography\"\u003eSymmetric Cryptography\u003c/h1\u003e\n\u003cp\u003e对称加密就是加密和解密使用的密钥是相同的．\u003c/p\u003e",
    "content": "PGP PGP: Pretty Good Privacy。\n用于签名和加密解密。\nPGP https://en.wikipedia.org/wiki/Pretty_Good_Privacy\nOpenPGP OpenPGP是PGP的标准,也有很多实现。\nhttp://openpgp.org/\nGnuPG GunPG: Gun Privacy Guard, 是基于openPGP的实现。\nhttps://gnupg.org/\n$ gpg --help $ 快速生成签名密钥对 gpg --quick-generate-key \u0026quot;Canux\u0026quot; // 查看公钥 gpg --list-keys // 查看私钥 gpg --list-secret-keys // 删除私钥 gpg --delete-secret-keys \u0026quot;Canux\u0026quot; // 删除公钥 gpg --delete-keys \u0026quot;Canux\u0026quot; GPGME: GPG Made Easy, 是一个让应用程序使用GPG更容易的库．\nOpenSSL 网络安全和密码工具。\nhttps://www.openssl.org/\n$ openssl --help 单向哈希加密 md5和shaX都是常用的存储密码的加密方法.\nrainbow table可以破解单向加密.\nsalt方法可以防止rainbow table破解.\nscrypt是最难破解的加密方案.\nmd5 sha1 sha256 sha512 hmac Symmetric Cryptography 对称加密就是加密和解密使用的密钥是相同的．\nbase32 base64 des aes rc4 Asymmetric Cryptography 非对称加密就是存在两个密钥.\nrsa dsa ecdsa ecc elliptic curves cryptography\n",
    "categories": ["Security"],
    "tags": ["capture"]
  },
  {
    "title": "JS DOM",
    "permalink": "https://canuxcheng.com/post/js_dom/",
    "date": "2017-03-15",
    "summary": "\u003ch1 id=\"dom\"\u003eDOM\u003c/h1\u003e\n\u003cp\u003eDOM: document object model.\u003c/p\u003e\n\u003cp\u003e当网页被加载时，浏览器会创建页面的文档对象模型(DOM).\u003c/p\u003e\n\u003cp\u003eDOM操作需要在html加载完成后进程.\u003c/p\u003e\n\u003cp\u003ejs可以通过DOM访问html文档的所有元素.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJavaScript 能够改变页面中的所有 HTML 元素\u003c/li\u003e\n\u003cli\u003eJavaScript 能够改变页面中的所有 HTML 属性\u003c/li\u003e\n\u003cli\u003eJavaScript 能够改变页面中的所有 CSS 样式\u003c/li\u003e\n\u003cli\u003eJavaScript 能够对页面中的所有事件做出反应\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"查找html元素\"\u003e查找html元素\u003c/h2\u003e\n\u003cp\u003e找到返回该元素的对象，没找到返回null.\u003c/p\u003e\n\u003cp\u003e通过id:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementById(\u0026quot;id\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过标签名:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementsByTagName(\u0026quot;tag\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过类名:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementsByName(\u0026quot;name\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"操作html元素或文本\"\u003e操作html元素或文本\u003c/h2\u003e\n\u003cp\u003e操作标签或标签内的文本.\u003c/p\u003e\n\u003cp\u003e直接改变html内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 绝不要使用在文档加载之后使用 document.write()。这会覆盖该文档\ndocument.write(...);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e改变元素的内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementById(id).innerHTML = \u0026quot;new text\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"操作html属性\"\u003e操作html属性\u003c/h2\u003e\n\u003cp\u003e改变元素属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementById(id).attribute = \u0026quot;new value\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"操作css\"\u003e操作css\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003edocument.getElementById(id).style.property = \u0026quot;new style\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"增删html元素\"\u003e增删html元素\u003c/h2\u003e\n\u003cp\u003e增加元素:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar para = document.createElement(\u0026quot;p\u0026quot;);\nvar node = document.createTextNode(\u0026quot;new para\u0026quot;);\npara.appendChild(node);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e删除元素:\u003c/p\u003e",
    "content": "DOM DOM: document object model.\n当网页被加载时，浏览器会创建页面的文档对象模型(DOM).\nDOM操作需要在html加载完成后进程.\njs可以通过DOM访问html文档的所有元素.\nJavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找html元素 找到返回该元素的对象，没找到返回null.\n通过id:\ndocument.getElementById(\u0026quot;id\u0026quot;); 通过标签名:\ndocument.getElementsByTagName(\u0026quot;tag\u0026quot;); 通过类名:\ndocument.getElementsByName(\u0026quot;name\u0026quot;) 操作html元素或文本 操作标签或标签内的文本.\n直接改变html内容:\n# 绝不要使用在文档加载之后使用 document.write()。这会覆盖该文档 document.write(...); 改变元素的内容:\ndocument.getElementById(id).innerHTML = \u0026quot;new text\u0026quot;; 操作html属性 改变元素属性:\ndocument.getElementById(id).attribute = \u0026quot;new value\u0026quot;; 操作css document.getElementById(id).style.property = \u0026quot;new style\u0026quot; 增删html元素 增加元素:\nvar para = document.createElement(\u0026quot;p\u0026quot;); var node = document.createTextNode(\u0026quot;new para\u0026quot;); para.appendChild(node); 删除元素:\nvar parent = document.getElementById(\u0026quot;id\u0026quot;); var child = document.getElementById(\u0026quot;cid\u0026quot;); parent.removeChild(child); 对事件做出反应 function changetext(id) { id.innerHTML = \u0026quot;new text\u0026quot; } \u0026lt;h1 onclick=\u0026quot;changetext(this)\u0026quot;\u0026gt;\u0026lt;/h1\u0026gt; document.getElementById(id).onclick=function(){...}; Document 集合:\nall[] anchors[] applets forms[] images[] links[] attribution:\nbody cookie domain lastModified referrer title URL readyState // loading/interfactive/complete method:\nopen() close() getElementById() # 返回id对应的第一个对象 getElementsByName() # 返回对应的所有对象的集合 getElementsByTagName() # 同上 write() writeln() createElement() createTextNode() Element element表示html元素,拥有元素，文本和注释的子节点.\nattribution:\ntagName // tag名字 innerHTML // 元素里面的文本内容 id title style className length nodeName // 和tagName相同 nodeType // 节点类型: 1= 元素节点，2= 属性节点, 3= 文本节点, 8= 注释 nodeValue // 文本节点的值 parentNode // 父节点 childNodes // 子节点 firstChild lastChild nextSibling previousSibling ownerDocument // 返回当前根节点文档对象 accesKey attributes contentEditable dir lang namespaceURI tabIndex textContent clientHeight clientWidth offsetHeight offsetWidth offsetLeft offsetParent offsetTop scrollHeight scrollLeft scrollTop scrollWidth method:\nappendChild(node) // 在元素后追加node InsertBefore() // 在元素前插入node removeChild() replaceChild() cloneNode() compareDocumentPosition() getAttribute() getAttributeNode() getElementsByTagName() getFeature() getUserData() hasAttribute() hasAttributes() hasChildNodes() isDefaultNamespace() isEqualNode() isSameNode() isSupported() normalize() removeAttribute() removeAttributeNode() setArrbitute() setArrtibuteNode() setIdAttribute() setIdArrtibuteNode() setUserData() toString() item() # Attribute Attribute表示html属性\nattribution:\nisId name value specified length methods:\ngtNamedItem() item() removeNameItem() setNamedItem() Event window事件:\n# 等待html加载完成 onload window.onload = function(){}; onunload 鼠标事件:\nonclick ondblclick onmousedown onmousemove onmouseout onmouseover onmouseup 键盘事件:\nonkeypress onkeydown onkeyup 表单事件:\nonsubmit 媒体事件:\nonabort onerror ",
    "categories": ["Web"],
    "tags": ["dom"]
  },
  {
    "title": "JS OOP",
    "permalink": "https://canuxcheng.com/post/js_oop/",
    "date": "2017-03-15",
    "summary": "\u003ch1 id=\"oop\"\u003eOOP\u003c/h1\u003e\n\u003cp\u003ejavascript中一切都是对象.\u003c/p\u003e\n\u003cp\u003ejavacript内置了Bull/Number/String/Object/Function/Array/Date/RegExp类型.\u003c/p\u003e\n\u003ch1 id=\"object\"\u003eObject\u003c/h1\u003e\n\u003cp\u003e创建Object实例:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar obj = new Object();\n\nvar obj = Object(); // new 可以省略\n\nvar obj = ｛\n    name: \u0026quot;value\u0026quot;\n};\n\nvar obj = {\n    \u0026quot;name\u0026quot;: \u0026quot;value\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e添加属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eobj.attr = \u0026quot;value\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e添加方法:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eobj.method =  methodName;\nfunction methodName() {};\n\nobj.method = function() {};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e删除属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edelete obj.attr\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e访问对象属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eobj.property\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e访问对象方法:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eobj.method()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"boolean\"\u003eBoolean\u003c/h1\u003e\n\u003cp\u003eattribution:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econstructor\nprototype\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emethod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etoSource()\nvalueOf()\ntoString()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"number\"\u003eNumber\u003c/h1\u003e\n\u003cp\u003eattribution:\u003c/p\u003e",
    "content": "OOP javascript中一切都是对象.\njavacript内置了Bull/Number/String/Object/Function/Array/Date/RegExp类型.\nObject 创建Object实例:\nvar obj = new Object(); var obj = Object(); // new 可以省略 var obj = ｛ name: \u0026quot;value\u0026quot; }; var obj = { \u0026quot;name\u0026quot;: \u0026quot;value\u0026quot; } 添加属性:\nobj.attr = \u0026quot;value\u0026quot; 添加方法:\nobj.method = methodName; function methodName() {}; obj.method = function() {}; 删除属性:\ndelete obj.attr 访问对象属性:\nobj.property 访问对象方法:\nobj.method() Boolean attribution:\nconstructor prototype method:\ntoSource() valueOf() toString() Number attribution:\nconstructor prototype MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY method:\nvalueOf() toString() toLocaleString() toFixed() toExponential() toPrecision() String attribution:\nconstructor prototype length method:\ntoSource() toString() valueOf() anchor() big() indexOf() replace() match() search() toLowerCase() toUpperCase() ... Function attribution:\nInfinity java NaN Packages undefined method：\ndecodeURI() decodeURIComponent() encodeURI() encodeURIComponent() escape() eval() getClass() isFinite() isNaN() parseFloat() parseInt() String() unescape() Array 创建对象:\nnew都可以省略.\nvar arr = new Array(); var arr = new Array(size); var arr = new Array(element0, element1, ...); var arr = []; var arr = [1,2, \u0026quot;test\u0026quot;]; 赋值:\narr[index] = \u0026quot;value\u0026quot;; // 字符串下标，不能直接通过数组对象访问，只能通过对象方法访问. arr[\u0026quot;key\u0026quot;] = \u0026quot;value\u0026quot;; attribution:\nconstructor prototype length // set或get数组中元素个数. method:\ntoSource() toString() valueOf() toLocaleString() join(separator) // 返回按照分隔符分隔的字符串 concat() // 拼接 push() // 往数组末尾添加元素,返回最新长度. pop() // 移除数组末尾元素,并返回 unshift() // 在数组开头添加元素，返回最新长度. shift() //　移除数组开头元素并返回 reverse() // 对数组逆序排序操作． sort(sortby) // 对数组顺序排序操作 slice(start, end) // 取下标为start和end之间的元素，不包括start和end. splice(index, howmany, item1, ...) // 删除，插入，替换功能. splice(index, howmany) // 从index开始，获取howmany个元素 splice(index, 0, item) // 从index插入item splice(index, 1, item) // 用item替换index的元素 Date 创建对象:\nvar date = new Date(); attribution:\nconstructor prototype method:\ntoString() toSource() valueOf() Date() UTC() parse(datestring) // 返回datestring的epoch毫秒数 toLocalString() toLocalTimeString() toLocalDateString(0) toUTCString() toGMTString() toDateString() toTimeString() get... set... RegExp Math Events ",
    "categories": ["Web"],
    "tags": ["oop"]
  },
  {
    "title": "Angular",
    "permalink": "https://canuxcheng.com/post/js_angular/",
    "date": "2017-03-13",
    "summary": "\u003ch1 id=\"angularjs\"\u003eangularjs\u003c/h1\u003e\n\u003cp\u003eangularjs 1.*\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/angular/angular.js\"\u003ehttps://github.com/angular/angular.js\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angularjs.org/\"\u003ehttps://angularjs.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rev087/ng-inspector\"\u003ehttps://github.com/rev087/ng-inspector\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"angular\"\u003eAngular\u003c/h1\u003e\n\u003cp\u003eAngular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。\u003c/p\u003e\n\u003cp\u003eangular.js 的升级版\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/angular/angular\"\u003ehttps://github.com/angular/angular\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/angular/angular-cli\"\u003ehttps://github.com/angular/angular-cli\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io\"\u003ehttps://angular.io\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.cn\"\u003ehttps://angular.cn\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装 angular-cli:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm install -g @angular/cli\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看版本:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ng v\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e新建项目:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd \u0026lt;project\u0026gt;\n$ ng new \u0026lt;application\u0026gt;\n\n# 严格模式\n$ ng new \u0026lt;application\u0026gt; --strict\n\n$ ng generate \u0026lt;schematic\u0026gt; [options]\nappShell\napplication\nclass\ncomponent\ndirective\nenum\nguard\ninterceptor\ninterface\nlibrary\nmodule\npipe\nresolver\nservice\nserviceWorker\nwebWorker\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e测试项目:\u003c/p\u003e",
    "content": "angularjs angularjs 1.*\nhttps://github.com/angular/angular.js\nhttps://angularjs.org/\nhttps://github.com/rev087/ng-inspector\nAngular Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。\nangular.js 的升级版\nhttps://github.com/angular/angular\nhttps://github.com/angular/angular-cli\nhttps://angular.io\nhttps://angular.cn\n安装 angular-cli:\n$ npm install -g @angular/cli 查看版本:\n$ ng v 新建项目:\n$ cd \u0026lt;project\u0026gt; $ ng new \u0026lt;application\u0026gt; # 严格模式 $ ng new \u0026lt;application\u0026gt; --strict $ ng generate \u0026lt;schematic\u0026gt; [options] appShell application class component directive enum guard interceptor interface library module pipe resolver service serviceWorker webWorker 测试项目:\n$ cd \u0026lt;my-app\u0026gt; $ ng serve // --open会自动打开浏览器 $ ng serve --open 打包:\n$ ng build --prod 项目结构 工作区配置：\n.editorconfig: 代码编辑器配置 angular.json: 为工作区所有项目指定CLI的默认配置，包括CLI要用到的构建，启动开发服务器和测试工具的配置项。 tsconfig.json: 工作空间所有项目的基本typescript配置。 tslint.json: 工作空间中所有项目的默认的TSlint配置。 src/: 根项目的源文件。 e2e/: 端到端测试文件。 应用配置:\n.browserslistrc 配置前端工具之间共享的目标浏览器和node.js版本 karma.conf.js 应用的karma配置 tsconfig.app.json 应用的typescript配置. tsconfig.spec.json 应用测试的typescript配置。 应用源文件：\napp/ 包含定义应用逻辑和数据的组件文件。\nassets/ 包含要在构建应用时应该按原样复制的图像和静态文件。\nenvironments/ 包含特定目标环境的构建配置选项。\nfavicon.ico 应用在标签栏中的图标。\nindex.html 主页面。\nmain.ts 应用的入口。\npolyfills.ts 为浏览器支持提供polyfill脚本。\nstyles.css 列出为项目提供样式的css文件。\napp/app.component.ts 根组件AppComponent.\napp/app.component.html\napp/app.component.css\napp/app.component.spec.ts 根组件的单元测试.\napp/app.module.ts 定义名为AppModule根模块.\nModule angular的模块化系统NgModule, 也就是根模块，习惯命名为AppModule,位于app.module.ts文件。\nNgModule是一个带有@NgModule()装饰器的类，该装饰器是一个函数.\n重要的属性:\ndeclarations: 可申明对象表，数据本NgModule的组件，指令和管道。 exports：导出表，能在其它模块的组件模板中使用的可申明对象的子集。 imports：导入表，导出了本模块中的组件模板所需的类的其它模块。 providers：本模块向全局服务中贡献的那些服务的创建器。 bootstrap：应用的主视图，称为根组件，是应用中所有其它视图的宿主。 components 组件控制屏幕上被称为视图的一小片区域, 每个angular应用最少有一个根组件。\n通过@Component装饰器定义组件.\n组件配置选项：\nselector: 选择器 templateUrl: 该组件的HTML模板文件相对于组件文件的地址。 template: html styleUrls: 该组件的CSS文件相对路径. style: css providers: 当前组件所需的服务提供者的一个数组。 pipes 管道\ndirectives 指令就是带有@Directive()装饰器的类。\n组件是特殊指令，angular还内置了结构型指令和属性型指令，也可以自定义指令。\n结构型指(structural)令通过添加，移除或替换DOM元素来修改布局。\n属性型指令(attribute)会修改现有元素的外观和行为。\nservices 服务类： 对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建服务类。\ndependency injection 依赖注入可以保持组件的精简和高效。\n通过@Injectable装饰器来定义DI。\nrouting ",
    "categories": ["Web"],
    "tags": ["angular"]
  },
  {
    "title": "DevOps",
    "permalink": "https://canuxcheng.com/post/js_devops/",
    "date": "2017-03-13",
    "summary": "\u003ch1 id=\"js--ts\"\u003eJS \u0026amp; TS\u003c/h1\u003e\n\u003cp\u003evscode\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;version\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;0.2.0\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;configurations\u0026#34;\u003c/span\u003e: [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Next.js: debug server-side\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;node-terminal\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;command\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;npm run dev\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Next.js: debug client-side\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;chrome\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;url\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://localhost:3000\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Next.js: debug client-side (Firefox)\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;firefox\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;url\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://localhost:3000\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;reAttach\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;pathMappings\u0026#34;\u003c/span\u003e: [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003e\u0026#34;url\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;webpack://_N_E\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#f92672\"\u003e\u0026#34;path\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;${workspaceFolder}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      ]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Next.js: debug full stack\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;node\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;program\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;${workspaceFolder}/node_modules/next/dist/bin/next\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;runtimeArgs\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;--inspect\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;skipFiles\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026lt;node_internals\u0026gt;/**\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;serverReadyAction\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e\u0026#34;action\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;debugWithEdge\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e\u0026#34;killOnServerStop\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e\u0026#34;pattern\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;- Local:.+(https?://.+)\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e\u0026#34;uriFormat\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;%s\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003e\u0026#34;webRoot\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;${workspaceFolder}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSPA: Single page application, 单页应用，like react, vue and angular.\nSSR: server side rendering. 服务端渲染, like next.js, nuxt.js\u003c/p\u003e",
    "content": "JS \u0026amp; TS vscode\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Next.js: debug server-side\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;node-terminal\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;npm run dev\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Next.js: debug client-side\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://localhost:3000\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Next.js: debug client-side (Firefox)\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://localhost:3000\u0026#34;, \u0026#34;reAttach\u0026#34;: true, \u0026#34;pathMappings\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;webpack://_N_E\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } ] }, { \u0026#34;name\u0026#34;: \u0026#34;Next.js: debug full stack\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/node_modules/next/dist/bin/next\u0026#34;, \u0026#34;runtimeArgs\u0026#34;: [\u0026#34;--inspect\u0026#34;], \u0026#34;skipFiles\u0026#34;: [\u0026#34;\u0026lt;node_internals\u0026gt;/**\u0026#34;], \u0026#34;serverReadyAction\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;debugWithEdge\u0026#34;, \u0026#34;killOnServerStop\u0026#34;: true, \u0026#34;pattern\u0026#34;: \u0026#34;- Local:.+(https?://.+)\u0026#34;, \u0026#34;uriFormat\u0026#34;: \u0026#34;%s\u0026#34;, \u0026#34;webRoot\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } } ] } SPA: Single page application, 单页应用，like react, vue and angular. SSR: server side rendering. 服务端渲染, like next.js, nuxt.js\nyalc https://github.com/wclr/yalc\ninstall:\nnpm i yalc -g usage:\nyalc publish yalc add ... yalc remove ... yalc publish yalc push yalc publish需要exports dist，而不是src。\n\u0026quot;exports\u0026quot;: { \u0026quot;.\u0026quot;: \u0026quot;./dist/index.cjs.js\u0026quot;, \u0026quot;./alpha\u0026quot;: \u0026quot;./dist/alpha.cjs.js\u0026quot;, \u0026quot;./package.json\u0026quot;: \u0026quot;./package.json\u0026quot; } ESLint https://github.com/typescript-eslint/typescript-eslint\nlinting.\nvite https://github.com/vitejs/vite\nWebpack bundler\nhttps://github.com/webpack/webpack\nRollup bundler\nhttps://github.com/rollup/rollup\ngulp Automation - gulp is a toolkit that helps you automate painful or time-consuming tasks in your development workflow.\nhttps://github.com/gulpjs/gulp\ngulp command line\n$ npm install --global gulp-cli gulp for devDependencies\n$ npm install --save-dev gulp create gulpfile.js and test it.\n$ vim gulpfile.js $ gulp karma A simple tool that allows you to execute JavaScript code in multiple real browsers.\nangularjs 的 test runner.\nThe main purpose of Karma is to make your test-driven development easy, fast, and fun.\nhttps://github.com/karma-runner/karma\nkarma command line:\n$ npm install -g karma-cli karma for devDependencies\n$ npm install --save-dev karma $ npm install karma-jasmine karma-chrome-launcher jasmine-core --save-dev run karma\n$ karma start ",
    "categories": ["Web"],
    "tags": ["tslint"]
  },
  {
    "title": "JavaScript",
    "permalink": "https://canuxcheng.com/post/js/",
    "date": "2017-03-13",
    "summary": "\u003ch1 id=\"javascript概述\"\u003eJavaScript概述\u003c/h1\u003e\n\u003cp\u003eJavascript包括三部分:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eECMAScript核心,提供核心语言功能．\u003c/li\u003e\n\u003cli\u003eDOM文档对象模型, 提供访问和操作网页内容的方法和接口．\u003c/li\u003e\n\u003cli\u003eBOM浏览器对象模型, 提供与浏览器交互的方法和接口．\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eES5.0 (2009)\nES5.1 (2011, ISO/IEC)\nES6.0 (2015)\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"javascript基本语法\"\u003ejavascript基本语法\u003c/h1\u003e\n\u003cp\u003ejavascript源程序叫xxx.js.\u003c/p\u003e\n\u003cp\u003ejavascript大小写敏感．\u003c/p\u003e\n\u003cp\u003ejavascript使用驼峰命名法．\u003c/p\u003e\n\u003cp\u003ejavascript的标识符以字母，下划线或美元符号开头，还可以包含数字．不能是关键字．\u003c/p\u003e\n\u003cp\u003eJvaScript代码块以大括号{}包围,开括号写在第一行结尾处，前面空格，闭括号单独一行。\u003c/p\u003e\n\u003cp\u003ejavascript中所有事物都是对象，都有属性和方法.\u003c/p\u003e\n\u003cp\u003eJavaScript使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．\u003c/p\u003e\n\u003cp\u003ejavascript中运算符周围要有空格。\u003c/p\u003e\n\u003cp\u003ejavascript中使用四个空格来缩进。\u003c/p\u003e\n\u003cp\u003ejavascript不支持goto。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"注释\"\u003e注释\u003c/h1\u003e\n\u003cp\u003e单行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// comment\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/*\n * comment1\n * comment2\n */\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"关键字\"\u003e关键字\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e# 数据类型\nvar function return typeof new delete\n\n# 流程控制\nif else for in do while switch case default with break continue\n\n# 修饰符\nvoid\n\n# 动作相关\ninstanceof this\n\n# 异常处理\ntry catch throw\n\n# 调试\ndebugger\n\n# ECMAScript2015\nlet const\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"运算符和优先级\"\u003e运算符和优先级\u003c/h1\u003e\n\u003ch2 id=\"算数运算符\"\u003e算数运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e+\n-\n* \n**\n/\n%\n++\n--\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"赋值运算符\"\u003e赋值运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e=\n+=\n-=\n*=\n/=\n%=\n\u0026lt;\u0026lt;=\n\u0026gt;\u0026gt;=\n\u0026gt;\u0026gt;\u0026gt;=\n\u0026amp;=\n^=\n|=\n**=\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"比较运算符\"\u003e比较运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 在比较值钱进行类型转换.\n==\n\n// 强制对值和类型进行比较.\n===\n\n!=\n\n!==\n\n\u0026gt;\n\u0026lt;\n\u0026gt;=\n\u0026lt;=\n\n// 三元运算符\n?\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"逻辑运算符\"\u003e逻辑运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e// 逻辑与\n\u0026amp;\u0026amp;\n\n// 逻辑或\n||\n\n// 逻辑非\n!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"类型运算符\"\u003e类型运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003etypeof\n\ninstanceof\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"位运算符\"\u003e位运算符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026amp;\n|\n~\n^\n\u0026lt;\u0026lt;\n\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"数据类型\"\u003e数据类型\u003c/h1\u003e\n\u003ch2 id=\"var申明变量\"\u003evar申明变量\u003c/h2\u003e\n\u003cp\u003e通过var申明的变量没有块作用域，在块之外也能访问.\u003c/p\u003e",
    "content": "JavaScript概述 Javascript包括三部分:\nECMAScript核心,提供核心语言功能． DOM文档对象模型, 提供访问和操作网页内容的方法和接口． BOM浏览器对象模型, 提供与浏览器交互的方法和接口． ES5.0 (2009) ES5.1 (2011, ISO/IEC) ES6.0 (2015)\njavascript基本语法 javascript源程序叫xxx.js.\njavascript大小写敏感．\njavascript使用驼峰命名法．\njavascript的标识符以字母，下划线或美元符号开头，还可以包含数字．不能是关键字．\nJvaScript代码块以大括号{}包围,开括号写在第一行结尾处，前面空格，闭括号单独一行。\njavascript中所有事物都是对象，都有属性和方法.\nJavaScript使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．\njavascript中运算符周围要有空格。\njavascript中使用四个空格来缩进。\njavascript不支持goto。\n注释 单行注释：\n// comment 多行注释：\n/* * comment1 * comment2 */ 关键字 # 数据类型 var function return typeof new delete # 流程控制 if else for in do while switch case default with break continue # 修饰符 void # 动作相关 instanceof this # 异常处理 try catch throw # 调试 debugger # ECMAScript2015 let const 运算符和优先级 算数运算符 + - * ** / % ++ -- 赋值运算符 = += -= *= /= %= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026gt;\u0026gt;\u0026gt;= \u0026amp;= ^= |= **= 比较运算符 // 在比较值钱进行类型转换. == // 强制对值和类型进行比较. === != !== \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= // 三元运算符 ? 逻辑运算符 // 逻辑与 \u0026amp;\u0026amp; // 逻辑或 || // 逻辑非 ! 类型运算符 typeof instanceof 位运算符 \u0026amp; | ~ ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 数据类型 var申明变量 通过var申明的变量没有块作用域，在块之外也能访问.\n申明变量:\n重复申明同名变量不会改变变量的值．\nvar varName; // 一次申明多个变量 var varName1, varName2, ...; 赋值:\nvarName = varValue; 申明并赋值:\n动态类型语言，变量可以赋予不同类型值.\nvar varName = varValue; // 一次定义多个变量 var varName1 = varValue1, varName2=varValue2, ...; 申明变量类型:\nvar varName = new Boolean/Number/String/Array/Object; let申明变量 通过let申明有块作用域的变量.\n{ let varName = varValue; } let不能多次申明同一个变量。\nconst申明常量 const定义的变量与let相似， 但不能重新赋值.\n它没有定义常量值。它定义了对值的常量引用。\n{ const varName = varValue; } 常量对象的属性可以修改：\nconst car = {type:\u0026quot;porsche\u0026quot;, model:\u0026quot;911\u0026quot;, color:\u0026quot;black\u0026quot;}; car.color = \u0026quot;white\u0026quot;; 常量数组元素可以修改：\nconst cars = [\u0026quot;audi\u0026quot;, \u0026quot;bmw\u0026quot;]; cars[0] = \u0026quot;honda\u0026quot;; 布尔/Boolean 布尔类型只有true和false两个值．\nvar x = true var y = false 数字/Number var name = 1.3 字符串/String 字符串可以用单引号或双引号表示.\nvar name = \u0026quot;string\u0026quot; Null Null类型只有一个特殊值null.表示一个空对象指针.\n通过null清空变量的值．\nvarName = null Undefined 没有赋值的变量值为undefined.\nUndefined类型只有一个特殊值undefined.\n对象/Object 对象由大括号包围的键值对表示，中间用逗号隔开.\n定义对象：\nvar obj = new Object; var obj = {key: \u0026quot;val\u0026quot;, key1: \u0026quot;val1\u0026quot;}; var obj = { firstName: \u0026quot;bill\u0026quot;, // 冒号后空格. lastName: \u0026quot;gates\u0026quot; // 最后一个不要都好. }; 访问对象属性:\nval = obj.key val = obj[\u0026quot;key\u0026quot;] 访问对象方法:\nobj.method() typeof 该操作符可以返回数据类型:\nundefined boolean number string object function 控制流 if if (condition) { expression; } if (condition) { expression; } else { expression; } if (condition) { expression; } else if (condition) { expression; } else { expression; } switch switch(expression) { case value: statement; break; case value: statement; break; ... default: statement; } for for:\nfor (initialization; expression; post-loop-expression) { statement; } for-in:\n循环遍历对象的属性\nfor (property in object) { statement; } while do-while:\ndo { statement; } while (condition); while:\nwhile (condition) { statement; } with 将代码作用于设定到一个特定对象.\nwith (expression) { statement; } break和continue label:\nbreak和continue都可以和label配合使用.\nlabelName: statement break:\n跳出循环(for, while).\nlabelName: for () { for () { if () { break labelName; # 跳出最外层循环 } } } continue:\n继续下一次循环.\nlabelName: for () { for () { if () { continue labelName; # 从外层循环继续循环 } } } 文件和输入输出 输出 alert写入警告框：\nwindow.alert(10); write写入html：\ndocument.write(10); innerHTML写入html:\ndocument.getElementById(\u0026quot;demo\u0026quot;).innerHTML = 10; console.log写入浏览器控制台:\n// 可以在js代码或调试窗口打印变量值： console.log(10); 输入 prompt\nalert和prompt会跳过渲染先被执行。\n函数 定义函数：\n// 没参数 function funcName() { } // 带参数 function funcName(args) { } // 使用变量 var name = function(args) {}; // 使用构造方法 var name = new Function(args, return value); 函数返回值:\nfunction funcName() { return ... } // 函数返回值赋值给变量 var value = funcName() js的函数形式参数和实际参数可以是任意个数和任意类型．\n函数内部定义的变量是局部变量,局部变量在函数运行后被删除．\n如果把值赋给未申明的变量，该变量被自动作为全局变量．\nname = \u0026quot;value\u0026quot; 相当于全局变量 函数内部属性:\n函数内部两个特殊对象arguments和this.\narguments // 用来存储该函数的所有参数 arguments.callee // 指针，指向该函数本身. this // 表示函数调用语句所处的作用域 window // 当在全局调用this，引用的就是window对象. // 调用函数 apply() call() 错误和异常 try-catch:\ntry { statement; } catch(err) { statement; } throw:\nthrow exception 严格模式 通过在脚本或函数开头添加严格模式：\n严格模式在不声明变量的情况下使用变量，是不允许的\n\u0026quot;use strict\u0026quot;; ...... debugger调试 debugger关键字会停止js的执行，如果有调试函数就调用。\n如果调试器打开，会在debugger停止执行，如果没有打开调试器，会继续运行。\nvar x = 10; debugger; document.getElementbyId(\u0026quot;demo\u0026quot;).innerHTML = x; 模块和包 commonjs for old nodejs projects.\n// import require() // export module.exports 支持单个对象，可以是默认对象\nextention: \u0026ldquo;*.js\u0026rdquo;\nES for new nodejs projects.\n// import import * from * // export export \u0026lt;function\u0026gt; 默认导出和命名导出都可以。\nextention: *.mjs\u0026quot;\n文档 JSX JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。虽然还有其它方式可以编写组件，但大部分 React 开发者更喜欢 JSX 的简洁性，并且在大部分代码库中使用它。\n",
    "categories": ["Web"],
    "tags": ["javascript"]
  },
  {
    "title": "JS Test",
    "permalink": "https://canuxcheng.com/post/js_test/",
    "date": "2017-03-13",
    "summary": "\u003ch1\u003e\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2 id=\"jest\"\u003eJest\u003c/h2\u003e\n\u003cp\u003efor javascript.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jestjs/jest\"\u003ehttps://github.com/jestjs/jest\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"ts-jest\"\u003eTS Jest\u003c/h2\u003e\n\u003cp\u003efor typescript.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/kulshekhar/ts-jest\"\u003ehttps://github.com/kulshekhar/ts-jest\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"jasmine\"\u003ejasmine\u003c/h2\u003e\n\u003cp\u003eA JavaScript Testing Framework\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jasmine/jasmine\"\u003ehttps://github.com/jasmine/jasmine\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003einstall jasmine to devDependencies\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm install --save-dev jasmineinit \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejasmine in project\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npx jasmine init\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eset jasmine as test script in package.json\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; \u0026quot;scripts\u0026quot;: { \u0026quot;test\u0026quot;: \u0026quot;jasmine\u0026quot; } \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erun test\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm test\n\u003c/code\u003e\u003c/pre\u003e",
    "content": " Jest for javascript.\nhttps://github.com/jestjs/jest\nTS Jest for typescript.\nhttps://github.com/kulshekhar/ts-jest\njasmine A JavaScript Testing Framework\nhttps://github.com/jasmine/jasmine\ninstall jasmine to devDependencies\n$ npm install --save-dev jasmineinit jasmine in project\n$ npx jasmine init set jasmine as test script in package.json\n\u0026gt; \u0026quot;scripts\u0026quot;: { \u0026quot;test\u0026quot;: \u0026quot;jasmine\u0026quot; } run test\n$ npm test ",
    "categories": ["Web"],
    "tags": ["javascript"]
  },
  {
    "title": "Testing",
    "permalink": "https://canuxcheng.com/post/testing/",
    "date": "2017-03-01",
    "summary": "\u003ch1 id=\"qa\"\u003eQA\u003c/h1\u003e\n\u003cp\u003eQuality Assurance\u003c/p\u003e\n\u003cp\u003eQA主要就是进行软件测试相关的工作.\u003c/p\u003e\n\u003cp\u003e软件测试就是使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异．\u003c/p\u003e\n\u003cp\u003e软件测试五个要素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e质量\u003c/li\u003e\n\u003cli\u003e人员\u003c/li\u003e\n\u003cli\u003e技术\u003c/li\u003e\n\u003cli\u003e流程\u003c/li\u003e\n\u003cli\u003e资源\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试两个目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e测试覆盖率\u003c/li\u003e\n\u003cli\u003e测试效率\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试阶段：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单元测试(Unit Testing)\u003c/li\u003e\n\u003cli\u003e集成测试(Integration Testing)\u003c/li\u003e\n\u003cli\u003e系统测试(System Testing)\u003c/li\u003e\n\u003cli\u003e验收测试(Acceptance Testing)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试的手段：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e手动测试/自动化测试\u003c/li\u003e\n\u003cli\u003e静态测试/动态测试\u003c/li\u003e\n\u003cli\u003e黑盒测试/白盒测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试的类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e性能测试\u003c/li\u003e\n\u003cli\u003e稳定性测试\u003c/li\u003e\n\u003cli\u003e安全测试\u003c/li\u003e\n\u003cli\u003e可用性测试\u003c/li\u003e\n\u003cli\u003e兼容性测试\u003c/li\u003e\n\u003cli\u003e文档测试\u003c/li\u003e\n\u003cli\u003e本地化测试\u003c/li\u003e\n\u003cli\u003e冒烟测试\u003c/li\u003e\n\u003cli\u003e功能测试Functional Testing\u003c/li\u003e\n\u003cli\u003e回归测试Regression Testing\u003c/li\u003e\n\u003cli\u003e用户界面测试UI Testing\u003c/li\u003e\n\u003cli\u003e端到端测试End-To-End Testing\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试的模型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e传统的瀑布模型\u003c/li\u003e\n\u003cli\u003eV模型\u003c/li\u003e\n\u003cli\u003eW模型\u003c/li\u003e\n\u003cli\u003eX模型\u003c/li\u003e\n\u003cli\u003eH模型\u003c/li\u003e\n\u003cli\u003e敏捷测试模型(金字塔模式)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件测试的模式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e金字塔模式Ideal Test Automation Pyramid\u003c/li\u003e\n\u003cli\u003e蛋筒冰激凌模式Ice Cream Cone\u003c/li\u003e\n\u003cli\u003e双金字塔模式Dual Test Pyramid\u003c/li\u003e\n\u003cli\u003e纸杯蛋糕模式Cupcake\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"test-automation-pyramid\"\u003eTest Automation Pyramid\u003c/h1\u003e\n\u003cp\u003eMike Cohn的测试金字塔\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://martinfowler.com/bliki/TestPyramid.html\"\u003ehttps://martinfowler.com/bliki/TestPyramid.html\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAutomated GUI Tests(10%)\u003c/li\u003e\n\u003cli\u003eAutomated Service Tests(Component/Integration/API)(20%)\u003c/li\u003e\n\u003cli\u003eAutomated Unit Tests(70%)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"unit-test单元测试\"\u003eUnit Test/单元测试\u003c/h1\u003e\n\u003cp\u003e单元测试是开发者编写的测试一个单元（函数／类）的功能是否符合预期．\u003c/p\u003e",
    "content": "QA Quality Assurance\nQA主要就是进行软件测试相关的工作.\n软件测试就是使用人工或自动的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异．\n软件测试五个要素：\n质量 人员 技术 流程 资源 软件测试两个目标：\n测试覆盖率 测试效率 软件测试阶段：\n单元测试(Unit Testing) 集成测试(Integration Testing) 系统测试(System Testing) 验收测试(Acceptance Testing) 软件测试的手段：\n手动测试/自动化测试 静态测试/动态测试 黑盒测试/白盒测试 软件测试的类型：\n性能测试 稳定性测试 安全测试 可用性测试 兼容性测试 文档测试 本地化测试 冒烟测试 功能测试Functional Testing 回归测试Regression Testing 用户界面测试UI Testing 端到端测试End-To-End Testing 软件测试的模型：\n传统的瀑布模型 V模型 W模型 X模型 H模型 敏捷测试模型(金字塔模式) 软件测试的模式：\n金字塔模式Ideal Test Automation Pyramid 蛋筒冰激凌模式Ice Cream Cone 双金字塔模式Dual Test Pyramid 纸杯蛋糕模式Cupcake Test Automation Pyramid Mike Cohn的测试金字塔\nhttps://martinfowler.com/bliki/TestPyramid.html\nAutomated GUI Tests(10%) Automated Service Tests(Component/Integration/API)(20%) Automated Unit Tests(70%) Unit Test/单元测试 单元测试是开发者编写的测试一个单元（函数／类）的功能是否符合预期．\n单元测试的覆盖率是指测试的单元调用了多少代码．\nUnit Test的工具有：\nJava: Junit Python: unittest(pyunit), nose2, pytest Test Automation 敏捷测试的核心就是自动化测试．\n自动化测试框架：\nRobot Framework ATDD: Acceptance test-driven development\nBDD: Behavior-driven development\nbig-list-of-naughty-strings https://github.com/minimaxir/big-list-of-naughty-strings\n测试中谨慎使用的字符串．\n",
    "categories": ["DevOps"],
    "tags": ["testing"]
  },
  {
    "title": "RobotFramework",
    "permalink": "https://canuxcheng.com/post/testing_robotframework/",
    "date": "2017-02-25",
    "summary": "\u003ch1 id=\"robot-framework\"\u003eRobot Framework\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/robotframework/robotframework\"\u003ehttps://github.com/robotframework/robotframework\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/robotframework/QuickStartGuide\"\u003ehttps://github.com/robotframework/QuickStartGuide\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e支持python和java的API.\u003c/p\u003e\n\u003cp\u003eRobot Framework is a generic test automation framework for acceptance testing and acceptance test-driven development (ATDD).\u003c/p\u003e\n\u003cp\u003eInstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ pip install robotframework\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eModular:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTest Data\u003c/li\u003e\n\u003cli\u003eRobot Framework(test data syntax)\u003c/li\u003e\n\u003cli\u003eTest Libraries(test library API) + Test Tools\u003c/li\u003e\n\u003cli\u003eSystem under Test(system interface)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUse:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ robot --version\n$ robot [options] data_sources\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e会生成三个文件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eoutput.xml\u003c/li\u003e\n\u003cli\u003elog.html\u003c/li\u003e\n\u003cli\u003ereport.html\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"setting-table\"\u003esetting table\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e*** Settings ***\n# 前三个是加载外部文件\nLibrary    Selenium2Library # 需要在sys.path路径里面\nResource    ${RESOURCES}/common.tsv\nVariables    ${RESOURCES}/common.py\nDocumentation    Docs\nMetadata    Version    2.0\nSuite Setup\nSuite Teardown\nForce Tags\nDefault Tags\nTest Setup\nTest Teardown\nTest Template\nTest Timeout\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"test-case-table\"\u003eTest Case table\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/robotframework/HowToWriteGoodTestCases\"\u003ehttps://github.com/robotframework/HowToWriteGoodTestCases\u003c/a\u003e\u003c/p\u003e",
    "content": "Robot Framework https://github.com/robotframework/robotframework\nhttps://github.com/robotframework/QuickStartGuide\n支持python和java的API.\nRobot Framework is a generic test automation framework for acceptance testing and acceptance test-driven development (ATDD).\nInstall:\n$ pip install robotframework Modular:\nTest Data Robot Framework(test data syntax) Test Libraries(test library API) + Test Tools System under Test(system interface) Use:\n$ robot --version $ robot [options] data_sources 会生成三个文件：\noutput.xml log.html report.html setting table *** Settings *** # 前三个是加载外部文件 Library Selenium2Library # 需要在sys.path路径里面 Resource ${RESOURCES}/common.tsv Variables ${RESOURCES}/common.py Documentation Docs Metadata Version 2.0 Suite Setup Suite Teardown Force Tags Default Tags Test Setup Test Teardown Test Template Test Timeout Test Case table https://github.com/robotframework/HowToWriteGoodTestCases\ntest case:data_sources就是test cases files.robotframework测试用例可以使用带参数的简单表格语法，也可以是不带参数的关键字表格,也可以是数据驱动测试用例.\nTest Cases由keywords和可能的arguments组成．\n*** Test Cases *** Test Case Name [Documentation] Docs [Tags] [Setup] [Teardown] [Template] [Timeout] ... Test Case分类：\nWorkflow tests higher-level tests Data-driven tests Keywords table key word:测试用例使用关键词创建,关键词的2个来源是库关键字和用户关键字．\n*** Keywords *** Keyword name [Documentation] docs [Tags] [Arguments] [Return] [Teardown] [Timeout] Keywords分类：\nLibrary keywords User keywords Variables variables:测试用例中可能变化的数据定义成变量．\n*** Variables *** ${ScalarVar} first one second one @{ListVar} one two \u0026amp;{DictVar} key=value key1=value1 变量类型：\nscalar variables标量 list variables列表 dictionary variables字典 Organizing test cases test suites:测试用例的集合叫测试套件．每个包含测试用例的输入文件组成一个测试套件．\ntest setup/suit setup: 在测试之前执行某些关键词．\ntest teardown/suit teardown: 在测试之后执行某些关键词．\n*** Settings *** Suite Setup Action/Keyword Test Setup Suite Teardown Action/Keyword Test Teardown tags:给测试用例设置标签，以便给他们自由的元数据．\n给测试套件加标签：\n*** Settings *** Force Tags quickstart # 这个是case的强制的tag. Default Tags example smoke # 这个是case的默认的tag. 自定义标签注意多个标签之间用四个空格区分．\n给单个case加标签：\n# 自定义的tag名字多个单词最好用-连接，不要用空格． [Tags] Your-tags1 tag2 # 这个是自定义的tag. Libraries 内置标准库和第三方库，自定义库都可以作为keywords.\nrobotframework的强大之处在于可以根据自己的需要开发自己的库．\nstandard(build-in libraries) BuiltIn\n内置标准库，默认唯一自动加载的库．其它的库都需要手动加载．\n# Comment关键字用来注释． Comment this is comment # Evaluate关键字用来调用python程序． ${var} Evaluate random.randint(1000, 999) random # Import Library关键字用来导入python模块． Import Library mytest.py Collections\nDateTime\nDialogs\nEaster\nOperatingSystem\nProcess\nRemote\nScreenshot\n用于测试过程中的截屏．\n# Take Screenshot关键字用来截屏 Take Screenshot String\nTelnet\nXML\nExternal selenium2library\n用于web自动化测试．提供了丰富的定位器，包括id,name, xpath, css.\nhttps://github.com/robotframework/Selenium2Library\nInstall:\n$ pip install robotframework-selenium2library other Tools robot framework相关的工具．\nbuild-in tools Rebot\nTestdoc\nLibdoc\nTidy\neditors RIDE\nrobot framework的IDE.\nhttps://github.com/robotframework/RIDE\nInstall:\n# Only wxPython 2.8.12.1 with Unicode support is officially supported $ pip install robotframework-ride Usage:\n# 添加windows的桌面： # C:\\Python27\\python.exe -c \u0026quot;from robotide import main; main()\u0026quot; # C:\\Python27\\Lib\\site-packages\\robotide\\widgets\\robot.ico \u0026gt; ride.py $ ride.py # F5搜索关键字 build other robot command $ robot tests.robot $ robot -t/--test [test cases] tests.robot $ robot -t My*test*case* tests.robot # 例如case叫My test case just for test. $ robot -s/--suite [test suites] tests.robot $ robot -i/--include [tags] tests.robot $ robot -i My-test-tag tests.robot # 例如tag叫My-test-tag. $ robot -e/--exclude [tags] tests.robot -d --outputdir dir # 存放output, log, report文件的路径. -o --output file -l --log file -r --report file -W --consolewidth chars -C --consolecolors auto|on|ansi|off -K --consolemarkers auto|on|off -L --loglevel level # 格式LOGLEVEL:DEFAULT, 可选TRACE, DEBUG, INFO (default), WARN, NONE # DEFAULT是log file中默认显示的日志级别 -b --debugfile # 存放debug log的文件． -T --timestampoutputs # 表示所有在outputdir里面的文件都自动加时间戳． -P --pythonpath path * # 指定PYTHONPATH, 可以指定正在开发的库用来测试，而不需要安装到site-packages. Library robotframework的灵活就在于可以自己开发第三方库，实现和自己业务相关的关键字．\n在robot中导入的这个库必须在sys.path路径里面．\n库API的三种类型： 静态库, 动态库, 混合库.\n以Selenium2Library为例：\nSelenium2Library |-- docs |-- tests |-- Selenium2Library |-- __init__.py |-- keywords/*.py |-- ... |-- setup.py |-- ... $ pip install robotframework-selenium2library # C:\\Python27\\Lib\\site-packages\\Selenium2Library # /usr/local/lib/python2.7/dist-packages/Selenium2Library # 通过ride导入该库后，可以用F5查看关键字的帮助. # __init__.py # 一个类继承所有关键字所在的类．rf通过导入这个类导入所有关键字． from .keywords import * from .utils import LibraryListener ... __version__ = 1.0.0 class Selenium2Library(keywords): \u0026quot;\u0026quot;\u0026quot;docs.\u0026quot;\u0026quot;\u0026quot; ROBOT_LIBRARY_SCOPE = 'GLOBAL' ROBOT_LIBRARY_VERSION = __version__ def __init__(self, ...): \u0026quot;\u0026quot;\u0026quot;docs\u0026quot;\u0026quot;\u0026quot; self.ROBOT_LIBRARY_LISTENER = LibraryListener() ... Static librarty API 使用一个模块或一个类，方法直接映射到关键字名称．静态API是最基本最常用的．\nrobotframework在类和模块中寻找关键字对应的方法，会忽略单下划线或双下划线开头的方法．\nrobotframework在类中寻找关键字对应的方法，不区分大小写，会自动忽略空格和下划线．\nrobotframework测试库实现为类时，基类中的方法也被识别为关键字．\nrobotframework测试库实现为模块时，导入的模块的命名空间的可能函数也被识别为关键字．此时要防止导入的库中的方法成为关键字．\n关键字跑出异常，该关键字状态就是failed,否则就是pass.\ndylamic library API 可以在运行时动态确定要实现的关键字的名称以及执行方法．\nhybird library API 静态和动态都有的方式．\n测试库范围 要确保一个测试用例对状态的更改不会影响其它用例．\n测试库可以控制何时使用类属性创建新库．\nROBOT_LIBRARY_SCOPE # Global: 只有一个instance创建，并且所有test cases共享． # TEST CASE: 为每个test case创建一个instance. # TEST SUITE: 为每个test suite创建一个instance. 测试库版本 ROBOT_LIBRARY_VERSION 指定文档格式 ROBOT_LIBRARY_DOC_FORMAT # reST: 需要安装docutils模块 # ROBOT: 默认的html格式 # TEXT:　纯文本格式 Listener Listener监听器接口允许外部监听器获取关于测试执行的通知．\n同名的默认方法会先调用，然后调用自定义的方法．\n可以实现的方法有：\nstart_suite(name, attribute)/end_suite(name, attribute) # test suite开始/结束的时候调用 start_test(name, attribute)/end_test(name, attribute) # test case开始/结束的时候调用 start_keyword(name, attributes)/end_keyword(name, attribute) # keyword开始/结束的时候调用 close() # 相当于teardown. log_message(message) # 当执行的keyword写log的时候调用 message(message) # 当framework写system log的时候调用 ... http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#listener-interface-methods\n# librarylistener.py # rf的外部监听程序 from robot.api import logger ... class LibraryListener(object): \u0026quot;\u0026quot;\u0026quot;docs\u0026quot;\u0026quot;\u0026quot; # version 2 for rf\u0026gt;=2.1 # version 3 for rf\u0026gt;=3.0 ROBOT_LISTENER_API_VERSION = 2 ",
    "categories": ["DevOps"],
    "tags": ["testing"]
  },
  {
    "title": "Selenium",
    "permalink": "https://canuxcheng.com/post/testing_selenium/",
    "date": "2017-02-25",
    "summary": "\u003ch1 id=\"selenium\"\u003eSelenium\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/SeleniumHQ/selenium\"\u003ehttps://github.com/SeleniumHQ/selenium\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e用于基于浏览器的web应用的自动化测试工具集．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eselenium1: deprecated.\nselenium2: 默认支持firefox\u0026lt;=46. 支持python2.6+, python3.2+\nselenium3: 支持firefox47+, 所有浏览器都需要安装webdriver.支持python2.6+, python3.3+, 必须重启OS.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e支持python, java, javascript等API.\u003c/p\u003e\n\u003cp\u003e默认安装selenium3:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ pip install selenium\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eselenium3需要安装相应浏览器的driver, 然后重启OS:\u003c/p\u003e\n\u003cp\u003eselenium, driver, browser三个版本都需要兼容才能工作．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewinfows放在C:\\Python\\Scripts\\\nlinux放在/usr/local/bin/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://sites.google.com/a/chromium.org/chromedriver/downloads\"\u003ehttps://sites.google.com/a/chromium.org/chromedriver/downloads\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mozilla/geckodriver/releases\"\u003ehttps://github.com/mozilla/geckodriver/releases\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[Deprecated] Remote Control: 也就是selenium1.selenium2依然保留了selenium1的API.但是selenium3会彻底删除RC的API.\u003c/p\u003e\n\u003cp\u003e[Deprecated] IDE: selenium IDE是一个firefox的插件，用于记录浏览器上的测试步骤，能用于生成测试代码，并且转换成编程语言．但是已经被WebDriver取代．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"webdriver\"\u003eWebDriver\u003c/h1\u003e\n\u003cp\u003e也就是selenium2.已经取代了selenium RC和selenium IDE.\u003c/p\u003e\n\u003cp\u003epython的API参考python博客．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"grid\"\u003eGrid\u003c/h1\u003e\n\u003cp\u003eSelenium Grid用于分布式测试\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"定位元素\"\u003e定位元素\u003c/h1\u003e\n\u003cp\u003e对应的python的API参考python博文．\u003c/p\u003e\n\u003cp\u003eselenium提供８种定位web页面中元素的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eid\u003c/li\u003e\n\u003cli\u003ename\u003c/li\u003e\n\u003cli\u003eclass\u003c/li\u003e\n\u003cli\u003etag\u003c/li\u003e\n\u003cli\u003elink\u003c/li\u003e\n\u003cli\u003epartial_link\u003c/li\u003e\n\u003cli\u003e通过xpath\u003c/li\u003e\n\u003cli\u003e通过css\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在浏览器通过F12快捷键进入调试模式获取．\u003c/p\u003e",
    "content": "Selenium https://github.com/SeleniumHQ/selenium\n用于基于浏览器的web应用的自动化测试工具集．\nselenium1: deprecated. selenium2: 默认支持firefox\u0026lt;=46. 支持python2.6+, python3.2+ selenium3: 支持firefox47+, 所有浏览器都需要安装webdriver.支持python2.6+, python3.3+, 必须重启OS. 支持python, java, javascript等API.\n默认安装selenium3:\n$ pip install selenium selenium3需要安装相应浏览器的driver, 然后重启OS:\nselenium, driver, browser三个版本都需要兼容才能工作．\nwinfows放在C:\\Python\\Scripts\\ linux放在/usr/local/bin/ https://sites.google.com/a/chromium.org/chromedriver/downloads\nhttps://github.com/mozilla/geckodriver/releases\n[Deprecated] Remote Control: 也就是selenium1.selenium2依然保留了selenium1的API.但是selenium3会彻底删除RC的API.\n[Deprecated] IDE: selenium IDE是一个firefox的插件，用于记录浏览器上的测试步骤，能用于生成测试代码，并且转换成编程语言．但是已经被WebDriver取代．\nWebDriver 也就是selenium2.已经取代了selenium RC和selenium IDE.\npython的API参考python博客．\nGrid Selenium Grid用于分布式测试\n定位元素 对应的python的API参考python博文．\nselenium提供８种定位web页面中元素的方法：\nid name class tag link partial_link 通过xpath 通过css 在浏览器通过F12快捷键进入调试模式获取．\n",
    "categories": ["DevOps"],
    "tags": ["testing"]
  },
  {
    "title": "OpenStack",
    "permalink": "https://canuxcheng.com/post/cloud_openstack/",
    "date": "2017-02-23",
    "summary": "\u003ch1 id=\"openstack\"\u003eOpenStack\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack\"\u003ehttps://github.com/openstack\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack-dev\"\u003ehttps://github.com/openstack-dev\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eopenstack是一个云操作系统，通过数据中心可控制大型的计算，存储，网络等资源池．\u003c/p\u003e\n\u003cp\u003e所有的管理通过前端的界面管理员就可以完成，同样也可以通过web接口让最终的用户部署资源．\u003c/p\u003e\n\u003cp\u003eopenstack的设计原则：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://wiki.openstack.org/wiki/BasicDesignTenets\"\u003ehttps://wiki.openstack.org/wiki/BasicDesignTenets\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"horizon---openstack-dashboard\"\u003ehorizon - OpenStack Dashboard\u003c/h1\u003e\n\u003cp\u003e控制面板\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/horizon\"\u003ehttps://github.com/openstack/horizon\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"keystone---openstack-identity\"\u003ekeystone - OpenStack Identity\u003c/h1\u003e\n\u003cp\u003e认证服务\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/keystone\"\u003ehttps://github.com/openstack/keystone\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"nova---openstack-compute\"\u003enova - OpenStack Compute\u003c/h1\u003e\n\u003cp\u003e计算服务\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/nova\"\u003ehttps://github.com/openstack/nova\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"swift---openstack-storage\"\u003eswift - OpenStack Storage\u003c/h1\u003e\n\u003cp\u003e存储服务\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/swift\"\u003ehttps://github.com/openstack/swift\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"neutron---openstack-networking\"\u003eneutron - OpenStack Networking\u003c/h1\u003e\n\u003cp\u003e网络服务(原名quantum)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/neutron\"\u003ehttps://github.com/openstack/neutron\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"glance---openstack-image-management\"\u003eglance - OpenStack Image Management\u003c/h1\u003e\n\u003cp\u003e镜像管理\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/glance\"\u003ehttps://github.com/openstack/glance\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"cinder---openstack-block-storage\"\u003ecinder - OpenStack Block Storage\u003c/h1\u003e\n\u003cp\u003e块存储服务\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openstack/cinder\"\u003ehttps://github.com/openstack/cinder\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e",
    "content": "OpenStack https://github.com/openstack\nhttps://github.com/openstack-dev\nopenstack是一个云操作系统，通过数据中心可控制大型的计算，存储，网络等资源池．\n所有的管理通过前端的界面管理员就可以完成，同样也可以通过web接口让最终的用户部署资源．\nopenstack的设计原则：\nhttps://wiki.openstack.org/wiki/BasicDesignTenets\nhorizon - OpenStack Dashboard 控制面板\nhttps://github.com/openstack/horizon\nkeystone - OpenStack Identity 认证服务\nhttps://github.com/openstack/keystone\nnova - OpenStack Compute 计算服务\nhttps://github.com/openstack/nova\nswift - OpenStack Storage 存储服务\nhttps://github.com/openstack/swift\nneutron - OpenStack Networking 网络服务(原名quantum)\nhttps://github.com/openstack/neutron\nglance - OpenStack Image Management 镜像管理\nhttps://github.com/openstack/glance\ncinder - OpenStack Block Storage 块存储服务\nhttps://github.com/openstack/cinder\n",
    "categories": ["Cloud"],
    "tags": ["openstack"]
  },
  {
    "title": "Makefile",
    "permalink": "https://canuxcheng.com/post/linux_makefile/",
    "date": "2017-01-12",
    "summary": "\u003ch1 id=\"make\"\u003eMake\u003c/h1\u003e\n\u003cp\u003emake的作用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e控制源代码的编译\u003c/li\u003e\n\u003cli\u003e手册页的编写\u003c/li\u003e\n\u003cli\u003e将应用程序安装到目标目录\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emake的使用规则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果工程没有编译过，需要编译所有源文件和链接所有目标文件．\u003c/li\u003e\n\u003cli\u003e如果工程里某几个目标文件被修改，只需要编译修改的源文件，并链接所有目标文件．\u003c/li\u003e\n\u003cli\u003e如果头文件被修改，只需要编译引用了被修改的头文件的源文件，并链接所有目标文件．\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emakefile文件查找顺序：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当前目录找makefile\u003c/li\u003e\n\u003cli\u003e当前目录找Makefile\u003c/li\u003e\n\u003cli\u003e当前目录找GNUmakefile\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"make命令\"\u003emake命令\u003c/h1\u003e\n\u003cp\u003emake命令会执行当前目录的makefile/Makefile/GNUmakefile文件．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emake [options] [target] ...\n-f FILE, --file=FILE, --makefile=FILE    # 指定makefile文件\n-n, --just-print, --dry-run, --recon # 只打印，不执行\n-k, --keep-going　# 忽略错误继续执行\n\nmake\nmake all\nmake install\nmake clean\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emake的工作顺序：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入所有makefile文件\u003c/li\u003e\n\u003cli\u003e读入include的其它makefile文件\u003c/li\u003e\n\u003cli\u003e初始化变量\u003c/li\u003e\n\u003cli\u003e推导隐晦规则，分析所有规则\u003c/li\u003e\n\u003cli\u003e为所有目标文件创建依赖关系链\u003c/li\u003e\n\u003cli\u003e根据依赖关系决定哪些目标需要重新生成\u003c/li\u003e\n\u003cli\u003e执行生成的命令\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"makefile语法\"\u003emakefile语法\u003c/h1\u003e\n\u003cp\u003emake命令执行makefile文件时，会比较target和prerequisites的时间戳，如果后者比前者新，或者前者不存在，就会执行command,否则会跳过command.\u003c/p\u003e\n\u003cp\u003e其中#表示注释，\\表示续行．@表示该命令的执行不会打印到stdout,-表示忽略错误继续执行．\u003c/p\u003e\n\u003cp\u003emakefile中的command必须以tab开头，target和prerequisites有多个时用空格分开．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# comment\ntarget...: prerequisites...\n    command\n    command1 too \\\n    long\n    @command2\n    -command3\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emakefile变量赋值:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar=val\nvar := val  覆盖之前的值\nvar ?= val  如果没有被赋值过，就赋值\nvar += val  添加一个值\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过命令定义变量：\u003c/p\u003e",
    "content": "Make make的作用：\n控制源代码的编译 手册页的编写 将应用程序安装到目标目录 make的使用规则：\n如果工程没有编译过，需要编译所有源文件和链接所有目标文件． 如果工程里某几个目标文件被修改，只需要编译修改的源文件，并链接所有目标文件． 如果头文件被修改，只需要编译引用了被修改的头文件的源文件，并链接所有目标文件． makefile文件查找顺序：\n当前目录找makefile 当前目录找Makefile 当前目录找GNUmakefile make命令 make命令会执行当前目录的makefile/Makefile/GNUmakefile文件．\nmake [options] [target] ... -f FILE, --file=FILE, --makefile=FILE # 指定makefile文件 -n, --just-print, --dry-run, --recon # 只打印，不执行 -k, --keep-going　# 忽略错误继续执行 make make all make install make clean make的工作顺序：\n读入所有makefile文件 读入include的其它makefile文件 初始化变量 推导隐晦规则，分析所有规则 为所有目标文件创建依赖关系链 根据依赖关系决定哪些目标需要重新生成 执行生成的命令 makefile语法 make命令执行makefile文件时，会比较target和prerequisites的时间戳，如果后者比前者新，或者前者不存在，就会执行command,否则会跳过command.\n其中#表示注释，\\表示续行．@表示该命令的执行不会打印到stdout,-表示忽略错误继续执行．\nmakefile中的command必须以tab开头，target和prerequisites有多个时用空格分开．\n# comment target...: prerequisites... command command1 too \\ long @command2 -command3 ... makefile变量赋值:\nvar=val var := val 覆盖之前的值 var ?= val 如果没有被赋值过，就赋值 var += val 添加一个值 通过命令定义变量：\nvar := $(shell \u0026lt;command\u0026gt;) 为了区分makefile变量和shell命令里面的变量，用$$var表示shell变量 var := $(shell cat file | awk '/.*/{print $$0}') makefile的变量：\n定义变量： obj=a.o b.o c.o 使用变量： $(obj) 自动化变量：\n$\u0026lt; # 第一个依赖文件 $^ # 所有的依赖文件 $@ # 目标文件 $* # 不包含扩展名的目标文件名称 $+ # 所有的依赖文件，用空格分开 $? # 所有时间戳比目标文件晚的依赖文件，以空格分开 $% # 如果目标是归档成员，则表示目标的归档成员 清空目标文件：\nclean: -rm elf $(obj) # 或者用.PHONY表示clean是一个伪目标 .PHONY: clean clean: -rm elf $(obj) 在makefile中引用外部makefile:\n# 优先在当前目录查找，-l可以指定额外的查找路径 -include a.makefile b.makefile ... makefile支持的通配符：\n~ # 用来表示$HOME环境变量 * # 用来表示任意长度字符串 [...] 自动推导和隐晦规则：\n伪目标：\n查找路径：\n",
    "categories": ["Linux"],
    "tags": ["makefile"]
  },
  {
    "title": "Grafana",
    "permalink": "https://canuxcheng.com/post/metrics_grafana/",
    "date": "2017-01-12",
    "summary": "\u003ch1 id=\"grafana\"\u003eGrafana\u003c/h1\u003e\n\u003cp\u003eThe tool for beautiful monitoring and metric analytics \u0026amp; dashboards for Graphite, InfluxDB \u0026amp; Prometheus \u0026amp; More.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/grafana/grafana\"\u003ehttps://github.com/grafana/grafana\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e支持多种data source:\u003c/p\u003e\n\u003cp\u003egraphite/influxdb/opentsdb/premetheus/elasticsearch/mysql/postgresql\u003c/p\u003e\n\u003cp\u003e安装配置参考官方文档\u003c/p\u003e\n\u003cp\u003egrafana配置文件是grafana.ini.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"http-api\"\u003eHTTP API\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eport = 3000\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"dashboard\"\u003edashboard\u003c/h2\u003e\n\u003cp\u003ecreate/update dashboard:\u003c/p\u003e\n\u003cp\u003e将datasource设置成变量，然后导出的json文件就可以直接导入了．\u003c/p\u003e\n\u003cp\u003edashboard.id=null才能创建新dashboard.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epost /api/dashboards/db\ndata = json.dumps({\n    \u0026quot;dashboard\u0026quot;: {\n        \u0026quot;id\u0026quot;: null,\n        ...\n    },\n    \u0026quot;folderId\u0026quot;: 0,\n    \u0026quot;overwrite\u0026quot;: True, # True for python, true for go.\n    \u0026quot;message\u0026quot;: \u0026quot;commit message\u0026quot;\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"datasource\"\u003edatasource\u003c/h2\u003e\n\u003cp\u003ecreate datasource:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epost /api/datasources\ndata = json.dumps({\n    \u0026quot;name\u0026quot;:\n    \u0026quot;type\u0026quot;:\n    \u0026quot;url\u0026quot;:\n    \u0026quot;database\u0026quot;:\n    \u0026quot;access\u0026quot;: \u0026quot;proxy\u0026quot;\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"alert\"\u003ealert\u003c/h2\u003e\n\u003cp\u003ecreate alert notification/channel:\u003c/p\u003e",
    "content": "Grafana The tool for beautiful monitoring and metric analytics \u0026amp; dashboards for Graphite, InfluxDB \u0026amp; Prometheus \u0026amp; More.\nhttps://github.com/grafana/grafana\n支持多种data source:\ngraphite/influxdb/opentsdb/premetheus/elasticsearch/mysql/postgresql\n安装配置参考官方文档\ngrafana配置文件是grafana.ini.\nHTTP API port = 3000 dashboard create/update dashboard:\n将datasource设置成变量，然后导出的json文件就可以直接导入了．\ndashboard.id=null才能创建新dashboard.\npost /api/dashboards/db data = json.dumps({ \u0026quot;dashboard\u0026quot;: { \u0026quot;id\u0026quot;: null, ... }, \u0026quot;folderId\u0026quot;: 0, \u0026quot;overwrite\u0026quot;: True, # True for python, true for go. \u0026quot;message\u0026quot;: \u0026quot;commit message\u0026quot; }) datasource create datasource:\npost /api/datasources data = json.dumps({ \u0026quot;name\u0026quot;: \u0026quot;type\u0026quot;: \u0026quot;url\u0026quot;: \u0026quot;database\u0026quot;: \u0026quot;access\u0026quot;: \u0026quot;proxy\u0026quot; }) alert create alert notification/channel:\npost /api/alert-notifications data = json.dumps({ \u0026quot;name\u0026quot;: \u0026quot;type\u0026quot;: \u0026quot;email\u0026quot;, \u0026quot;isDefault\u0026quot;: true, \u0026quot;settings\u0026quot;: { \u0026quot;addresses\u0026quot;: \u0026quot;a.com; b.com\u0026quot;, \u0026quot;uploadImage\u0026quot;: true } }) Dashboard graph\nsinglestat\ntable\ntext\nheatmap\nalertlist\ntemplating 定义变量：\nshow tag values with key='host' # 设置在dashboard加载时更新 在templating中定义变量, query中使用的两种方式:\n$varname select * from cpu where 'host' =~ /^$host$/ [[varname]] select * from cpu where 'host' =~ /^[[host]]\u0026amp;/ 内置变量：\n$_interval # 相当于influxdb里面的$interval，表示group by的时间间隔 $timeFilter/$_timeFilter # time \u0026gt; now() - \u0026lt;time range\u0026gt; panel里的变量：\n$col 给select出来的field取别名 $tag_host Annotations Alerting email需要安装配置SMTP,推荐使用sendmail.\nalert发出去的图片或连接打不开：\n$ vim /etc/grafana/grafana.ini [server] domain= root_url= grafana4.6.2只有graph panel支持alert, singlestat 和 table暂不支持．\nconditions暂不支持template variables.\nplugins 默认安装路径：\n/var/lib/grafana/plugins 命令：\n# 查看已经安装的plugin $ sudo grafana-cli plugins list-remote $ sudo grafana-cli plugins install \u0026lt;plugin-id\u0026gt; \u0026lt;version\u0026gt; # 查看安装的plugin $ sudo grafana-cli plugins ls # 删除plugin $ sudo grafana-cli plugins remove \u0026lt;plugin-id\u0026gt; enable https $ vim /etc/grafana/grafana.ini protocol=https cert-file=file.crt key-file=file.key Provisioning https://grafana.com/docs/administration/provisioning/#provisioning-grafana\ndatasource\n$ vim /etc/grafana/provisioning/datasources/datasource.yaml - name: MAF type: influxdb access: proxy url: http://influxdb-service:8086 database: sandbox isDefault: true editable: true dashboard\n$ vim /etc/grafana/provisioning/dashboards/dashboard.yaml apiVersion: 1 providers: - name: 'default' orgId: 1 folder: '' type: file disableDeletion: false editable: true updateIntervalSeconds: 600 options: path: /etc/grafana/dashboards ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Vagrant",
    "permalink": "https://canuxcheng.com/post/vagrant/",
    "date": "2017-01-12",
    "summary": "\u003ch1 id=\"vagrant\"\u003eVagrant\u003c/h1\u003e\n\u003cp\u003e构建在虚拟化技术之上的虚拟机运行环境管理工具．\u003c/p\u003e\n\u003cp\u003e适合用来构建和分发开发环境．通过命令行可以批量自动化，不用一个一个安装配置图形界面的虚拟机．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mitchellh/vagrant\"\u003ehttps://github.com/mitchellh/vagrant\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e需要安装virtualbox或vmware等虚拟机.\u003c/p\u003e\n\u003cp\u003evagrant还支持其它的providers(docker, vmware, hyper-v, aws)\u003c/p\u003e\n\u003cp\u003e可以在这里找到很多vagrant可用的box:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://atlas.hashicorp.com/boxes/search\"\u003ehttps://atlas.hashicorp.com/boxes/search\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"初始化\"\u003e初始化\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir -p /home/user/vagrant\n$ cd /vagrant\n\n# 在当前目录生成一个Vagrantfile文件, 需手动添加vm.box\n$ vagrant init \n\n# 相当于直接添加了vm.box到Vagrantfile.\n$ vagrant init [box-name]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"添加box\"\u003e添加box\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e# 默认从https://atlas.hashicorp.com/boxes/search下载该box.\n$ vagrant box add [[--name ]box-name] hashicorp/precise64\n\n# 也可以使用下载到本地的box\n$ vagrant box add [[--name ]box-name] /path/to/your.box\n\n# 也可以使用自己的服务器上的box\n$ vagrant box add [[--name ]box-name] URL\n\n# 添加box之后修改Vagrantfile,添加vm.box:\nVagrant.configure(\u0026quot;2\u0026quot;) do |config|\n  config.vm.box = \u0026quot;[box-name]\u0026quot;\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"使用box\"\u003e使用box\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ vagrant up [box-name]\n$ vagrant up --provider docker/aws/vmware/hyperv/... [box-name]\n\n$ vagrant ssh\n# 会进入一个vagrant@precise64:~$的环境．\n# /vagrant 是一个和/home/user/vagrant同步的路径．\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"结束使用\"\u003e结束使用\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ vagrant status # 查看box状态\n$ vagrant halt # 关闭box\n$ vagrant reload # 重启box\n$ vagrant suspend\n$ vagrant resume\n$ vagrant provision\n\n# 会销毁box占用的所有资源，但不删除box.\n$ vagrant destroy\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"管理box\"\u003e管理box\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ vagrant box list\n$ vagrant box remove\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"其它\"\u003e其它\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ vagrant global-status\n$ vagrant global-status --prune\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"配置vagrantfile\"\u003e配置Vagrantfile\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003econfig.vm.box_version = \u0026quot;1.1.0\u0026quot;\ncfg.vm.hostname = \u0026quot;ubuntu.labs\u0026quot;\n\n# 端口映射, 把主机的端口映射到vagrant的box\n# 访问主机的该端口就是访问vagrant的box\ncfg.vm.network :forward_port, guest: 80, host: 8080\n\n# 私有网络，只有主机可以访问vagrant的box.\n# 如果多个vagrant的box设定在同一个网段也可以互相访问．\ncfg.vm.network :private_network, ip: \u0026quot;192.168.50.10\u0026quot;\n\n# 公有网络，vagrant的box和主机使用一样的网络．\ncfg.vm.network :public_network\ncfg.vm.network :public_network, ip: \u0026quot;192.168.1.1\u0026quot;\n\ncfg.vm.synced_folder \u0026quot;/var/tmp/pkg-build\u0026quot;, \u0026quot;/var/tmp/pkg-build\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"打包\"\u003e打包\u003c/h1\u003e\n\u003cp\u003e用户可以打包自己的开发环境，然后分发出去．\u003c/p\u003e",
    "content": "Vagrant 构建在虚拟化技术之上的虚拟机运行环境管理工具．\n适合用来构建和分发开发环境．通过命令行可以批量自动化，不用一个一个安装配置图形界面的虚拟机．\nhttps://github.com/mitchellh/vagrant\n需要安装virtualbox或vmware等虚拟机.\nvagrant还支持其它的providers(docker, vmware, hyper-v, aws)\n可以在这里找到很多vagrant可用的box:\nhttps://atlas.hashicorp.com/boxes/search\n初始化 $ mkdir -p /home/user/vagrant $ cd /vagrant # 在当前目录生成一个Vagrantfile文件, 需手动添加vm.box $ vagrant init # 相当于直接添加了vm.box到Vagrantfile. $ vagrant init [box-name] 添加box # 默认从https://atlas.hashicorp.com/boxes/search下载该box. $ vagrant box add [[--name ]box-name] hashicorp/precise64 # 也可以使用下载到本地的box $ vagrant box add [[--name ]box-name] /path/to/your.box # 也可以使用自己的服务器上的box $ vagrant box add [[--name ]box-name] URL # 添加box之后修改Vagrantfile,添加vm.box: Vagrant.configure(\u0026quot;2\u0026quot;) do |config| config.vm.box = \u0026quot;[box-name]\u0026quot; end 使用box $ vagrant up [box-name] $ vagrant up --provider docker/aws/vmware/hyperv/... [box-name] $ vagrant ssh # 会进入一个vagrant@precise64:~$的环境． # /vagrant 是一个和/home/user/vagrant同步的路径． 结束使用 $ vagrant status # 查看box状态 $ vagrant halt # 关闭box $ vagrant reload # 重启box $ vagrant suspend $ vagrant resume $ vagrant provision # 会销毁box占用的所有资源，但不删除box. $ vagrant destroy 管理box $ vagrant box list $ vagrant box remove 其它 $ vagrant global-status $ vagrant global-status --prune 配置Vagrantfile config.vm.box_version = \u0026quot;1.1.0\u0026quot; cfg.vm.hostname = \u0026quot;ubuntu.labs\u0026quot; # 端口映射, 把主机的端口映射到vagrant的box # 访问主机的该端口就是访问vagrant的box cfg.vm.network :forward_port, guest: 80, host: 8080 # 私有网络，只有主机可以访问vagrant的box. # 如果多个vagrant的box设定在同一个网段也可以互相访问． cfg.vm.network :private_network, ip: \u0026quot;192.168.50.10\u0026quot; # 公有网络，vagrant的box和主机使用一样的网络． cfg.vm.network :public_network cfg.vm.network :public_network, ip: \u0026quot;192.168.1.1\u0026quot; cfg.vm.synced_folder \u0026quot;/var/tmp/pkg-build\u0026quot;, \u0026quot;/var/tmp/pkg-build\u0026quot; 打包 用户可以打包自己的开发环境，然后分发出去．\n$ vagrant package [options] [name] $ vagrant package windows 在windows物理机安装virtualbox和vagrant.\nwindows不支持ssh,所以需要类似于putty这种客户端．\nhost: 127.0.0.1 port: 2222 user: vagrant/root password: vagrant linux 只能在linux物理机安装virtualbox和vagrant使用．\n如果想在windows物理机里面的virtualbox上安装的linux系统中使用vagrant会报错：\n# default: Warning: Connection timeout. Retrying... 因为需要在linux上在安装virtualxo，然后不能设置加速．\nQ\u0026amp;A vagrant怎样打包ESXi上的虚拟机．\nvagrant能否打包cluster(virtualbox或esxi)\n",
    "categories": ["Virtualization"],
    "tags": ["vagrant"]
  },
  {
    "title": "Django Misc",
    "permalink": "https://canuxcheng.com/post/django_misc/",
    "date": "2017-01-04",
    "summary": "\u003ch1 id=\"django的国际化和本地化\"\u003eDjango的国际化和本地化\u003c/h1\u003e\n\u003cp\u003esettings.py里面和国际化和本地化相关的设置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUSE_I18N = True\nUSE_L10N = True\nTIME_ZONE = 'UTC'\nUSE_TZ = True\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"国际化i18n\"\u003e国际化(i18N)\u003c/h2\u003e\n\u003cp\u003e由开发者完成,本地化的准备工作.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.i18nguy.com/unicode/language-identifiers.html\"\u003ehttp://www.i18nguy.com/unicode/language-identifiers.html\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eLANGUAGE_CODE = 'en-us' # default\n\nLANGUAGES = [\n    ('en-US', _('English')),\n    ('zh-CN', _('Chinese')),\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"本地化l10n\"\u003e本地化(l10N)\u003c/h2\u003e\n\u003cp\u003e由翻译者完成.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"django的安全\"\u003eDjango的安全\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"django的性能优化\"\u003eDjango的性能优化\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.djangoproject.com/zh-hans/3.2/topics/performance/\"\u003ehttps://docs.djangoproject.com/zh-hans/3.2/topics/performance/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"django的地理框架\"\u003eDjango的地理框架\u003c/h1\u003e",
    "content": "Django的国际化和本地化 settings.py里面和国际化和本地化相关的设置:\nUSE_I18N = True USE_L10N = True TIME_ZONE = 'UTC' USE_TZ = True 国际化(i18N) 由开发者完成,本地化的准备工作.\nhttp://www.i18nguy.com/unicode/language-identifiers.html\nLANGUAGE_CODE = 'en-us' # default LANGUAGES = [ ('en-US', _('English')), ('zh-CN', _('Chinese')), ] 本地化(l10N) 由翻译者完成.\nDjango的安全 Django的性能优化 https://docs.djangoproject.com/zh-hans/3.2/topics/performance/\nDjango的地理框架 ",
    "categories": ["Django"],
    "tags": ["misc"]
  },
  {
    "title": "TSDB",
    "permalink": "https://canuxcheng.com/post/database/",
    "date": "2017-01-03",
    "summary": "\u003ch1 id=\"rdbms\"\u003eRDBMS\u003c/h1\u003e\n\u003cp\u003e关系数据库管理系统。\u003c/p\u003e\n\u003cp\u003eSQLite\u003c/p\u003e\n\u003cp\u003eOracle\u003c/p\u003e\n\u003cp\u003eMSSQL\u003c/p\u003e\n\u003cp\u003eMysql\u003c/p\u003e\n\u003cp\u003ePostgre\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"nosql\"\u003eNoSQL\u003c/h1\u003e\n\u003cp\u003eNoSQL: Not only SQL.\u003c/p\u003e\n\u003cp\u003e非关系型数据库。\u003c/p\u003e\n\u003cp\u003ememcached(cache)\u003c/p\u003e\n\u003cp\u003eredis(cache)\u003c/p\u003e\n\u003cp\u003emongodb\u003c/p\u003e\n\u003cp\u003ehbase(hadoop)\u003c/p\u003e\n\u003cp\u003ecassandra(hadoop)\u003c/p\u003e\n\u003cp\u003erethinkdb\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tsdb\"\u003eTSDB\u003c/h1\u003e\n\u003cp\u003eTime series database.\u003c/p\u003e\n\u003cp\u003e时序数据库\u003c/p\u003e\n\u003cp\u003einfluxdb\u003c/p\u003e\n\u003cp\u003errdtool\u003c/p\u003e\n\u003cp\u003egraphite\u003c/p\u003e\n\u003cp\u003eopentsdb\u003c/p\u003e\n\u003cp\u003epremetheus\u003c/p\u003e",
    "content": "RDBMS 关系数据库管理系统。\nSQLite\nOracle\nMSSQL\nMysql\nPostgre\nNoSQL NoSQL: Not only SQL.\n非关系型数据库。\nmemcached(cache)\nredis(cache)\nmongodb\nhbase(hadoop)\ncassandra(hadoop)\nrethinkdb\nTSDB Time series database.\n时序数据库\ninfluxdb\nrrdtool\ngraphite\nopentsdb\npremetheus\n",
    "categories": ["Database"],
    "tags": ["tsdb"]
  },
  {
    "title": "Awk",
    "permalink": "https://canuxcheng.com/post/shell_awk/",
    "date": "2016-12-14",
    "summary": "\u003ch1 id=\"awk\"\u003eawk\u003c/h1\u003e\n\u003cp\u003eawk 是一门编程语言\u003c/p\u003e\n\u003cp\u003eawk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。\u003c/p\u003e\n\u003cp\u003enawk： new awk。\u003c/p\u003e\n\u003cp\u003emawk： awk的解释器\u003c/p\u003e\n\u003cp\u003egawk是gnu的awk，功能更全面。\u003c/p\u003e\n\u003cp\u003eawk命令格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eawk [-v var=value [-F *] [–] '/pattern/ {action}'  file\nawk [-v var=value [-F *] [-f scriptfile ...] [–] file\nawk [-v var=value [-F *] [-] 'BEGIN {} /pattern/ {action} END {}'  file\nBEGIN { }  在读取输入之前就操作\nEND { }    在读物输入之后操作\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eawk的指令需要用单引号包围；\n模式需要用/pattern/包围；\n过程需要用{command1；command2}包围，多个过程需要用；隔开。\u003c/p\u003e\n\u003cp\u003e脚本中传递参数格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eawk [-f scriptfile]OR['/pattern/{action}'] val1=value1 val2=value2 … file1   vala=valuea valb=valueb... file2 ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果通过shell传参数，把value改成$n即可。\n可以通过命令返回值作为参数value。\n也可以使用环境变量作为value，也可以给awk的环境变量赋值。\n可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。\n只有在-v和在BEGIN中定义的变量能在BEGIN中使用。\n在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。\n在任何位置定义的变量在END中都可以使用。\u003c/p\u003e",
    "content": "awk awk 是一门编程语言\nawk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。\nnawk： new awk。\nmawk： awk的解释器\ngawk是gnu的awk，功能更全面。\nawk命令格式：\nawk [-v var=value [-F *] [–] '/pattern/ {action}' file awk [-v var=value [-F *] [-f scriptfile ...] [–] file awk [-v var=value [-F *] [-] 'BEGIN {} /pattern/ {action} END {}' file BEGIN { } 在读取输入之前就操作 END { } 在读物输入之后操作 awk的指令需要用单引号包围； 模式需要用/pattern/包围； 过程需要用{command1；command2}包围，多个过程需要用；隔开。\n脚本中传递参数格式：\nawk [-f scriptfile]OR['/pattern/{action}'] val1=value1 val2=value2 … file1 vala=valuea valb=valueb... file2 ... 如果通过shell传参数，把value改成$n即可。 可以通过命令返回值作为参数value。 也可以使用环境变量作为value，也可以给awk的环境变量赋值。 可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。 只有在-v和在BEGIN中定义的变量能在BEGIN中使用。 在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。 在任何位置定义的变量在END中都可以使用。\nOptions:\n-f: 指定运行脚本文件中的命令,可以指定多个脚本。 -F: 指定输入字段分隔符，默认是空格键和制表符。 -v $val=value 定义变量 awk中的由空格或制表符分隔的单元作为一个字段\n$0\t当前行的文本内容 $1\t第一个字段的文本内容 $n\t第n个字段的文本内容 awk中的常量和变量：\n常量：字符串型和数字型，字符串常量必须用“”引号引用。 变量：变量名大小写敏感，字母或下划线开头，可以包含数字。 awk会自动将变量根据环境初始化为空串或0. awk中的命令：\nprint命令： print a,b 参数用，隔开，打印出来的就是用空格隔开的,eg：a b. print a“string”b 参数中用双引号打印出来就是原样输出,eg:astringb. Print 打印匹配到的行 print “” 打印一个空行 printf命令：\n格式化输出，和c语言中的printf类似。\nprintf(format[,arguments]) format是用“”引起来的格式 arguments是一个可选的参数列表 %s:字符串 %d：十进制整数 %f：浮点格式，默认精度小数点后6位。 %%：打印% |%mX|:对于格式X按照默认的右对齐，精确到m位，左边补空格 |%-mX|：对于格式X按照左对齐，精确到m位，右边补空格 “%*.*g”， m， n， $val ： 动态指定精度，总共m位，小数点后n位。 \\t：跳格 \\n：换行 next命令：\n取得下一条记录\ndelete命令：\n删除\nexit命令：\n退出输入记录的处理，进入END。 exit n 设置awk的退出状态。\nawk中的内置的变量：\nFS 定义输入记录字段分隔符，默认是空格 OFS 输出记录字段分隔符，默认是空格 NF\t当前输入记录的字段个数（列号） RS 输入记录分隔符，默认是换行符 ORS 输出记录分隔符，默认是换行符 NR\t读入的输入记录的个数(行号） FILENAME 当前输入文件的名字 CONVFMT 控制类型转换，默认为%.6g 在BEGIN{}中可以给变量赋值；在{}中用$来引用这些变量；在END{}中可以打印这些变量。\n运算符：\n算数操作符： + - * / % ^ 赋值操作符： ++ –- += -= *= /= %= ^= 关系操作符： \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= ==(注意和赋值=的区别） != ~（匹配） !~（不匹配） 布尔操作符： \u0026amp;\u0026amp; 逻辑与，优先级高于|| || 逻辑或 ！ 逻辑非 awk内置的语句：\n和c语言相似\n条件语句：\nif (expression) action1 [else if (expression2) { action2 action3 ... }] 多个动作需要用{}包围 [else if () {action1;action2;...}] 多个动作写在一行需要用；隔开。 [else if () action ; else action] 在同一行用；结束一个语句 也可以用条件运算符代替条件语句：\nexpression ? Action1 : action2 循环语句：\nwhile (condition) action while (condition) { action1 action2 … } while (condition) { action1 ; action2 ; … } do action while (condition) do { action1 action2 … } while (condition) do { action1;action2;...} while (condition) for (set_counter; test_counter; increment_counter) action break:\n退出循环\ncontinue：\n终止本次循环，进入下一次循环\n数组：\narray[subscript] = value awk中的数组直接给数组元素赋值，不用指定数组大小。通过下标访问。 关联数组：\nawk中的数组是关联数组，也就是可以用数值和字符作为下标来访问。\nin操作符用来测试variable是否是数组array的下标，如果是条件为真。\nfor (variable in array) print variable: array[variable] if (variable in array) print variable: array[variable] 删除数组元素：\ndelete array[subscript] 系统变量的数组：\nARGV： 命令行参数数组，下标从0开始，不包括awk脚本本身和任何调用awk脚本指定的选项。 akw -f awk.sh … #不包括-f和awk.sh ENVIRON：\n环境变量数组，下标是环境变量的名字，元素是环境变量的值。\nawk内置的函数：\n函数分为算数函数和字符串函数。\n算数函数有9个：\nsin(x)：返回x的正弦 cos(x)：返回x的余弦 atan2(y,x)：返回y/x的反正切 exp(x)：返回e的x次幂 log(x)：返回以e为底的x的自然对数 sqrt(x)：返回x的平方根 int(x)：返回x的整数部分 rand()：返回伪随机数r，0=\u0026lt; r \u0026lt;1 srand(x)：建立rand（）的新的种子数 字符串函数：\ngsub(r,s,t) 在字符串t中用s替换和正则表达式r匹配的所有字符串，返回替换的个数。 gsub(r,s) 相当于t=$0 sub(r,s,t)用s替换正则表达式在t中的首次匹配。成功返回1，失败返回0. sub(r,s)相当于t=$0 substr(s,p)返回s中从位置p开始的子串 substr(s,p,n)返回s中从位置p开始最大长度为n的子串。 index(s,t)返回子串t在s中的位置，如果没有指定s或没有匹配项返回0.也就是返回t中的首字母在s中是第几个字符，如果首字母重复出现返回第一个的位置。 length(s) 返回字符串s长度，没有指定s返回$0的长度，\\n \\t \\r 空格都算一个字节。 match(s,r)如果正则表达式r在s中出现，返回出现的起始位置，没有匹配返回0. split(string, array, separator) 将字符串string分解到数组array中，数组下标从1到n，string根据指定的分隔符来分解，如果没有指定分隔符，默认为FS。返回数组中元素个数。 sprintf(“format”, expr)和printf一样。 tolower(s)将s中的所有大写字母转换成小写并返回新的字符串 toupper(s)将s中的左右小写字母转换成大写并返回新的字符串 其它函数：\ngetline命令（其实是个函数）： 获取下一条记录给$0,成功返回1，到达EOF返回0，失败返回-1. getline可以从文件中读取：getline \u0026lt; “filename”,每次读一行。 getline从标准输入读取：getline \u0026lt; “-”,每次从stdin读取一行。 将输入赋给一个变量：getline var_name. 从管道读取：”command”|getline；“command”|getline var_name;把一个命令结果输出给getline. close()：关闭打开的文件和管道 “command” | ... close(“command”)关闭输入管道 ...| “command“ \u0026gt; filename close(“command \u0026gt; filename”)关闭输出管道 system()：执行一个命令。 system(“command options”),返回命令的退出状态。 可以定义自己的函数：\nfunction yourfunctionname(parameter-list) { statements } 可以使用系统定义的变量、语句、函数来定义自己的函数。 使用自己定义的函数可以将函数写成一个单独脚本，使用-f选项来指定多个脚本进行调用。\n常用命令 删除字符串前后空格:\necho \u0026quot;string\u0026quot; |　awk \u0026quot;$1=$1\u0026quot; ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Wordpress",
    "permalink": "https://canuxcheng.com/post/wordpress/",
    "date": "2016-11-18",
    "summary": "\u003ch1 id=\"wordpress\"\u003eWordPress\u003c/h1\u003e\n\u003ch1 id=\"安装\"\u003e安装\u003c/h1\u003e\n\u003cp\u003e安装依赖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$sudo apt install apache2\n$sudo apt install mysql-server\n$sudo apt install php5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下载wordpress：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$cd /var/www/html\n$git clone https://github.com/WordPress/WordPress.git\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"配置\"\u003e配置\u003c/h1\u003e\n\u003cp\u003e添加mysql数据库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$mysql -u root -p\nmysql\u0026gt; create user 'wordpress'@'localhost' identified by '******';\nmysql\u0026gt; create database 'wordpress';\nmysql\u0026gt; GRANT ALL PRIVILEGES ON wordpress.* TO \u0026quot;wordpress\u0026quot;@\u0026quot;localhost\u0026quot;;\nmysql\u0026gt; FLUSH PRIVILEGES;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e编辑配置文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewp-config.php\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e登陆并安装站点：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://localhost\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e管理界面：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://localhost/wp-admin\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"语言\"\u003e语言\u003c/h1\u003e\n\u003cp\u003e下载相应的语言版本,中文下载中文版的wordpress.\u003c/p\u003e\n\u003cp\u003e然后将wordpress/wp-content/languages拷贝到英文版的wordpress/wp-content下\u003c/p\u003e\n\u003cp\u003e语言包路径:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewordpress/wp-content/languages\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"主题\"\u003e主题\u003c/h1\u003e\n\u003cp\u003e修改wp-config.php安装主题不用输入ftp信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edefine(\u0026quot;FS_METHOD\u0026quot;, \u0026quot;direct\u0026quot;);\ndefine(\u0026quot;FS_CHMOD_DIR\u0026quot;, 0777);\ndefine(\u0026quot;FS_CHMOD_FILE\u0026quot;, 0777);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e主题安装在：\u003c/p\u003e",
    "content": "WordPress 安装 安装依赖：\n$sudo apt install apache2 $sudo apt install mysql-server $sudo apt install php5 下载wordpress：\n$cd /var/www/html $git clone https://github.com/WordPress/WordPress.git 配置 添加mysql数据库：\n$mysql -u root -p mysql\u0026gt; create user 'wordpress'@'localhost' identified by '******'; mysql\u0026gt; create database 'wordpress'; mysql\u0026gt; GRANT ALL PRIVILEGES ON wordpress.* TO \u0026quot;wordpress\u0026quot;@\u0026quot;localhost\u0026quot;; mysql\u0026gt; FLUSH PRIVILEGES; 编辑配置文件：\nwp-config.php 登陆并安装站点：\nhttp://localhost 管理界面：\nhttp://localhost/wp-admin 语言 下载相应的语言版本,中文下载中文版的wordpress.\n然后将wordpress/wp-content/languages拷贝到英文版的wordpress/wp-content下\n语言包路径:\nwordpress/wp-content/languages 主题 修改wp-config.php安装主题不用输入ftp信息：\ndefine(\u0026quot;FS_METHOD\u0026quot;, \u0026quot;direct\u0026quot;); define(\u0026quot;FS_CHMOD_DIR\u0026quot;, 0777); define(\u0026quot;FS_CHMOD_FILE\u0026quot;, 0777); 主题安装在：\nwordpress/wp-content/themes 主题数据导入到:\nwordpress/wp-content/uploads 插件 插件安装在：\nwordpress/wp-content/plugins WordPress Reset 一款可以重置所有数据库数据的插件。\nwidget-settings-importexport wordpress-importer wordpress-move 设置 默认的固定连接:\n/index.php/%year%/%monthnum%/%day%/%postname%/ 主题开发 插件开发 ",
    "categories": ["Web"],
    "tags": ["wordpress"]
  },
  {
    "title": "Html Form",
    "permalink": "https://canuxcheng.com/post/html_form/",
    "date": "2016-10-31",
    "summary": "\u003ch1 id=\"html表单\"\u003ehtml表单\u003c/h1\u003e\n\u003cp\u003ehtml表单用于搜集不同类型的用户输入。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"form\"\u003e\u003cstrong\u003eform\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eform元素定义html表单。支持全局属性和事件属性。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;form action=\u0026quot;action_page.py\u0026quot;\u0026gt;\n\u0026lt;fieldset\u0026gt;\n\u0026lt;legend\u0026gt;Form information:\u0026lt;/legend\u0026gt;\nFirst name:\u0026lt;br\u0026gt;\n\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;firstname\u0026quot;\u0026gt;\n\u0026lt;br\u0026gt;\nLast name:\u0026lt;br\u0026gt;\n\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;lastname\u0026quot;\u0026gt;\n\u0026lt;/fieldset\u0026gt;\n\u0026lt;/form\u0026gt;\n\n# accept-charset属性规定服务器可处理的表单数据字符集。\n\n# action属性规定当提交表单时向何处发送表单数据。\n\u0026lt;form action=\u0026quot;action_page.py\u0026quot;\u0026gt;\n\n# autocomplete属性规定是否启用表单的自动完成功能\non/off\n\n# enctype属性规定在发送表单数据之前如何编码\napplication/x-www-form-urlencoded, 默认值，表示在发送前编码所有值．\nmultipart/form-data, 不编码，在使用包含文件上传控件的表单必须使用．\ntext/plain, 空格转换为\u0026quot;+\u0026quot;加号，不对特殊字符编码．\n\n# method属性规定用于发送form-data的http方法\nget/post\n\n# name属性规定表单名称\n# novalidate属性规定提交表单时不验证\n\n# target属性规定在何处打开URL。\n_blank/_self/_parent/_top\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"input\"\u003e\u003cstrong\u003einput\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003einput元素是最重要的表单元素。支持全局属性和事件属性。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# type属性规定输入元素类型\nbutton\ncheckbox\nfile\nhidden\nimage\npassword\nradio\nreset\nsubmit\ntext\n\n# name属性定义input元素名称\n# value属性定义input元素默认值\nreadonly\ndisabled\nsize\nmaxlength\nalt\naccept\nchecked\nsrc\n\nautocomplete\nautofocus\nform\nformaction\nformenctype\nformmethod\nformnovalidate\nformtarget\nheight\nwidth\nlist\nmax\nmin\nmultiple\npattern\nplaceholder\nrequired\nstep\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"fieldset\"\u003e\u003cstrong\u003efieldset\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003efieldset元素组合表单中的相关数据，支持全局属性和事件属性\u003c/p\u003e",
    "content": "html表单 html表单用于搜集不同类型的用户输入。\nform form元素定义html表单。支持全局属性和事件属性。\n\u0026lt;form action=\u0026quot;action_page.py\u0026quot;\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;Form information:\u0026lt;/legend\u0026gt; First name:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;firstname\u0026quot;\u0026gt; \u0026lt;br\u0026gt; Last name:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;lastname\u0026quot;\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; # accept-charset属性规定服务器可处理的表单数据字符集。 # action属性规定当提交表单时向何处发送表单数据。 \u0026lt;form action=\u0026quot;action_page.py\u0026quot;\u0026gt; # autocomplete属性规定是否启用表单的自动完成功能 on/off # enctype属性规定在发送表单数据之前如何编码 application/x-www-form-urlencoded, 默认值，表示在发送前编码所有值． multipart/form-data, 不编码，在使用包含文件上传控件的表单必须使用． text/plain, 空格转换为\u0026quot;+\u0026quot;加号，不对特殊字符编码． # method属性规定用于发送form-data的http方法 get/post # name属性规定表单名称 # novalidate属性规定提交表单时不验证 # target属性规定在何处打开URL。 _blank/_self/_parent/_top input input元素是最重要的表单元素。支持全局属性和事件属性。\n# type属性规定输入元素类型 button checkbox file hidden image password radio reset submit text # name属性定义input元素名称 # value属性定义input元素默认值 readonly disabled size maxlength alt accept checked src autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height width list max min multiple pattern placeholder required step fieldset fieldset元素组合表单中的相关数据，支持全局属性和事件属性\n# disable属性规定应该禁用fieldset # form属性规定fieldset所属的一个或多个表单。 # name属性规定fieldset名称。 legend legend元素为fieldset元素定义标题，支持全局属性和事件属性,支持样式。\nselect 定义下拉列表。支持全局属性和事件属性。\n\u0026lt;form action=\u0026quot;action_page.py\u0026quot;\u0026gt; \u0026lt;select name=\u0026quot;cars\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;volvo\u0026quot;\u0026gt;volvo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026quot;audi\u0026quot;\u0026gt;audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/form\u0026gt; # autofocus属性规定在页面加载后文本区域自动获得焦点 # disable # form # multiple # name # required # size optgroup option 定义选项。支持全局属性和事件属性。\n# disabled # label # selected # value label button 定义可点击的按钮，支持全局属性和事件属性。\n\u0026lt;button type=\u0026quot;button\u0026quot; onclick=\u0026quot;alert(\u0026quot;hello world\u0026quot;)\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; # name属性规定按钮名称 # type属性规定按钮类型 # value属性规定按钮初始值 # autofocus # disabled # form # formaction # formenctype # formmethod # formnovalidate # formtarget textarea datalist keygen output ",
    "categories": ["Web"],
    "tags": ["html"]
  },
  {
    "title": "Bootstrap",
    "permalink": "https://canuxcheng.com/post/js_bootstrap/",
    "date": "2016-10-27",
    "summary": "\u003ch1 id=\"bootstrap\"\u003eBootstrap\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/twbs/bootstrap\"\u003ehttps://github.com/twbs/bootstrap\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.bootcss.com/\"\u003ehttps://www.bootcss.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003einstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm install bootstrap@next\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTML,CSS,JavaScript的支持响应式和移动设备的WEB框架.\u003c/p\u003e",
    "content": "Bootstrap https://github.com/twbs/bootstrap\nhttps://www.bootcss.com/\ninstall:\n$ npm install bootstrap@next HTML,CSS,JavaScript的支持响应式和移动设备的WEB框架.\n",
    "categories": ["Web"],
    "tags": ["bootstrap"]
  },
  {
    "title": "jQuery",
    "permalink": "https://canuxcheng.com/post/js_jquery/",
    "date": "2016-10-27",
    "summary": "\u003ch1 id=\"jquery\"\u003ejQuery\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jquery/jquery\"\u003ehttps://github.com/jquery/jquery\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.jquery123.com/\"\u003ehttps://www.jquery123.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ejquery是一个js库，简化了js编程。\u003c/p\u003e\n\u003cp\u003einstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm install jqury\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejquery功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTML 元素选取\u003c/li\u003e\n\u003cli\u003eHTML 元素操作\u003c/li\u003e\n\u003cli\u003eHTML 事件函数\u003c/li\u003e\n\u003cli\u003eHTML DOM 遍历和修改\u003c/li\u003e\n\u003cli\u003eCSS 操作\u003c/li\u003e\n\u003cli\u003eJavaScript 特效和动画\u003c/li\u003e\n\u003cli\u003eAJAX\u003c/li\u003e\n\u003cli\u003eUtilities\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"syntax\"\u003esyntax\u003c/h1\u003e\n\u003cp\u003e对元素操作语法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$(selector).action()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文档就绪函数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$(document).ready(function(){\n    ......\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehead中:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;head\u0026gt;\n\u0026lt;script type=\u0026quot;text/javascript\u0026gt;\n$(document).ready(function(){\n    $(\u0026quot;button\u0026quot;).click(function(){\n        $(\u0026quot;p\u0026quot;).hide();\n    })\n})\n\u0026lt;/script\u0026gt;\n\u0026lt;/head\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e独立js文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;head\u0026gt;\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/path/to/my.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n\u0026lt;/head\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"选择器\"\u003e选择器\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://api.jquery.com/category/selectors/\"\u003ehttps://api.jquery.com/category/selectors/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$(this).hide()   this表示当前html元素\n$(\u0026quot;p.test\u0026quot;)    class=\u0026quot;test\u0026quot;的\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;元素\n$(\u0026quot;p#test\u0026quot;)    id=\u0026quot;test\u0026quot;的\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;元素\n$(\u0026quot;div#test .demo\u0026quot;)  id=\u0026quot;test\u0026quot;的\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;中class=demo的元素\n$(\u0026quot;ul li:first\u0026quot;)  每个\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;的第一个\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eelement选择器：\u003c/p\u003e",
    "content": "jQuery https://github.com/jquery/jquery\nhttps://www.jquery123.com/\njquery是一个js库，简化了js编程。\ninstall:\n$ npm install jqury jquery功能：\nHTML 元素选取 HTML 元素操作 HTML 事件函数 HTML DOM 遍历和修改 CSS 操作 JavaScript 特效和动画 AJAX Utilities syntax 对元素操作语法：\n$(selector).action() 文档就绪函数:\n$(document).ready(function(){ ...... }) head中:\n\u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026gt; $(document).ready(function(){ $(\u0026quot;button\u0026quot;).click(function(){ $(\u0026quot;p\u0026quot;).hide(); }) }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; 独立js文件\n\u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/path/to/my.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; 选择器 https://api.jquery.com/category/selectors/\n$(this).hide() this表示当前html元素 $(\u0026quot;p.test\u0026quot;) class=\u0026quot;test\u0026quot;的\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;元素 $(\u0026quot;p#test\u0026quot;) id=\u0026quot;test\u0026quot;的\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;元素 $(\u0026quot;div#test .demo\u0026quot;) id=\u0026quot;test\u0026quot;的\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;中class=demo的元素 $(\u0026quot;ul li:first\u0026quot;) 每个\u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt;的第一个\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; element选择器：\n$(\u0026quot;p\u0026quot;).hide() 元素\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; id选择器:\n$(\u0026quot;#test\u0026quot;).hide() id=\u0026quot;test\u0026quot; class选择器:\n$(\u0026quot;.test\u0026quot;).hide() class=\u0026quot;test\u0026quot; attribute选择器:\n$(\u0026quot;[href]\u0026quot;) 所有带href属性的元素 $(\u0026quot;[href='value']\u0026quot;) 带有href属性且值等于value的元素 $(\u0026quot;[href!='value']\u0026quot;) 带有href元素且值不等于value的元素 $(\u0026quot;[href$='.jpg']\u0026quot;) 带有href属性且值以.jpg结尾的元素 子元素选择器/child:\n后代选择器/descendant:\nEvent/事件 https://api.jquery.com/category/events/\n$(selector).click(function) 单击事件 $(selector).dblclick(function) 双击事件 $(selector).focus(function) 焦点事件 $(selector).mouseover(function) 鼠标悬停事件 Effects/效果 basic .hide() .show() .toggle() custom .animate() .stop() fading .fadeIn() .fadeOut() .fadeTo() .fadeToggle() sliding .slideDown() .slideToggle() .slideUp() core 核心功能\njQuery() jQuery.noConflict() 使用其它代替$\n\u0026lt;script type=\u0026quot;text/javascript\u0026gt; $.noConflict(); // 兼容其它库也是用$ my(document).ready(function(){ my(\u0026quot;button\u0026quot;).click(function(){ my(\u0026quot;p\u0026quot;).hide(); }) }) \u0026lt;/script\u0026gt; jQuery.ready 文档操作 属性操作 CSS操作 jquey css选择器改变元素的css属性:\n.css() // 修改\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;元素的背景色 $(\u0026quot;p\u0026quot;).css(\u0026quot;background-color\u0026quot;,\u0026quot;red\u0026quot;); .addClass() .hasClass() Attributes .attr() .addClass() .hasClass() .html() .val() Data .data() .clearQueue() .dequeue() .queue() .removeData() Ajax ",
    "categories": ["Web"],
    "tags": ["jquery"]
  },
  {
    "title": "Test",
    "permalink": "https://canuxcheng.com/post/django_test/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"testspy\"\u003etests.py\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/\"\u003ehttps://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/\"\u003ehttps://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e单个测试文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evim app/tests.py\nfrom django.test import TestCase\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多个测试文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emkdir -p app/tests\nvi test_case1.py\nvi test_case2.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"配置和运行\"\u003e配置和运行\u003c/h1\u003e\n\u003cp\u003e默认情况下运行 manage.py test 会创建测试数据库运行testcase，完成后自动销毁测试数据库.\u003c/p\u003e\n\u003cp\u003e测试相关配置\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evim project/settings.py\n\nDATABASES = {\n    'default': {\n        'NAME': 'mydb',\n        'TEST': {\n            // 默认测试数据库是'NAME'前加'test_' (eg: 'test_mydb')\n            // 可以通过TEST.NAME指定测试数据库\n            'NAME': 'mytestdb'\n        }\n    }\n}\n\n# 指定runner\n## 默认 django.test.runner.DiscoverRunner\nTEST_RUNNER = 'site_main.base_tests.TestRunner\n\n# 指定fixture文件路径\nFIXTURE_DIRS = (os.path.join(BASE_DIR, 'app', 'fixtures'), )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行测试程序：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ python3 manage.py test // 查找test 开头的文件运行里面的 unittest.TestCase的子类.\n$ python3 manage.py test \u0026lt;package\u0026gt; // 运行指️定应用内的测试\n$ python3 manage.py test \u0026lt;module\u0026gt; // 运行指定模块内的测试\n$ python3 manage.py test \u0026lt;module\u0026gt;.tests.MyTestCase // 运行一个指定的testcase\n$ python3 manage.py test \u0026lt;module\u0026gt;.tests.MyTestCase.test_method // 运行一个指定的test method\n\n--keepdb // 保留测试数据库\n--parallel // 并行运行测试。\n-v/--verbosity 0/1/2/3  测试输出信息级别，默认为1， 0表示不输出。\n-d/--debug-sql 输出测试执行的sql语句.\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"client\"\u003eClient\u003c/h1\u003e\n\u003cp\u003e测试客户端是一个 Python 类，它充当一个虚拟的 Web 浏览器，\n允许你测试视图并以编程方式与 Django 驱动的应用程序交互。\u003c/p\u003e",
    "content": "tests.py https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/\nhttps://docs.djangoproject.com/zh-hans/3.1/topics/testing/advanced/\n单个测试文件\nvim app/tests.py from django.test import TestCase 多个测试文件\nmkdir -p app/tests vi test_case1.py vi test_case2.py 配置和运行 默认情况下运行 manage.py test 会创建测试数据库运行testcase，完成后自动销毁测试数据库.\n测试相关配置\nvim project/settings.py DATABASES = { 'default': { 'NAME': 'mydb', 'TEST': { // 默认测试数据库是'NAME'前加'test_' (eg: 'test_mydb') // 可以通过TEST.NAME指定测试数据库 'NAME': 'mytestdb' } } } # 指定runner ## 默认 django.test.runner.DiscoverRunner TEST_RUNNER = 'site_main.base_tests.TestRunner # 指定fixture文件路径 FIXTURE_DIRS = (os.path.join(BASE_DIR, 'app', 'fixtures'), ) 运行测试程序：\n$ python3 manage.py test // 查找test 开头的文件运行里面的 unittest.TestCase的子类. $ python3 manage.py test \u0026lt;package\u0026gt; // 运行指️定应用内的测试 $ python3 manage.py test \u0026lt;module\u0026gt; // 运行指定模块内的测试 $ python3 manage.py test \u0026lt;module\u0026gt;.tests.MyTestCase // 运行一个指定的testcase $ python3 manage.py test \u0026lt;module\u0026gt;.tests.MyTestCase.test_method // 运行一个指定的test method --keepdb // 保留测试数据库 --parallel // 并行运行测试。 -v/--verbosity 0/1/2/3 测试输出信息级别，默认为1， 0表示不输出。 -d/--debug-sql 输出测试执行的sql语句. Client 测试客户端是一个 Python 类，它充当一个虚拟的 Web 浏览器， 允许你测试视图并以编程方式与 Django 驱动的应用程序交互。\nfrom django.test import Client 测试Class SimpleTestCase SimpleTestCase继承自unittest.TestCase.\nTransactionTestCase TransactionTestCase继承自SimpleTestCase.\nLiveServerTestCase LiveServerTestCase继承自TransactionTestCase.\nLiveServerTestCase 和 TransactionTestCase` 的功能基本相同， 但多了一个功能：它在设置时在后台启动一个实时的 Django 服务器，并在关闭时将其关闭。 这就允许使用 Django 虚拟客户端 以外的自动化测试客户端， 例如，Selenium 客户端，在浏览器内执行一系列功能测试，并模拟真实用户的操作。\nTestCase TestCase继承自TransactionTestCase.\nfixtures fixtures是类属性, 可以通过模拟在数据库中插入数据进行测试.\n在setUp的时候会插入fixtures指定的json文件中的数据。\n在tearDown的时候会销毁数据。\n# 导出数据为json格式，用于单元测试 $ python3 manage.py dumpdata \u0026gt; test_data.json databases databases是类属性\n",
    "categories": ["Django"],
    "tags": ["test"]
  },
  {
    "title": "Form",
    "permalink": "https://canuxcheng.com/post/django_form/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"formspy\"\u003eforms.py\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003efrom django import forms\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"表单\"\u003e表单\u003c/h1\u003e\n\u003cp\u003e用户在浏览器中输入数据提交，对数据验证以及输入框的生成等。\u003c/p\u003e\n\u003cp\u003edjango的表单系统的核心类是django.forms.Form类,所有的构建的表单都是这个类的子类。\u003c/p\u003e",
    "content": "forms.py from django import forms 表单 用户在浏览器中输入数据提交，对数据验证以及输入框的生成等。\ndjango的表单系统的核心类是django.forms.Form类,所有的构建的表单都是这个类的子类。\n",
    "categories": ["Django"],
    "tags": ["form"]
  },
  {
    "title": "Admin",
    "permalink": "https://canuxcheng.com/post/django_admin/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"adminpy\"\u003eadmin.py\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.contrib import admin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建一个管理员用户：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ python manage.py createsuperuser\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e管理员登陆界面：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://localhost:8000/admin/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在admin.py中注册模型，然后就可以在登陆界面管理模型了\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom .models import Question\nadmin.site.register(Question)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e自定义管理表单：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom .models import Question\nclass QuestionAdmin(admin.ModelAdmin):\n    fileds = ['pub_date', 'question_date']\nadmin.site.register(Question, QuestionAdmin)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e把表单分割成字段集：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom .models import Question\nclass QuestionAdmin(admin.ModelAdmin):\n    fieldsets = [\n        (None,               {'fields': ['question_text']}),\n        ('Date information', {'fields': ['pub_date']}),\n    ]\nadmin.site.register(Question, QuestionAdmin)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"后台\"\u003e后台\u003c/h1\u003e\n\u003cp\u003edjango的后台管理程序。\u003c/p\u003e",
    "content": "admin.py from django.contrib import admin 创建一个管理员用户：\n$ python manage.py createsuperuser 管理员登陆界面：\nhttp://localhost:8000/admin/ 在admin.py中注册模型，然后就可以在登陆界面管理模型了\nfrom .models import Question admin.site.register(Question) 自定义管理表单：\nfrom .models import Question class QuestionAdmin(admin.ModelAdmin): fileds = ['pub_date', 'question_date'] admin.site.register(Question, QuestionAdmin) 把表单分割成字段集：\nfrom .models import Question class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, {'fields': ['question_text']}), ('Date information', {'fields': ['pub_date']}), ] admin.site.register(Question, QuestionAdmin) 后台 django的后台管理程序。\n",
    "categories": ["Django"],
    "tags": ["admin"]
  },
  {
    "title": "URL",
    "permalink": "https://canuxcheng.com/post/django_url/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"urlspy\"\u003eurls.py\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.urls import path, include\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edjango请求站点的方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eROOT_URLCONF，在settings.py中设置。\u003c/li\u003e\n\u003cli\u003e寻找urlpatterns，它是django.conf.urls.url()实例的一个python列表。\u003c/li\u003e\n\u003cli\u003ednango依次匹配每个URL模式，在第一个匹配停下。\u003c/li\u003e\n\u003cli\u003e一旦一个正则表达式匹配，django就调用对应的视图，视图获得HttpRequest实例,如果是没有命名的组返回内容作为位置参数，如果是命名的组返回内容作为关键字参数。\u003c/li\u003e\n\u003cli\u003e如果没有匹配到或者过程跑出异常，django调用合适的错误处理。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"项目的url\"\u003e项目的URL\u003c/h1\u003e\n\u003cp\u003e项目的URL主要用来包含应用的URL以及全局的URL:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    # 默认的项目的admin的url\n    path('admin/', admin.site.urls),\n    \n    # 在项目URL添加链接到应用URL：\n    # 在下面添加你的所有应用的url,\n    path('polls/', include('polls.urls')),\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"应用的url\"\u003e应用的URL\u003c/h1\u003e\n\u003cp\u003e将应用的视图映射到URL,需要在应用目录新建urls.py文件,然后在项目的url中包含应用的url。\u003c/p\u003e\n\u003cp\u003eurlpatterns是url()实例类型的python列表。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.urls import path\nfrom . import views\n\napp_name = 'polls'\n\nurlpatterns = [\n    # 普通视图\n    path('', views.index, name='index'),\n    # 类视图\n    path('', views.IndexView.as_view(), name='index'),\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"没有命名的组\"\u003e没有命名的组\u003c/h1\u003e\n\u003cp\u003e视图函数只有request参数，匹配的正则表达式作为位置参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eurl(r'^pattern1/pattern2/$', views.index, name='index'),\n\ndef index(request):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"命名组\"\u003e命名组\u003c/h1\u003e\n\u003cp\u003e视图函数除了request参数还有关键字参数，匹配的命名表达式组作为关键字参数,覆盖默认的关键字参数。\u003c/p\u003e",
    "content": "urls.py from django.urls import path, include django请求站点的方法：\nROOT_URLCONF，在settings.py中设置。 寻找urlpatterns，它是django.conf.urls.url()实例的一个python列表。 dnango依次匹配每个URL模式，在第一个匹配停下。 一旦一个正则表达式匹配，django就调用对应的视图，视图获得HttpRequest实例,如果是没有命名的组返回内容作为位置参数，如果是命名的组返回内容作为关键字参数。 如果没有匹配到或者过程跑出异常，django调用合适的错误处理。 项目的URL 项目的URL主要用来包含应用的URL以及全局的URL:\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ # 默认的项目的admin的url path('admin/', admin.site.urls), # 在项目URL添加链接到应用URL： # 在下面添加你的所有应用的url, path('polls/', include('polls.urls')), ] 应用的URL 将应用的视图映射到URL,需要在应用目录新建urls.py文件,然后在项目的url中包含应用的url。\nurlpatterns是url()实例类型的python列表。\nfrom django.urls import path from . import views app_name = 'polls' urlpatterns = [ # 普通视图 path('', views.index, name='index'), # 类视图 path('', views.IndexView.as_view(), name='index'), ] 没有命名的组 视图函数只有request参数，匹配的正则表达式作为位置参数。\nurl(r'^pattern1/pattern2/$', views.index, name='index'), def index(request): ... 命名组 视图函数除了request参数还有关键字参数，匹配的命名表达式组作为关键字参数,覆盖默认的关键字参数。\n使用命名的正则表达式组： (?Ppattern)\nname就是关键字参数。\nurl(r'^pattern1/(?P\u0026lt;name\u0026gt;pattern)/pattern2/$), views.index, name='index), def index(request, name): ... 错误处理 django会调用一个错误处理视图处理异常。\nhandler404 页面没找到 handler500 服务器错误 handler403 权限被拒绝 handler400 无效的请求 你也可以在项目的urls.py中重新定义这些默认视图：\nhandler404 = 'mysite.views.your_custom_page_not_found_view' handler500 = 'mysite.views.your_custom_error_view' handler403 = 'mysite.views.your_custom_permission_denied_view' handler400 = 'mysite.views.your_custom_bad_request_view' ",
    "categories": ["Django"],
    "tags": ["url"]
  },
  {
    "title": "View",
    "permalink": "https://canuxcheng.com/post/django_view/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"viewspy\"\u003eviews.py\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.shortcuts import render\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e定义自己的视图函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.http import HttpResponse\nfrom django.template import RequestContext, loader\n\n# 导入模板中的类\nfrom .models import Question\n\ndef index(request):\n    ...\n    t = loader.get_template('application/index.html')\n    c = RequestContext(request, {'foo': 'bar'})\n    return HttpResponse(t.render(c), content_type=\u0026quot;text/html\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当请求一个页面时django会建立一个包含请求元数据的HttpRequest对象，当django加载对应视图时，这个对象作为视图第一个参数。\u003c/p\u003e\n\u003cp\u003e每个视图会返回一个HttpResponse对象。\u003c/p\u003e\n\u003cp\u003e每个视图函数都用HttpRequest对象（通常用request）作为第一个参数。\u003c/p\u003e\n\u003cp\u003e每个视图函数都返回一个HttpResponse对象，包含生成的响应。\u003c/p\u003e\n\u003cp\u003eHttpRquest和HttpResponse在django.http包中，参考：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://python.usyiyi.cn/documents/django_182/ref/request-response.html\"\u003ehttp://python.usyiyi.cn/documents/django_182/ref/request-response.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHttpRequest对象属性：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erequest.scheme # http/https\nrequest.body\nrequest.path\nrequest.path_info\nrequest.method # GET/POST\nrequest.encoding\nrequest.user\nrequest.session\nrequest.urlconf\nrequest.GET\nrequest.POST\nrequest.REQUEST\nrequest.COOKIES\nrequest.FILES\nrequest.META\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHttpRequest对象方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erequest.get_host()\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHttpResponse对象属性：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eresponse.content\nresponse.charset\nresponse.status_code\nresponse.reason_phrase\nresponse.streaming\nresponse.closed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHttpResponse对象的方法：\u003c/p\u003e",
    "content": "views.py from django.shortcuts import render 定义自己的视图函数：\nfrom django.http import HttpResponse from django.template import RequestContext, loader # 导入模板中的类 from .models import Question def index(request): ... t = loader.get_template('application/index.html') c = RequestContext(request, {'foo': 'bar'}) return HttpResponse(t.render(c), content_type=\u0026quot;text/html\u0026quot;) 当请求一个页面时django会建立一个包含请求元数据的HttpRequest对象，当django加载对应视图时，这个对象作为视图第一个参数。\n每个视图会返回一个HttpResponse对象。\n每个视图函数都用HttpRequest对象（通常用request）作为第一个参数。\n每个视图函数都返回一个HttpResponse对象，包含生成的响应。\nHttpRquest和HttpResponse在django.http包中，参考：\nhttp://python.usyiyi.cn/documents/django_182/ref/request-response.html\nHttpRequest对象属性：\nrequest.scheme # http/https request.body request.path request.path_info request.method # GET/POST request.encoding request.user request.session request.urlconf request.GET request.POST request.REQUEST request.COOKIES request.FILES request.META HttpRequest对象方法：\nrequest.get_host() ... HttpResponse对象属性：\nresponse.content response.charset response.status_code response.reason_phrase response.streaming response.closed HttpResponse对象的方法：\nresponse.getvalue() ... 返回错误：\nHttpResponse的子类提供了对不同类型HTTP响应。\nfrom django.http import HttpResponseBadRequest, HttpResponseNotFound, HttpResponseForbidden, HttpResponseServerError, return HttpResponseNotFound(\u0026quot;\u0026lt;h1\u0026gt;Page not found\u0026lt;/h1\u0026gt;\u0026quot;) http404异常：\n在应用的模板目录顶层定义一个404.html模板文件，当跑出Http404异常就会调用这个模板文件展示。\nfrom django.http import Http404 def index(request): try: ... except Application.DoesNotExist: raise Http404(\u0026quot;Application does not exist\u0026quot;) return HttpResponse(...) 自定义错误视图：\n参考urls中的内容。\n快捷函数 django.shortcuts中定义了多个快捷函数。\nfrom django.shortcuts import render render(request, template_name, context=None, context_instance=\u0026lt;object object\u0026gt;, content_type=None, status=None, current_app=\u0026lt;object object\u0026gt;, dirs=\u0026lt;object object\u0026gt;, dictionary=\u0026lt;object object\u0026gt;, using=None) # render第一个参数是request，根据给定模板和上下文字典，返回一个渲染后的HttpResponse对象。 return render(request, 'application/index.html', {'foo': 'bar'}, content_type=\u0026quot;text/html\u0026quot;) from django.shortcuts import get_object_or_404 get_object_or_404(klass, *args, **kwargs) # 在给定的模型管理器调用get()，如果不存在引发Http404异常。 基于类的视图 基于类的视图的基类在django.views.generic中\nfrom django.views.generic import View def MyView(View): def get(self, request): return HttpResponse(...) TemplateResponse和SimpleTemplateResponse from django.template.response import TemplateResponse, SimpleTemplateResponse 视图装饰器 django.views.decorators包中定义了视图的装饰器。\nfrom django.views.decorators import * 内建的视图 django.views.static.serve定义了开发环境的文件服务器视图，仅用于开发。\nfrom django.views.static import serve django.views.defaults定义了内建的错误处理的视图\nfrom django.views.defaults import * ",
    "categories": ["Django"],
    "tags": ["view"]
  },
  {
    "title": "Model",
    "permalink": "https://canuxcheng.com/post/django_model/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"modelspy\"\u003emodels.py\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003efrom django.db import models\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edjango模型是和数据库关联的，代码放在models.py，数据库信息在settings.py中统一配置即可。\u003c/p\u003e\n\u003cp\u003e每个模型对应数据库唯一的一张表，是django.db.models.Model的子类。\u003c/p\u003e\n\u003cp\u003e每个模型实例代表数据库中的一条特定记录.\u003c/p\u003e\n\u003cp\u003e模型的每个属性都表示为数据库中的一个字段。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在项目的settings.py中激活应用，并设置数据库相关参数。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e让django包含你的应用：\u003c/p\u003e\n\u003cp\u003e告诉django你对模型做了更改，并且将这些更改存储为迁移文件polls/migrations/0001_initial.py:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  $python manage.py makemigrations polls\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以查看迁移文件执行了哪些sql语句,并不真的在数据库执行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  $python manage.py sqlmigrate polls 0001\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以检查项目中的模型是否存在问题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  $python manage.py check\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在数据库中创建模型,查找还没有被应用的迁移文件然后和数据库同步：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  $python manage.py migrate\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"模型的字段类型和字段选项\"\u003e模型的字段类型和字段选项\u003c/h1\u003e\n\u003cp\u003e模型的每个属性都表示为数据库的一个字段,是Field子类的某个实例。\u003c/p\u003e\n\u003cp\u003e模型的字段还有一些选项。\u003c/p\u003e\n\u003cp\u003e字段命名规则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不能是python的保留关键字。\u003c/li\u003e\n\u003cli\u003e字段名中连续的下划线不能超过一个。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e访问其它应用的模型,导入即可：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom \u0026lt;other-aplication\u0026gt;.models import \u0026lt;module-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模型字段类型和选项参考：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options\"\u003ehttp://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"模型字段类型\"\u003e模型字段类型\u003c/h2\u003e\n\u003cp\u003e字段的类型都是Field类的子类：\u003c/p\u003e\n\u003cp\u003e每个字段都接受一个可选的位置参数(一般是第一个），叫字段的自述名,如果不指定就默认是字段名字（下划线换成空格）。\u003c/p\u003e\n\u003cp\u003e自增字段:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAutoField\n# 默认django会每个模型添加一个自增主键字段,如果你显示设置一个自增主键字段就不会默认再添加,每个模型只能有一个主键字段。\n# id = models.AutoField(primary_key=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e普通字段:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBigIntegerField\nBinaryField\nBooleanField\nCharField\nCommaSeparatedIntegerField\nDateField\nDateTimeField\nDecimalField\nDurationField\nEmailField\nFileField\nFilePathField\nFloatField\nGenericIPAddressField\nIPAddressField\nImageField\nIntegerField\nNullBooleanField\nPositiveIntegerField\nPositiveSmallIntegerField\nSlugField\nSmallIntegerField\nTextField\nTimeField\nURLField\nUUIDField\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e关系字段:\u003c/p\u003e",
    "content": "models.py from django.db import models django模型是和数据库关联的，代码放在models.py，数据库信息在settings.py中统一配置即可。\n每个模型对应数据库唯一的一张表，是django.db.models.Model的子类。\n每个模型实例代表数据库中的一条特定记录.\n模型的每个属性都表示为数据库中的一个字段。\n在项目的settings.py中激活应用，并设置数据库相关参数。\n让django包含你的应用：\n告诉django你对模型做了更改，并且将这些更改存储为迁移文件polls/migrations/0001_initial.py:\n$python manage.py makemigrations polls 可以查看迁移文件执行了哪些sql语句,并不真的在数据库执行：\n$python manage.py sqlmigrate polls 0001 可以检查项目中的模型是否存在问题：\n$python manage.py check 在数据库中创建模型,查找还没有被应用的迁移文件然后和数据库同步：\n$python manage.py migrate 模型的字段类型和字段选项 模型的每个属性都表示为数据库的一个字段,是Field子类的某个实例。\n模型的字段还有一些选项。\n字段命名规则：\n不能是python的保留关键字。 字段名中连续的下划线不能超过一个。 访问其它应用的模型,导入即可：\nfrom \u0026lt;other-aplication\u0026gt;.models import \u0026lt;module-name\u0026gt; 模型字段类型和选项参考：\nhttp://python.usyiyi.cn/documents/django_182/ref/models/fields.html#common-model-field-options\n模型字段类型 字段的类型都是Field类的子类：\n每个字段都接受一个可选的位置参数(一般是第一个），叫字段的自述名,如果不指定就默认是字段名字（下划线换成空格）。\n自增字段:\nAutoField # 默认django会每个模型添加一个自增主键字段,如果你显示设置一个自增主键字段就不会默认再添加,每个模型只能有一个主键字段。 # id = models.AutoField(primary_key=True) 普通字段:\nBigIntegerField BinaryField BooleanField CharField CommaSeparatedIntegerField DateField DateTimeField DecimalField DurationField EmailField FileField FilePathField FloatField GenericIPAddressField IPAddressField ImageField IntegerField NullBooleanField PositiveIntegerField PositiveSmallIntegerField SlugField SmallIntegerField TextField TimeField URLField UUIDField 关系字段:\ndjango定义了一系列字段类型描述数据库之间的关联:\n这三个字段要求第一个参数是模型类，用verbose_name选项才能指定自述名。\nForeignKey 定义多对一关系 OneToOneField 定义一对一关系 ManyToManyField 定义多对多关系 模型字段选项 django定义的字段的通用的选项：\n每个字段都有特定的选项，也有通用的选项,特定参数参考文档。\nField.null django将空值以NULL存储到数据库中,默认是false Field.blank 该字段允许为空白,默认false Field.primary_key true表示该字段为模型的主键字段,默认是false Field.unique true表示该字段在表中必须有唯一值,默认是false Field.unique_for_date Field.unique_for_month Field.unique_for_year Field.choices 可迭代结构,给字段提供选项 Field.default 该字段默认值 Field.help_text 额外的help文本 Field.editable false表示该字段不会出现在admin,默认是true Field.error_messages 重写默认抛出的错误信息 Field.verbose_name 该字段可读性更高的名称 Field.validators 该字段要运行的一个Validator的列表 Field.db_column Field.db_index Field.db_tablespace 模型元选项 使用内部类Meta定义模型的元数据。\n模型元数据是任何不是字段的数据，比如排序选项等。\nfrom django.db import models class Ox(models.Model): horn_length = models.IntegerField() ... class Meta: ordering = [\u0026quot;horn_length\u0026quot;] verbose_name_plural = \u0026quot;oxen\u0026quot; 模型的元选项：\nhttp://python.usyiyi.cn/translate/django_182/ref/models/options.html\n在元类Meta中使用的选项.\nOptions.abstract = True 表示模型是抽象基类, 数据库不会创建这个表 Options.db_table 该模型所用的数据表的名称 Options.db_tablespace Options.default_related_name Options.get_latest_by Options.managed Options.order_with_respect_to Options.ordering = ['字段名', '-字段名'] 对象的默认顺序, -表示倒序 Options.permissions Options.default_permissions Options.proxy Options.select_on_save Options.unique_together Options.index_together Options.verbose_name 对象的一个易于理解的名字 Options.verbose_name_plural 该对象复数形式的名字 模型的属性 模型的属性是表级别的,是对表的操作.\nhttp://python.usyiyi.cn/translate/django_182/ref/models/class.html\n每个模型类都要添加一个Manager实例,如果不显示添加，django就会默认添加objects属性，包含Manager实例。\nManager或object属性是模型进行数据库查询操作的接口,也叫管理器,用于从数据库获取实例。\nfrom django.db import models class Foo(models.Model): # 显示添加 bar = models.Manager() 执行查询 一旦建立数据模型,django会自动生成一套抽象的API,用于创建,检索,更新和删除对象.\n创建对象 q = Question(question_text='content', pub_date='date') q.save() q = Question(question_text='content') q.pub_date='date' q.save() Question.objects.create(question_text=\u0026quot;content\u0026quot;, pub_date='date') # 防止重复,不存在就创建，返回(object, True),存在返回(object, False) Question.objects.get_or_create(question_text='content', pub_date='date') 获取对象 通过模型中的管理器构造一个查询集来从数据库获取对象.\n查询集求值：\n迭代 切片 序列化 repr() len() list() bool() 查询集参考QuerySet类的方法：\nhttp://python.usyiyi.cn/translate/django_182/ref/models/querysets.html#queryset-api\n# 获取表中所有对象 Question.objects.all() # 切片获取部分 Question.objects.all()[:10] # 获取单个 Question.objects.get(question_text='content') # 过滤 Question.objects.filter(**kwargs) Question.objects.exclude(**kwargs) 查询集的链式过滤：\nQuestion.objects.all().exists() Question.objects.all().order_by('name') Question.objects.filter(**kwargs).filter(**kwargs) 模型的方法 模型的方法是对模型的实例的操作.\n模型中可以自定义方法，可以使用预定义的自动生成的方法，也可以覆盖预定义的方法。\n预定义方法参考：\nhttp://python.usyiyi.cn/translate/django_182/ref/models/instances.html\nModel.__unicode__() python2需要使用__unicode__方法.\ndef __unicode__(self): return u'%s' % self.title Model.__str__() python3只需要__str__方法.\ndef __str__(self): return '%s' % self.title 这段代码兼容python2和python3.\npython_2_unicode_compatible是一个用于类的装饰器，在类中定义__str__并返回文本.\nfrom __future__ import unicode_literals from django.utils.encoding import python_2_unicode_compatible @python_2_unicode_compatible class Question(models.Model): title = models.CharField('title', max_length=256) ... def __str__(self): return self.title Model.__eq__() Model.__hash__() Model.get_absolute_url() Model.get_FOO_display() Model.get_next_by_FOO(**kwargs) Model.get_previous_by_FOO(**kwargs) Model.DoesNotExist ",
    "categories": ["Django"],
    "tags": ["model"]
  },
  {
    "title": "Template",
    "permalink": "https://canuxcheng.com/post/django_template/",
    "date": "2016-10-04",
    "summary": "\u003ch1 id=\"模板设置\"\u003e模板设置\u003c/h1\u003e\n\u003cp\u003e模板引擎在settings.py设置, django有两套模板引擎：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTEMPLATES = [\n    # DjangoTemplates\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        # 定义项目的通用模板, mysite/templates\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        # True 表示在所有安装应用的application/templates中查找。\n        'APP_DIRS': True,\n        # 模板的选项：\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ]\n        },\n    },\n\n    # Jinja2\n    {\n        'BACKEND': 'django.template.backends.jinja2.Jinja2',\n        # 定义项目的通用模板, mysite/templates\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        # True表示在所有已安装应用的application/jinja2中查找。\n        'APP_DIRS': True,\n        # 模板的选项：\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ]\n        },\n    },\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBACKEND定义模板引擎,django内置的模板引擎有两个django.template.backends.django.DjangoTemplates(默认)和django.template.backends.jinja2.Jinja2\u003c/p\u003e\n\u003cp\u003eDIRS存放自定义的不在应用路径的模板，模板引擎按列表顺序搜索查找模板源文件,默认就是默认引擎的默认路径。\u003c/p\u003e\n\u003cp\u003eAPP_DIRS告诉模板引擎是否进入安装应用的templates(jinja2的目录是jinja2)查找模板。\u003c/p\u003e\n\u003cp\u003e在视图中使用模板：\u003c/p\u003e\n\u003cp\u003e默认django会在项目的所有应用的templates中查找模板，所以为了防止多个应用有同名的模板，需要在templates下新建application同名的目录来存放模板\u003c/p\u003e",
    "content": "模板设置 模板引擎在settings.py设置, django有两套模板引擎：\nTEMPLATES = [ # DjangoTemplates { 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 定义项目的通用模板, mysite/templates 'DIRS': [os.path.join(BASE_DIR, 'templates')], # True 表示在所有安装应用的application/templates中查找。 'APP_DIRS': True, # 模板的选项： 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ] }, }, # Jinja2 { 'BACKEND': 'django.template.backends.jinja2.Jinja2', # 定义项目的通用模板, mysite/templates 'DIRS': [os.path.join(BASE_DIR, 'templates')], # True表示在所有已安装应用的application/jinja2中查找。 'APP_DIRS': True, # 模板的选项： 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ] }, }, ] BACKEND定义模板引擎,django内置的模板引擎有两个django.template.backends.django.DjangoTemplates(默认)和django.template.backends.jinja2.Jinja2\nDIRS存放自定义的不在应用路径的模板，模板引擎按列表顺序搜索查找模板源文件,默认就是默认引擎的默认路径。\nAPP_DIRS告诉模板引擎是否进入安装应用的templates(jinja2的目录是jinja2)查找模板。\n在视图中使用模板：\n默认django会在项目的所有应用的templates中查找模板，所以为了防止多个应用有同名的模板，需要在templates下新建application同名的目录来存放模板\n应用的模板文件需要在应用目录创建templates文件夹\n默认模板放在polls/templates/polls/XXX.html\n应用的静态文件需要在应用目录创建static文件夹\n默认静态文件存放在polls/static/polls/XXX.css\n静态文件夹用来集中存放和管理图片，js脚本和css样式表等静态文件。\ndjango.template.loader定义了两个函数加载模板。\nget_template(template_name, dirs=\u0026lt;object object\u0026gt;, using=None) select_template(template_name_list, dirs=\u0026lt;object object\u0026gt;, using=None) 模板语言 django模板语言由四部分组成：\n变量 标签 过滤器 评论 变量 {{ var }} 显示字符串：\nstring = \u0026quot;test string\u0026quot; return render(request, 'index.html', {'string': string}) {{ string }} 显示字典：\ndict = {\u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: \u0026quot;value2\u0026quot;} return render(request, 'index.html', {'dict': dict}) {{ dict.name1 }} 标签 {% tag %} 参考内置标签：\nhttp://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-tags\nfor标签：\n遍历列表：\nlist = ['val1', 'val2', 'val3'] return render(request, 'index.html', {'list': 'list'}) ```html {% for i in list %} {{ i }} {% endfor %} ``` 遍历字典：\n```html {% for key, value in dict.items %} {{ key }}: {{ value }} {% endfor %} ``` empty列表可能为空：\n```html {% for i in list %} ... {% empty %} ... {% endfor %} ``` reversed反向循环：\n{% for i in list reversed %} for循环有用的变量：\nforloop.counter # 1 - indexed forloop.counter0 # 0 - indexed forloop.revcounter # 1 - indexed forloop.revcounter0 # 0 - indexed forloop.first forloop.last forloop.parentloop if标签：\n```html {% if expression %} ... {% else %} ... {% endif %} ``` if可用的布尔操作符：\n{% if expression1 and expression2 %} {% if not expression %} {% if expression1 or expression2 %} {% if not expression1 or expression2 %} # not优先级高于or {% if expression1 and not expression2 %} # not优先级高于and {% if expression1 and expression2 or expression3 %} # and优先级高于or {% if var == value %} {% if var != value %} {% if var \u0026lt; value %} {% if var \u0026gt; value %} {% if var \u0026lt;= value %} {% if var \u0026gt;= value %} {% if var in value %} {% if a \u0026gt; b and b \u0026gt; c %} {% if var|filter\u0026quot;arguments expression %} # if中使用过滤器 布尔操作符的优先级：\nor and not in ==, !=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= include标签：\n加载模板并以标签内的参数渲染。\n{% include 'XXX.html' %} load标签：\n加载自定义模板标签集。\n{% load foo bar from somelibrary %} now标签：\n显示最近的日期和事件。\nspaceless标签：\n删除html标签之间的空白格，包括制表符和换行。\nurl标签：\n返回一个绝对路径的引用，该引用匹配一个给定的视图函数和一些可选的参数。\n{% 'some-url-name' v1 v2 %} 模板继承 block标签：\n在底层模板定义一些通用的内容，block标签可以被子模板覆盖。\n```html {% block XXX %} This is default content {% endblock %}} ``` extends标签：\n表示当前模板继承自父模板。\nextends标签必须放在子模板第一行。\nextends用来调用底层的模板，然后修改block标签内容。\n```html {% extends \u0026quot;XXX.html\u0026quot;/variable %} {% block XXX %} This is rewrite content {% endblock %} ``` block.super:\n如果需要获取父模板的block中的内容，可以用block.super。\n可以在父模板的block中增加内容，而不是完全覆盖。\n过滤器 {{ var|filter:arguments }} 参考内置过滤器\nhttp://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html#ref-templates-builtins-filters\nadd过滤器：\n把add后的参数加给value。\n{{ value|add:\u0026quot;2\u0026quot; }} # value -\u0026gt; value+2 {{ value|addslashes }} # \u0026quot;I'm string\u0026quot; -\u0026gt; \u0026quot;I\\'m string\u0026quot; addslashed过滤器：\n在引号前面加\\\n{{ value|addslashes }} # I'm canux -\u0026gt; I\\'m canux capfirst过滤器：\n变量的第一个字母大写。\n{{ value|capfirst }} center过滤器：\n使value在给定的宽度范围内居中。\n{{ value|center:\u0026quot;15\u0026quot; }} cut过滤器：\n移除value中所有的与给出的变量相同的字符串。\n{{ value|cut:\u0026quot;cut\u0026quot; }} # 移除value中的字符串\u0026quot;cut\u0026quot; date过滤器：\n根据给定格式对一个date变量格式化。\ndefault过滤器：\n给value设定默认值，如果value没有赋值，就用默认值。\n{{ value|default:\u0026quot;default-value\u0026quot; }} default_if_none过滤器：\n仅当value是None使用默认值。\n{{ value:default_if_none:\u0026quot;nothing\u0026quot; }} dictsort过滤器：\ndictsortreversed过滤器：\ndivisibleby过滤器：\n如果value可以被给出的参数整除，返回True。\n{{ value|divisibleby:\u0026quot;3\u0026quot; }} escape过滤器：\nescapejs过滤器：\nfilesizeformat过滤器：\n格式化为人类可读的文件大小。\nfirst过滤器：\n返回迭代器的第一个元素。\nfloatformat过滤器：\nforce_escape过滤器：\nget_digit过滤器：\niriencode过滤器：\njoin过滤器：\nlast过滤器：\nlength过滤器：\nlength_is过滤器：\nlinebreaks过滤器：\nlinebreaksbr过滤器：\nlinenumbers过滤器：\nljust过滤器：\nlower过滤器：\n把字符串转换成小写。\nmake_list过滤器：\nphone2numeric过滤器：\npluralize过滤器：\npprint过滤器：\nrandom过滤器：\nromevetags过滤器：\nrjust过滤器：\nslice过滤器：\nslugify过滤器：\nstringformat过滤器：\nstriptags过滤器：\ntime过滤器：\ntimesince过滤器：\ntimeuntil过滤器：\ntitle过滤器：\ntruncatechars过滤器：\ntruncatechars_html过滤器：\ntruncatewords过滤器：\ntruncatewords_html过滤器;\nunordered_list过滤器：\nupper过滤器：\n将字符串转换成大写形式。\nurlencode过滤器：\nurlize过滤器：\nurlizetrunc过滤器：\nwordcount过滤器：\nwordwrap过滤器：\nyesno过滤器：\ni18n过滤器：\nl10n过滤器：\ntz过滤器：\n注释 单行注释：\n```html {# this is single line comment #} ``` 多行注释：\n```html {% comment %} line1 line2 {% endcomment %} ``` 自动html转义 当从模板生成html时，值可能包含影响html最终呈现的字符。\ndjango的自动转义,默认是打开的：\n\u0026lt; 转义成 \u0026amp;lt; \u0026gt; 转义成 \u0026amp;gt; ' 转义成 \u0026amp;#39 \u0026quot; 转义成 \u0026amp;quot; $ 转义成 \u0026amp;amp; 如果不需要自动转义可以关闭它\n可以用safe过滤器关闭独立变量中的自动转义：\ndata = \u0026lt;b\u0026gt; {{ data }} -\u0026gt; \u0026amp;lt;b\u0026amp;gt; {{ data|safe }} -\u0026gt; \u0026lt;b\u0026gt; 可以用autoescape标签关闭模板代码中的自动转义：\nautoescape标签有off和on两个参数，表示关闭和打开自动转义。\n父模板中的autoescape可以被子模板继承，也可以被include标签包含的模板继承。\n```html {% autoescape off %} {{ name }} {% endautoescape %} ``` ",
    "categories": ["Django"],
    "tags": ["template"]
  },
  {
    "title": "Deploy",
    "permalink": "https://canuxcheng.com/post/django_deploy/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"发布django项目\"\u003e发布django项目\u003c/h1\u003e\n\u003cp\u003edjango内置一个轻量级web开发服务器。\u003c/p\u003e\n\u003cp\u003e如果要发布django项目需要另外的操作。\u003c/p\u003e\n\u003cp\u003e也可以发布到其它的云平台。\u003c/p\u003e\n\u003cp\u003e一般通过wsgi或者asgi来部署.\u003c/p\u003e\n\u003ch2 id=\"deploy时django的设置\"\u003edeploy时django的设置\u003c/h2\u003e\n\u003cp\u003esettings.py中的设置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eALLOWED_HOSTS = ['*']\nDEBUG = False\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"wsgi-部署\"\u003eWSGI 部署\u003c/h1\u003e\n\u003ch2 id=\"apache2--mod_wsgi\"\u003eapache2 + mod_wsgi\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/GrahamDumpleton/mod_wsgi\"\u003ehttps://github.com/GrahamDumpleton/mod_wsgi\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003emod_wsgi是C写的apache的模块，实现了兼容WSGI接口，用来部署python的web应用。\u003c/p\u003e\n\u003cp\u003e作为apache2的模块安装\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# ubuntu/debian\nsudo aptitude install apache2 # 安装apache2\nsudo aptitude install libapache2-mod-wsgi # for python2\nsudo aptitude install libapache2-mod-wsgi-py3 # for python3\n\n# redhat/centos/fedora\nsudo yum install httpd2\nsudo yum install httpd-devel\nsudo yum install mod_wsgi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUbuntu创建网站的配置文件/etc/apache2/sites-available/mysite.conf:\u003c/p\u003e\n\u003cp\u003eFedora创建网站的配置文件/etc/httpd/conf.d/mysite.conf:\u003c/p\u003e\n\u003cp\u003e一般部署到web服务器，/home/user/修改为/var/www/\u003cproject-name\u003e/\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Include the project dir, can not inside VirtualHost section.\nWSGIPythonPath /home/user/mysite\n# If use virtualenv and named .venv\n# WSGIPythonPath /home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages\n\n\u0026lt;VirtualHost *:80\u0026gt;\n    ServerName localhost\n    # ServerName yoursite.domain\n    ServerAdmin canuxcheng@gmail.com\n\n    Alias /robots.txt /home/user/mysite/static/robots.txt\n    Alias /favicon.ico /home/user/mysite/static/favicon.ico\n\n    Alias /media/ /home/user/mysite/media/\n    Alias /static/ /home/user/mysite/static/\n\n    \u0026lt;Directory /home/user/mysite/media\u0026gt;\n    Required all granted\n    \u0026lt;/Directory\u0026gt;\n\n    \u0026lt;Directory /home/user/mysite/static\u0026gt;\n    Required all granted\n    \u0026lt;/Directory\u0026gt;\n\n    # If use daemon mode to run WSGI process.\n    WSGIDaemonProcess mysite python-path=/home/user/mysite\n    # If use virtualenv and named .venv\n    # WSGIDaemonProcess mysite python-path=/home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages\n    # WSGIProcessGroup mysite\n\n    WSGIScriptAlias / /home/user/mysite/mysite/wsgi.py\n\n    \u0026lt;Directory /home/user/mysite/mysite\u0026gt;\n    \u0026lt;Files wsgi.py\u0026gt;\n    Required all granted\n    \u0026lt;/Files\u0026gt;\n    \u0026lt;/Directory\u0026gt;\n\n    # check the log in /var/log/apache2/error_mysite.log or access_mysite.log\n    ErrorLog ${APACHE_LOG_DIR}/error_mysite.log\n    CustomLog ${APACHE_LOG_DIR}/access_mysite.log combined\n\u0026lt;/VirtualHost\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改项目的wsgi.py:\u003c/p\u003e",
    "content": "发布django项目 django内置一个轻量级web开发服务器。\n如果要发布django项目需要另外的操作。\n也可以发布到其它的云平台。\n一般通过wsgi或者asgi来部署.\ndeploy时django的设置 settings.py中的设置：\nALLOWED_HOSTS = ['*'] DEBUG = False WSGI 部署 apache2 + mod_wsgi https://github.com/GrahamDumpleton/mod_wsgi\nmod_wsgi是C写的apache的模块，实现了兼容WSGI接口，用来部署python的web应用。\n作为apache2的模块安装\n# ubuntu/debian sudo aptitude install apache2 # 安装apache2 sudo aptitude install libapache2-mod-wsgi # for python2 sudo aptitude install libapache2-mod-wsgi-py3 # for python3 # redhat/centos/fedora sudo yum install httpd2 sudo yum install httpd-devel sudo yum install mod_wsgi Ubuntu创建网站的配置文件/etc/apache2/sites-available/mysite.conf:\nFedora创建网站的配置文件/etc/httpd/conf.d/mysite.conf:\n一般部署到web服务器，/home/user/修改为/var/www//\n# Include the project dir, can not inside VirtualHost section. WSGIPythonPath /home/user/mysite # If use virtualenv and named .venv # WSGIPythonPath /home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages \u0026lt;VirtualHost *:80\u0026gt; ServerName localhost # ServerName yoursite.domain ServerAdmin canuxcheng@gmail.com Alias /robots.txt /home/user/mysite/static/robots.txt Alias /favicon.ico /home/user/mysite/static/favicon.ico Alias /media/ /home/user/mysite/media/ Alias /static/ /home/user/mysite/static/ \u0026lt;Directory /home/user/mysite/media\u0026gt; Required all granted \u0026lt;/Directory\u0026gt; \u0026lt;Directory /home/user/mysite/static\u0026gt; Required all granted \u0026lt;/Directory\u0026gt; # If use daemon mode to run WSGI process. WSGIDaemonProcess mysite python-path=/home/user/mysite # If use virtualenv and named .venv # WSGIDaemonProcess mysite python-path=/home/user/mysite:/home/user/mysite/.venv/lib/python2.7/site-packages # WSGIProcessGroup mysite WSGIScriptAlias / /home/user/mysite/mysite/wsgi.py \u0026lt;Directory /home/user/mysite/mysite\u0026gt; \u0026lt;Files wsgi.py\u0026gt; Required all granted \u0026lt;/Files\u0026gt; \u0026lt;/Directory\u0026gt; # check the log in /var/log/apache2/error_mysite.log or access_mysite.log ErrorLog ${APACHE_LOG_DIR}/error_mysite.log CustomLog ${APACHE_LOG_DIR}/access_mysite.log combined \u0026lt;/VirtualHost\u0026gt; 修改项目的wsgi.py:\n因为环境变量是进程范围的，在同一个进程运行多个站点会出问题，所以推荐多站点使用mod_wsgi的守护进程模式,也可以在单进程中覆盖DJANGO_SETTINGS_MODULE这个变量。\nimport os from django.core.wsgi import get_wsgi_application # If you have more than 1 django project you need to change this. # Or you can use daemon mode for WSGI process. # os.environ.setdefault(\u0026quot;DJANGO_SETTINGS_MODULE\u0026quot;, \u0026quot;mysite.settings\u0026quot;) os.environ[\u0026quot;DIANGO_SETTINGS_MODULE\u0026quot;] = \u0026quot;mysite.settings\u0026quot; application = get_wsgi_application() 修改项目的settings.py:\nROOT表示存放位置，URL表示对应网址。\nDEBUG = False ALLOWED_HOSTS = ['*'] # Static files (CSS, JavaScript, Images) STATIC_URL = '/static/' STATIC_ROOT = os.path.join(BASE_DIR, 'static') # Media files (upload files) MEDIA_URL = '/media/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 收集静态文件和迁移：\n$python manage.py makemigration $python mamage.py migrate $python manage.py collectstatic 设置权限：\nUbuntu默认用户和组是www-data,Fedora默认用户和组是apache。\n$cd /home/user $sudo chgrp www-data mysite $sudo chmod g+w mysite $sudo chgrp www-data mysite/db.sqlite3 $sudo chmod g+w mysite/db.sqlite3 $sudo chgrp -R www-data mysite/media/uploads $sudo chmod -R g+w mysite/media/uploads Ubuntu激活网站：\n$sudo a2ensite \u0026lt;newsite\u0026gt; $sudo service apache2 restart Fedora激活网站：\n$sudo systemctl restart httpd uWSGI https://github.com/unbit/uwsgi\nC写的wsgi应用服务器。\n$ python3 -m pip install uwsgi $ uwsgi --http :8000 --chdir /path/to/project --module mysite.wsgi Gunicorn https://github.com/benoitc/gunicorn\n纯python写的WSGI服务器。\n$ python3 -m pip install gunicorn $ gunicorn mysite.wsgi ASGI Uvicorn $ python -m pip install uvicorn gunicorn $ gunicorn myproject.asgi:application -k uvicorn.workers.UvicornWorker Hypercorn $ python -m pip install hypercorn $ hypercorn myproject.asgi:application Daphne $ python -m pip install daphne $ daphne myproject.asgi:application ",
    "categories": ["Django"],
    "tags": ["deploy"]
  },
  {
    "title": "Nodejs",
    "permalink": "https://canuxcheng.com/post/js_node/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"nodejs\"\u003eNodejs\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/nodejs/node\"\u003ehttps://github.com/nodejs/node\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。\u003c/p\u003e\n\u003cp\u003eNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。\u003c/p\u003e\n\u003cp\u003eNode.js 的包管理器npm，是全球最大的开源库生态系统.\u003c/p\u003e\n\u003cp\u003e常说的javascript是前端语言，nodejs就是后端版本的javascript。\u003c/p\u003e\n\u003cp\u003e安装nodejs(npm):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install nodejs\n$ brew install nodejs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ node --version\n$ npm --version\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"nvm\"\u003envm\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/nvm-sh/nvm\"\u003ehttps://github.com/nvm-sh/nvm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003enodejs版本管理器.\u003c/p\u003e\n\u003cp\u003einstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003everify:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecommand -v nvm\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eusage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 查看所有可安装版本\nnvm ls-remote\n\n// 安装指定版本\nnvm install v14.15.5\n\n// 查看已安装版本\nnvm ls\n\n// 指定默认版本\nnvm alias default v16.14.0\n\n// 指定版本\nnvm use v14.15.5\nnvm use default\n\n// 查看版本\nnvm run node --version\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Nodejs https://github.com/nodejs/node\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。\nNode.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。\nNode.js 的包管理器npm，是全球最大的开源库生态系统.\n常说的javascript是前端语言，nodejs就是后端版本的javascript。\n安装nodejs(npm):\n$ sudo apt-get install nodejs $ brew install nodejs 查看\n$ node --version $ npm --version nvm https://github.com/nvm-sh/nvm\nnodejs版本管理器.\ninstall:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash verify:\ncommand -v nvm usage:\n// 查看所有可安装版本 nvm ls-remote // 安装指定版本 nvm install v14.15.5 // 查看已安装版本 nvm ls // 指定默认版本 nvm alias default v16.14.0 // 指定版本 nvm use v14.15.5 nvm use default // 查看版本 nvm run node --version ",
    "categories": ["Web"],
    "tags": ["nodejs"]
  },
  {
    "title": "NPM",
    "permalink": "https://canuxcheng.com/post/js_npm/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"npm\"\u003eNPM\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.npmjs.cn/\"\u003ehttps://www.npmjs.cn/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003enpm: node package manager.\u003c/p\u003e\n\u003cp\u003enpm 由三部分组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewebsite \u003ca href=\"https://www.npmjs.com\"\u003ehttps://www.npmjs.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eCLI\u003c/li\u003e\n\u003cli\u003eregistry \u003ca href=\"https://registry.npmjs.org\"\u003ehttps://registry.npmjs.org\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003econfig:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 修改registry\n$ npm config set registry https://registry.npm.taobao.org\n$ npm config get registry\n\n// 修改默认全局安装路径\nmkdir /path/npm_global\nnpm config set prefix /path/npm_global\necho 'export PATH=/path/npm_global/bin:$PATH' \u0026gt;\u0026gt; ~/.profile\nsource ~/.profile\n\n// 查看配置\n$ npm config ls -l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einstall:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 根据当前目录package.json安装到当前目录node_modules\n$ npm install\n\n// 安装pkg到当前目录的 node_modules\n$ npm install \u0026lt;pkg\u0026gt;\n\n// 安装到全局的node_modules\n$ npm install -g \u0026lt;name\u0026gt;\n\n--save-dev // 安装并自动更新到package.json的devDependencies.\n--no-save // 不保存到package.json 和 package-lock.json.\n--no-package-lock // 不生成package-lock.json\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elist:\u003c/p\u003e",
    "content": "NPM https://www.npmjs.cn/\nnpm: node package manager.\nnpm 由三部分组成：\nwebsite https://www.npmjs.com CLI registry https://registry.npmjs.org config:\n// 修改registry $ npm config set registry https://registry.npm.taobao.org $ npm config get registry // 修改默认全局安装路径 mkdir /path/npm_global npm config set prefix /path/npm_global echo 'export PATH=/path/npm_global/bin:$PATH' \u0026gt;\u0026gt; ~/.profile source ~/.profile // 查看配置 $ npm config ls -l install:\n// 根据当前目录package.json安装到当前目录node_modules $ npm install // 安装pkg到当前目录的 node_modules $ npm install \u0026lt;pkg\u0026gt; // 安装到全局的node_modules $ npm install -g \u0026lt;name\u0026gt; --save-dev // 安装并自动更新到package.json的devDependencies. --no-save // 不保存到package.json 和 package-lock.json. --no-package-lock // 不生成package-lock.json list:\n// 查看安装了哪些包 $ npm list --depth=0 --global init:\n// 创建package.json $ npm init test:\n$ npm test publish:\n# 注册npm账号 # 添加账号 npm adduser # 验证账号 npm whoami # 发布 npm publish 发布好了可以去npm网站查看.\nnpm + shrinkwrap = yarn lock npm-shrinkwrap.json = yarn.lock\nfolders nodejs加载的路径:\n1. 当前目录 2. $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node_modules 3. $NODE_PATH // 查看prefix (也是-g 安装的目录) $ npm config ls -l | grep prefix npmrc get token\ncurl -u\u0026lt;username\u0026gt;:\u0026lt;api-key\u0026gt; https://artifactory.canux.com/artifactory/api/npm/auth \u0026ldquo;.npmrc\u0026rdquo; 配置private registry\nregistry=https://artifactory.canux.com/artifactory/api/npm/iep.npm-virtual always-auth=true email=\u0026lt;user-email\u0026gt; //artifactory.arm.com/artifactory/api/npm/:_auth=\u0026lt;token\u0026gt; npmignore 打包的时候忽略的文件和目录，优先级高于gitignore。\npackage.json package.json\npackage-locks\npackage-lock.json\nyarn https://yarnpkg.com/\n使用corepack安装yarn。\n激活corepack\n$ corepack enable 安装yarn\n$ corepack prepare yarn@3.8.1 --activate CLI:\n// yarn config, yarn 会读npmrc yarn config cacheFolder: $HOME/.yarn/berry/cache globalFolder: $HOME/.yarn/berry // create package.json $ yarn init // 设置project的yarn version，自动下载.yarn/release/yarn-\u0026lt;version\u0026gt;.cjs yarn set version berry // remove all local archives $ yarn cache clean // add/remove/install dependencies $ yarn add ... $ yarn remove ... $ yarn install --inline-builds // nodejs $ yarn node // check npm package information $ yarn npm info react // run script defined in package.json $ yarn run \u0026lt;scriptName\u0026gt; // plugin management $ yarn plugin ...... // workspace management $ yarn workspaces ... $ yarn workspaces list $ yarn workspaces foreach // run command on all workspaces // login to private registry yarn npm login yarn npm logout yarn npm publish npmRegistries: \u0026quot;https://artifactory.arm.com/artifactory/api/npm/iep.npm-virtual\u0026quot;: npmAuthToken: \u0026lt;token\u0026gt; yarn build \u0026quot;exports\u0026quot;: { \u0026quot;.\u0026quot;: \u0026quot;./src/index.ts\u0026quot;, \u0026quot;./alpha\u0026quot;: \u0026quot;./src/alpha.ts\u0026quot;, \u0026quot;./package.json\u0026quot;: \u0026quot;./package.json\u0026quot; }, ",
    "categories": ["Web"],
    "tags": ["npm"]
  },
  {
    "title": "Web",
    "permalink": "https://canuxcheng.com/post/web/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"web\"\u003eWEB\u003c/h1\u003e\n\u003cp\u003eweb一般包括web server, web service, load balancing.\u003c/p\u003e\n\u003cp\u003eURL: Uniform Resource Locator, 统一资源定位符．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escheme://host[:port#]/path/.../[?query-string][#anchor]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDNS: Domain Name System, 域名系统.\u003c/p\u003e\n\u003cp\u003eheader: header中用来保存session，cookie等头部信息．\u003c/p\u003e\n\u003cp\u003esession: 服务端的数据存储机制．\u003c/p\u003e\n\u003cp\u003ecookie: 客户端的数据存储机制．分为会话cookie和持久cookie.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"webserver\"\u003ewebserver\u003c/h1\u003e\n\u003cp\u003eLAMP: Linux+apache+mysql+php\u003c/p\u003e\n\u003cp\u003eLNMP: Linux+nginx+mysql+php\u003c/p\u003e\n\u003ch1 id=\"blog静态站点\"\u003eBlog静态站点\u003c/h1\u003e\n\u003cp\u003ehugo是golang开发的静态站点生成器．\u003c/p\u003e\n\u003cp\u003epelican是python开发的静态站点生成器.\u003c/p\u003e\n\u003cp\u003ehexo是nodejs开发的静态站点生成器.\u003c/p\u003e\n\u003cp\u003ejekyll是ruby开发的静态站点生成器.\u003c/p\u003e\n\u003cp\u003eoctopress是ruby开发的kekyll的升级版.\u003c/p\u003e\n\u003ch1 id=\"cms系统\"\u003eCMS系统\u003c/h1\u003e\n\u003cp\u003ewordpress是php开发的website, blog, app框架。\u003c/p\u003e\n\u003cp\u003ejoomla是php开发的内容管理系统.\u003c/p\u003e\n\u003cp\u003edrupal是php开发的内容管理系统.\u003c/p\u003e\n\u003cp\u003edjango-cms是python开发的基于django的内容管理系统.\u003c/p\u003e\n\u003cp\u003ewagtail是python开发的基于django的内容管理系统.\u003c/p\u003e\n\u003cp\u003emezzanine是python开发的基于django的内容管理系统.\u003c/p\u003e\n\u003ch1 id=\"forum系统\"\u003eForum系统\u003c/h1\u003e\n\u003cp\u003evanilla是php开发的论坛系统.\u003c/p\u003e\n\u003cp\u003ephpbb是php开发的论坛系统.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"webservice\"\u003ewebservice\u003c/h1\u003e\n\u003cp\u003eweb service是一种标准,将应用程序转换成网络应用程序.\u003c/p\u003e\n\u003cp\u003eWSDL:网络服务描述语言\u003c/p\u003e\n\u003cp\u003eUDDI:\u003c/p\u003e\n\u003cp\u003eRDF:\u003c/p\u003e\n\u003cp\u003eRSS:\u003c/p\u003e\n\u003cp\u003eSOAP: 是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。\u003c/p\u003e\n\u003chr\u003e",
    "content": "WEB web一般包括web server, web service, load balancing.\nURL: Uniform Resource Locator, 统一资源定位符．\nscheme://host[:port#]/path/.../[?query-string][#anchor] DNS: Domain Name System, 域名系统.\nheader: header中用来保存session，cookie等头部信息．\nsession: 服务端的数据存储机制．\ncookie: 客户端的数据存储机制．分为会话cookie和持久cookie.\nwebserver LAMP: Linux+apache+mysql+php\nLNMP: Linux+nginx+mysql+php\nBlog静态站点 hugo是golang开发的静态站点生成器．\npelican是python开发的静态站点生成器.\nhexo是nodejs开发的静态站点生成器.\njekyll是ruby开发的静态站点生成器.\noctopress是ruby开发的kekyll的升级版.\nCMS系统 wordpress是php开发的website, blog, app框架。\njoomla是php开发的内容管理系统.\ndrupal是php开发的内容管理系统.\ndjango-cms是python开发的基于django的内容管理系统.\nwagtail是python开发的基于django的内容管理系统.\nmezzanine是python开发的基于django的内容管理系统.\nForum系统 vanilla是php开发的论坛系统.\nphpbb是php开发的论坛系统.\nwebservice web service是一种标准,将应用程序转换成网络应用程序.\nWSDL:网络服务描述语言\nUDDI:\nRDF:\nRSS:\nSOAP: 是一种简单的基于XML的协议，它使应用程序通过HTTP来交换信息。\n",
    "categories": ["Web"],
    "tags": ["web"]
  },
  {
    "title": "TPL",
    "permalink": "https://canuxcheng.com/post/django_tpl/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"django-third-party-library\"\u003eDjango Third Party Library.\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rosarior/awesome-django\"\u003ehttps://github.com/rosarior/awesome-django\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAdd this application to your django project in settings.py.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eINSTALLED_APPS = (\n    'south',\n    'debug_toolbar',\n    'crispy_forms',\n    ...\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"django-rest-framework\"\u003edjango-rest-framework\u003c/h1\u003e\n\u003cp\u003edjango的RESTful API的application。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/tomchristie/django-rest-framework/tree/master\"\u003ehttps://github.com/tomchristie/django-rest-framework/tree/master\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-json-api/django-rest-framework-json-api\"\u003ehttps://github.com/django-json-api/django-rest-framework-json-api\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/SimpleJWT/django-rest-framework-simplejwt\"\u003ehttps://github.com/SimpleJWT/django-rest-framework-simplejwt\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"admin-interface\"\u003eadmin interface\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/geex-arts/django-jet\"\u003ehttps://github.com/geex-arts/django-jet\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/sehmaschine/django-grappelli\"\u003ehttps://github.com/sehmaschine/django-grappelli\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/darklow/django-suit\"\u003ehttps://github.com/darklow/django-suit\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/sshwsfc/xadmin\"\u003ehttps://github.com/sshwsfc/xadmin\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"authentication\"\u003eauthentication\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/etianen/django-python3-ldap\"\u003ehttps://github.com/etianen/django-python3-ldap\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/pennersr/django-allauth/\"\u003ehttps://github.com/pennersr/django-allauth/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-guardian/django-guardian\"\u003ehttps://github.com/django-guardian/django-guardian\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"database\"\u003edatabase\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-dbbackup/django-dbbackup\"\u003ehttps://github.com/django-dbbackup/django-dbbackup\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"debug\"\u003edebug\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jazzband/django-debug-toolbar\"\u003ehttps://github.com/jazzband/django-debug-toolbar\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-extensions/django-extensions/\"\u003ehttps://github.com/django-extensions/django-extensions/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"form\"\u003eform\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-crispy-forms/django-crispy-forms\"\u003ehttps://github.com/django-crispy-forms/django-crispy-forms\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"search\"\u003esearch\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/carltongibson/django-filter\"\u003ehttps://github.com/carltongibson/django-filter\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-haystack/django-haystack\"\u003ehttps://github.com/django-haystack/django-haystack\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"security\"\u003esecurity\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/adamchainz/django-cors-headers\"\u003ehttps://github.com/adamchainz/django-cors-headers\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"cms-project\"\u003eCMS Project\u003c/h1\u003e\n\u003ch2 id=\"django-cms\"\u003edjango-cms\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/divio/django-cms/\"\u003ehttps://github.com/divio/django-cms/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"wagtail\"\u003ewagtail\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wagtail/wagtail\"\u003ehttps://github.com/wagtail/wagtail\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"mezzanine\"\u003emezzanine\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/stephenmcd/mezzanine/\"\u003ehttps://github.com/stephenmcd/mezzanine/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"e-commerce-project\"\u003ee-Commerce Project\u003c/h1\u003e\n\u003ch2 id=\"django-oscar\"\u003edjango-oscar\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django-oscar/django-oscar\"\u003ehttps://github.com/django-oscar/django-oscar\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"django-shop\"\u003edjango-shop\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/awesto/django-shop\"\u003ehttps://github.com/awesto/django-shop\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"pm-project\"\u003ePM Project\u003c/h1\u003e\n\u003ch2 id=\"taiga\"\u003etaiga\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/taigaio\"\u003ehttps://github.com/taigaio\u003c/a\u003e\u003c/p\u003e",
    "content": "Django Third Party Library. https://github.com/rosarior/awesome-django\nAdd this application to your django project in settings.py.\nINSTALLED_APPS = ( 'south', 'debug_toolbar', 'crispy_forms', ... ) django-rest-framework django的RESTful API的application。\nhttps://github.com/tomchristie/django-rest-framework/tree/master\nhttps://github.com/django-json-api/django-rest-framework-json-api\nhttps://github.com/SimpleJWT/django-rest-framework-simplejwt\nadmin interface https://github.com/geex-arts/django-jet\nhttps://github.com/sehmaschine/django-grappelli\nhttps://github.com/darklow/django-suit\nhttps://github.com/sshwsfc/xadmin\nauthentication https://github.com/etianen/django-python3-ldap\nhttps://github.com/pennersr/django-allauth/\nhttps://github.com/django-guardian/django-guardian\ndatabase https://github.com/django-dbbackup/django-dbbackup\ndebug https://github.com/jazzband/django-debug-toolbar\nhttps://github.com/django-extensions/django-extensions/\nform https://github.com/django-crispy-forms/django-crispy-forms\nsearch https://github.com/carltongibson/django-filter\nhttps://github.com/django-haystack/django-haystack\nsecurity https://github.com/adamchainz/django-cors-headers\nCMS Project django-cms https://github.com/divio/django-cms/\nwagtail https://github.com/wagtail/wagtail\nmezzanine https://github.com/stephenmcd/mezzanine/\ne-Commerce Project django-oscar https://github.com/django-oscar/django-oscar\ndjango-shop https://github.com/awesto/django-shop\nPM Project taiga https://github.com/taigaio\n",
    "categories": ["Django"],
    "tags": ["tpl"]
  },
  {
    "title": "Apache",
    "permalink": "https://canuxcheng.com/post/apache/",
    "date": "2016-09-27",
    "summary": "\u003ch1 id=\"apache\"\u003eApache\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/httpd\"\u003ehttps://github.com/apache/httpd\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://httpd.apache.org/\"\u003ehttp://httpd.apache.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eubuntu/debian：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo aptitude install apache2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eredhat/centos/fedora:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo yum install httpd2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动服务器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eservice apache2 start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动浏览器查看：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp://localhost:80\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"apache命令\"\u003eapache命令\u003c/h1\u003e\n\u003cp\u003eapache2ctl:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 检查配置\n$ apache2ctl configtest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ea2ensite\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 启用一个站点\n$ sudo a2ensite \u0026lt;site\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ea2dissite\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo a2dissite \u0026lt;site\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ea2enmod\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 启用一个模块\n$ sudo a2enmod \u0026lt;mod\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ea2dismod\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo a2dismod \u0026lt;mod\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"配置\"\u003e配置\u003c/h1\u003e\n\u003cp\u003e配置站点site-enable/site.conf:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;VirtualHost *:8080\u0026gt;\n    ServerAdmin webmaster@localhost\n    DocumentRoot /opt\n\n    # 适合多目录\n    Alias /qa /opt/qa\n    Alias /dev /opt/dev\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\u0026lt;/VirtualHost\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改权限apache2.conf:\u003c/p\u003e",
    "content": "Apache https://github.com/apache/httpd\nhttp://httpd.apache.org/\nubuntu/debian：\nsudo aptitude install apache2 redhat/centos/fedora:\n$ sudo yum install httpd2 启动服务器：\nservice apache2 start 启动浏览器查看：\nhttp://localhost:80 apache命令 apache2ctl:\n// 检查配置 $ apache2ctl configtest a2ensite\n// 启用一个站点 $ sudo a2ensite \u0026lt;site\u0026gt; a2dissite\n$ sudo a2dissite \u0026lt;site\u0026gt; a2enmod\n// 启用一个模块 $ sudo a2enmod \u0026lt;mod\u0026gt; a2dismod\n$ sudo a2dismod \u0026lt;mod\u0026gt; 配置 配置站点site-enable/site.conf:\n\u0026lt;VirtualHost *:8080\u0026gt; ServerAdmin webmaster@localhost DocumentRoot /opt # 适合多目录 Alias /qa /opt/qa Alias /dev /opt/dev ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined \u0026lt;/VirtualHost\u0026gt; 修改权限apache2.conf:\n\u0026lt;Directory /opt/qa\u0026gt; Options Indexes FollowSymLinks AllowOverride None Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;Directory /opt/dev\u0026gt; Options Indexes FollowSymLinks AllowOverride None Require all granted \u0026lt;/Directory\u0026gt; 修改端口ports.conf:\nListen 8080 \u0026lt;IfModule ssl_module\u0026gt; Listen 4433 \u0026lt;/IfModule\u0026gt; \u0026lt;IfModule mod_gnutls.c\u0026gt; Listen 4433 \u0026lt;/IfModule\u0026gt; 配置ssl和basic auth\n# 安装创建账号的工具 sudo apt-get install apache2-utils 创建账号 sudo htpasswd -c /etc/apache2/.htpasswd user sudo htpasswd /etc/apache2/.htpasswd another_user 启用依赖的模块:\ncd /etc/apache2/mods-enabled ln -sf ../mods-available/rewrite.load rewrite.load ln -sf ../mods-available/ssl.conf ssl.conf ln -sf ../mods-available/ssl.load ssl.load #ln -sf ../mods-available/slotmem_shm.load slotmem_shm.load #ln -sf ../mods-available/socache_shmcb.load socache_shmcb.load 修改site-avaliable/site.conf\n\u0026lt;VirtualHost *:80\u0026gt; ServerAdmin webmaster@localhost DocumentRoot /var/www // 将http重定向到https, 如果注释掉，http和https都可以访问. RewriteEngine on RewriteCond %{SERVER_PORT} !^443$ RewriteRule ^/(.*) https://%{HTTP_HOST}/$1 [NC,R=301,L] LogLevel warn ErrorLog /var/log/apache2/error.log CustomLog /var/log/apache2/access.log combined \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:443\u0026gt; ServerAdmin webmaster@localhost DocumentRoot /var/www // 开启ssl SSLEngine on SSLCertificateFile \u0026quot;/etc/apache2/user.domain.com.crt\u0026quot; SSLCertificateKeyFile \u0026quot;/etc/apache2/user.domain.com.key\u0026quot; BrowserMatch \u0026quot;MSIE [2-6]\u0026quot; nokeepalive ssl-unclean-shutdown downgrade-1.0 force-response-1.0 BrowserMatch \u0026quot;MSIE [17-9]\u0026quot; ssl-unclean-shutdown // 开启basic auth. \u0026lt;Directory \u0026quot;/var/www\u0026quot;\u0026gt; AuthType Basic AuthName \u0026quot;Restricted Content\u0026quot; AuthUserFile /etc/apache2/.htpasswd Require valid-user \u0026lt;/Directory\u0026gt; LogLevel warn ErrorLog /var/log/apache2/error.log CustomLog /var/log/apache2/access.log combined \u0026lt;/VirtualHost\u0026gt; ",
    "categories": ["Network"],
    "tags": ["apache"]
  },
  {
    "title": "Django",
    "permalink": "https://canuxcheng.com/post/django/",
    "date": "2016-09-20",
    "summary": "\u003ch1 id=\"django\"\u003eDjango\u003c/h1\u003e\n\u003cp\u003edjango是python的web框架。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/django/django\"\u003ehttps://github.com/django/django\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.djangoproject.com/\"\u003ehttps://www.djangoproject.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.djangoproject.com/zh-hans/3.1/contents/\"\u003ehttps://docs.djangoproject.com/zh-hans/3.1/contents/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003edjango遵守MVC设计模式，采用MTV框架。\u003c/p\u003e\n\u003cp\u003eM: model,数据存取\u003c/p\u003e\n\u003cp\u003eT: template，如何展现数据\u003c/p\u003e\n\u003cp\u003eV: view，展现哪些数据\u003c/p\u003e\n\u003ch1 id=\"安装\"\u003e安装\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support\"\u003ehttps://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003edjango1.11是最后一个支持python2.7的长期支持版(2017.4).\u003c/p\u003e\n\u003cp\u003edjango2.0开始只支持python3(2018).\u003c/p\u003e\n\u003cp\u003e本文以django3.1为例创建名为next的project.\u003c/p\u003e\n\u003cp\u003evirtualenv中安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$mkdir next\n$cd next\n$virtualenv .venv\n\n# mac/linux\n$source .venv/bin/activate\n\n# windows\n\u0026gt;cd .venv/Scripts\n\u0026gt;activate\n\n$pip install django\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e验证安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$python\n\u0026gt;\u0026gt;\u0026gt;import django\n\u0026gt;\u0026gt;\u0026gt;django.VERSION\n\u0026gt;\u0026gt;\u0026gt;django.get_version()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装使用的数据库引擎的库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo udo apt-get install libmysqlclient-dev\n$ pip install mysqlclient\n\n$pip install psycopg2\n\n$pip install cx_Oracle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edjango默认是mysqlclient，可以使用pymysql替代：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# vim settings.py\nimport pymysql\npymysql.version_info = (1, 4, 13, \u0026quot;final\u0026quot;, 0)\npymysql.install_as_MySQLdb()\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"project\"\u003eproject\u003c/h1\u003e\n\u003cp\u003e创建一个名为next的项目\u003c/p\u003e",
    "content": "Django django是python的web框架。\nhttps://github.com/django/django\nhttps://www.djangoproject.com/\nhttps://docs.djangoproject.com/zh-hans/3.1/contents/\ndjango遵守MVC设计模式，采用MTV框架。\nM: model,数据存取\nT: template，如何展现数据\nV: view，展现哪些数据\n安装 https://docs.djangoproject.com/zh-hans/3.1/faq/install/#faq-python-version-support\ndjango1.11是最后一个支持python2.7的长期支持版(2017.4).\ndjango2.0开始只支持python3(2018).\n本文以django3.1为例创建名为next的project.\nvirtualenv中安装：\n$mkdir next $cd next $virtualenv .venv # mac/linux $source .venv/bin/activate # windows \u0026gt;cd .venv/Scripts \u0026gt;activate $pip install django 验证安装：\n$python \u0026gt;\u0026gt;\u0026gt;import django \u0026gt;\u0026gt;\u0026gt;django.VERSION \u0026gt;\u0026gt;\u0026gt;django.get_version() 安装使用的数据库引擎的库：\n$ sudo udo apt-get install libmysqlclient-dev $ pip install mysqlclient $pip install psycopg2 $pip install cx_Oracle django默认是mysqlclient，可以使用pymysql替代：\n# vim settings.py import pymysql pymysql.version_info = (1, 4, 13, \u0026quot;final\u0026quot;, 0) pymysql.install_as_MySQLdb() project 创建一个名为next的项目\n$ cd next $ django-admin startproject next. next |-- manage.py |-- next |- __init__.py |- settings.py |- urls.py |- wsgi.py |- asgi.py next 最外层根目录只是你项目的容器， 根目录名称对Django没有影响，你可以将它重命名为任何你喜欢的名称。\nmanage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。\ntemplates: project的模版.\nnext 里层的目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 next.urls).\nnext/init.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。\nnext/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。\nnext/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。\nnext/asgi.py：作为你的项目的运行在 ASGI 兼容的Web服务器上的入口。阅读 如何使用 ASGI 来部署 了解更多细节。\nnext/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。\n验证开发服务器：\n$python manage.py runserver $python manage.py runserver \u0026lt;ip address\u0026gt;:\u0026lt;port\u0026gt; \u0026gt; py manage.py runserver 浏览器输入：\nhttp://127.0.0.1:8000 settings.py 默认enable的app:\nINSTALLED_APPS = [ 'django.contrib.admin', //管理员站点， 你很快就会使用它。 'django.contrib.auth', //认证授权系统。 'django.contrib.contenttypes', //内容类型框架。/ 'django.contrib.sessions', //会话框架。 'django.contrib.messages', //消息框架。 'django.contrib.staticfiles', //管理静态文件的框架。 ] 默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表 $ python manage.py migrate \u0026gt; py manage.py migrate 默认enable的midleware:\nMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 支持的template:\nTEMPLATES = [ { 'BACKEND': 'django.template.backends.jinja2.Jinja2', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, } ] 默认的数据库:\nDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', 'TEST': { // 默认测试数据库是test_ 加 default.NAME，TEST可以指定数据库名字. 'NAME': 'test_db' } } } // 可扩展的数据库 ENGINE: django.db.backends.mysql django.db.backends.oracle django.db.badkends.postgresql_psycopg2 NAME: your database name USER: your database username PASSWORD: your database password HOST: local database or remote database PORT: database port 其它配置：\nBASE_DIR = Path(__file__).resolve().parent.parent SECRET_KEY = '-%b)79izbio$!(g!0io(he)giaqi1@))fzfq!t3s1g1dzysc(r' WSGI_APPLICATION = 'next.wsgi.application' ROOT_URLCONF = 'next.urls' DEBUG = True # 开发用来调试 DEBUG = False # 部署之后关闭 ALLOWED_HOSTS = [] # 设置哪些域名可以访问，优先级高于web服务器，debug=false必须设置 ALLOWED_HOSTS = [''*''] # 允许所有域名访问 STATIC_URL = '/static/' STATIC_ROOT = '/path/to/static' # static目录存放js/css等静态文件,collectstatic命令用来收集静态文件。 LANGUAGE_CODE = 'en-us' TIME_ZONE = 'UTC' USE_I18N = True USE_L10N = True USE_TZ = True urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls), ] 在项目的urls添加所有应用的urls，为每个应用独立创建urls，方便管理。\nwsgi.py Web Server Gateway Interface.\nimport os from django.core.wsgi import get_wsgi_application os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'next.settings') application = get_wsgi_application() django通过wsgi来部署，参考django的deploy。 asgi.py Asynchronous Server Gateway Interface.\nimport os from django.core.asgi import get_asgi_application os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'next.settings') application = get_asgi_application() application 应用，一个项目可以有多个应用，一个应用可以用到多个项目中。\n可以单独打包应用发布到pypi，包名格式django-project，参考python的打包方法。\n创建一个名为polls的应用：\n$python manage.py startapp polls \u0026gt; py manage.py startapp polls polls/ |- __init__.py |- admin.py |- apps.py |- models.py |- views.py |- tests.py (tests/test_case.py) |- migrations |- __init__.py |- templates |- polls |- index.html |- static |- polls |- style.css admin.py admin管理界面\napps.py\nmodels.py 模型\nviews.py 视图\nurls.py 新建的application的url\ntest.py 测试\nmigrations 迁移文件夹\ntemplates 应用的模版文件夹\nstatic 静态文件\ndjango-admin \u0026amp; manage.py [staticfiles] collectstatic # 设置STATIC_ROOT = '/var/www/static/project/'用来收集静态文件 findstatic runserver # 启动django自带的web开发服务器 [sessions] clearsessions [auth] changepassword createsuperuser [contenttypes] remove_stale_contenttypes [django] startapp startproject check compilemessages createcachetable dbshell # 数据库命令行 diffsettings dumpdata # 导出数据 (json, xml, yaml) dumpdata \u0026gt; db.json flush # 清空数据库 loaddata # 导入数据 loaddata db.json inspectdb makemessages makemigrations # 创建迁移文件 migrate # 创建/更新表结构（执行迁移文件） sendtestemail shell # 项目环境终端 showmigrations # 查看可迁移的文件 sqlflush sqlmigrate # 查看迁移文件会执行哪些sql sqlsequencereset squashmigrations test testserver ",
    "categories": ["Django"],
    "tags": ["django","web","python"]
  },
  {
    "title": "Http",
    "permalink": "https://canuxcheng.com/post/http/",
    "date": "2016-09-13",
    "summary": "\u003ch1 id=\"httphttps\"\u003eHTTP/HTTPS\u003c/h1\u003e\n\u003cp\u003ehttp port: 80\u003c/p\u003e\n\u003cp\u003ehttps port: 443\u003c/p\u003e\n\u003cp\u003ehttp/https的请求方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eget # 从服务器取出资源\npost # 在服务器新建资源\nput # 在服务器更新资源，客户端提供改变后的完整资源\ndelete # 从服务器删除资源\npatch # 在服务器更新资源，客户端提供改变的属性\nhead # 获取资源的源数据\noptions # 获取资源的哪些信息是客户端可以改变的信息\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eURL: Uniform Resource Locator\u003c/p\u003e\n\u003cp\u003eURI: Universal Resource Identifier\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;scheme\u0026gt;://\u0026lt;netloc\u0026gt;/\u0026lt;path\u0026gt;;\u0026lt;params\u0026gt;?\u0026lt;query\u0026gt;#\u0026lt;fragment\u0026gt;\nscheme: http/https/ftp/file\nnetloc: username:password@host:port\npath: /path/to/path\nparams: options arguments\nquery: connector\u0026amp;key-value\nfragment:\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"http命令\"\u003ehttp命令\u003c/h1\u003e\n\u003ch2 id=\"curl\"\u003ecurl\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl [options] [URL...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"httpie\"\u003ehttpie\u003c/h2\u003e\n\u003cp\u003epython开发的类似于curl的命令行工具，同时还有wget的功能．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jakubroztocil/httpie\"\u003ehttps://github.com/jakubroztocil/httpie\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo yum/apt-get install httpie\n\n$ http -a 'username:password' GET http://google.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"python的http标准库\"\u003epython的http标准库\u003c/h1\u003e\n\u003cp\u003epython2的http标准库\u003c/p\u003e",
    "content": "HTTP/HTTPS http port: 80\nhttps port: 443\nhttp/https的请求方式：\nget # 从服务器取出资源 post # 在服务器新建资源 put # 在服务器更新资源，客户端提供改变后的完整资源 delete # 从服务器删除资源 patch # 在服务器更新资源，客户端提供改变的属性 head # 获取资源的源数据 options # 获取资源的哪些信息是客户端可以改变的信息 URL: Uniform Resource Locator\nURI: Universal Resource Identifier\n\u0026lt;scheme\u0026gt;://\u0026lt;netloc\u0026gt;/\u0026lt;path\u0026gt;;\u0026lt;params\u0026gt;?\u0026lt;query\u0026gt;#\u0026lt;fragment\u0026gt; scheme: http/https/ftp/file netloc: username:password@host:port path: /path/to/path params: options arguments query: connector\u0026amp;key-value fragment: http命令 curl $ curl [options] [URL...] httpie python开发的类似于curl的命令行工具，同时还有wget的功能．\nhttps://github.com/jakubroztocil/httpie\n$ sudo yum/apt-get install httpie $ http -a 'username:password' GET http://google.com python的http标准库 python2的http标准库\nhttplib for client BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, cookielib, Cookie for server python3的标准库\nhttp python的url标准库 python2的url标准库：\nurlparse urllib urllib2 python3的url标准库：\nurllib ",
    "categories": ["Network"],
    "tags": ["http"]
  },
  {
    "title": "PSL_builtins",
    "permalink": "https://canuxcheng.com/post/psl_builtins/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"_builtins_\"\u003e_\u003cem\u003ebuiltins\u003c/em\u003e_\u003c/h1\u003e\n\u003cp\u003epython的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。\u003c/p\u003e\n\u003cp\u003e包括内置类类型以及所属的内置方法，和内置函数.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ebuiltin\u003c/strong\u003e - 包括内置类类型以及所属的内置方法，和内置函数.解释器不会自动导入．\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ebuiltins\u003c/strong\u003e - 仅仅是__builtin__的一个引用．解释器自动导入的．\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\n\u003cp\u003e内置常量\u003c/p\u003e\n\u003cp\u003e内置函数(BIF)\u003c/p\u003e\n\u003cp\u003e内置类型(BIT)\u003c/p\u003e\n\u003cp\u003e工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．\u003c/p\u003e\n\u003cp\u003e内置类型的内置方法(BIM)\u003c/p\u003e\n\u003cp\u003e内置异常\u003c/p\u003e\n\u003cp\u003e该模块是通过C/C++实现的．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"内置函数\"\u003e内置函数\u003c/h1\u003e\n\u003cp\u003epython2和python3共同的内置函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数\n\ncompile(source, filename, mode[, flags[, dont_inherit]])\n# 编译source返回一个code对象(代码对象)．\n# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;\nmodule = \u0026quot;for i in xrange(10): print(i)\u0026quot;\ncode = compile(module, '', 'exec')\ntype(code) # code\nexec code\n# mode: single, 用于单行语句, 也是用exec执行;\ncode = compile(\u0026quot;print 'test'\u0026quot;, '', single)\ntype(code) # code\nexec code\n# mode: eval, 用于表达式 可以用eval()函数执行． eg:\nexpression = \u0026quot;3 * 4\u0026quot;\ncode = compile(expression, '', 'eval')\ntype(code) # code\neval(code)\n\neval(source[, globals[, locals]])\n# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．\n\nformat(value[, format_spec]) # 返回格式化后的字符串形式．\n\n## 环境变量相关\nglobals() # 返回当前作用域的全局名称空间的字典．\nlocals() # 返回当前作用域的局部名称空间的字典．\n\n## 数字类型的数学运算\nabs(number) # 返回int/long的绝对值\ndivmod(x, y) # 返回x/y 的　(商，余数) 组成的元组\npow(x, y[, z]) # 返回x**y或(x**y) % z\nround(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.\nchr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 \u0026lt;= i \u0026lt; 256.\nord(c) # 返回字符ASCII字符c对应的整数.\nbin(number) # 返回int/long的二进制的字符串形式\noct(number) # 返回int/long的八进制的字符串形式．\nhex(number) # 返回int/long的十六进制的字符串形式.\n\n## 对象相关的操作\nid(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.\nrepr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.\ncallable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()\nhash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.\nlen(object) # 返回序列（str, tuple, list)或映射（dict)的长度\ndir([object]) # 查看对象的信息\ngetattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．\nhasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.\nsetattr(object, name, value) # 给对象的属性赋值，相当于object.name = value\ndelattr(object, name) # 删除对象object的属性name\nisinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.\nissubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．\nvars([object]) # 没有参数等于locals()，有参数等于object.__dict__.\n\n## related to iterable\nmin(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素\nmin(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素\nmax(iterable[, key=func]) # 和min相反\nmax(a, b, c, ...[, key=func]) # 和min相反\nall(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,''则返回True,iterable为空也返回True,否则返回False\nany(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,''则返回False,　否则返回True\nsum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．\n\n## related to iterator\niter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.\niter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．\nnext(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．\n\n## related to input\ninput([prompt]) # 等于eval(raw_input(prompt))\n# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.\n\n## related to file\nopen(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e[New]python3新增的内置函数：\u003c/p\u003e",
    "content": "_builtins_ python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。\n包括内置类类型以及所属的内置方法，和内置函数.\nbuiltin - 包括内置类类型以及所属的内置方法，和内置函数.解释器不会自动导入．\nbuiltins - 仅仅是__builtin__的一个引用．解释器自动导入的．\n内置常量\n内置函数(BIF)\n内置类型(BIT)\n工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．\n内置类型的内置方法(BIM)\n内置异常\n该模块是通过C/C++实现的．\n内置函数 python2和python3共同的内置函数：\n__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数 compile(source, filename, mode[, flags[, dont_inherit]]) # 编译source返回一个code对象(代码对象)． # mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数; module = \u0026quot;for i in xrange(10): print(i)\u0026quot; code = compile(module, '', 'exec') type(code) # code exec code # mode: single, 用于单行语句, 也是用exec执行; code = compile(\u0026quot;print 'test'\u0026quot;, '', single) type(code) # code exec code # mode: eval, 用于表达式 可以用eval()函数执行． eg: expression = \u0026quot;3 * 4\u0026quot; code = compile(expression, '', 'eval') type(code) # code eval(code) eval(source[, globals[, locals]]) # 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式． format(value[, format_spec]) # 返回格式化后的字符串形式． ## 环境变量相关 globals() # 返回当前作用域的全局名称空间的字典． locals() # 返回当前作用域的局部名称空间的字典． ## 数字类型的数学运算 abs(number) # 返回int/long的绝对值 divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组 pow(x, y[, z]) # 返回x**y或(x**y) % z round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0. chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 \u0026lt;= i \u0026lt; 256. ord(c) # 返回字符ASCII字符c对应的整数. bin(number) # 返回int/long的二进制的字符串形式 oct(number) # 返回int/long的八进制的字符串形式． hex(number) # 返回int/long的十六进制的字符串形式. ## 对象相关的操作 id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字. repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object. callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__() hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键. len(object) # 返回序列（str, tuple, list)或映射（dict)的长度 dir([object]) # 查看对象的信息 getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样． hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False. setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value delattr(object, name) # 删除对象object的属性name isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False. issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类． vars([object]) # 没有参数等于locals()，有参数等于object.__dict__. ## related to iterable min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素 min(a, b, c, ...[, key=func]) # 返回a,b,c...中的最小元素 max(iterable[, key=func]) # 和min相反 max(a, b, c, ...[, key=func]) # 和min相反 all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,''则返回True,iterable为空也返回True,否则返回False any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,''则返回False,　否则返回True sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０． ## related to iterator iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象. iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止． next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常． ## related to input input([prompt]) # 等于eval(raw_input(prompt)) # 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回. ## related to file open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象． [New]python3新增的内置函数：\nexec(object[, globals[, locals]]) # python2中是一个关键字，python3才是内置函数． # object可以是一个文件对象，也可以是一个语句或代码块． ascii(object) # 和repr()函数等效． print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) # python2中是一个关键字，python3才是内置函数． [Deprecated]python2.7中有，python3中被废弃的内置函数：\napply(object[, args[, kwargs]]) # 直接使用函数定义的可变长参数形式, function_name(*args, **kwargs) # python2中还可以使用的函数 coerce(x, y) intern(string) execfile(filename[, globals[, locals]]) # 类似于exec unichr(i) # 返回chr(i)的unicode形式． # 建议使用替代方法的函数 raw_input([prompt]) # python3中合并为input(). 不会对输入的表达式求值，以字符串的形式原样返回． `` # python3中合并为repr() cmp(x, y) # 参考python3的operator.cmp() reduce(function, sequence[, initial]) # 参考python3的functools.reduce() reload(module) # 参考python3的imp.reload() [Changed]python3中发生变化的函数:\n// python2 sorted(iterable, cmp=None, key=None, reverse=False) # 返回可迭代对象iterable的元素排序后组成的列表． // python3 sorted(iterable, key=None, reverse=False) // 多维数据排序 dict = {'a': 3, 'b': 2, 'c': 1} sorted(dict.items(), key=lambda x:x[1], reverse=False) json = [{\u0026quot;time\u0026quot;: 1, \u0026quot;data\u0026quot;: \u0026quot;message\u0026quot;}, {\u0026quot;time\u0026quot;: 2, \u0026quot;data\u0026quot;: \u0026quot;message\u0026quot;}] sorted(json, key=lambda k:k[\u0026quot;time\u0026quot;]) 内置常量 False # 内置类型bool的实例 True # 内置类型bool的实例 None # python的Null对象或types.NoneType,只有一个值None.布尔值始终为False. NotImplemented # types.NotImplementedType Ellipsis # types.EllipsisType, 省略对象，布尔值始终为True. __debug__ # True/False 内置特殊属性 object.__dict__ # 以字典的形式存储对象的属性 class.__bases__ # 类的父类构成的元组 instance.__class__ # 实例对应的类 definition.__name__ # class/type/function/method/descriptor/generator的名字 [New in python2.2] 新式类才有的三个属性： class.__mro__ class.mro() class.__subclasses__() [New in python3] definition.__qualname__ # python3新增 [Deprecated]object.__methods__ # 用内置函数dir()代替 [Deprecated]object.__members__ # 用内置函数dir()代替 python2内置异常 BaseException(object) # 所有异常的基类, 继承自object.\n# BaseException的四个子类 SystemExit # python解释器请求退出 KeyboardInterrupt # 用户输入ctrl-c中断执行 GeneratorExit # 生成器发出异常来通知退出 Exception # 常规错误的基类 StopIteration # 迭代器结束抛出的异常 StandardError # 所有内置标准error的基类 BufferError ArithmeticError # 数值计算错误的基类 FloatingPointError OverflowError ZeroDivisionError # 除法分母为０错误 AsseertionError # 断言语句失败 AttributeError # 访问未知的对象属性 EnvironmentError IOError # 打开不存在的磁盘文件导致的输入/输出错误 OSError WindowError VMSError EOFError ImportError LookupError IndexError # 序列的索引错误 KeyError # 字典的键错误 MemoryError NameError # 未申明或初始化的对象 UnboundLocalError ReferenceError RuntimeError # 一般的运行错误 NotImplementedError # 尚未实现的方法 SyntaxError # 语法错误， 唯一不在运行时发生的异常 IndentationError # 缩进错误 TabError # 跳格和空格混用 SystemError # 一般的解释器系统错误 TypeError # 对类型无效的操作 ValueError # 传入无效的参数 UnicodeError UnicodeDecodeError UnicodeEncodeError UnicodeTranslateError Warning # 所有warning的基类 DeprecationWarning # 被弃用特征的警告 RuntimeWarning # 可疑的运行时行为警告 SyntaxWarning # 可疑的语法行为警告 UserWarning # 用户代码生成的警告 FutureWarning # 使用新的语法特征的警告 ImportWarning # 导入包警告 UnicodeWarning ByteWarning python3内置异常 BaseException(object) # 所有异常的基类, 继承自object.\nSystemExit KeyboardInterrupt GeneratorExit Exception StopIteration StopAsyncIteration ArithmeticError ... Warning # 所有warning的基类 DeprecationWarning ... object object类是所有类的基类\n继承自object的内置类类型都有对应的工厂函数．\npython2数字类型(int, long, float, complex)是不可变类型,是标量，是直接存储的．\npython3数字类型int, float, complex\nint int(x=0) int(x, base=10) 内置方法:\nbit_length() # 一个int类型的二进制形式的位数． conjugate() 内置数据描述符：\ndenominator numerator imag real bool(int) bool(x) 内置类类型int的内置方法和数据描述符都是继承自基类int.\n(long) python2中的重要的内置类型．\npython3中被废弃．\nlong(x=0) long(x, base=10) 内置方法:\nbit_length() # 一个int类型的二进制形式的位数 conjugate() 内置数据描述符:\ndenominator numerator imag real float float(x) 内置方法:\nas_integer_ratio() # 返回一个整数对，相除的结果是该浮点数 conjugate() fromhex(string) # 将十六进制的字符转换成浮点型 # float.fromhex('-0x1p-1074') hex() # 将浮点数转换成十六进制形式 is_integer() # 如果浮点数是整数，返回true 内置数据描述符：\nimag real complex complex(real[, imag]) 内置方法:\nconjugate() # 返回一个复数的工軛复数 内置数据描述符：\nimag 复数的虚部 real 复数的实部 python2序列包括str, list, tuple, bytearray, unicode, buffer, xrange.都是可迭代的．\npython3序列包括str, list, tuple, bytearray, range, bytes, memoryview.都是可迭代的．\n(basestring) python2中basestring是str类和unicode类的基类, basestring继承自object.\npython3中str类直接继承自object，没有unicode和basestring.\nstr 字符串是不可变类型, 是标量，是序列．\nstr(object='') # 把一个对象转换成字符串．或者返回一个对象的可读性好的字符串表示，无法用语eval()求值． 内置方法：\ncapitalize() # 字符串首字母大写, 返回新的字符串 title() # 所有单词首字母大写，返回新的字符串 lower() # 所有字符小写，返回新的字符串 upper() # 所有字符大写，返回新的字符串 swapcase() # 大写字符转换成小写，小写转化成大写 translate(table [,deletechars]) # join(iterable) # 用字符串分割iterable,返回新的字符串 replace(old, new[, count]) # 用new替换字符串中的前count个old, 返回替换后的字符串 expandtabs([tabsize]) # 把字符串中的tab键替换为tabsize指定的宽度的新tab，默认是8,然后返回新的字符串 format(*args, **kwargs) # 返回格式化后的字符串 lstrip([chars]) # 如果字符串以chars开头,就删除开头chars，然后返回新的字符串, chars默认是空格． strip([chars]) # 删除开头和结尾的chars,如果有的话，然后返回新的字符串，chars默认是空格． rstrip([chars]) # 如果字符串以chars结尾，就删除结尾的chars,然后返回新的字符串，chars默认是空格． center(width[, fillchar]) # 以字符串为中心填充字符串，默认用空格填充,返回填充后的字符串 zfill(width) # 用0填充字符串的左边，直到width长度，返回新的字符串 ljust(width[, fillchar]) # 字符串左对齐，右边填充fillchar,默认空格，直到长度为width,返回新的字符串 rjust(width[, fillchar]) # 字符串右对齐，左边填充fillchar，默认空格，直到长度为width,返回新的字符串 count(sub[, start[, end]]) # 返回sub字符串在str[start:end]中出现的次数 # 参考codecs模块的decode/encode. decode([encoding[,errors]]) # 解码 encode([encoding[,errors]]) # 编码 startswith(prefix[, start[, end]]) # 如果str[start:end]以prefix开头，返回true. endswith(suffix[, start[, end]]) # 如果str[start:end]以suffix结尾，返回true. isalnum() # 如果非空字符串，且元素都是字符或数字，返回True,否则返回False isalpha() # 如果非空字符串，且元素都是字符，返回True,否则返回False isdigit() # 如果非空字符串，且元素都是数字，返回True,否则返回False isspace() # 如果非空字符串，且所有元素都是空格，返回True,否则返回False istitle() # 如果非空字符串，且所有单词的首字母大写，返回True,否则返回False islower() # 如果非空字符串，且所有元素都是小写，返回True,否则返回False isupper() # 如果非空字符串，且所有单词都是大写，返回True,否则返回False splitlines(keepends=False) # 根据\\n,\\r,\\r\\n来拆分字符串，返回拆分后的列表，True表示保留换行符，默认是False． split([sep [,maxsplit]]) # 将字符串以从左到右的maxsplit个seq分割，返回分割后的列表，默认seq是空格，maxsplit是所有seq． rsplit([sep [,maxsplit]]) # 和split相反,从右到左的maxsplit个seq分割． partition(sep) # 字符串根据从左往右根据第一个找到的seq分割，返回一个(head, seq, tail), 如果没有找到seq, 返回(str, '', ''). rpartition(sep) # 字符串根据最后一个找到的seq分割，返回(head, seq, tail),如果没有找到seq,返回('', '', str) find(sub [,start [,end]]) # 在str[start:end]中从左往右查找sub,返回找到的第一个字符所在的下标,没找到返回-1 rfind(sub [,start [,end]]) # 在str[start:end]中查找sub,返回最后一个sub的第一个元素的索引,没有找到返回-1 index(sub [,start [,end]]) # 和find一样，但是没找到抛出异常ValueError． rindex(sub [,start [,end]]) # 和rfind一样，但是没找到抛出ValueError异常． (unicode) python2中的内置类型，和str是兄弟类型．\npython3中被废弃．\npython2中的unicode的工厂函数:\nunicode(object='') unicode(string[, encoding[, errors]]) tuple 元组是不可变类型, 是容器，是序列.\ntuple() tuple(iterable) # 把可迭代对象转换成元组. 内置方法：\ncount(value) # 返回值为value的元素在元组中出现的次数 index(value, [start, [stop]]) # 返回值为value的元素在元组tuple[start:stop]中的第一次出现的索引，没有该元素返回ValueError. (xrange) python2的重要的内置类型．\npython3中将range和xrange合并为range类．\nxrange和range功能一样，但是返回的是xrange类型的可迭代对象．\nxrange比range更轻量级，更快，内存使用更高效．\nxrange(stop) xrange(start, stop[, step]) (buffer) python2中的内置类型．\npython3中被废弃．\nlist 列表是可变类型,　是容器，是序列.\nlist() list(iterable) # 把可迭代的对象转换成列表． 内置方法：\ncount(value) # 返回value在列表中出现的次数 index(value, [start, [stop]]) # 从左往右在list[start:stop]中寻找value,返回第一个找到的元素的索引，否则返回ValueError异常． # 下列改变列表的值的方法都没有返回值，直接改变原列表的值． append(object) # 在列表结尾追加对象 extend(iterable) # 将可迭代对象iterable的元素依次追加到列表,相当于序列的+运算． insert(index, object) # 在list[index]前面插入object. pop([index]) # 删除list[index],默认是最后一个元素，如果列表为空或索引越界，抛出IndexError异常． remove(value) # 删除第一个出现的value． reverse() # 翻转列表 sort(cmp=None, key=None, reverse=False) # 默认对列表中的元素从小到大排序，reverse=True,则从大到小． dict 字典是可变类型, 是容器，是映射类型（mapping), 字典可以迭代键．字典是无序的．\ndict() dict(mapping) # dict(one=1, two=2) dict(iterable) # dict([(1, 'one'), (2, 'two')]), dict([[1,1], [2,2]]), dict(([1,1], [2, 2])), dict(((1,1), (2,2))), dict(**kwargs) # dict({1:\u0026quot;one\u0026quot;, 2:\u0026quot;two\u0026quot;}) 内置方法：\ncopy() # 返回字典的一个浅拷贝 clear() # 清空字典所有元素 fromkeys(S[,v]) # 返回以S的元素为键，v为值的新字典，v默认为None. get(k[,d]) # 如果键k在字典里面，返回dict[k], 否则返回d, d默认为None. [Deprecated]has_key(k) # 如果键k在字典里面，返回True,否则返回False. 使用in和not in代替. pop(k[,d]) # 从字典中删除键k的键值对，返回dict[k], 如果不存在返回d,如果没有指定d,抛出KeyError异常． popitem() # 从字典中删除随机的键值对，返回该键值对组成的元组，如果字典为空，抛出KeyError异常． setdefault(k[,d]) # 如果键k在字典中存在，等效于get(k[,d]), 否则就插入D[k]=d键值对． update([E, ]**F) # 向字典插入指定的项目(字典或可迭代对象). keys() # 返回字典的键组成的列表． values() # 返回字典的值组成的列表． items() # 返回一个列表，每个元素是字典的键和值组成的元组． iteritems() # 返回字典的键值对组成的迭代器，next()每次返回一个一对键值组成的元组． iterkeys() # 返回字典的键组成的迭代器． itervalues() # 返回字典的值组成的迭代器． viewitems() # 返回键和值组成的可迭代对象 viewkeys()　# 返回键组成的可迭代对象 viewvalues() # 返回值组成的可迭代对象 frozenset 不可变集合frozenset是不可变类型\nfrozenset() frozenset(iterable) 不可变集合和可变集合共同的内置方法：\ncopy() # 返回集合的一个浅拷贝 isdisjoint() # 两个集合交集为空，返回为True. a.issubset(b) # a是b的非严格子集，　a \u0026lt;= b, 返回True a.issuperset(b) # a是b的非严格超集, a \u0026gt;= b, 返回True union() # 联合/并集，OR操作，等效于|运算符 intersection([others, ...]) # 交集，　AND操作，　等效于\u0026amp;运算符 difference([others, ...]) # 差补或相对补充集，等效于-运算符 symmetric_difference() # 对称差分或异或，等效于^运算符 set 可变集合set是可变类型\nset() set(iterable) set除了有frozenset的所有方法还有自己特有的内置方法：\nclear() # 清空集合所有元素 pop() # 删除并返回任意一个集合元素，集合为空抛出KeyError. add(obj) # 往集合中添加一个不存在的元素 remove(obj) # 删除集合中的存在的指定的数字元素, 非数字抛出KeyError. a.discard(obj) # 如果obj是集合s中的元素，从s中删除obj. update() # 等效于|=运算符 intersection_update() # 等效于\u0026amp;=运算符 difference_update() # 等效于-=运算法 symmetric_difference_update() # 等效于^=运算符 (file) python2中的内置类型．使用open()内置函数．\npython3中被废弃．用open()内置函数代替．\nfile是python2中的内置类类型，有next()方法，返回一个迭代器的file类型．\nfile(name[, mode[, buffering]]) 内置方法:\nclose() next() fileno() # 返回打开的文件的描述符. flush() # 把内部缓冲区的数据立即写入文件． isatty() # 文件是tty设备返回True. # 文件输入操作 read([size]) # 从文件读取size个字节到字符串并返回，默认读取到文件结尾．保留行结束符． readline([size]) # 读取一行的size个字符到字符串并返回，默认读取文件的一行，包括行结束符． readlines([size]) # 读取文件所有行，返回行组成的字符串列表，size表示返回的最大字节数. [depredated] xreadlines() [deprecated] readinto() # 文件输出操作 write(str) # 往文件中写．如果str表示一行，需要手动加上行结束符． writelines(sequence_of_strings) # 往文件写入一个字符串列表，需要手动给列表元素加上行结束符． # 文件内移动 seek(offset[, whence]) tell() truncate([size]) 内置数据描述符：\nclosed encoding mode name newlines softspace errors slice python2:\nslice(stop) slice(start, stop[, step]) 内置方法:\nindices(len) -\u0026gt; (start, stop, stride) 内置数据描述符：\nstart step stop enumerate python2:\nenumerate是一个内置的类类型，有next()内置方法，是迭代器．\nenumerate(iterable[, start]) # 返回一个可迭代的enumerate类型的迭代器，生成一个元组序列，包含从start 开始的索引，默认是０，和从iterable取出的值． a = enumerate([1,2,3]) for index, item in a: print(index, item) type(a) # enumerate a.next() reversed python2:\nreversed是一个内置类类型，有next()方法，是迭代器．\nreversed(sequence) # 反转sequence序列的元素的值，返回反转后的reversed类型的迭代器． a = reversed((1,2,3)) for i in a: print(i) type(a) # reversed a.next() python2中的函数在python3变为类类型．\nrange python2中的内置函数：\nrange(stop) # 返回[0, 1, stop-1]的列表 range(start, stop[, step]) # 返回[start, start+n*step... ], n\u0026gt;=1,start+n*step\u0026lt;stop. python3中的内置类类型：\nzip python2中的内置函数：\nzip(seq1 [, seq2 [...]]) # 返回一个列表，元素是序列中相同下标元素组成的元组，只取到所有序列的最小的下标． zip((1,2,3),(4,5,6),(7,8)) -\u0026gt; [(1, 4, 7), (2, 5, 8)] python3中的内置类类型：\nfilter python2中的函数式编程的内置函数．\npython2中的内置函数：\nfilter(function or None, sequence) # 对sequence序列中的所有元素调用function，返回所有function结果为True的结果组成的列表／元组／字符串． # filter(lambda x: x % 2, [1,2,3]) -\u0026gt; [1,3] # filter(None, (1,2,3)) -\u0026gt; (1,2,3) python3中的内置类类型：\nmap python2中的函数式编程的内置函数．\npython2中的内置函数：\nmap(function, sequence[, sequence, ...]) # 将序列中相同下标的元素作为参数传给function，返回所有的结果组成的列表． # map(lambda x: x*2, [1,2,3]) -\u0026gt; [2,4,6] # map(lambda x,y,z: str(x)+str(y)+str(z), \u0026quot;test\u0026quot;, (1,2,3), [0,9,8,7,6]) -\u0026gt; ['t10', 'e29', 's38', 'tNone7', 'NoneNone6'] # map(None, \u0026quot;test\u0026quot;, (1,2,3)) -\u0026gt; [('t', 1), ('e', 2), ('s', 3), ('t', None)] python3中的内置类类型：\nbytes, bytearray, memoryview都是python3中的binary sequence序列类型\nbytes python2:\npython2中是str类型的别名．\npython3中是内置类类型:\nbytes(iterable_of_ints) bytes(string, encoding[, errors]) -\u0026gt; bytes bytes(bytes_or_buffer) -\u0026gt; immutable copy of bytes_or_buffer bytes(int) -\u0026gt; bytes object of size given by the parameter initialized with null bytes bytes() -\u0026gt; empty bytes object 内置方法：\ncapitalize() ... bytearray python2:\nbytearray表示可变字节数组类型．\nbytearray是可变类型，是序列（可迭代）\nbytearray(int) bytearray(iterable_of_ints) bytearray(string, encoding[, errors]) bytearray(bytes_or_bytearray) bytearray(memory_view) 内置方法:\nappend(int) capitalize() ... memoryview python2:\nmemoryview(object) 内置方法:\ntobytes(...) tolist(...) ... 内置数据描述符：\nformat ... type python2:\ntype(object) # 返回object对象的类型, 也就是对象的类型． type(name, bases, dict) # a new type 内置方法:\nmro() # 返回一个类型的method resolution order 内置数据描述符：\n__abstractmethods__ ... 参考面向对象编程．\nsuper super(type, obj) super(type, type2) super(type) 内置方法：\n__get__(...) __getattribute__(...) __init__(...) __repr__(...) 内置数据描述符：\n__self__ __self_class__ __thisclass__ python内置的三个装饰器\nclassmethod classmethod(function) 内置方法：\n__get__(...) __getattribute__(...) __init__(...) 内置数据描述符：\n__func__ staticmethod staticmethod(function) 内置方法：\n__get__(...) __getattribute__(...) __init__(...) 内置数据描述符：\n__func__ property property(fget=None, fset=None, fdel=None, doc=None) 内置方法：\n__delete__(...) __get__(...) __getattribute__(...) __init__(...) __set__(...) deleter(...) getter(...) setter(...) 内置数据描述符：\nfdel fget fset ",
    "categories": ["Python"],
    "tags": ["builtin"]
  },
  {
    "title": "PSL_Concurrency",
    "permalink": "https://canuxcheng.com/post/psl_concurrency/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"concurrent-execution\"\u003eConcurrent Execution\u003c/h1\u003e\n\u003cp\u003e进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。\u003c/p\u003e\n\u003cp\u003e线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。\u003c/p\u003e\n\u003cp\u003eIPC: 进程/线程之间交换信息叫进程间通信．\u003c/p\u003e\n\u003cp\u003epython的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.\u003c/p\u003e\n\u003cp\u003eIO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.\u003c/p\u003e\n\u003cp\u003epython的多进程可以并行,每个进程启动一个解释器进程.\u003c/p\u003e\n\u003cp\u003e多进程开销大，消耗内存.\u003c/p\u003e\n\u003cp\u003e计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.\u003c/p\u003e\n\u003ch2 id=\"multiprocessing\"\u003emultiprocessing\u003c/h2\u003e\n\u003cp\u003e多进程就是同时执行多个任务.\u003c/p\u003e\n\u003cp\u003epython可以通过多进程取代多线程，从而绕过多线程的GIL.\u003c/p\u003e\n\u003cp\u003epython是静态语言，\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport multiprocessing\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# multiprocessing.Process\nproc = Process(group=None, target=None, name=None, args=(), kwargs={})\n# methods:\nrun(self)\nstart(self) # 启动一个进程\njoin(self, timeout=None) # 父进程等待子进程结束\nis_alive()\nterminate(self)\n# data descriptor:\nauthkey\ndaemon # proc.daemon = True 后台运行\nexitcode\nident\nname\npid\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 普通函数\nactive_children()\nallow_connection_pickling()\ncpu_count() # 获取cpu个数\ncurrent_process()\nfreeze_support()\nget_logger()\nlog_to_stderr(level=None)\n\nPool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)\npool = Pool()\n# func只能是顶层函数，不能是方法和内部函数.\n# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())\n# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.\napply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,\nmap_async(func, iterable, chunksize=None, callback=None) # 非阻塞\n# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.\napply(func, args=(), kwargs={}) # 阻塞\nmap(func, itreable, chunksize=None) # 阻塞\nterminate() # 终止所有任务\nclose() # 关闭pool,不接受新任务\njoin() # 等待pool中子进程结束，要在close/terminate之后调用.\n\n# IPC: 管道\nPipe(duplex=True) # duplex=True表示默认是双向pipe.\nreceiver, sender = Pipe()\nsender.send(obj)\nreceiver.recv()\nclose()\n\n# IPC: 消息队列\n# 来自于Queue.Queue, 具体方法参考Queue.Queue\nQueue(maxsize=0) # return a queue object\nq = Queue()\n\n# IPC: 共享内存\nManager()\nlist, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array\n\nArray(typecode_or_type, size_or_initializer, **kwds)\n\nRawArray(typecode_or_type, size_or_initializer)\n\nValue(typecode_or_type, *args, **kwds)\n\nRawValue(typecode_or_type, *args)\n\nEvent()\n\n# 同步：　条件变量\nCondition(lock=None)\n\n# 同步：信号量\nSemaphore(value=1)\n\n# 同步：有界信号量\nBoundedSemaphore(value=1)\n\n# 同步： 锁\nLock()\n\n# 同步: 锁\nRLock()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e",
    "content": "Concurrent Execution 进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。\n线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。\nIPC: 进程/线程之间交换信息叫进程间通信．\npython的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.\nIO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.\npython的多进程可以并行,每个进程启动一个解释器进程.\n多进程开销大，消耗内存.\n计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.\nmultiprocessing 多进程就是同时执行多个任务.\npython可以通过多进程取代多线程，从而绕过多线程的GIL.\npython是静态语言，\nimport multiprocessing classes:\n# multiprocessing.Process proc = Process(group=None, target=None, name=None, args=(), kwargs={}) # methods: run(self) start(self) # 启动一个进程 join(self, timeout=None) # 父进程等待子进程结束 is_alive() terminate(self) # data descriptor: authkey daemon # proc.daemon = True 后台运行 exitcode ident name pid functions:\n# 普通函数 active_children() allow_connection_pickling() cpu_count() # 获取cpu个数 current_process() freeze_support() get_logger() log_to_stderr(level=None) Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None) pool = Pool() # func只能是顶层函数，不能是方法和内部函数. # 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count()) # 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行. apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞, map_async(func, iterable, chunksize=None, callback=None) # 非阻塞 # 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行. apply(func, args=(), kwargs={}) # 阻塞 map(func, itreable, chunksize=None) # 阻塞 terminate() # 终止所有任务 close() # 关闭pool,不接受新任务 join() # 等待pool中子进程结束，要在close/terminate之后调用. # IPC: 管道 Pipe(duplex=True) # duplex=True表示默认是双向pipe. receiver, sender = Pipe() sender.send(obj) receiver.recv() close() # IPC: 消息队列 # 来自于Queue.Queue, 具体方法参考Queue.Queue Queue(maxsize=0) # return a queue object q = Queue() # IPC: 共享内存 Manager() list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array Array(typecode_or_type, size_or_initializer, **kwds) RawArray(typecode_or_type, size_or_initializer) Value(typecode_or_type, *args, **kwds) RawValue(typecode_or_type, *args) Event() # 同步：　条件变量 Condition(lock=None) # 同步：信号量 Semaphore(value=1) # 同步：有界信号量 BoundedSemaphore(value=1) # 同步： 锁 Lock() # 同步: 锁 RLock() data:\nSUBDEBUG = 5 SUBWARNING = 25 threading 多线程就是把单个任务分成不同部分运行.\nthreading支持守护线程(通过join方法实现)．\nimport threading classes:\n# threading.Thread t = Thread(group=None, target=None, name=None, args=(), kwargs=None, verbose=None) threads.append(t) # methods: run(self) # 子类重写用来定义线程的功能的函数, 通常通过这种方式来创建线程 start(self) # 开始执行线程 join(self, timeout=None) # 主程序挂起，直到线程结束,再继续运行主程序 is_alive(self) # 表示线程是否还在运行的boolean getName(self) # 返回线程名字 setName(self, name) # 设置线程名字 isDaemon(self) # 返回线程的daemon标志 setDaemon(self, daemonic) # daemonic=True 使线程在后台运行 functions:\nactive_count() # 当前活动的线程对象的数量 current_thread() # 返回当前线程对象 enumerate() # 返回当前活动线程列表 settrace(func) # 为所有的线程设置一个跟踪函数 setprofile(func) # 为所有线程设置一个profile函数 stack_size() Timer(*args, **kwargs) t = Timer(30.0, f, args=[], kwargs={}) t.start() # 在一个子线程等待，timeout就执行f(*args, **kwaargs). t.cancel() # 如果还在等待就取消． Event(*args, **kwargs) # 同步：　条件变量 Condition(*args, **kwargs) # 同步：　信号量 Semaphore(value=1, *args, **kwargs) # 信号量，默认value=1, 内部计数器不能小于0,当计数器==0时，调用acquire会阻塞. # 同步：　有界信号量 BoundedSemaphore(value=1, *args, **kwargs) # 有界信号量，默认value=1，内部计数器不能小于0，并且不能大于value。 # 当计数器==0，调用acquire会阻塞，当\u0026gt;value抛出VAlueError异常 # 可用来控制并发运行的线程数量 bs = BoundSemaphore(number) # bs是全局的. def thread_function(*args, **kwargs): ... bs.release() # 使计数器+1 for t in threads: bs.acquire() # 使计数器-1 thread.start() for t in threads: t.join() # 同步：　锁 Lock() # 使同一变量在多个线程间同步 lock = Lock() variable = value def thread_function(*args, **kwargs): global lock global variable lock.acquire() # 加锁，使线程进入同步阻塞状态 variable = new_value lock.release() # 释放锁 # 同步：　锁 RLock(*args, **kwargs) subprocess 开启一个子进程来执行外部命令.\nimport subprocess classes:\nPopen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False,cwd=None, env=None, universal_newlines=False,startupinfo=None, creationflags=0) # p = Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE) # 如果命令和参数是字符串形式，需要参数shell=True # p = Popen(command_string, shell=True, ...) # 非交互执行sudo命令, 或者使用sh/pexpect等第三方库 Popen(['sudo', '-S'] + shlex.split(command), stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, ...) stdout, stderr = child.communicate(password+'\\n') # methods: poll() # 检查子进程是否结束，返回returncode. wait() # 等待子进程结束，返回returncode. communicate(input=None) # 返回(stdout, stderr). kill() # 发送SIGKILL信号 pipe_cloexec() send_signal(sig) terminate() # Data: stdin stdout stderr pid returncode functions:\ncall(*popenargs, **kwargs) # retcode = call([\u0026quot;ls\u0026quot;, \u0026quot;-l\u0026quot;]) check_call(*popenargs, **kwargs) # check_call([\u0026quot;ls\u0026quot;, \u0026quot;-l\u0026quot;]) -\u0026gt; 如果返回码为０就返回，否则抛出CalledProcessError. check_output(*popenargs, **kwargs) # 返回一个字符串 # output = check_output([\u0026quot;ls\u0026quot;, \u0026quot;-l\u0026quot;, \u0026quot;/dev/null\u0026quot;]) -\u0026gt; 如果返回码为０返回命令结果，否则抛出CalledProcessError. data:\nPIPE = -1 STDOUT = -2 sched queue dummy_threading Interprocess Communication and Networking socket socket协议的标准库\nimport socket classes:\n# socket = class _socketobject(__builtin__.object) # socket.socket([family[, type[, proto]]]) close() # 关闭socket shutdown(flag) # 0 关闭读，１关闭写，２全部关闭 # eg: socket.socket(AF_INET, SOCK_STREAM, 0) ipv4+tcp # eg: socket.socket(AF_INET, SOCK_DGRAM, 0) ipv4+udp # methods: bind(address) # 服务器绑定(host, port)到socket listen(backlog) # 服务器开始监听tcp accept() # 服务器阻塞等待客户的tcp连接, 返回(socket object, address info) connect(address) # 客户端主动初始化tcp连接,连接失败抛出异常 connect_ex(address) # 同上，连接失败返回errno send(data[, flags]) # 发送tcp数据 sendall(data[, flags]) # 发送完整tcp数据 recv(buflen[, flags]) # 接收tcp数据 recv_into(buffer[, nbytes[, flags]]) sendto(data[, flags], addr) # 发送udp数据 recvfrom(buflen[, flags]) # 接收udp数据 recvfrom_into(buffer[, nbytes, [, flags])]) getpeername() # 获取当前socket的远端地址 getsockname() # 获取当前socket的地址 getsockopt(level, option[, buffersize]) # 获取socket参数 setsockopt(level, option, value) # 设置socket参数 setblocking(flag) gettimeout() settimeout(timeout) makefile([mode[, bufsize]]) fileno() dup() # data descriptor: family/type/proto　参考man 2 socket recv recv_into recvfrom recvfrom_into send sendto class SocketIO:\nclass SocketIO(io.RawIOBase) sio = SocketIO(sock, mode) methods: close() readinto(b) write(b) functions:\ncreate_connection(address, timeout=\u0026lt;object object\u0026gt;, source_address=None) fromfd(fd, family, type[, proto]) # 用一个已经打开的文件描述符创建一个socket对象 getaddrinfo(host, port [, family, socktype, proto, flags]) getdefaulttimeout() getfqdn(name='') # FQDN, 获取完整域的信息 gethostbyaddr(host) -\u0026gt; (name, aliaslist, addresslist) gethostbyname(host) gethostbyname_ex(host) -\u0026gt; (name, aliaslist, addresslist) gethostname() getnameinfo(sockaddr, flags) --\u0026gt; (host, port) getprotobyname(name) getservbyname(servicename[, protocolname]) getservbyport(port[, protocolname]) htonl(integer) htons(integer) inet_aton(string) inet_ntoa(packed_ip) inet_ntop(af, packed_ip) inet_pton(af, ip) ntohl(integer) ntohs(integer) setdefaulttimeout(timeout) socketpair([family[, type[, proto]]]) -\u0026gt; (socket object, socket object) ssl select selectors asyncio asyncore asynchat signal mmap ",
    "categories": ["Python"],
    "tags": ["concurrency"]
  },
  {
    "title": "PSL_Python",
    "permalink": "https://canuxcheng.com/post/psl_python/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"python-runtime-services\"\u003ePython Runtime Services\u003c/h1\u003e\n\u003ch2 id=\"_builtin_\"\u003e_\u003cem\u003ebuiltin\u003c/em\u003e_\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ebuiltin\u003c/strong\u003e/builtins - Built-in functions, exceptions, and other objects.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003epython2叫__builtin__\u003c/p\u003e\n\u003cp\u003epython3叫builtins\u003c/p\u003e\n\u003ch2 id=\"_main_\"\u003e_\u003cem\u003emain\u003c/em\u003e_\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003emain\u003c/strong\u003e - Top-level script environment.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode\u003eif __name__ == \u0026quot;__main__\u0026quot;:\n    main()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当作为顶层脚本运行时(\u003cstrong\u003emain\u003c/strong\u003e), 当作为一个模块运行时候就是模块名称．\u003c/p\u003e\n\u003ch2 id=\"_future_\"\u003e_\u003cem\u003efuture\u003c/em\u003e_\u003c/h2\u003e\n\u003cp\u003e把下一个版本的新特性导入到当前版本。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom __future__ import \u0026lt;feature_name\u0026gt;\n\n# feature name:\nall_feature_names # 一次导入所有feature\nabsolute_import # 绝对导入\ndivision\ngenerators\nnested_scopes\nprint_function\nunicode_literals # python2中u'string'才表示unicode, 'string'表示str，python3中所有字符串都是unicode。\nwith_statement\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eall_feature_names\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"sys\"\u003esys\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport sys\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDynamic objects:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 动态对象\nsys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc\nsys.path # 搜索的路径．import导入模块的搜索路径．\nsys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来．\nsys.stdin # 标准输入，用于input()\nsys.stdout # 标准输出，用于print\nsys.stderr # 标准出错\ndisplayhook -- called to show results in an interactive session\nexcepthook --\nlast_type -- type of last uncaught exception\nlast_value -- value of last uncaught exception\nlast_traceback --\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStatic objects:\u003c/p\u003e",
    "content": "Python Runtime Services _builtin_ builtin/builtins - Built-in functions, exceptions, and other objects.\npython2叫__builtin__\npython3叫builtins\n_main_ main - Top-level script environment.\nif __name__ == \u0026quot;__main__\u0026quot;: main() 当作为顶层脚本运行时(main), 当作为一个模块运行时候就是模块名称．\n_future_ 把下一个版本的新特性导入到当前版本。\nfrom __future__ import \u0026lt;feature_name\u0026gt; # feature name: all_feature_names # 一次导入所有feature absolute_import # 绝对导入 division generators nested_scopes print_function unicode_literals # python2中u'string'才表示unicode, 'string'表示str，python3中所有字符串都是unicode。 with_statement data:\nall_feature_names ... sys import sys Dynamic objects:\n# 动态对象 sys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc sys.path # 搜索的路径．import导入模块的搜索路径． sys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来． sys.stdin # 标准输入，用于input() sys.stdout # 标准输出，用于print sys.stderr # 标准出错 displayhook -- called to show results in an interactive session excepthook -- last_type -- type of last uncaught exception last_value -- value of last uncaught exception last_traceback -- Static objects:\n# 静态对象 float_info -- a dict with information about the float inplementation. long_info -- a struct sequence with information about the long implementation. maxint -- the largest supported integer (the smallest is -maxint-1). maxsize -- the largest supported length of containers. maxunicode -- the largest supported character builtin_module_names -- tuple of module names built into this interpreter version -- the version of this interpreter as a string version_info -- version information as a named tuple hexversion -- version information encoded as a single integer copyright -- copyright notice pertaining to this interpreter platform -- platform identifier # 可以判断操作系统类型 sys.platform # 'win32', 'linux2', 'darwin' executable -- absolute path of the executable binary of the Python interpreter prefix -- prefix used to find the Python library exec_prefix -- prefix used to find the machine-specific Python library float_repr_style -- string indicating the style of repr() output for floats __stdin__ -- the original stdin; don't touch! __stdout__ -- the original stdout; don't touch! __stderr__ -- the original stderr; don't touch! __displayhook__ -- the original displayhook; don't touch! __excepthook__ -- the original excepthook; don't touch! functions:\ndisplayhook() -- print an object to the screen, and save it in __builtin__._ excepthook() -- print an exception and its traceback to sys.stderr exc_info() -- 返回当前异常的线程安全的三个信息．type, value, traceback. exc_clear() -- 清空当前线程的异常状态 exit() -- 抛出 SystemExit 异常退出解释器 getdlopenflags() -- returns flags to be used for dlopen() calls getprofile() -- get the global profiling function getrefcount() -- return the reference count for an object (plus one :-) getrecursionlimit() -- return the max recursion depth for the interpreter getsizeof() -- return the size of an object in bytes gettrace() -- get the global debug tracing function setcheckinterval() -- control how often the interpreter checks for events setdlopenflags() -- set the flags to be used for dlopen() calls setprofile() -- set the global profiling function setrecursionlimit() -- set the max recursion depth for the interpreter settrace() -- set the global debug tracing function data:\nflags # 命令行的状态，-d debug, -v verbose sysconfig future_builtins warnings python的警告模块，只警告，不中断程序运行．\nimport warnings functions:\nwarn(message[, category[, stacklevel]]) contextlib 编写上下文管理器的模块．\nimport contextlib abc 实现抽象方法．\nimport abc classes:\n# abc.ABCMeta ABCMeta # abc.abstractproperty abstractproperty functions:\nabstractmethod(funcobj) atexit traceback For python stack traces. 追踪python的堆栈信息．\nimport traceback functions:\nextract_stack(f=None, limit=None) extract_tb(tb, limit=None) format_stack(f=None, limit=None) format_tb(tb, limit=None) # 格式化后返回字符串 print_stack(f=None, limit=None, file=None) print_tb(tb, limit=None, file=None) # 直接打印stacktrace信息 ... gc garbage collector：python的垃圾回收模块．\nimport gc inspect 从运行的python对象获取有用的信息．\nimport inspect classes:\nfunctions:\nclassify_class_attrs(cls) stack(context=1) isgenerator() isgeneratorfunction() # 检查一个函数是否是生成器 data:\nsite user fpectl ",
    "categories": ["Python"],
    "tags": ["python"]
  },
  {
    "title": "PSL_System",
    "permalink": "https://canuxcheng.com/post/psl_system/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"generic-operating-system-services\"\u003eGeneric Operating System Services\u003c/h1\u003e\n\u003ch2 id=\"os\"\u003eos\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport os\n\nos.path # 参考PSL_File\nos.name\nos.curdir\nos.pardir # 表示上一级路径.., 需要用abspath解析\n# os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))\nos.sep\nos.extsep\nos.altsep\nos.pathsep\nos.linesep\nos.defpath\nos.devnull\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWCOREDUMP(...)\n...\n\nabort(...)\nfork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程．\nexec*\nwait() # 等待子进程结束，返回(pid, status).\nwaitpid(pid, options) # 等待指定子进程结束.\nlistdir(path) # 列出目录下的文件和目录\nmakedirs(path [, mode=0o777], exist_ok=False)\nmkdir(path [, mode=0777])\nwalk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器\nremove(path) # 删除文件\nrmdir(path) # 删除目录\nremovedirs(path)\nsymlink(src, dst)\nchown(path, uid, gid)\nchmod(path, mode=0o777)\n...\n\n# 使用subprocess模块代替下列函数：\nsystem(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果．\nspawn*\npopen*(command [, mode='r' [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e",
    "content": "Generic Operating System Services os import os os.path # 参考PSL_File os.name os.curdir os.pardir # 表示上一级路径.., 需要用abspath解析 # os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)) os.sep os.extsep os.altsep os.pathsep os.linesep os.defpath os.devnull classes:\nfunctions:\nWCOREDUMP(...) ... abort(...) fork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程． exec* wait() # 等待子进程结束，返回(pid, status). waitpid(pid, options) # 等待指定子进程结束. listdir(path) # 列出目录下的文件和目录 makedirs(path [, mode=0o777], exist_ok=False) mkdir(path [, mode=0777]) walk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器 remove(path) # 删除文件 rmdir(path) # 删除目录 removedirs(path) symlink(src, dst) chown(path, uid, gid) chmod(path, mode=0o777) ... # 使用subprocess模块代替下列函数： system(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果． spawn* popen*(command [, mode='r' [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象) data:\nEX_CANTCREAT = 73 ... time import time classes:\nfunctions:\nclock() sleep(seconds) # 延迟 tzset() # 获取时间戳(Epoch seconds) time() # 获取当前时间戳 mktime(tuple) # mktime((2017,8,23,11,7,10,12)) , 参数是时间元组 # 获取时间元组 (tm_year,tm_mon,tm_mday,tm_hour,tm_min, tm_sec,tm_wday,tm_yday,tm_isdst) localtime([seconds]) # 参数是时间戳 gmtime([seconds]) # 参数是时间戳 strptime(string, format) # 参数是时间字符串 # 获取时间字符串 asctime([tuple]) # 参数是时间元组 strftime(format[, tuple]) # 参数是时间元组 ctime(seconds) # 参数是时间戳 data:\nlogging import logging classes:\nLogger(Filterer) # methods: setLevel(self, level) # 只会输出指定level以上的log, 默认是WARNING critical(self, msg, *args, **kwargs) # 50 error(self, msg, *args, **kwargs) # 40 warning(self, msg, *args, **kwargs) # 30 info(self, msg, *args, **kwargs) # 20 debug(self, msg, *args, **kwargs) # 10 exception(self, msg, *args, **kwargs) # log(self, level, msg, *args, **kwargs) # addHandler(self, hdlr) # 添加handler到logger Formatter # %(asctime)s:%(levelname)s:%(name)s:%(message)s' Formatter(fmt=None, datefmt=None) Handler(Filterer) # methods: setFormatter(self, fmt) setLevel(self, level) StreamHandler(Handler) # 默认打印到sys.stderr StreamHandler(stream=None) FileHandler(StreamHandler) # 打印到文件 FileHandler(filename, mode='a', encoding=None, delay=0) # from logging.handlers import * WatchedFileHandler RotatingFileHandler functions:\nbasicConfig(**kwargs) # 设置log的格式 # filename/filemode/format/datefmt/level/stream # format默认是BASIC_FORMAT. # level默认是warning/warn. # stream默认是sys.stderr,当filename和stream同时指定，stream被忽略． # datafmt # filename 日志文件名 # filemode w每次覆盖写入，a每次追加写入 getLogger(name=None) # 返回Logger类型对象 data:\nBASIC_FORMAT = '%(levelname)s:%(name)s:%(message)s' CRITICAL = 50 FATAL = 50 ERROR = 40 WARN = 30 WARNING = 30 INFO = 20 DEBUG = 10 NOTSET = 0 getopt C风格的参数处理.\nargparse import argparse classes:\n# argparse.ArgumentParser(_AttributeHolder, _ActionsContainer) parser = argparse.ArgumentParser() prog -- The name of the program (default: sys.argv[0]) usage -- A usage message (default: auto-generated from arguments) description -- A description of what the program does epilog -- Text following the argument descriptions parents -- Parsers whose arguments should be copied into this one formatter_class -- HelpFormatter class for printing help messages prefix_chars -- Characters that prefix optional arguments fromfile_prefix_chars -- Characters that prefix files containing additional arguments argument_default -- The default value for all arguments conflict_handler -- String indicating how to handle conflicts add_help -- Add a -h/-help option # methods: add_argument_group(self, *args, **kwargs) # -\u0026gt; argparse._ArgumentGroup add_argument(self, *args, **kwargs) name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo. action - The basic type of action to be taken when this argument is encountered at the command line. nargs - The number of command-line arguments that should be consumed. const - A constant value required by some action and nargs selections. default - The value produced if the argument is absent from the command line. type - The type to which the command-line argument should be converted. choices - A container of the allowable values for the argument. required - Whether or not the command-line option may be omitted (optionals only). help - A brief description of what the argument does. # 用来打印默认值：%(default)s metavar - A name for the argument in usage messages. dest - The name of the attribute to be added to the object returned by. add_subparsers(self, **kwargs) # -\u0026gt; argparse._SubParsersAction add_mutually_exclusive_group(self, **kwargs) set_defaults(self, **kwargs) parse_args(self, args=None, namespace=None) # -\u0026gt; argparse.Namespace parse_known_args(self, args=None, namespace=None) # -\u0026gt; argparse.Namespace convert_arg_line_to_args(self, arg_line) error(self, message) exit(self, status=0, message=None) format_help(self) format_usage(self) format_version(self) print_help(self, file=None) print_usage(self, file=None) print_version(self, file=None) get_default(self, dest) register(self, registry_name, value, object) # argparse._ArgumentGroup # methods: add_argument(self, *args, **kwargs) add_argument_group(self, *args, **kwargs) add_mutually_exclusive_group(self, **kwargs) get_default(self, dest) register(self, registry_name, value, object) set_defaults(self, **kwargs) # argparse._SubParsersAction # methods: add_parser(self, name, **kwargs) # -\u0026gt; argparse.ArgumentParser # HelpFormatter # Action functions:\ndata:\nio errno getpass curses https://github.com/crazy-canux/python/blob/master/python/psl/mycurses.py\nimport curses platform ctypes import ctypes Unix/Linux sytem pwd import pwd functions:\n// 根据用户名获取uid和gid pw = getpwnam(user) pw.pw_uid pw.pw_gid getpwuid(uid) grp import grp functions:\ngroup = group.getgrnam(\u0026lt;group_name\u0026gt;) group.gr_name // 返回组名 group.gr_mem // 返回该组的所有用户 ",
    "categories": ["Python"],
    "tags": ["system"]
  },
  {
    "title": "PSL_GUI",
    "permalink": "https://canuxcheng.com/post/psl_gui/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"gui\"\u003eGUI\u003c/h1\u003e\n\u003ch2 id=\"tkinter\"\u003eTkinter\u003c/h2\u003e\n\u003ch2 id=\"ttk\"\u003ettk\u003c/h2\u003e\n\u003ch2 id=\"tix\"\u003eTix\u003c/h2\u003e\n\u003ch2 id=\"scrolledtext\"\u003eScrolledText\u003c/h2\u003e\n\u003ch2 id=\"turtle\"\u003eturtle\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"tpl\"\u003eTPL\u003c/h1\u003e\n\u003cp\u003e相关的第三方库\u003c/p\u003e\n\u003ch2 id=\"wxwidgets\"\u003ewxWidgets\u003c/h2\u003e\n\u003cp\u003epython2的库叫wxPython.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.wxpython.org/\"\u003ehttps://www.wxpython.org/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Windows下载安装包安装即可．\n$ sudo apt-get install python-wxgtk2.8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epython３启用新的项目phoneix.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wxWidgets/Phoenix\"\u003ehttps://github.com/wxWidgets/Phoenix\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"gtk\"\u003egtk\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003ePyGTK\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"qt\"\u003eqt\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003ePyQt\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "GUI Tkinter ttk Tix ScrolledText turtle TPL 相关的第三方库\nwxWidgets python2的库叫wxPython.\nhttps://www.wxpython.org/\n# Windows下载安装包安装即可． $ sudo apt-get install python-wxgtk2.8 python３启用新的项目phoneix.\nhttps://github.com/wxWidgets/Phoenix\ngtk PyGTK qt PyQt ",
    "categories": ["Python"],
    "tags": ["gui"]
  },
  {
    "title": "PSL_Misc",
    "permalink": "https://canuxcheng.com/post/psl_misc/",
    "date": "2016-08-15",
    "summary": "\u003ch1 id=\"psl\"\u003ePSL\u003c/h1\u003e\n\u003cp\u003ePython Standard Library: Python标准库\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"internationalization\"\u003eInternationalization\u003c/h1\u003e\n\u003ch2 id=\"gettext\"\u003egettext\u003c/h2\u003e\n\u003ch2 id=\"locale\"\u003elocale\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"program-frameworks\"\u003eProgram Frameworks\u003c/h1\u003e\n\u003ch2 id=\"cmd\"\u003ecmd\u003c/h2\u003e\n\u003ch2 id=\"shlex\"\u003eshlex\u003c/h2\u003e\n\u003cp\u003e类shell的词法分析．\u003c/p\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eshlex\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esplit(s, comments=False, posix=True)\n# split(\u0026quot;command **kwargs\u0026quot;) -\u0026gt; ['command', 'arg1', ...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"custom-python-interpreters\"\u003eCustom Python Interpreters\u003c/h1\u003e\n\u003ch2 id=\"code\"\u003ecode\u003c/h2\u003e\n\u003ch2 id=\"codeop\"\u003ecodeop\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"python-language-services\"\u003ePython Language Services\u003c/h1\u003e\n\u003ch2 id=\"keyword\"\u003ekeyword\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport keyword\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekeyword.iskeyword(keyword) # x.__contains__(y) \u0026lt;==\u0026gt; y in x\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekeyword.kwlist # 返回所有关键字的列表\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"parser\"\u003eparser\u003c/h2\u003e\n\u003ch2 id=\"ast\"\u003east\u003c/h2\u003e\n\u003ch2 id=\"symtable\"\u003esymtable\u003c/h2\u003e\n\u003ch2 id=\"symbol\"\u003esymbol\u003c/h2\u003e\n\u003ch2 id=\"token\"\u003etoken\u003c/h2\u003e\n\u003ch2 id=\"tokenize\"\u003etokenize\u003c/h2\u003e\n\u003ch2 id=\"tabnanny\"\u003etabnanny\u003c/h2\u003e\n\u003ch2 id=\"pyclbr\"\u003epyclbr\u003c/h2\u003e\n\u003ch2 id=\"py_compile\"\u003epy_compile\u003c/h2\u003e\n\u003ch2 id=\"compileall\"\u003ecompileall\u003c/h2\u003e\n\u003ch2 id=\"dis\"\u003edis\u003c/h2\u003e\n\u003ch2 id=\"pickletools\"\u003epickletools\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"importing-modules\"\u003eImporting Modules\u003c/h1\u003e\n\u003ch2 id=\"imp\"\u003eimp\u003c/h2\u003e\n\u003ch2 id=\"importlib\"\u003eimportlib\u003c/h2\u003e\n\u003ch2 id=\"zipimport\"\u003ezipimport\u003c/h2\u003e\n\u003ch2 id=\"pkgutil\"\u003epkgutil\u003c/h2\u003e\n\u003ch2 id=\"modulefinder\"\u003emodulefinder\u003c/h2\u003e\n\u003ch2 id=\"runpy\"\u003erunpy\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"miscellaneous-services\"\u003eMiscellaneous Services\u003c/h1\u003e\n\u003ch2 id=\"formatter\"\u003eformatter\u003c/h2\u003e\n\u003ch2 id=\"ihooks\"\u003eihooks\u003c/h2\u003e",
    "content": "PSL Python Standard Library: Python标准库\nInternationalization gettext locale Program Frameworks cmd shlex 类shell的词法分析．\nclasses:\nshlex functions:\nsplit(s, comments=False, posix=True) # split(\u0026quot;command **kwargs\u0026quot;) -\u0026gt; ['command', 'arg1', ...] data:\nCustom Python Interpreters code codeop Python Language Services keyword import keyword functions:\nkeyword.iskeyword(keyword) # x.__contains__(y) \u0026lt;==\u0026gt; y in x data:\nkeyword.kwlist # 返回所有关键字的列表 parser ast symtable symbol token tokenize tabnanny pyclbr py_compile compileall dis pickletools Importing Modules imp importlib zipimport pkgutil modulefinder runpy Miscellaneous Services formatter ihooks ",
    "categories": ["Python"],
    "tags": ["misc"]
  },
  {
    "title": "PSL_Cryptographic",
    "permalink": "https://canuxcheng.com/post/psl_cryptographic/",
    "date": "2016-08-14",
    "summary": "\u003ch1 id=\"cryptographic-services\"\u003eCryptographic Services\u003c/h1\u003e\n\u003ch2 id=\"hashlib\"\u003ehashlib\u003c/h2\u003e\n\u003cp\u003e哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．\u003c/p\u003e\n\u003cp\u003eMD5: Message Digest Algorithm 5.\u003c/p\u003e\n\u003cp\u003eSHA1: Secure Hash Algorithm.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport hashlib\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# methods:\n# 哈希对象有下列方法：\nupdate(arg) # 更新字符串\nmd5.update('string or read from a file') # 放入需要转换的内容\n\ndigest() # 字符串\nhexdigest() # 十六进制字符串\nmd5.hexdigest() # 获取md5十六进制字符串\n\ncopy() # 复制哈希对象\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 下类函数都返回哈希对象\nnew(name, string='')\nmd5()\nmd5 = hashlib.md5() # 创建一个md5的hash对象\nsha1()\nsha224()\nsha256()\nsha384()\nsha512()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"hmac\"\u003ehmac\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"tpl\"\u003eTPL\u003c/h1\u003e\n\u003cp\u003e相关的第三方库\u003c/p\u003e\n\u003ch2 id=\"pycrypto\"\u003epycrypto\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/dlitz/pycrypto\"\u003ehttps://github.com/dlitz/pycrypto\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ewindows需要MS Visual C++ compiler for python2.7.\u003c/p\u003e",
    "content": "Cryptographic Services hashlib 哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．\nMD5: Message Digest Algorithm 5.\nSHA1: Secure Hash Algorithm.\nimport hashlib classes:\n# methods: # 哈希对象有下列方法： update(arg) # 更新字符串 md5.update('string or read from a file') # 放入需要转换的内容 digest() # 字符串 hexdigest() # 十六进制字符串 md5.hexdigest() # 获取md5十六进制字符串 copy() # 复制哈希对象 functions:\n# 下类函数都返回哈希对象 new(name, string='') md5() md5 = hashlib.md5() # 创建一个md5的hash对象 sha1() sha224() sha256() sha384() sha512() hmac TPL 相关的第三方库\npycrypto https://github.com/dlitz/pycrypto\nwindows需要MS Visual C++ compiler for python2.7.\n$ pip install pycrypto ecdsa pure-python ECDSA signature/verification\nhttps://github.com/warner/python-ecdsa\n$ pip install ecdsa pygpgme https://pypi.python.org/pypi/pygpgme\nA Python wrapper for the GPGME library.\nWindows安装失败？\n# 需要先安装gpgme的开发库 $ sudo apt-get install libgpgme11-dev $ pip install pygpgme ",
    "categories": ["Python"],
    "tags": ["cryptographic"]
  },
  {
    "title": "PSL_Data",
    "permalink": "https://canuxcheng.com/post/psl_data/",
    "date": "2016-08-14",
    "summary": "\u003ch1 id=\"data-types\"\u003eData Types\u003c/h1\u003e\n\u003ch2 id=\"datetime\"\u003edatetime\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport datetime\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# datetime.date\ndate(year, month, day)\n# methods:\nctime(...)\n...\n# data descriptors:\nday\nmonth\nyear\n\n# datetime.datetime(datetime.date)\ndatetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n# methods:\ndatetime.datetime.strptime(string, format)\nformat_datetime = datetime.datetime.strptime('20160824161431', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31)\nformat_datetime = datetime.datetime.strptime('24 August 2016 16:14:31', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31)\n\ndatetime.datetime.strftime(format[, tuple])\nstring_datetime = format_datetime.strftime(\u0026quot;%d %B %Y %H:%M:%S\u0026quot;) # return: '24 August 2016 16:14:31'\ndatetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') # return: '2017-02-07 23:07:32'\n\nstr(datetime.datetime.now())\ndatetime.datetime.now().strftime('%Y%m%d%H%M%S') # 当前时间戳\n\n# datetime.time\n\n# datetime.timedelta\n\n# datetime.tzinfo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e",
    "content": "Data Types datetime import datetime classes:\n# datetime.date date(year, month, day) # methods: ctime(...) ... # data descriptors: day month year # datetime.datetime(datetime.date) datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) # methods: datetime.datetime.strptime(string, format) format_datetime = datetime.datetime.strptime('20160824161431', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31) format_datetime = datetime.datetime.strptime('24 August 2016 16:14:31', '%Y%m%d%H%M%S') # return: datetime.datetime(2016, 8, 24, 16, 14, 31) datetime.datetime.strftime(format[, tuple]) string_datetime = format_datetime.strftime(\u0026quot;%d %B %Y %H:%M:%S\u0026quot;) # return: '24 August 2016 16:14:31' datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') # return: '2017-02-07 23:07:32' str(datetime.datetime.now()) datetime.datetime.now().strftime('%Y%m%d%H%M%S') # 当前时间戳 # datetime.time # datetime.timedelta # datetime.tzinfo data:\nMAXYEAR = 9999 MINYEAR = 1 calendar collections import collections classes:\n# collections.Callable # collections.Container # collections.Counter # collections.Hashable # collections.ItemsView # collections.Iterable # collections.Iterator # collections.deque # 返回一个deque类型的实例，也就是双端队列 deque([iterable[, maxlen]]) # collections.defaultdict # 返回一个defaultdict类型的实例，类似于dict.setdefault() defaultdict(default_factory[, ...]) functions:\nnamedtuple(typename, field_names, verbose=False, rename=False) # 返回一个tuple的子类, 将只能通过index访问的tuple变为可以通过name来访问． NewTuple = namedtuple('NewTuple', ['elm1', 'elm2', 'elm3']) nt = NewTuple(1, 2, 3) nt.elm1 # 1 data:\nheapq bisect array sched Queue 队列数据结构．\nimport Queue classes:\n# Queue.Queue Queue(maxsize=0) # 创建一个大小为maxsize的queue对象 # methods: empty(self) # 如果queue为空返回True full(self) # 如果queue达到maxsize返回True get(self, block=True, timeout=None) # 从队列中取出一个元素并返回,如果block=True,会一直阻塞,直到队列中有元素． get_nowait(self) join(self) put(self, item, block=True, timeout=None) # 把item放到队列中,如果block=true,会一直阻塞,直到队列有空间存放item. put_nowait(self, item) qsize(self) # 返回queue大小，近似值 task_done(self) weakref UserDict UserList UserString types copy copy和deepcopy都只拷贝对象的类型和数值，不拷贝对象的ID.也就是==运算为True, is(id())运算为False.\nimport copy functions:\ncopy.copy(x) # 浅复制, 只拷贝父对象，不拷贝内部的子对象. copy.deepcopy(x, memo=None, _nil=[]) # 深复制, 拷贝父对象和内部的子对象 pprint repr Data Persistence pickle/cPickle/marshal提供对象的序列化操作．\ngdb相关的模块anydbm/whichdb/dbm/gdbm/dumbdbm提供类似字典和文件的对象．\nshelve集合了以上两者的功能．\npickle pickle不支持unicode,只支持ascii.\ncPickle python3将cPickle和pickle统一合并为pickle.\ncPickle是c开发的，速度比pickle快，但是不支持被继承．\nimport cPickle functions:\nPickler(file, protocol=0) Unpickler(file) dump(obj, file, protocol=0) # 写入到一个文件 dumps(obj, protocol=0) # 写入到一个字符串 load(file) # 从文件读取 loads(string) # 从字符串读取 data:\nHIGHEST_PROTOCOL = 2 marshal shelve import shelve with shelve.open(f, flag='n', writeback=True) as f: r/w: 不存在报错 c: read-write to new/existing，不存在创建 n: read-write to new. 总是创建新的 anydbm whichdb dbm gdbm dumbdbm cope_reg pickletools sqlite python访问数据库两种方式：\nORM DB-API ORM是对象-关系管理器，相关模块有SQLAlchemy, SQLObject.\nDB-API参考PEP248/249定义了Database的API。\nhttps://www.python.org/dev/peps/pep-0249/\nimport sqlite3 classes:\n# sqlite3.Connection # methods: close(...) commit(...) cursor(...) execute(...) ... # sqlite3.Cursor # methods: close(...) ... functions:\nadapt(obj, protocol, alternate) connect(database[, timeout, isolation_level, detect_types, factory]) ... data:\nData Compression and Archiving gzip bz2 zlib zipfile tarfile ",
    "categories": ["Python"],
    "tags": ["data"]
  },
  {
    "title": "PSL_File",
    "permalink": "https://canuxcheng.com/post/psl_file/",
    "date": "2016-08-14",
    "summary": "\u003ch1 id=\"file-and-directory-access\"\u003eFile and Directory Access\u003c/h1\u003e\n\u003ch2 id=\"ospath\"\u003eos.path\u003c/h2\u003e\n\u003cp\u003ewindows的路径要写成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eC:\\\\test\\\\sub\\\\\n\nimport os\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eos.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(\u0026quot;~/src\u0026quot;) -\u0026gt; /home/user/src\nos.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原．\nos.path.dirname(filename) # 返回filename的路径 dirname(\u0026quot;/home/user/file.py\u0026quot;) -\u0026gt; /home/user\nos.path.join(a, *p) # 拼结一个完整的路径　\nos.path.join(a, os.pardir) # 返回上级目录的路径\nos.path.realpath(filename) # 返回filename的真实路径+文件名 realpath('__file__')\nos.path.abspath(path) # 返回绝对路径, os.path.abspath('__file__')\nos.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -\u0026gt; (\u0026quot;/home/user/test\u0026quot;, \u0026quot;.py\u0026quot;)\nos.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -\u0026gt; test.py\nos.path.getsize(filename) # 返回文件大小\nos.path.exists(path) # 判断path(文件或目录)是否存在\nos.path.isfile(path) # 判断path是否是常规文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"pathlib\"\u003epathlib\u003c/h2\u003e\n\u003cp\u003enew in python3.4\u003c/p\u003e",
    "content": "File and Directory Access os.path windows的路径要写成：\nC:\\\\test\\\\sub\\\\ import os function:\nos.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(\u0026quot;~/src\u0026quot;) -\u0026gt; /home/user/src os.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原． os.path.dirname(filename) # 返回filename的路径 dirname(\u0026quot;/home/user/file.py\u0026quot;) -\u0026gt; /home/user os.path.join(a, *p) # 拼结一个完整的路径　os.path.join(a, os.pardir) # 返回上级目录的路径 os.path.realpath(filename) # 返回filename的真实路径+文件名 realpath('__file__') os.path.abspath(path) # 返回绝对路径, os.path.abspath('__file__') os.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -\u0026gt; (\u0026quot;/home/user/test\u0026quot;, \u0026quot;.py\u0026quot;) os.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -\u0026gt; test.py os.path.getsize(filename) # 返回文件大小 os.path.exists(path) # 判断path(文件或目录)是否存在 os.path.isfile(path) # 判断path是否是常规文件 pathlib new in python3.4\nfrom pathlib import Path from pathlib import PurePosixPath from pathlib import PureWindowsPath stat fileinput filecmp fnmatch linecache glob functions:\nglob(pathname) # 返回匹配pathname路径下正则表达式的所有文件组成的列表 iglob(pathname) # 同上，返回generator. shutil Utility functions for copying and archiving files and directory trees.\nimport shutil functions:\ncopy(src, dst) copy2(src, dst) ... rmtree(path, ignore_errors=False, onerror=None) # 删除指定的目录,path不能是文件． unregister_archive_format(name) move(src, dst) ... tempfile macpath ConfigParser 一般用来处理*.ini文件，格式为：\n[section] option-key = option-value 导入：\nimport ConfigParser classes:\nConfigParser.ConfigParser(defaults=None) # methods: read(filenames) # 读取ini文件 sections() # 获取所有section options(section) # 获取section的所有option get(section, option, raw=False, vars=None) # 返回字符串 getint(section, options) getfloat(section, options) getboolean(section, options) # 大小写都可以:0/1, false/true, no/yes, off/on set(section, option, value) has_section(section) has_option(section, option) remove_section(section) remove_option(section, option) write(fp) issue:\n默认是全部小写写入. config = ConfigParser.ConfigParser(allow_no_value=True) config.optionxform =str # 原样写入 from configparser import ConfigParser, ExtendedInterpolation 变量:\n// 默认interpolation只支持section之间变量 [section1] 1var1 = /opt 1var2 = %(1var1)s/test // 扩展interpolation支持section变量引用 config = ConfigParser(interpolation=ExtendedInterpolation()) [section1] 1var1 = /opt [section2] 2var1 = ${section1:1var1}/test File Formats csv import csv classes:\n# csv.DictReader DictReader(self, f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds) # methods next() # csv.DictWriter DictWriter(self, f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwargs) # mthods writeheader() writerow(rowdict) writerows(rowdicts) functions:\n// 返回DictReader对象 reader(iterable, dialect='excel', **kwargs) // 返回DictWriter对象 writer(fileobj, dialect='excel', **kwargs) data:\nrobotparser netrc xdrlib plistlib ",
    "categories": ["Python"],
    "tags": ["file"]
  },
  {
    "title": "PSL_Math",
    "permalink": "https://canuxcheng.com/post/psl_math/",
    "date": "2016-08-12",
    "summary": "\u003ch1 id=\"numeric-and-mathematical-modules\"\u003eNumeric and Mathematical Modules\u003c/h1\u003e\n\u003ch2 id=\"random\"\u003erandom\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport random\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# random.Random\nRandom()\n# methods:\nseed([self,], a=None)\nrandint(a, b) # 随机一个[a,b]中的整数．\nchoice(self, seq) # 从seq中随机选择一个元素\nuniform(self, a, b)\nsample(self, population, k)\nrandint(self, a, b)\nrandrange(self, start, stop=None, step=1, _int=\u0026lt;type 'int'\u0026gt;, _maxwidth=9007199254740992L)\n\n# random.SystemRandom(Random)\nSystemRandom(Random)\n\n# random.WichmannHill(Random)\nWichmannHill(Random)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egetrandbits(k)\nrandom(self) # 随机一个小于１的数．\n# 所有Random类的methods也可以直接使用．\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"fractions\"\u003efractions\u003c/h2\u003e\n\u003ch2 id=\"functools\"\u003efunctools\u003c/h2\u003e\n\u003cp\u003e函数式编程相关的模块\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport functools\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# functools.partial\npartial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型.\nRED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED)\nRED(\u0026quot;show me red\u0026quot;) == lambda content, color: Fore.RED + str(\u0026quot;show me red\u0026quot;) + Fore.RESET\n# 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数．\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e",
    "content": "Numeric and Mathematical Modules random import random classes:\n# random.Random Random() # methods: seed([self,], a=None) randint(a, b) # 随机一个[a,b]中的整数． choice(self, seq) # 从seq中随机选择一个元素 uniform(self, a, b) sample(self, population, k) randint(self, a, b) randrange(self, start, stop=None, step=1, _int=\u0026lt;type 'int'\u0026gt;, _maxwidth=9007199254740992L) # random.SystemRandom(Random) SystemRandom(Random) # random.WichmannHill(Random) WichmannHill(Random) functions:\ngetrandbits(k) random(self) # 随机一个小于１的数． # 所有Random类的methods也可以直接使用． fractions functools 函数式编程相关的模块\nimport functools classes:\n# functools.partial partial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型. RED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED) RED(\u0026quot;show me red\u0026quot;) == lambda content, color: Fore.RED + str(\u0026quot;show me red\u0026quot;) + Fore.RESET # 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数． functions:\nreduce(function, sequence[, initial]) # 如果initial存在，就把initial作为function的第一个参数，如果function有两个参数，就再从sequence取第一个元素作为function的第二个参数，然后调用function，返回的结果作为function的第一个参数，再继续从sequence获取元素作为参数，继续调用function, 直到sequence为空． reduce(lambda x,y: x+y, range(5)) cmp_to_key(mycmp) total_ordering(cls) update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__doc__'), updated=('__dict__',)) wraps(wrapped, assigned=('__module__', '__name__', '__doc__'), updated=('__dict__',)) # example: def deco(func): @wraps(func): def wrapper(*args, **kwargs): \u0026quot;\u0026quot;\u0026quot;Docs for wrapper.\u0026quot;\u0026quot;\u0026quot; pass @deco def foo() \u0026quot;\u0026quot;\u0026quot;Docs for new function.\u0026quot;\u0026quot;\u0026quot; pass # 不用wraps被装饰的函数foo的属性其实是原来函数的属性，也就是wrapper的属性 # 用了wraps被装饰的函数foo的属性就是foo自己的属性． print foo.__name__ print foo.__doc__ operator 操作符相关的模块\nimport operator decimal itertools import itertools cmath math numbers ",
    "categories": ["Python"],
    "tags": ["math"]
  },
  {
    "title": "PSL_String",
    "permalink": "https://canuxcheng.com/post/psl_string/",
    "date": "2016-08-12",
    "summary": "\u003ch1 id=\"text-processing-services\"\u003eText Processing Services\u003c/h1\u003e\n\u003ch2 id=\"string\"\u003estring\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cp\u003edata:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eascii_letters\nascii_lowercase\nascii_uppercase\ndigits\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"re\"\u003ere\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport re\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecompile(pattern, flags=0)\nescape(pattern)\nfindall(pattern, string, flags=0)\nfinditer(pattern, string, flags=0)\nmatch(pattern, string, flags=0) # if not match, return None, else return object.\nsearch(pattern, string, flags=0)\npurge()\nsplit(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表．\nsub(pattern, repl, string, count=0, flags=0)\nsubn(pattern, repl, string, count=0, flags=0)\ntemplate(pattern, flags=0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edata:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# flags:\nIGNORECASE # 大小写不敏感\nLOCALE\nMULTILINE\nDOTALL\nVERBOSE\nUNICODE\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emodules:\u003c/p\u003e",
    "content": "Text Processing Services string import string classes:\nfunctions:\ndata:\nascii_letters ascii_lowercase ascii_uppercase digits ... re import re classes:\nfunctions:\ncompile(pattern, flags=0) escape(pattern) findall(pattern, string, flags=0) finditer(pattern, string, flags=0) match(pattern, string, flags=0) # if not match, return None, else return object. search(pattern, string, flags=0) purge() split(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表． sub(pattern, repl, string, count=0, flags=0) subn(pattern, repl, string, count=0, flags=0) template(pattern, flags=0) data:\n# flags: IGNORECASE # 大小写不敏感 LOCALE MULTILINE DOTALL VERBOSE UNICODE modules:\n# sre_parse module # functions: sre_parse.parse(str, flags=0, pattern=None) sre_parse.expand_template(template, match) sre_parse.parse_template(source, pattern) # sre_compile module # functions: sre_compile.compile(p, flags=0) sre_compile.isstring(obj) cStringIO StringIO codecs python的编码解码器coder/decoder。\nimport codecs # 使用注册名为encoding的编码器编码obj，encoding默认为ascii。 # encode将unicode编码的obj编码成encoding编码对应的字节序列． codecs.encode(obj, [encoding[,errors]]) codecs.encode(u'hello world', 'utf-8') # 编码成utf-8字节序． # 使用注册名为encoding的解码器解码obj，encoding默认是ascii。 # decode将原来按照encoding编码的obj解码成unicode字符串. codecs.decode(obj, [encoding[,errors]]) codecs.decode(obj, 'utf-8') # 将utf-8编码的obj解码成unicode. # encoding取下面值: # ascii是默认值,gb2312, gbk, gb18030, utf-8, utf-16 # ascii利用一个字节把字符转换成数字． # unicode利用多字节转换，支持多种编码方式，utf-8, uft-16. # errors取下面值： # strict, 默认值，抛出UnicodeError异常。 # ignore # replace # xmlcharrefreplace # backslashreplace functions:\nopen(filename, mode='rb', encoding=None, errors='strict', buffering=1) data:\nstruct difflib import difflib classes:\nfunctions:\nget_close_matches(word, possibilities, n=3, cutoff=0.6) textwrap unicodedata stringprep readline rlcompleter ",
    "categories": ["Python"],
    "tags": ["string"]
  },
  {
    "title": "PSL_Multimedia",
    "permalink": "https://canuxcheng.com/post/psl_multimedia/",
    "date": "2016-08-12",
    "summary": "\u003ch1 id=\"multimedia-services\"\u003eMultimedia Services\u003c/h1\u003e\n\u003ch2 id=\"audioop\"\u003eaudioop\u003c/h2\u003e\n\u003ch2 id=\"aifc\"\u003eaifc\u003c/h2\u003e\n\u003ch2 id=\"sunau\"\u003esunau\u003c/h2\u003e\n\u003ch2 id=\"wave\"\u003ewave\u003c/h2\u003e\n\u003ch2 id=\"chunk\"\u003echunk\u003c/h2\u003e\n\u003ch2 id=\"colorsys\"\u003ecolorsys\u003c/h2\u003e\n\u003ch2 id=\"imghdr\"\u003eimghdr\u003c/h2\u003e\n\u003ch2 id=\"sndhdr\"\u003esndhdr\u003c/h2\u003e\n\u003ch2 id=\"ossaudiodev\"\u003eossaudiodev\u003c/h2\u003e\n\u003chr\u003e",
    "content": "Multimedia Services audioop aifc sunau wave chunk colorsys imghdr sndhdr ossaudiodev ",
    "categories": ["Python"],
    "tags": ["multimedia"]
  },
  {
    "title": "PSL_Network",
    "permalink": "https://canuxcheng.com/post/psl_network/",
    "date": "2016-08-12",
    "summary": "\u003ch1 id=\"internet-protocols-and-support\"\u003eInternet Protocols and Support\u003c/h1\u003e\n\u003cp\u003esocketserver/http/ftp参考\u003ca href=\"https://super-devops.readthedocs.io/en/latest/\"\u003ehttps://super-devops.readthedocs.io/en/latest/\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003epop,imap/smtp参考\u003ca href=\"https://super-devops.readthedocs.io/en/latest/\"\u003ehttps://super-devops.readthedocs.io/en/latest/\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"urllib\"\u003eurllib\u003c/h2\u003e\n\u003cp\u003eurllib.request\u003c/p\u003e\n\u003cp\u003eurllib.respponse\u003c/p\u003e\n\u003cp\u003eurllib.parse\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom urllib.parse import urlparse\nfrom urllib.parse import urljoin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eurllib.error\u003c/p\u003e\n\u003cp\u003eurllib.robotparser\u003c/p\u003e\n\u003ch2 id=\"ipaddress\"\u003eipaddress\u003c/h2\u003e\n\u003ch2 id=\"webbrowser\"\u003ewebbrowser\u003c/h2\u003e\n\u003ch2 id=\"cgi\"\u003ecgi\u003c/h2\u003e\n\u003ch2 id=\"cgitb\"\u003ecgitb\u003c/h2\u003e\n\u003ch2 id=\"wsgiref\"\u003ewsgiref\u003c/h2\u003e\n\u003ch2 id=\"xmlrpc\"\u003exmlrpc\u003c/h2\u003e\n\u003ch2 id=\"socketserver\"\u003esocketserver\u003c/h2\u003e\n\u003ch2 id=\"nntplib\"\u003enntplib\u003c/h2\u003e\n\u003cp\u003enetwork news transfer protocol\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport nntplib\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"telnet\"\u003etelnet\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport telnetlib\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"structured-markup-processing-tools\"\u003eStructured Markup Processing Tools\u003c/h1\u003e\n\u003ch2 id=\"html\"\u003ehtml\u003c/h2\u003e\n\u003ch2 id=\"xml\"\u003exml\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"internet-data-handling\"\u003eInternet Data Handling\u003c/h1\u003e\n\u003ch2 id=\"json\"\u003ejson\u003c/h2\u003e\n\u003cp\u003ehttp api(restful)一般使用json格式的数据．\u003c/p\u003e\n\u003cp\u003epython和json数据类型对应关系参考WEB/JSON.\u003c/p\u003e\n\u003cp\u003ecomplex和class/def不能被编码.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport json\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cp\u003efunctions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 将转换后的json格式写入文件\ndump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\nwith open(file, 'w') as f:\n    json.dump(dict_data, f)\n\n# 将dict类型转换成json格式\ndumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\njson_data = json.dumps(dict_data)\n\nindent=4 # 写入自动缩进４个空格\n\n# 将读出的文件(json格式)转换成dict\nload(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)\nwith open(file, 'r') as f:\n    dict_data = json.load(f)\n\n# json类型变成dict类型\nloads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)\nresponse_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"base64\"\u003ebase64\u003c/h2\u003e\n\u003ch2 id=\"mailcap\"\u003emailcap\u003c/h2\u003e\n\u003ch2 id=\"mailbox\"\u003emailbox\u003c/h2\u003e\n\u003ch2 id=\"minetypes\"\u003eminetypes\u003c/h2\u003e\n\u003ch2 id=\"binhex\"\u003ebinhex\u003c/h2\u003e\n\u003ch2 id=\"binascii\"\u003ebinascii\u003c/h2\u003e\n\u003ch2 id=\"quopri\"\u003equopri\u003c/h2\u003e\n\u003ch2 id=\"uu\"\u003euu\u003c/h2\u003e",
    "content": "Internet Protocols and Support socketserver/http/ftp参考https://super-devops.readthedocs.io/en/latest/.\npop,imap/smtp参考https://super-devops.readthedocs.io/en/latest/.\nurllib urllib.request\nurllib.respponse\nurllib.parse\nfrom urllib.parse import urlparse from urllib.parse import urljoin urllib.error\nurllib.robotparser\nipaddress webbrowser cgi cgitb wsgiref xmlrpc socketserver nntplib network news transfer protocol\nimport nntplib telnet import telnetlib Structured Markup Processing Tools html xml Internet Data Handling json http api(restful)一般使用json格式的数据．\npython和json数据类型对应关系参考WEB/JSON.\ncomplex和class/def不能被编码.\nimport json classes:\nfunctions:\n# 将转换后的json格式写入文件 dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw) with open(file, 'w') as f: json.dump(dict_data, f) # 将dict类型转换成json格式 dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw) json_data = json.dumps(dict_data) indent=4 # 写入自动缩进４个空格 # 将读出的文件(json格式)转换成dict load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) with open(file, 'r') as f: dict_data = json.load(f) # json类型变成dict类型 loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) response_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型 base64 mailcap mailbox minetypes binhex binascii quopri uu ",
    "categories": ["Python","Network"],
    "tags": ["network"]
  },
  {
    "title": "ReStructuredText",
    "permalink": "https://canuxcheng.com/post/restructuredtext/",
    "date": "2016-08-08",
    "summary": "\u003ch1 id=\"restructuredtext\"\u003ereStructuredText\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://docutils.sourceforge.net/rst.html\"\u003ehttp://docutils.sourceforge.net/rst.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ereST是易读所见即所得的文本标记语言，格式类似markdown。\u003c/p\u003e\n\u003cp\u003epython的reST参考pep12和pep287:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0012/\"\u003ehttps://www.python.org/dev/peps/pep-0012/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0287/\"\u003ehttps://www.python.org/dev/peps/pep-0287/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e主标题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etitle\n=====\n\n=====\ntitle\n=====\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e副标题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSubtitle\n-----\n\n--------\nSubtitle\n--------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e次级标题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eContent\n^^^^^^^\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e星号斜体强调：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e*text*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e双星号加粗重点强调：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e**text**\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e四个或以上的-表示分割线：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e----\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e参考式链接：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e`hyperlink`_\n\n.. _hyperlink: http://hyperlink.org\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e行内式链接：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e`link \u0026lt;https://link.com\u0026gt;`_\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e图片：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. image:: https://path/image.png\n    :alt: HTTPie compared to cURL\n    :width: 679\n    :heigh: 781\n    :align: center\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原样引用块：\u003c/p\u003e\n\u003cp\u003e双冒号加四个空格\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esource code::\n\n    print(\u0026quot;source\u0026quot;)\n    return 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文档测试块：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt;\u0026gt; print doctest block.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e无序列表：\u003c/p\u003e",
    "content": "reStructuredText http://docutils.sourceforge.net/rst.html\nreST是易读所见即所得的文本标记语言，格式类似markdown。\npython的reST参考pep12和pep287:\nhttps://www.python.org/dev/peps/pep-0012/\nhttps://www.python.org/dev/peps/pep-0287/\n主标题：\ntitle ===== ===== title ===== 副标题：\nSubtitle ----- -------- Subtitle -------- 次级标题：\nContent ^^^^^^^ 星号斜体强调：\n*text* 双星号加粗重点强调：\n**text** 四个或以上的-表示分割线：\n---- 参考式链接：\n`hyperlink`_ .. _hyperlink: http://hyperlink.org 行内式链接：\n`link \u0026lt;https://link.com\u0026gt;`_ 图片：\n.. image:: https://path/image.png :alt: HTTPie compared to cURL :width: 679 :heigh: 781 :align: center 原样引用块：\n双冒号加四个空格\nsource code:: print(\u0026quot;source\u0026quot;) return 0 文档测试块：\n\u0026gt;\u0026gt;\u0026gt; print doctest block. 无序列表：\nbullet lists: - This is item 1 - This is item 2 有序列表：\nenumerated lists: 1. this is first item 2. this is second item 定义列表：\ndefinition lists: what Definition lists. how The term is a one-line phrase. 域列表：\nfield lists: :Authors: Canux :Version: 1.0.0 选项列表：\noption lists: -a option \u0026quot;a\u0026quot; -b file option for filename 评论：\n.. This is commnet. As well. ",
    "categories": ["Web"],
    "tags": ["rest"]
  },
  {
    "title": "Debug",
    "permalink": "https://canuxcheng.com/post/python_debug/",
    "date": "2016-08-06",
    "summary": "\u003ch1 id=\"ide\"\u003eIDE\u003c/h1\u003e\n\u003cp\u003epycharm可以通过breakpoint和step调试.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"debug\"\u003edebug\u003c/h1\u003e\n\u003ch2 id=\"bdb\"\u003ebdb\u003c/h2\u003e\n\u003ch2 id=\"pdb\"\u003epdb\u003c/h2\u003e\n\u003ch2 id=\"hotshot\"\u003ehotshot\u003c/h2\u003e\n\u003ch2 id=\"timeit\"\u003etimeit\u003c/h2\u003e\n\u003ch2 id=\"trace\"\u003etrace\u003c/h2\u003e\n\u003ch2 id=\"cprofile\"\u003ecProfile\u003c/h2\u003e\n\u003ch2 id=\"profile\"\u003eprofile\u003c/h2\u003e\n\u003chr\u003e",
    "content": "IDE pycharm可以通过breakpoint和step调试.\ndebug bdb pdb hotshot timeit trace cProfile profile ",
    "categories": ["Python"],
    "tags": ["debug"]
  },
  {
    "title": "PEP",
    "permalink": "https://canuxcheng.com/post/python_pep/",
    "date": "2016-08-06",
    "summary": "\u003ch1 id=\"pep-8--style-guide-for-python-code\"\u003ePEP 8 \u0026ndash; Style Guide for Python Code\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0008/\"\u003ehttps://www.python.org/dev/peps/pep-0008/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"pep-257--docstring-conventions\"\u003ePEP 257 \u0026ndash; Docstring Conventions\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0257/\"\u003ehttps://www.python.org/dev/peps/pep-0257/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"pep-20pep-20--the-zen-of-python\"\u003ePEP-20PEP 20 \u0026ndash; The Zen of Python\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0020/\"\u003ehttps://www.python.org/dev/peps/pep-0020/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 查看pep20\n\u0026gt;import this\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "PEP 8 \u0026ndash; Style Guide for Python Code https://www.python.org/dev/peps/pep-0008/\nPEP 257 \u0026ndash; Docstring Conventions https://www.python.org/dev/peps/pep-0257/\nPEP-20PEP 20 \u0026ndash; The Zen of Python https://www.python.org/dev/peps/pep-0020/\n# 查看pep20 \u0026gt;import this ",
    "categories": ["Python"],
    "tags": ["pep"]
  },
  {
    "title": "Document",
    "permalink": "https://canuxcheng.com/post/python_document/",
    "date": "2016-08-03",
    "summary": "\u003ch1 id=\"document\"\u003eDocument\u003c/h1\u003e\n\u003cp\u003epython项目文档相关的工具．\u003c/p\u003e\n\u003ch1 id=\"pydoc\"\u003epydoc\u003c/h1\u003e\n\u003cp\u003epython自带的文档命令行接口\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ pydoc --help\n$ pydoc -p \u0026lt;port\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"tpl\"\u003eTPL\u003c/h1\u003e\n\u003ch2 id=\"sphinx\"\u003eSphinx\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/sphinx-doc/sphinx\"\u003ehttps://github.com/sphinx-doc/sphinx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html\"\u003ehttps://zh-sphinx-doc.readthedocs.io/en/latest/contents.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSphinx就是python处理reStructuredText格式的工具。\u003c/p\u003e\n\u003cp\u003e安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$pip install -U Sphinx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用sphinx：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$cd your-project/docs\n\n$sphinx-quickstart\n# 以下选项需要手动设定，其它都可以用默认值：\n\u0026gt; Project name: pydeveloper\n\u0026gt; Author name(s): Canux CHENG\n\u0026gt; Project version: 1.0.0.0\n\u0026gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y\n\u0026gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置文件conf.py包含刚才的所有配置，可以在这里手动修改。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs\"\u003ehttp://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e添加包的版本：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esys.path.insert(0, os.path.abspath(\u0026quot;..\u0026quot;))\nfrom \u0026lt;project\u0026gt; import __version__\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改自己的配置：\u003c/p\u003e",
    "content": "Document python项目文档相关的工具．\npydoc python自带的文档命令行接口\n$ pydoc --help $ pydoc -p \u0026lt;port\u0026gt; TPL Sphinx https://github.com/sphinx-doc/sphinx\nhttps://zh-sphinx-doc.readthedocs.io/en/latest/contents.html\nSphinx就是python处理reStructuredText格式的工具。\n安装：\n$pip install -U Sphinx 使用sphinx：\n$cd your-project/docs $sphinx-quickstart # 以下选项需要手动设定，其它都可以用默认值： \u0026gt; Project name: pydeveloper \u0026gt; Author name(s): Canux CHENG \u0026gt; Project version: 1.0.0.0 \u0026gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y \u0026gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y 配置文件conf.py包含刚才的所有配置，可以在这里手动修改。\nhttp://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs\n添加包的版本：\nsys.path.insert(0, os.path.abspath(\u0026quot;..\u0026quot;)) from \u0026lt;project\u0026gt; import __version__ 修改自己的配置：\ncopyright = u'2016, \u0026lt;a href=\u0026quot;http://canuxcheng.com\u0026quot;\u0026gt;Canux CHENG\u0026lt;/a\u0026gt;' sphinx-docs https://zh-sphinx-doc.readthedocs.io/en/latest/markup/index.html#sphinxmarkup\nsphinx的标记把reST格式的文档关联起来。\nindex.rst这是文档的首页。\nsphinx-build 生成web可读的文档。\n简单方法生成文档：\n# 生成html格式的文档 $make html sphinx-apidoc 自动生成API文档。\n$sphinx-apidoc Debug 浏览器打开docs/_build/html/index.html即可。\n$firefox _build/html/index.html ReadTheDocs https://readthedocs.org/\nhttp://readthedocs.readthedocs.io/zh_CN/latest/\n将项目文档部署到readthedocs站点。\n直接注册帐号，同步github项目，然后导入你的项目即可。\nalabaster https://github.com/bitprophet/alabaster/\n这个主题是sphinx的默认主题，基于requests和flask的文档的主题而来。\n主题设置：\nhtml_theme_options = { 'github_user': 'crazy-canux', 'github_repo': '\u0026lt;your-project\u0026gt;', 'github_banner': True, 'show_powered_by': False, 'show_related': True, } pypandoc https://github.com/bebraw/pypandoc\n文档转换工具pandoc的python包。\n安装：\n$ sudo apt-get install pandoc $ pip install pypandoc ",
    "categories": ["Python"],
    "tags": ["document"]
  },
  {
    "title": "Ftp",
    "permalink": "https://canuxcheng.com/post/ftp/",
    "date": "2016-07-28",
    "summary": "\u003ch1 id=\"ftp\"\u003eFTP\u003c/h1\u003e\n\u003cp\u003eftp服务器有很多：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003evsftpd\u003c/li\u003e\n\u003cli\u003eproftpd\u003c/li\u003e\n\u003cli\u003epyftpdlib\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"vsftpd\"\u003evsftpd\u003c/h1\u003e\n\u003cp\u003e安装vsftpd:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install vsftpd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewindows开启ftp服务和建立IIS站点即可。\u003c/p\u003e\n\u003cp\u003elinux配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vim /etc/vsftpd.conf\nlocal_root=/home/canux/FTP\nanon_root=/home/canux/FTP\nlocal_enable=YES\nanonymous_enable=YES\nchroot_local_user=YES\n$ sudo service vsftpd restart\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eftp的网页浏览格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eftp://host/path\nftp://username:password@host:port/path\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"ftp命令\"\u003eftp命令\u003c/h1\u003e\n\u003ch2 id=\"ftp-1\"\u003eftp\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$ ftp [-46pinegvd] [host [port]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"python的ftp标准库\"\u003epython的FTP标准库\u003c/h1\u003e\n\u003ch2 id=\"ftplib\"\u003eftplib\u003c/h2\u003e\n\u003chr\u003e",
    "content": "FTP ftp服务器有很多：\nvsftpd proftpd pyftpdlib vsftpd 安装vsftpd:\n$ sudo apt-get install vsftpd windows开启ftp服务和建立IIS站点即可。\nlinux配置：\n$ vim /etc/vsftpd.conf local_root=/home/canux/FTP anon_root=/home/canux/FTP local_enable=YES anonymous_enable=YES chroot_local_user=YES $ sudo service vsftpd restart ftp的网页浏览格式：\nftp://host/path ftp://username:password@host:port/path ftp命令 ftp $ ftp [-46pinegvd] [host [port]] python的FTP标准库 ftplib ",
    "categories": ["Network"],
    "tags": ["ftp"]
  },
  {
    "title": "Ldap",
    "permalink": "https://canuxcheng.com/post/ldap/",
    "date": "2016-07-28",
    "summary": "\u003ch1 id=\"ldap\"\u003eLDAP\u003c/h1\u003e\n\u003cp\u003eLDAP占用tcp和udp的389端口。\u003c/p\u003e\n\u003cp\u003e使用SSL的LDAP占用tcp和udp的636端口。\u003c/p\u003e\n\u003cp\u003eLightweight Directory Access Protocol.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.openldap.org/\"\u003ehttp://www.openldap.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLDAP的windows工具：LDAPSoft LDAP Browser\u003c/p\u003e\n\u003chr\u003e",
    "content": "LDAP LDAP占用tcp和udp的389端口。\n使用SSL的LDAP占用tcp和udp的636端口。\nLightweight Directory Access Protocol.\nhttp://www.openldap.org/\nLDAP的windows工具：LDAPSoft LDAP Browser\n",
    "categories": ["Network"],
    "tags": ["ldap"]
  },
  {
    "title": "Nfs",
    "permalink": "https://canuxcheng.com/post/nfs/",
    "date": "2016-07-28",
    "summary": "\u003ch1 id=\"nfs\"\u003eNFS\u003c/h1\u003e\n\u003cp\u003eNFS: Network File System\u003c/p\u003e\n\u003cp\u003e安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 在nfs服务器安装nfs服务\n$ sudo apt-get install nfs-kernel-server\n# 添加共享目录并授权\n$ sudo vim /etc/exports\n/home/user/share *(rw,no_root_squash)\n$ sudo service nfs-kernel-server restart\n\n# 在nfs客户端安装nfs客户端\n$ sudo apt-get install nfs-common\n# 自动挂载\n$ sudo vim /etc/fstab\nnfs-server-ip:/home/user/share /home/user1/share nfs auto 0 0\n$ sudo mount -a\n# 手动挂载\n$ sudo mount -t nfs nfs-server-ip:/home/user/share /home/user1/share\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"nfs-server\"\u003enfs-server\u003c/h1\u003e\n\u003cp\u003e配置/etc/exports\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/etc/exports  文件格式\n\u0026lt;输出目录\u0026gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"nfs-client\"\u003enfs-client\u003c/h1\u003e\n\u003cp\u003e配置/etc/fstab\u003c/p\u003e",
    "content": "NFS NFS: Network File System\n安装：\n# 在nfs服务器安装nfs服务 $ sudo apt-get install nfs-kernel-server # 添加共享目录并授权 $ sudo vim /etc/exports /home/user/share *(rw,no_root_squash) $ sudo service nfs-kernel-server restart # 在nfs客户端安装nfs客户端 $ sudo apt-get install nfs-common # 自动挂载 $ sudo vim /etc/fstab nfs-server-ip:/home/user/share /home/user1/share nfs auto 0 0 $ sudo mount -a # 手动挂载 $ sudo mount -t nfs nfs-server-ip:/home/user/share /home/user1/share nfs-server 配置/etc/exports\n/etc/exports 文件格式 \u0026lt;输出目录\u0026gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）] nfs-client 配置/etc/fstab\n",
    "categories": ["Network"],
    "tags": ["nfs"]
  },
  {
    "title": "Ntp",
    "permalink": "https://canuxcheng.com/post/ntp/",
    "date": "2016-07-28",
    "summary": "\u003ch1 id=\"ntp\"\u003eNTP\u003c/h1\u003e\n\u003cp\u003eNFS: Network Time Protocol\u003c/p\u003e\n\u003cp\u003eUTC: Coordinated Universal Time, 世界统一时间\u003c/p\u003e\n\u003cp\u003eGMT: Greenwich Mean Time, 格林尼治标准时间, = UTC\u003c/p\u003e\n\u003cp\u003eCET: Central European Time, 欧洲中部时间, = UTC+1, 下令时=UTC+2\u003c/p\u003e\n\u003cp\u003eCST: Chinese Standard Time, 中国标准时间, = UTC+8\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"时区管理\"\u003e时区管理\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ timedatectl list-timezones # 查看所有时区\n$ sudo timedatectl set-timezone Asia/Shanghai # 设置时区\n$ sudo timedatectl set-timezone Etc/UTC\n$ ls -l /etc/localtime # 应该是一个链接\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"ntp-1\"\u003entp\u003c/h1\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install ntp\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ntpdate\"\u003entpdate\u003c/h2\u003e\n\u003cp\u003e从目标服务器同步.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003entpdate -u ip\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ntpstat\"\u003entpstat\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install ntpstat\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"chrony\"\u003echrony\u003c/h1\u003e\n\u003cp\u003entp的升级版.\u003c/p\u003e",
    "content": "NTP NFS: Network Time Protocol\nUTC: Coordinated Universal Time, 世界统一时间\nGMT: Greenwich Mean Time, 格林尼治标准时间, = UTC\nCET: Central European Time, 欧洲中部时间, = UTC+1, 下令时=UTC+2\nCST: Chinese Standard Time, 中国标准时间, = UTC+8\n时区管理 $ timedatectl list-timezones # 查看所有时区 $ sudo timedatectl set-timezone Asia/Shanghai # 设置时区 $ sudo timedatectl set-timezone Etc/UTC $ ls -l /etc/localtime # 应该是一个链接 ntp 安装:\n$ sudo apt-get install ntp ntpdate 从目标服务器同步.\nntpdate -u ip ntpstat $ sudo apt-get install ntpstat chrony ntp的升级版.\n",
    "categories": ["Network"],
    "tags": ["ntp"]
  },
  {
    "title": "Ssh",
    "permalink": "https://canuxcheng.com/post/ssh/",
    "date": "2016-07-28",
    "summary": "\u003ch1 id=\"openssh\"\u003eOpenSSH\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://www.openssh.com/\"\u003ehttp://www.openssh.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ewindows上支持ssh协议的客户端：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eputty\u003c/li\u003e\n\u003cli\u003exshell\u003c/li\u003e\n\u003cli\u003eMobaXterm\u003c/li\u003e\n\u003cli\u003esecureCRT\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install openssh-server\n$ sudo apt-get install openssh-client\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"ssh命令\"\u003eSSH命令\u003c/h1\u003e\n\u003cp\u003essh是openssh协议的客户端．\u003c/p\u003e\n\u003cp\u003e远程操作的命令包括ssh, scp, sftp.\u003c/p\u003e\n\u003cp\u003essh\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ssh\n# 远程执行命令需要用双引号，不能用单引号\n$ ssh username@host \u0026quot;command/script\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003escp\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ scp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esftp\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sftp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e常用选项：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-C   compression\n# 不需要输入yes来交互, 或者修改/etc/ssh/ssh_config\n-o StrictHostKeyChecking=no\n-o UserKnownHostsFile /dev/null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003essh也包括一些密钥管理的命令.\u003c/p\u003e\n\u003cp\u003essh-keygen\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ssh-keygen -t rsa -C 'canuxcheng@gmail.com'\n\n# 通过将本机的公钥拷贝到远程机器实现无密码访问．\n# 将本机的public-key拷贝到远程机器的authorized_keys.\n$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote\n# 另外的拷贝方法\n$ ssh user@host \u0026quot;cat \u0026gt;\u0026gt; ~/.ssh/authorized_keys\u0026quot; \u0026lt; ~/.ssh/id_rsa.pub\n$ sudo service ssh restart # 需要重启ssh服务\n\n非交互式通过命令行传密码的命令：\n$ sshpass -p [password]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003essh-add\u003c/p\u003e",
    "content": "OpenSSH http://www.openssh.com/\nwindows上支持ssh协议的客户端：\nputty xshell MobaXterm secureCRT 安装：\n$ sudo apt-get install openssh-server $ sudo apt-get install openssh-client SSH命令 ssh是openssh协议的客户端．\n远程操作的命令包括ssh, scp, sftp.\nssh\n$ ssh # 远程执行命令需要用双引号，不能用单引号 $ ssh username@host \u0026quot;command/script\u0026quot; scp\n$ scp sftp\n$ sftp 常用选项：\n-C compression # 不需要输入yes来交互, 或者修改/etc/ssh/ssh_config -o StrictHostKeyChecking=no -o UserKnownHostsFile /dev/null ssh也包括一些密钥管理的命令.\nssh-keygen\n$ ssh-keygen -t rsa -C 'canuxcheng@gmail.com' # 通过将本机的公钥拷贝到远程机器实现无密码访问． # 将本机的public-key拷贝到远程机器的authorized_keys. $ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote # 另外的拷贝方法 $ ssh user@host \u0026quot;cat \u0026gt;\u0026gt; ~/.ssh/authorized_keys\u0026quot; \u0026lt; ~/.ssh/id_rsa.pub $ sudo service ssh restart # 需要重启ssh服务 非交互式通过命令行传密码的命令： $ sshpass -p [password] ssh-add\nssh-keysign\nssh-keyscan\n启用root远程ssh $ sudo -i # passwd root # vim /etc/ssh/sshd_config \u0026gt; PermitRootLogin prohibit-password \u0026gt; PermitRootLogin yes # service ssh restart ssh tunel SSH Tunnel有三种\n本地Local（ssh -NfL）, 在ssh client(本地)执行.\n正向代理：（a能ssh到b，b能访问c，实现a访问c，相当于a是ssh client）A 通过 中转B连接 server C. 在A 上建立tunnel: ssh -Nf -L ssh-client-ip:ssh-client-port:remoteServerIp:remoteServerPort user@agentIp 访问ssh-client-ip/A的ssh-client-port 即可访问 remoteServerIp/C 的 remoteServerPort 提供的服务. 远程Remote（ssh -NfR）, 在ssh server执行.\n反向代理：（b能ssh到a，b能访问c，实现a访问c, a相当于ssh server, c相当于remote server) A 通过中转B访问server C. 在B上建立tunnel: ssh -Nf -R ssh-server-ip:ssh-server-port:remoteServerIp:remoteServerPort user@agent 访问ssh-server-ip/A的ssh-server-port端口即可访问remoteServerIp/C 的 remoteServerPort 提供的服务。 动态Dynamic（ssh -NfD）\nsocks代理： a能ssh到B，b能访问一个网段，实现a访问该网段. 在a上建立tunnel ssh -D [ssh-client-ip]:ssh-client-port user@agent socks代理配置ssh-client-ip:ssh-client-port 即可通过B访问该网段。 ",
    "categories": ["Network"],
    "tags": ["ssh"]
  },
  {
    "title": "Remote Management",
    "permalink": "https://canuxcheng.com/post/ps_remote/",
    "date": "2016-07-18",
    "summary": "\u003ch1 id=\"windows远程管理\"\u003eWindows远程管理\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eWinRM, 远程处理,在远程机器上执行命令\u003c/li\u003e\n\u003cli\u003eWMI/CIM\u003c/li\u003e\n\u003cli\u003eRPC, 远程连接,在发起远程连接的机器上执行命令\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"winrm\"\u003eWinRM\u003c/h1\u003e\n\u003cp\u003e一对一远程处理:\u003c/p\u003e\n\u003cp\u003e类似于linux的ssh。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEnter-PSSession -ComputerName name\n...\nExit-PSSession\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e一对多远程处理:\u003c/p\u003e\n\u003cp\u003e同时远程到多台机器执行命令或脚本。\u003c/p\u003e\n\u003cp\u003eInvoke-Command一次创建一个连接对象，返回PSComputerName属性，执行完后就关闭连接。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eInvoke-Command -ComputerName name1,name2 -ScriptBlock {command1;command2}\n\nInvoke-Command -ComputerName name1,name2 -FilePath filepath\n\nInvoke-Command -ComputerName (Get-Content hosts.txt) ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过argumentlist把本地的参数传给远程的命令:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$lvar1=\u0026quot;value1\u0026quot;\n$lvar2=\u0026quot;value2\u0026quot;\nInvoke-Command -ComputerName name\n-ScriptBlock {\nParam($var1, $var2)\n...\n}\n-ArgumentList $lvar1, $lvar2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过$using:传本地参数到远程机器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$var1=\u0026quot;value1\u0026quot;\nInvoke-Command -ComputerName name\n-ScriptBlock {\n... $using:var1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建持久的远程处理：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$session1=New-PSSession -ComputerName server1\nEnter-PSSession -Session $session1 ...\nInvoke-Command -Session $session1 ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"wmi\"\u003eWMI\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eGet-WmiObject\nRemove-WmiObject\nInvoke-WmiMethod\nRegister-WmiEvent\nSet-WmiInstance\n\n# 用powershell跑一个wql。\nGet-WmiObject -Query \u0026quot;select * from win32_service where name='winRM'\u0026quot; | Format-List -Property Name,status\n\n# 远程管理\nGet-WMIObject -ComputerName ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"cim\"\u003eCIM\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eGet-CimClass\nGet-CimInstance\nGet-CimSession\nGet-CimAssociatedInstance\nInvoke-CimMethod\nNew-CimInstance\nNew-CimSession\nNew-CimSessionOption\nRegister-CimIndicationEvent\nRemove-CimInstance\nRemove-CimSession\nSet-CimInstance\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"rpc\"\u003eRPC\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e# 远程连接\nGet-Service -ComputerName ...\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Windows远程管理 WinRM, 远程处理,在远程机器上执行命令 WMI/CIM RPC, 远程连接,在发起远程连接的机器上执行命令 WinRM 一对一远程处理:\n类似于linux的ssh。\nEnter-PSSession -ComputerName name ... Exit-PSSession 一对多远程处理:\n同时远程到多台机器执行命令或脚本。\nInvoke-Command一次创建一个连接对象，返回PSComputerName属性，执行完后就关闭连接。\nInvoke-Command -ComputerName name1,name2 -ScriptBlock {command1;command2} Invoke-Command -ComputerName name1,name2 -FilePath filepath Invoke-Command -ComputerName (Get-Content hosts.txt) ... 通过argumentlist把本地的参数传给远程的命令:\n$lvar1=\u0026quot;value1\u0026quot; $lvar2=\u0026quot;value2\u0026quot; Invoke-Command -ComputerName name -ScriptBlock { Param($var1, $var2) ... } -ArgumentList $lvar1, $lvar2 通过$using:传本地参数到远程机器：\n$var1=\u0026quot;value1\u0026quot; Invoke-Command -ComputerName name -ScriptBlock { ... $using:var1 } 创建持久的远程处理：\n$session1=New-PSSession -ComputerName server1 Enter-PSSession -Session $session1 ... Invoke-Command -Session $session1 ... WMI Get-WmiObject Remove-WmiObject Invoke-WmiMethod Register-WmiEvent Set-WmiInstance # 用powershell跑一个wql。 Get-WmiObject -Query \u0026quot;select * from win32_service where name='winRM'\u0026quot; | Format-List -Property Name,status # 远程管理 Get-WMIObject -ComputerName ... CIM Get-CimClass Get-CimInstance Get-CimSession Get-CimAssociatedInstance Invoke-CimMethod New-CimInstance New-CimSession New-CimSessionOption Register-CimIndicationEvent Remove-CimInstance Remove-CimSession Set-CimInstance RPC # 远程连接 Get-Service -ComputerName ... ",
    "categories": ["Windows"],
    "tags": ["remote"]
  },
  {
    "title": "WinRM",
    "permalink": "https://canuxcheng.com/post/win_winrm/",
    "date": "2016-07-17",
    "summary": "\u003ch1 id=\"winrm\"\u003eWinRM\u003c/h1\u003e\n\u003cp\u003eWindows Remote Management\u003c/p\u003e\n\u003cp\u003eWinRM是WSMAN(WS-Management Protocol)的增强版。\u003c/p\u003e\n\u003cp\u003eWinRM是基于SOAP的防火墙友好的远程协议。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx\"\u003ehttps://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWinRM设置:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx\"\u003ehttps://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e检查winrm所有配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd\u0026gt; winrm get winrm/config\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e快速设置winrm：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd\u0026gt; winrm quickconfig\ncmd\u0026gt; winrm quickconfig -transport:https\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看listener配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd\u0026gt; winrm enumerate winrm/config/listener\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWinRM配置包括监听设置,协议设置,Client,Service和Winrs四部分.\u003c/p\u003e\n\u003cp\u003ewindows的三种网络安全协议。\u003c/p\u003e\n\u003cp\u003eBasic是基本的明文协议, NTLM是早期的安全协议,Kerberos是最新的安全协议.\u003c/p\u003e\n\u003ch1 id=\"service权限管理\"\u003eservice权限管理\u003c/h1\u003e\n\u003cp\u003e查看service的auth配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd\u0026gt; winrm get winrm/config/service/auth\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eservice只有Negotiate和Kerberos是默认开启的:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBasic = false\nKerberos = true\nNegotiate = true\nCertificate = false\nCredSSP = false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNegotiate对domain用户选择kerberos,对local用户选择NTLM.\u003c/p\u003e\n\u003cp\u003e设置service的Basic和Certificate和CredSSP(默认关闭)：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#cmd\u0026gt; winrm set winrm/config/service/auth @{Basic=\u0026quot;true\u0026quot;}\n#cmd\u0026gt; winrm set winrm/config/service/auth @{Certificate=\u0026quot;true\u0026quot;}\n#cmd\u0026gt; winrm set winrm/config/service/auth @{CredSSP=\u0026quot;true\u0026quot;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e设置是否允许不加密：\u003c/p\u003e",
    "content": "WinRM Windows Remote Management\nWinRM是WSMAN(WS-Management Protocol)的增强版。\nWinRM是基于SOAP的防火墙友好的远程协议。\nhttps://msdn.microsoft.com/en-us/library/aa384426(v=vs.85).aspx\nWinRM设置:\nhttps://msdn.microsoft.com/en-us/library/aa384372(v=vs.85).aspx\n检查winrm所有配置：\ncmd\u0026gt; winrm get winrm/config 快速设置winrm：\ncmd\u0026gt; winrm quickconfig cmd\u0026gt; winrm quickconfig -transport:https 查看listener配置：\ncmd\u0026gt; winrm enumerate winrm/config/listener WinRM配置包括监听设置,协议设置,Client,Service和Winrs四部分.\nwindows的三种网络安全协议。\nBasic是基本的明文协议, NTLM是早期的安全协议,Kerberos是最新的安全协议.\nservice权限管理 查看service的auth配置：\ncmd\u0026gt; winrm get winrm/config/service/auth service只有Negotiate和Kerberos是默认开启的:\nBasic = false Kerberos = true Negotiate = true Certificate = false CredSSP = false Negotiate对domain用户选择kerberos,对local用户选择NTLM.\n设置service的Basic和Certificate和CredSSP(默认关闭)：\n#cmd\u0026gt; winrm set winrm/config/service/auth @{Basic=\u0026quot;true\u0026quot;} #cmd\u0026gt; winrm set winrm/config/service/auth @{Certificate=\u0026quot;true\u0026quot;} #cmd\u0026gt; winrm set winrm/config/service/auth @{CredSSP=\u0026quot;true\u0026quot;} 设置是否允许不加密：\n#cmd\u0026gt; winrm set winrm/config/service @{AllowUnencrypted=\u0026quot;true\u0026quot;} client权限管理 查看client的auth配置：\ncmd\u0026gt; winrm get winrm/config/client/auth 设置client的CredSSP(默认关闭),其它默认都是开启：\n#cmd\u0026gt; winrm set winrm/config/client/auth @{CredSSP=\u0026quot;true\u0026quot;} 设置client的trustedhosts:\n#cmd\u0026gt; winrm set winrm/config/client @{TrustedHosts=\u0026quot;*\u0026quot;} Winrs winrs是winrm的客户端．\n$winrs -r:http://\u0026lt;ip-address\u0026gt; -u:domain/user -p:pass command ",
    "categories": ["Windows"],
    "tags": ["winrm"]
  },
  {
    "title": "Coreutils",
    "permalink": "https://canuxcheng.com/post/ps_coreutils/",
    "date": "2016-07-12",
    "summary": "\u003ch1 id=\"外部命令\"\u003e外部命令\u003c/h1\u003e\n\u003cp\u003epowershell可以执行外部命令.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eC:\\Windows\\System32\\*.exe\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"cmd\"\u003ecmd\u003c/h1\u003e\n\u003ch1 id=\"ping\"\u003eping\u003c/h1\u003e\n\u003ch1 id=\"netstat\"\u003enetstat\u003c/h1\u003e\n\u003ch1 id=\"ipconfig\"\u003eipconfig\u003c/h1\u003e\n\u003ch1 id=\"route\"\u003eroute\u003c/h1\u003e\n\u003ch1 id=\"arp\"\u003earp\u003c/h1\u003e\n\u003ch1 id=\"nslookup\"\u003enslookup\u003c/h1\u003e\n\u003ch1 id=\"ftp\"\u003eftp\u003c/h1\u003e\n\u003ch1 id=\"mstsc\"\u003emstsc\u003c/h1\u003e\n\u003cp\u003eRDP client.\u003c/p\u003e\n\u003ch1 id=\"taskmgr\"\u003etaskmgr\u003c/h1\u003e\n\u003cp\u003e任务管理器．\u003c/p\u003e\n\u003ch1 id=\"tskill\"\u003etskill\u003c/h1\u003e\n\u003ch1 id=\"tree\"\u003etree\u003c/h1\u003e\n\u003ch1 id=\"whoami\"\u003ewhoami\u003c/h1\u003e\n\u003chr\u003e\n\u003cp\u003e需要下载，然后放入环境变量的第三方命令.\u003c/p\u003e\n\u003ch1 id=\"windump\"\u003eWinDump\u003c/h1\u003e\n\u003cp\u003eWindows版本的tcpdump, 依赖WinPcap包．\u003c/p\u003e\n\u003cp\u003e通过windump导出的*.pcap文件可以通过wireshark打开．\u003c/p\u003e",
    "content": "外部命令 powershell可以执行外部命令.\nC:\\Windows\\System32\\*.exe cmd ping netstat ipconfig route arp nslookup ftp mstsc RDP client.\ntaskmgr 任务管理器．\ntskill tree whoami 需要下载，然后放入环境变量的第三方命令.\nWinDump Windows版本的tcpdump, 依赖WinPcap包．\n通过windump导出的*.pcap文件可以通过wireshark打开．\n",
    "categories": ["Windows"],
    "tags": ["coreutils"]
  },
  {
    "title": "Json",
    "permalink": "https://canuxcheng.com/post/json/",
    "date": "2016-07-07",
    "summary": "\u003ch1 id=\"json\"\u003eJSON\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://www.json.org/\"\u003ehttp://www.json.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eJSON: JavaScript Object Notation.\u003c/p\u003e\n\u003cp\u003ejson有两种数据结构.\u003c/p\u003e\n\u003ch1 id=\"key-value键值对\"\u003ekey-value/键值对\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    key: value,\n    key1: value1,\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"列表数组\"\u003e列表/数组\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e[value, value1, ...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"数据类型\"\u003e数据类型\u003c/h1\u003e\n\u003cp\u003ebool:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epython -\u0026gt; True/False\ngo -\u0026gt; true/false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estring:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; 只能用双引号.\n\npython -\u0026gt; str\ngo -\u0026gt; string\ngo -\u0026gt; []byte -\u0026gt; base64编码字符串\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enumber:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epython -\u0026gt; int/float\ngo -\u0026gt; int64/float64\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enull:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epython -\u0026gt; None\ngo -\u0026gt; nil\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003earray\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epython -\u0026gt; tuple/list\ngo -\u0026gt; array/slice\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eobject\u003c/p\u003e",
    "content": "JSON http://www.json.org/\nJSON: JavaScript Object Notation.\njson有两种数据结构.\nkey-value/键值对 { key: value, key1: value1, ... } 列表/数组 [value, value1, ...] 数据类型 bool:\npython -\u0026gt; True/False go -\u0026gt; true/false string:\n\u0026gt; 只能用双引号. python -\u0026gt; str go -\u0026gt; string go -\u0026gt; []byte -\u0026gt; base64编码字符串 number:\npython -\u0026gt; int/float go -\u0026gt; int64/float64 null:\npython -\u0026gt; None go -\u0026gt; nil array\npython -\u0026gt; tuple/list go -\u0026gt; array/slice object\npython -\u0026gt; dict go -\u0026gt; struct/map ",
    "categories": ["Web"],
    "tags": ["json"]
  },
  {
    "title": "Yaml",
    "permalink": "https://canuxcheng.com/post/yaml/",
    "date": "2016-07-07",
    "summary": "\u003ch1 id=\"yaml\"\u003eYAML\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://yaml.org\"\u003ehttps://yaml.org\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eYaml Ain\u0026rsquo;t Markup Language.\u003c/p\u003e\n\u003ch2 id=\"yamllint\"\u003eyamllint\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/adrienverge/yamllint\"\u003ehttps://github.com/adrienverge/yamllint\u003c/a\u003e\u003c/p\u003e",
    "content": "YAML https://yaml.org\nYaml Ain\u0026rsquo;t Markup Language.\nyamllint https://github.com/adrienverge/yamllint\n",
    "categories": ["Web"],
    "tags": ["yaml"]
  },
  {
    "title": "CSS",
    "permalink": "https://canuxcheng.com/post/css/",
    "date": "2016-06-23",
    "summary": "\u003ch1 id=\"css\"\u003e\u003cstrong\u003eCSS\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eCSS是叠层样式表\u003c/p\u003e\n\u003ch1 id=\"css3\"\u003eCSS3\u003c/h1\u003e\n\u003cp\u003eCSS3是最新的CSS标准\u003c/p\u003e\n\u003ch1 id=\"css创建\"\u003eCSS创建\u003c/h1\u003e\n\u003cp\u003e优先级从上往下。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e内联样式， 在html中通过style属性定义，仅用于一个html元素。\u003c/li\u003e\n\u003cli\u003e内部样式表，在html中通过style标签在头部定义,针对单个页面。\u003c/li\u003e\n\u003cli\u003e外部样式表，在html中通过link标签在文档头部定义，方便将样式用于多个页面。\u003c/li\u003e\n\u003cli\u003e浏览器的默认值。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"css基本语法\"\u003e\u003cstrong\u003eCSS基本语法\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eCSS由两部分组成，选择器和声明，选择器是html元素，声明由属性和值组成。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eselector {\n  property1: value1;\n  property2: value2;\n  ...;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多个声明用分号隔开，属性的值有空格要用引号。\u003c/p\u003e\n\u003cp\u003eCSS对大小写不敏感。\u003c/p\u003e\n\u003cp\u003eCSS注释:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/* comment */\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"css选择器\"\u003e\u003cstrong\u003eCSS选择器\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003e最常见的选择器是元素选择器,html元素是最基本的选择器。\u003c/p\u003e\n\u003ch2 id=\"元素选择器\"\u003e元素选择器\u003c/h2\u003e\n\u003cp\u003ehtml {color:black;}\u003c/p\u003e\n\u003ch2 id=\"id选择器\"\u003eid选择器\u003c/h2\u003e\n\u003cp\u003eid选择器可以为标有特定id的html元素指定特定样式。\u003c/p\u003e\n\u003cp\u003eid选择器用#开头定义。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#red {color: red;}\n#green {color: green;}\n\n\u0026lt;p id=\u0026quot;red\u0026quot;\u0026gt;This is red.\u0026lt;/p\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eid选择器常常用来建立派生选择器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#sidebar p {\n  font-style: italic;\n  text-align: right;\n  margin-top: 0.5em;\n}\n\n\u0026lt;div id=\u0026quot;sidebar\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"class选择器\"\u003eclass选择器\u003c/h2\u003e\n\u003cp\u003e和id选择器功能类似，类选择器以.开头。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.center {text-align: center}\n\n\u0026lt;h1 class=\u0026quot;center\u0026quot;\u0026gt;...\u0026lt;/h1\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类选择器用于建立派生选择器：\u003c/p\u003e",
    "content": "CSS CSS是叠层样式表\nCSS3 CSS3是最新的CSS标准\nCSS创建 优先级从上往下。\n内联样式， 在html中通过style属性定义，仅用于一个html元素。 内部样式表，在html中通过style标签在头部定义,针对单个页面。 外部样式表，在html中通过link标签在文档头部定义，方便将样式用于多个页面。 浏览器的默认值。 CSS基本语法 CSS由两部分组成，选择器和声明，选择器是html元素，声明由属性和值组成。\nselector { property1: value1; property2: value2; ...; } 多个声明用分号隔开，属性的值有空格要用引号。\nCSS对大小写不敏感。\nCSS注释:\n/* comment */ CSS选择器 最常见的选择器是元素选择器,html元素是最基本的选择器。\n元素选择器 html {color:black;}\nid选择器 id选择器可以为标有特定id的html元素指定特定样式。\nid选择器用#开头定义。\n#red {color: red;} #green {color: green;} \u0026lt;p id=\u0026quot;red\u0026quot;\u0026gt;This is red.\u0026lt;/p\u0026gt; id选择器常常用来建立派生选择器：\n#sidebar p { font-style: italic; text-align: right; margin-top: 0.5em; } \u0026lt;div id=\u0026quot;sidebar\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt; class选择器 和id选择器功能类似，类选择器以.开头。\n.center {text-align: center} \u0026lt;h1 class=\u0026quot;center\u0026quot;\u0026gt;...\u0026lt;/h1\u0026gt; 类选择器用于建立派生选择器：\n.fancy td { color: #f60; background: #666; } \u0026lt;td class=\u0026quot;fancy\u0026quot;\u0026gt; 也可以用：\ntd.fancy { color: #f60; background: #666; } \u0026lt;td class=\u0026quot;fancy\u0026quot;\u0026gt; 属性选择器 为拥有指定属性的html元素设置样式。\n[title] { color: red; } \u0026lt;a title=\u0026quot;title is red\u0026quot;\u0026gt;...\u0026lt;/a\u0026gt; 属性和值选择器：\n[title=w3c] { border: 5px solid blue; } \u0026lt;img title=\u0026quot;w3c\u0026quot; src=\u0026quot;/images/w3c.gif\u0026quot;\u0026gt; # 属性和值选择器的操作符： = ~= |= ^= $= *= 后代选择器/descendant 子元素选择器/child 相邻兄弟选择器/adjacent sibling CSS样式 内联样式：\n\u0026lt;p style=\u0026quot;background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center\u0026quot;\u0026gt;...\u0026lt;/h1\u0026gt; 样式表：\np { background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center; } background样式 background: # 可以定义所有背景的值 background-color: gray # 背景颜色 background-image: url(/images/test.gif) # 背景图片,默认水平和垂直都平铺 background-repeat: repeat-x # 水平方向平铺 background-repeat: repeat-y # 垂直方向平铺 background-repeat: no-repeat # 不平铺 background-position: center/top/buttom/left/right # 图像在背景中的位置 background-attachment: fixed # 图像相对于可视区是固定的 background-size background-origin background-clip 文本样式 color: red # 设置文本颜色 line-height # 设置行高 letter-spacing # 设置字符间距 word-spacing # 设置字间距 text-indent # 缩进元素中文本首行 direction: ltr/rtl # 设置文本方向 text-align: left/right/center/justify # 对齐元素中的文本 text-decoration: none/underline/overline/line-through/blink # 向文本添加修饰 text-transform: none/capitalize/uppercase/lowercase # 控制元素的字母 white-space: normal/pre/nowrap/pre-wrap/pre-line # 设置元素中空白的处理方式 字体样式 font: # 定义所有和字体有关的属性 font-family: # 设置字体系列 font-size: # 设置字体尺寸 font-style: normal/italic/oblique # 设置字体风格 font-variant: normal/small-caps # 设置字体变体 font-weight: normal/bold/bolder/lighter/... # 设置字体粗细 链接样式 链接可以设置background，color，font等样式。\na:link {background: red} # 普通的未被访问的链接 a:visited {color: blue} # 用户已访问的链接 a:hover {font: } # 鼠标指针位于链接的上方 a:active {font: } # 链接被点击的时刻 列表样式 list-style: # 定义所有和列表相关的属性 list-style-image: # 把图像设置为列表项标志 list-style-position: inside/outside # 设置列表项标志的位置 list-style-type: # 设置列表项标志的位置 表格样式 border-collapse: separate/collapse # 设置是否把表格边框合并为单一的边框 border-spacing: # 设置分割单元边框距离 caption-side: top/bottom # 规定表格标题设置方式 empty-cells: hide/show # 设置是否现实表格中的空单元格 table-layout: automatic/fixed # 设置现实单元，行和列的算法 轮廓样式 outline: # 设置所有和轮廓相关的属性 outline-color: # 设置轮廓颜色 outline-style: none/dotted/dashed/solid/double/groove/ridge/inset/outset # 设置轮廓风格 outline-width: # 设置轮廓宽度 尺寸属性 height width max-height max-width min-height min-width CSS模型框 内边距属性 padding padding-top padding-rigit padding-bottom padding-left 边框属性 border border-style border-width border-color border-buttom border-buttom-color/style/width border-left border-left-color/style/width border-right border-right-color/style/width border-top border-top-color/style/width 外边距属性 margin # 依次为上，右，下，左． margin-right margin-top margin-bottom margin-left CSS定位 position # 规定元素的定位 top right bottom left overflow # 内容益处元素框时，visible/hidden/scroll/auto/inderit clip vertical-align z-index display # 规定元素应该生成的框的类型, inline/none/block/... float # none/left/right/inderit, 规定框是否应该浮动 color 16进制 和 rgb表示\nrgb(255,255,255) == #FFFFFF == white rgb(0,0,0) == #000000 == black rgb(255,0,0) == red rgb(0,255,0) == green rgb(0,0,255) == blue rgb(255,255,0) == yellow ",
    "categories": ["Web"],
    "tags": ["css"]
  },
  {
    "title": "Html",
    "permalink": "https://canuxcheng.com/post/html/",
    "date": "2016-06-23",
    "summary": "\u003ch1 id=\"html\"\u003eHTML\u003c/h1\u003e\n\u003cp\u003eHTML是超文本标记语言\u003c/p\u003e\n\u003ch1 id=\"xhtml\"\u003eXHTML\u003c/h1\u003e\n\u003cp\u003eXHTML是更严谨的更纯净的HTML\u003c/p\u003e\n\u003ch1 id=\"html5\"\u003eHTML5\u003c/h1\u003e\n\u003cp\u003eHTML5是下一代HTML\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"html元素和属性\"\u003e\u003cstrong\u003ehtml元素和属性\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003ehtml元素指从开始标签到结束标签的所有代码,包括元素内容：\u003c/p\u003e\n\u003cp\u003ehtml元素可以嵌套。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;p\u0026gt; This is paragrph \u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; # 空内容的元素\n\u0026lt;br /\u0026gt; # 空元素，在开始标签中关闭\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehtml标签可以拥有属性，属性总是以name=\u0026lsquo;value\u0026rsquo;的形式出现，属性总是在html元素的开始标签中规定。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;a href=\u0026quot;http://www.test.com\u0026quot;\u0026gt;This is a link\u0026lt;/a\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehtml属性和值大小写不敏感，推荐使用小写,始终给属性值加引号。\u003c/p\u003e\n\u003ch2 id=\"html的全局属性标准属性\"\u003ehtml的全局属性(标准属性)\u003c/h2\u003e\n\u003cp\u003e参考：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.w3school.com.cn/tags/html_ref_standardattributes.asp\"\u003ehttp://www.w3school.com.cn/tags/html_ref_standardattributes.asp\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"html的事件属性\"\u003ehtml的事件属性\u003c/h2\u003e\n\u003cp\u003e参考：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.w3school.com.cn/tags/html_ref_eventattributes.asp\"\u003ehttp://www.w3school.com.cn/tags/html_ref_eventattributes.asp\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"html字符实体\"\u003ehtml字符实体\u003c/h2\u003e\n\u003cp\u003e参考：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.w3school.com.cn/tags/html_ref_entities.html\"\u003ehttp://www.w3school.com.cn/tags/html_ref_entities.html\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"html基本标签\"\u003e\u003cstrong\u003ehtml基本标签\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"doctype\"\u003eDOCTYPE\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# 文档类型\n\u0026lt;!DOCTYPE html\u0026gt;\n\u0026lt;html\u0026gt;\n\n\u0026lt;head\u0026gt;\n...\n\u0026lt;/head\u0026gt;\n\n\u0026lt;body\u0026gt;\n...\n\u0026lt;/body\u0026gt;\n\n\u0026lt;/html\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"html-1\"\u003ehtml\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# html文档,支持全局属性\n\u0026lt;html\u0026gt;\n...\n\u0026lt;/html\u0026gt;\n\n# mainfest属性，定义一个url，描述文档缓存信息\n\n# xmlns属性，定义XML的namespace属性\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"注释\"\u003e注释\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e# 注释, 浏览器会忽略注释,没有任何属性\n\u0026lt;!-- This is a comment --\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"空格\"\u003e空格\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026amp;nbsp;    # 空格\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"head\"\u003e\u003cstrong\u003ehead\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"head-1\"\u003ehead\u003c/h2\u003e\n\u003cp\u003e可以在head标签中使用的标签： link, style, base, meta, script, title.\u003c/p\u003e",
    "content": "HTML HTML是超文本标记语言\nXHTML XHTML是更严谨的更纯净的HTML\nHTML5 HTML5是下一代HTML\nhtml元素和属性 html元素指从开始标签到结束标签的所有代码,包括元素内容：\nhtml元素可以嵌套。\n\u0026lt;p\u0026gt; This is paragrph \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; # 空内容的元素 \u0026lt;br /\u0026gt; # 空元素，在开始标签中关闭 html标签可以拥有属性，属性总是以name=\u0026lsquo;value\u0026rsquo;的形式出现，属性总是在html元素的开始标签中规定。\n\u0026lt;a href=\u0026quot;http://www.test.com\u0026quot;\u0026gt;This is a link\u0026lt;/a\u0026gt; html属性和值大小写不敏感，推荐使用小写,始终给属性值加引号。\nhtml的全局属性(标准属性) 参考：\nhttp://www.w3school.com.cn/tags/html_ref_standardattributes.asp\nhtml的事件属性 参考：\nhttp://www.w3school.com.cn/tags/html_ref_eventattributes.asp\nhtml字符实体 参考：\nhttp://www.w3school.com.cn/tags/html_ref_entities.html\nhtml基本标签 DOCTYPE # 文档类型 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; html # html文档,支持全局属性 \u0026lt;html\u0026gt; ... \u0026lt;/html\u0026gt; # mainfest属性，定义一个url，描述文档缓存信息 # xmlns属性，定义XML的namespace属性 注释 # 注释, 浏览器会忽略注释,没有任何属性 \u0026lt;!-- This is a comment --\u0026gt; 空格 \u0026amp;nbsp; # 空格 head head 可以在head标签中使用的标签： link, style, base, meta, script, title.\n# html文档的头部, head支持全局属性 \u0026lt;head\u0026gt; \u0026lt;base\u0026gt; \u0026lt;meta\u0026gt; \u0026lt;title\u0026gt; 必须的 \u0026lt;link\u0026gt; \u0026lt;style\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/head\u0026gt; # profile属性 title 定义文档标题，支持全局属性。\n# dir属性规定元素中内容的文本方向 # lang属性规定元素中内容的语言编码 # xml:lang属性规定xhtml文档中元素内容的语言编码 base 定义页面所有的链接的默认地址和默认目标。\n# href属性规定页面中所有相对链接的基准url # target属性规定在何处打开页面中的链接 meta 定义元数据,支持全局属性\n# content属性 # http-equiv # name # scheme body body # html文档的主体, 支持样式，支持全局属性和事件属性 \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; h1-h6 # 标题,浏览器会自动在标题前后添加空行,支持样式 \u0026lt;h1\u0026gt;This is the max heading\u0026lt;/h1\u0026gt; ... \u0026lt;h6\u0026gt;This is the min heading\u0026lt;/h6\u0026gt; # 支持部分全局属性 # id,class,title,style,dir,lang,xml:lang # 支持部分事件属性 # onclick,ondblclick,onmousedown,onmouseup,onmouseover, # onmousemove, ommouseout,onkeypress,onkeydown,onkeyup hr # 水平线分割线，支持样式，支持全局属性和事件属性 \u0026lt;hr /\u0026gt; 段落 p # 段落, 浏览器会自动在段落前后添加空行,支持样式，支持全局属性和事件属性 \u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt; br # 空行, 支持全局属性和事件属性 \u0026lt;br /\u0026gt; # clear属性 链接和图像 URL: Uniform Resource Locator\nscheme://host.domain:port/path/filename scheme: http/https/ftp/file url只能使用ASCII字符集。\n参考：\nhttp://www.w3school.com.cn/tags/html_ref_urlencode.html\na 支持全局属性和事件属性\n# href属性定义指向另一个文档的链接 \u0026lt;a href=\u0026quot;http://www.test.com\u0026quot;\u0026gt;Click me as link\u0026lt;/a\u0026gt; # target属性，定义被链接的文档在何处显示, blank在新窗口显示,rect, circle, poly \u0026lt;a href=\u0026quot;http://www.test.com\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;Link\u0026lt;/a\u0026gt; # name属性定义文档内的书签 \u0026lt;a href=\u0026quot;http://www.test.com\u0026quot; name=\u0026quot;label\u0026quot;\u0026gt;Link\u0026lt;/a\u0026gt; # hreflang # rel # download # media # type img 支持全局属性和事件属性\n# src属性定义源 \u0026lt;img src=\u0026quot;url\u0026quot; /\u0026gt; # alt属性，当图像不能显示，就显示alt的默认值。 \u0026lt;img src=\u0026quot;http://www.test.com/images/test.img\u0026quot; alt=\u0026quot;default value\u0026quot;/\u0026gt; # height # ismap # longdesc # usemap # width map 支持全局属性和事件属性\n# id属性为map定义唯一的名称 \u0026lt;map id=\u0026quot;planetmap\u0026quot;\u0026gt; ... \u0026lt;/map\u0026gt; # name属性为image-map规定的名称 area 支持全局属性和事件属性\n# alt # coords # href # nohref # shape # target 样式 内联样式,定义在html元素内部。style样式属性可以包含任何的css属性。\n内联样式优先级最高。\n\u0026lt;h1 style=\u0026quot;font-family:verdana\u0026quot;\u0026gt;A heading\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026quot;font-family:arial;color:red;font-size:20px\u0026quot;\u0026gt;A paragraph\u0026lt;/p\u0026gt; style 内部样式表,位于head标签内部。支持全局属性和事件属性\n优先级仅次于内联样式。\n\u0026lt;head\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; h1 {color: red} p {color: blue} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; # type属性规定样式表的MIME类型 # media属性规定不同的媒体类型 link 外部样式表,支持全局属性和事件属性\n优先级仅高于浏览器缺省值。\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href=\u0026quot;mystyle.css\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; # href属性规定被链接文档的位置 # hreflang属性规定被链接文档中文本的语言 # media属性规定被链接文档被显示在什么设备 # rel属性规定当前文档与被链接文档的关系 # sizes属性规定rel='icon'的尺寸 # type属性规定被链接文档的MINE类型 div 分类块级元素,支持样式，支持全局属性和事件属性\n\u0026lt;div\u0026gt; 使用样式属性 span 分类行内元素，支持样式，支持全局属性和事件属性\n\u0026lt;span\u0026gt; 定义文档中的行内的块 格式化 文本格式化标签 \u0026lt;b\u0026gt; 定义粗体文本 \u0026lt;big\u0026gt; 定义大号字 \u0026lt;em\u0026gt; 定义着重文字 \u0026lt;i\u0026gt; 定义斜体字 \u0026lt;small\u0026gt; 定义小号字 \u0026lt;strong\u0026gt; 定义加重语气 \u0026lt;sub\u0026gt; 定义下标字 \u0026lt;sup\u0026gt; 定义上标字 \u0026lt;ins\u0026gt; 定义插入字 \u0026lt;del\u0026gt; 定义删除字 计算机输出标签 \u0026lt;code\u0026gt; 定义计算机代码 \u0026lt;kbd\u0026gt; 定义键盘码 \u0026lt;samp\u0026gt; 定义计算机代码样本 \u0026lt;tt\u0026gt; 定义打字机代码 \u0026lt;var\u0026gt; 定义变量 \u0026lt;pre\u0026gt; 定义预格式文本 引用和术语标签 \u0026lt;abbr\u0026gt; 定义缩写 \u0026lt;p\u0026gt;\u0026lt;abbr title=\u0026quot;Hyper Text Markup Language\u0026quot;\u0026gt;HTML\u0026lt;/abbr\u0026gt;is perfect.\u0026lt;/p\u0026gt; \u0026lt;acronym\u0026gt; 定义首字母缩写 \u0026lt;address\u0026gt; 定义地址 \u0026lt;bdo\u0026gt; 定义文字方向 \u0026lt;blockquote\u0026gt; 定义长的引用 \u0026lt;q\u0026gt; 定义短的引用 \u0026lt;cite\u0026gt; 定义著作的标题 \u0026lt;dfn\u0026gt; 定义一个项目或缩写 表格 \u0026lt;table border=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;caption\u0026gt;The title\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Month\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Saving\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jan.\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;$100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; table 定义表格,支持事件属性和全局属性\n# border属性规定表格边框宽度 # cellpadding属性规定单元边沿与其内容之间的空白 # cellspacing属性规定单元格之间的空白 # frame属性规定外侧边框的哪个部分是可见的 # rules属性规定内侧边框的哪个部分是可见的 # summary属性规定表格的摘要 # width属性规定表格的宽度 caption 定义表格标题,支持样式，支持事件属性和全局属性\ntr 定义表格的行,支持事件属性和全局属性\n# align属性定义表格内容对齐方式 # char属性规定根据哪个字符来进行文本对齐 # charoff属性规定第一个对齐字符的偏移量 # valign属性规定表格中内容的垂直对齐方式 th td th定义表格表头,支持全局属性和事件属性\ntd定义表格单元,支持全局属性和事件属性\n# abbr属性规定单元格中内容的缩写版本 # align属性规定单元格内容的水平对齐方式 # axis属性对单元进行分类 # char # charoff # colspan # headers # rowspan # scope # valign col 定义用于表格的属性\ncolgroup 定义表格的组\n列表 ol 定义有序列表,支持全局属性和事件属性\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;first one\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second one\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; # reversed属性规定列表顺序为降序 # start属性有序列表的起始值 # type属性规定在列表中使用的标记类型 ul 定义无序列表,支持样式，支持全局属性和事件属性\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;coffee\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;tea\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt; li 定义列表项,支持样式，支持全局属性和事件属性\ndl dt dd dl定义定义列表,dt定义定义项目,dd定义定义的描述,都支持全局属性和事件属性\n\u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;computer\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;used to monitor...\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; 网站布局 使用html5的网站布局标签.\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; header {} nav {} section {} footer {} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt;...\u0026lt;/header\u0026gt; ... \u0026lt;footer\u0026gt;...\u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; 也可以使用id选择器：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; #header {} ... #footer {} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026quot;header\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt; ... \u0026lt;div id=\u0026quot;footer\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; header标签 nav标签 section标签 article标签 aside标签 footer标签 details标签 summary标签 框架 框架可以在一个html添加多个页面。\n垂直框架：\n\u0026lt;frameset cols=\u0026quot;50%, 50%\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;a.html\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;b.html\u0026quot;\u0026gt; \u0026lt;/frameset\u0026gt; 水平框架：\n\u0026lt;frameset rows=\u0026quot;50%, 50%\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;a.html\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;b.html\u0026quot;\u0026gt; \u0026lt;/frameset\u0026gt; 混合框架：\n\u0026lt;frameset rows=\u0026quot;50%, 50%\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;a.html\u0026quot;\u0026gt; \u0026lt;frameset cols=\u0026quot;%25, 75%\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;b.html\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;c.html\u0026quot;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/frameset\u0026gt; frameset标签 # cols属性定义框架中列的数目和尺寸 # rows属性定义框架中行的数目和尺寸 # 标准属性： id,class,title,style frame标签 定义frameset中的一个特定的窗口。\n# frameborder属性规定是否现实框架周围的边框 # longdesc属性 # marginheight属性 # marginwidth属性 # name属性 # scrolling属性 # src属性 # 标准属性： id,class,title,style iframe标签 内联框架。\n把内容放在iframe标签中，在无法理解iframe的浏览器显示。\n支持事件属性和全局属性。\n# frameborder属性 # height属性 # width属性 # longdesc属性 # marginheight属性 # marginwidth属性 # name属性 # scrolling属性 # src属性 # sandbox # seamless # srcdoc noframes标签 脚本 在html中插入javascript等脚本\nscript标签 定义客户端脚本，支持全局属性\n直接嵌入javascript代码时注意代码中如果有\u0026lt;/script\u0026gt;需要转义．\n通过src属性指定外部javascript脚本的script标签中不能包含额外的javascript代码．\n\u0026lt;!-- 直接嵌入javascript代码 --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; document.write(\u0026quot;hello javascript\u0026quot;) \u0026lt;/script\u0026gt; \u0026lt;!-- 指定外部javascript脚本　--\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;example.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; # type 可选，指定脚本MIME类型，比如text/javascript # src 可选，表示指定的外部文件 # charset 可选，表示通过src属性指定的代码的字符集 # defer 可选，表示外部脚本可以延迟到文档完全被解析和显示之后再执行 # async 可选，表示应该立即下载外部脚本 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; ...head content... \u0026lt;!-- head中的script是调用才执行的，或者是事件触发的，可以提前备加载 --\u0026gt; \u0026lt;script\u0026gt;...\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ...body content... \u0026lt;!-- 页面内容先呈现，然后按顺序加载和解析脚本 --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;example.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- defer表示整个页面解析完后才加载和解析脚本 --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; defer=\u0026quot;defer\u0026quot; src=\u0026quot;example.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- async表示在加载页面期间异步加载和解析脚本 --\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; async src=\u0026quot;example.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; noscript标签 针对早期不支持javascript的浏览器，为不支持客户端脚本的浏览器定义替代内容,支持全局属性\n当浏览器不支持，就显示noscript标签的内容，否则就不显示．\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;example.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Your browser does not support javascript\u0026lt;/noscript\u0026gt; ",
    "categories": ["Web"],
    "tags": ["html"]
  },
  {
    "title": "Package",
    "permalink": "https://canuxcheng.com/post/python_package/",
    "date": "2016-06-22",
    "summary": "\u003ch1 id=\"package\"\u003ePackage\u003c/h1\u003e\n\u003cp\u003ePEP426是python最新的打包标准，定义了wheel为最新的python包。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.python.org/dev/peps/pep-0426/\"\u003ehttps://www.python.org/dev/peps/pep-0426/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"ensurepip\"\u003eensurepip\u003c/h2\u003e\n\u003cp\u003e内置模块.提供使用pip从pypi安装模块。\u003c/p\u003e\n\u003ch2 id=\"distutils\"\u003edistutils\u003c/h2\u003e\n\u003cp\u003e内置的模块.处理简单的包安装,一般使用setuptools代替该模块。\u003c/p\u003e\n\u003ch2 id=\"venv\"\u003evenv\u003c/h2\u003e\n\u003cp\u003epython3新增了虚拟环境的包．python2中使用virtualenv.\u003c/p\u003e\n\u003ch2 id=\"zipapp\"\u003ezipapp\u003c/h2\u003e\n\u003cp\u003epython3新增管理可执行的python的zip包．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tpl\"\u003eTPL\u003c/h1\u003e\n\u003cp\u003e相关的第三方库\u003c/p\u003e\n\u003ch2 id=\"virtualenv\"\u003evirtualenv\u003c/h2\u003e\n\u003cp\u003epython3.5开始并入了虚拟化标准库venv.\u003c/p\u003e\n\u003cp\u003e分离的虚拟的python环境,自动安装setuptools和pip和wheel\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/pypa/virtualenv\"\u003ehttps://github.com/pypa/virtualenv\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$cd project\n\n# 默认python2.7\n$virtualenv .env\n# 指定python3, 会安装pip/setuptools/wheel到当前环境.\n$$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env\n\n# 激活虚拟环境\n$source .env/bin/activate\n\n# 先升级pip和setuptools\n$pip install pip\n$pip install setuptools\n$pip install wheel\n\n# 导出项目用的所有依赖库．\n$pip freeze \u0026gt; requirements.txt\n# 在其它环境需要安装依赖：\n$pip install -r requirements.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evirtualenvwrapper\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://bitbucket.org/virtualenvwrapper/virtualenvwrapper\"\u003ehttps://bitbucket.org/virtualenvwrapper/virtualenvwrapper\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e封装了virtualenv的工具:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ pip install virtualenvwrapper\n\n# 创建主目录\n$ mkdir -p $WORKON_HOME\n\n# 最好写入到.bashrc/.zshrc:\n$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python\n$ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv\n$ export WORKON_HOME=~/.virtualenvs\n$ source /usr/local/bin/virtualenvwrapper.sh\n\n# 为每个项目创建独立python环境：\n$ mkvirtualenv -r requirementx.txt [project-name]\n# 不安装setuotools/wheel/pip\n$ mkvirtualenv --no-setuptools --no-wheel --no-pip [name]\n# 指定查找pip/setuptools的路径\n--extra-search-dir=/usr/local/lib/python2.7/dist-packages\n--extra-search-dir=/usr/lib/python2.7/dist-packages\n$ workon [project-name] # 切换到针对该项目的virtualenv\n(pro)$ /path/to/pip install [package] # 安装第三方包\n(pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装\n(pro)$ lssitepackages # 查看安装的第三方包\n$ deactivate # 退出virtualenv\n$ rmvirtualenv [project-name] # 删除环境\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epipenv\u003c/p\u003e",
    "content": "Package PEP426是python最新的打包标准，定义了wheel为最新的python包。\nhttps://www.python.org/dev/peps/pep-0426/\nensurepip 内置模块.提供使用pip从pypi安装模块。\ndistutils 内置的模块.处理简单的包安装,一般使用setuptools代替该模块。\nvenv python3新增了虚拟环境的包．python2中使用virtualenv.\nzipapp python3新增管理可执行的python的zip包．\nTPL 相关的第三方库\nvirtualenv python3.5开始并入了虚拟化标准库venv.\n分离的虚拟的python环境,自动安装setuptools和pip和wheel\nhttps://github.com/pypa/virtualenv\n$cd project # 默认python2.7 $virtualenv .env # 指定python3, 会安装pip/setuptools/wheel到当前环境. $$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env # 激活虚拟环境 $source .env/bin/activate # 先升级pip和setuptools $pip install pip $pip install setuptools $pip install wheel # 导出项目用的所有依赖库． $pip freeze \u0026gt; requirements.txt # 在其它环境需要安装依赖： $pip install -r requirements.txt virtualenvwrapper\nhttps://bitbucket.org/virtualenvwrapper/virtualenvwrapper\n封装了virtualenv的工具:\n$ pip install virtualenvwrapper # 创建主目录 $ mkdir -p $WORKON_HOME # 最好写入到.bashrc/.zshrc: $ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python $ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv $ export WORKON_HOME=~/.virtualenvs $ source /usr/local/bin/virtualenvwrapper.sh # 为每个项目创建独立python环境： $ mkvirtualenv -r requirementx.txt [project-name] # 不安装setuotools/wheel/pip $ mkvirtualenv --no-setuptools --no-wheel --no-pip [name] # 指定查找pip/setuptools的路径 --extra-search-dir=/usr/local/lib/python2.7/dist-packages --extra-search-dir=/usr/lib/python2.7/dist-packages $ workon [project-name] # 切换到针对该项目的virtualenv (pro)$ /path/to/pip install [package] # 安装第三方包 (pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装 (pro)$ lssitepackages # 查看安装的第三方包 $ deactivate # 退出virtualenv $ rmvirtualenv [project-name] # 删除环境 pipenv\nhttps://github.com/pypa/pipenv\n封装了virtualenv的工具，用于取代virtualenvwrapper.\nsetuptools https://github.com/pypa/setuptools\nhttps://github.com/pypa/wheel\npython2.7.9和python3.4以及virtualenv自带setuptools．\n支持sdist打包成tar.gz包,和wheel打包成whl包．\n$pip install -U pip $pip install -U setuotools $pip install -U wheel 创建setup.py文件：\nhttps://pypi.python.org/pypi?%3Aaction=list_classifiers\nimport os from setuptools import setup, find_packages import project def read(readme): extend = os.path.splitext(readme)[1] # pypi只识别reST格式 if (extend == \u0026quot;.rst\u0026quot;): import codecs return codecs.open(readme, 'r', 'utf-8').read() # pypandoc可以将markdown格式转换成reST格式 elif (extend == \u0026quot;.md\u0026quot;): import pypandoc return pypandoc.convert(readme, 'rst') setup( # metadata: name=project, version=project.__version__, url='', download_url='', author='', author_email='', maintainer='', maintainer_email='', description='' long_description=read('README.XXX'), license='', platforms='any', keywords='', classifiers=[ 'Development Status :: 5 - Production/Stable', ... ], # options # 指定源码的位置 packages=find_packages(), package_dir={}, # 需要和源码一起安装的非代码文件,写入MANIFEST.in # 比如文档和测试文件 package_data={}, # 将指定的文件放入安装路径 include_package_data=None, # True表示 exclude_package_data=None, # 不需要和源码一起安装的非代码文件. # 比如配置文件 data_files=[(dest, source),()], # 通过pip安装requirement install_requires=['a==1.0.0', 'b\u0026gt;=1.0.0'], # python版本的要求 python_requires='\u0026gt;=3', setup_requires=[], extras_require=None, test_require=[] zip_safe=True, # 安装一个命令 scripts=[], # 会被添加到环境变量用于命令. entry_points={} # preinst/postinst cmdclass={ \u0026quot;develop\u0026quot;: PostInstDevelop, \u0026quot;install\u0026quot;: PostInstInstall } ) 怎样实现postinst功能：\nfrom setuptools.command.develop import develop from setuptools.command.install import install class InstDevelop(develop): def run(self): # your preinst code here for develop. develop.run(self) # your postinst code here for develop. class InstInstall(install): def run(self): # your preinst code here for install. install.run(self) # your postinst code here for install. 创建setup.cfg文件：\n[wheel] universal = 1 创建README.rst文件：\n可以是rst格式也可是是md格式。\n如果是md格式不要使用类似于***的分割线。\n参考rst和md的文档 创建MAINFEST.in文件：\n默认只有python模块和包会被打包，如果需要其它文件需要添加到这个文件中。\ninclude LICENSE README.rst AUTHORS.rst CONTRIBUTING.rst recursive-include docs * graft examples graft tests global-exclude *.py[co] prune docs/_build prune docs/_themes 创建__init__.py文件：\n位于project/project/__init__.py，安装后用import导入，help(project)看到的信息。\nNAME: 自动获取的项目名字 - 该文件注释的总结部分 FILE: /install_path/project/project/__init__.py DESCRIPTION: 该文件的注释，除总结部分 PACKAGE CONTENTS: 在project/project/自动获取的py文件名 DATA: __开头和结尾的变量 VERSION: __version__变量的值 AUTHOR: __author__变量的值 #!/usr/bin/env python # -*- coding: utf-8 -*- \u0026quot;\u0026quot;\u0026quot; SUMMARY Descriptions \u0026quot;\u0026quot;\u0026quot; __version__ = '' __author__ = '' ... 发布到pypi主服务器pypi：\n去pypi注册帐号\nhttps://pypi.python.org/pypi\n创建~/.pypirc文件\n[distutils] index-servers = pypi [pypi] username = \u0026lt;username\u0026gt; password = \u0026lt;password\u0026gt; 在索引中注册项目(不再支持，直接upload)：\n[Deprecated] $ python setup.py register -r pypi 先打包, 在dist目录生成包:\n$ python setup.py sdist # 生成tarball $ python setup.py bdist_wheel # 安装wheel后，可以用setuptools生成wheel包 再上传到pypi(推荐):\n$ pip install twine $ twine upload dist/* 打包并上传到pypi：\n$python setup.py sdist upload -r pypi $python setup.py bdist_wheel upload -r pypi cython 编译成.so文件\n安装:\n$ sudo pip install cython 在setup.py中引用:\nfrom Cython.Build import cythonize from Cython.Distutils import build_ext def add_extensions(modules): extensions = [] for module in modules: level = module for depth in range(10): source_dir = level + \u0026quot;.py\u0026quot; if glob.glob(source_dir): extensions.append(Extension(module, [source_dir], include_dirs=[\u0026quot;.\u0026quot;], extra_compile_args=['-O3']),) level = os.path.join(level, \u0026quot;*\u0026quot;) print(extensions) return extensions INCLUDE_PACKAGES = [] EXCLUDE_PACKAGES = [] setup( ext_modules=cythonize( add_extensions(INCLUDE_PACKAGES), build_dir=\u0026quot;build\u0026quot;, # 指定 .py =\u0026gt; .c 使用8个线程编译. nthreads=8, compiler_directives=dict( always_allow_keywords=True, language_level=3), exclude=EXCLUDE_PACKAGES), cmdclass={ \u0026quot;install\u0026quot;: InstInstall, \u0026quot;build_ext\u0026quot;: build_ext }, ) // -j 8 指定.c =\u0026gt; .so 使用8个线程编译. $ python3 setup.py build_ext --inplace -j 8 // 删除符号信息 $ find sandbox/ -name \u0026quot;*.so\u0026quot; -exec strip {} \\; pbr https://github.com/openstack-dev/pbr\n扩展点（Entry Points） pkg_resources\nentry_point_inspector\nhttps://github.com/dhellmann/entry_point_inspector\nstevedore http://docs.openstack.org/developer/stevedore/\n",
    "categories": ["Python"],
    "tags": ["package"]
  },
  {
    "title": "Summary",
    "permalink": "https://canuxcheng.com/post/python_summary/",
    "date": "2016-06-21",
    "summary": "\u003ch1 id=\"python难点总结\"\u003epython难点总结\u003c/h1\u003e\n\u003ch1 id=\"多线程\"\u003e多线程\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGIL\u003c/p\u003e\n\u003cp\u003eGIL: Global Interpretror Lock. 全局解释器锁．\u003c/p\u003e\n\u003cp\u003epython不建议使用多线程，用多进程代替．\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"协程\"\u003e协程\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ecoroutine\u003c/p\u003e\n\u003cp\u003e协程就是同时开启两个任务，但一次只顺序执行一个．\n如果执行的任务阻塞，就切换到下一个继续执行．节省时间．\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e",
    "content": "python难点总结 多线程 GIL\nGIL: Global Interpretror Lock. 全局解释器锁．\npython不建议使用多线程，用多进程代替．\n协程 coroutine\n协程就是同时开启两个任务，但一次只顺序执行一个． 如果执行的任务阻塞，就切换到下一个继续执行．节省时间．\n",
    "categories": ["Python"],
    "tags": ["summary"]
  },
  {
    "title": "OOP",
    "permalink": "https://canuxcheng.com/post/python_oop/",
    "date": "2016-06-21",
    "summary": "\u003ch1 id=\"面向对象oop\"\u003e面向对象/OOP\u003c/h1\u003e\n\u003cp\u003eOOD: Object Oriented Design.\u003c/p\u003e\n\u003cp\u003e面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．\u003c/p\u003e\n\u003cp\u003eOOP: Object Oriented Programming.\u003c/p\u003e\n\u003cp\u003epython内置OOP的结构，但是不必一定要使用类和OOP.\u003c/p\u003e\n\u003cp\u003e面向对象的两个主题就是类和类实例．\u003c/p\u003e\n\u003cp\u003e创建实例的过程叫实例化．\u003c/p\u003e\n\u003cp\u003e属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"类class\"\u003e类/Class\u003c/h1\u003e\n\u003cp\u003e类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．\u003c/p\u003e\n\u003cp\u003e类是一种数据结构的定义，实例是申明了一个这种类型的变量．\u003c/p\u003e\n\u003cp\u003e类的定义：\u003c/p\u003e\n\u003cp\u003ePython 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass ClassName(object):\n    \u0026quot;\u0026quot;\u0026quot;Doc string.\u0026quot;\u0026quot;\u0026quot;\n    class_suite\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类的初始化方法init(相当于构造器):\u003c/p\u003e\n\u003cp\u003e如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。\u003c/p\u003e\n\u003cp\u003einit方法的第一个参数必须是实例self，而且不能有return语句。\u003c/p\u003e\n\u003cp\u003einit方法一般用来设置实例属性(也就是数据属性)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass ClassName(object):\n    def __init__(self, *args, **kwargs):\n        pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e特殊方法new:\u003c/p\u003e\n\u003cp\u003e如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。\u003c/p\u003e\n\u003cp\u003enew方法的第一个参数必须是类cls。并且需要返回一个实例。\u003c/p\u003e\n\u003cp\u003enew方法在object中被定义为staticmethod。\u003c/p\u003e\n\u003cp\u003e相当于析构器的特殊方法del:\u003c/p\u003e\n\u003cp\u003e__del__特殊方法要在实例对象的所有引用都被清除后才会执行。\u003c/p\u003e\n\u003cp\u003e不要在del中做与实例没有关系的事情，一般不建议实现该方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass ClassName(object):\n\n    def __new__(cls, *args, **kwargs):\n        ...\n        return ...\n\n    def __del__(self):\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"类属性\"\u003e类属性\u003c/h2\u003e\n\u003cp\u003e类属性分为数据属性和方法属性。\u003c/p\u003e\n\u003cp\u003e类的数据属性仅仅是定义的类的变量。\u003c/p\u003e\n\u003cp\u003e数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。\u003c/p\u003e",
    "content": "面向对象/OOP OOD: Object Oriented Design.\n面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．\nOOP: Object Oriented Programming.\npython内置OOP的结构，但是不必一定要使用类和OOP.\n面向对象的两个主题就是类和类实例．\n创建实例的过程叫实例化．\n属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．\n类/Class 类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．\n类是一种数据结构的定义，实例是申明了一个这种类型的变量．\n类的定义：\nPython 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。\nclass ClassName(object): \u0026quot;\u0026quot;\u0026quot;Doc string.\u0026quot;\u0026quot;\u0026quot; class_suite 类的初始化方法init(相当于构造器):\n如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。\ninit方法的第一个参数必须是实例self，而且不能有return语句。\ninit方法一般用来设置实例属性(也就是数据属性)。\nclass ClassName(object): def __init__(self, *args, **kwargs): pass 特殊方法new:\n如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。\nnew方法的第一个参数必须是类cls。并且需要返回一个实例。\nnew方法在object中被定义为staticmethod。\n相当于析构器的特殊方法del:\n__del__特殊方法要在实例对象的所有引用都被清除后才会执行。\n不要在del中做与实例没有关系的事情，一般不建议实现该方法。\nclass ClassName(object): def __new__(cls, *args, **kwargs): ... return ... def __del__(self): ... 类属性 类属性分为数据属性和方法属性。\n类的数据属性仅仅是定义的类的变量。\n数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。\n直接通过类名来访问类的数据属性。不建议通过实例来访问类的数据属性。\nclass ClassName(object): CONST_VARIABLE = 'value' def __init__(self, *args, **kwargs): ClassName.CONST_VARIABLE = 'new' ClassName.CONST_VARIABLE = 'new value' 类的方法属性仅仅是一个作为类定义的一部分定义的函数, 与类的实例无关。\n类中定义的方法的第一个参数是一个实例self。\n方法属性必须绑定到一个实例才能被直接调用, 非绑定方法没有给出实例对象一般不能直接调用。\nclass ClassName(object): def func(self, *args, **kwargs): pass Python 3 中，直接调用 ClassName.func() 会报错：TypeError: func() missing 1 required positional argument: \u0026lsquo;self\n调用非绑定方法：\nClassName.func(ClassName()) # 除非传入实例作为第一个参数self的值 # 常用场景： 调用父类中的非绑定方法 class ClassName(BaseClass): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) ... 调用绑定方法： 自动把实例作为self传入，不用显式传入。\nClassName().func() 查看类的属性：\ndir(class) # 内建函数 class.__dict__ # 类的特殊属性 类的特殊属性：\nclass.__doc__ # 文档的特殊属性, 不会被继承. class.__name__ # class name class.__bases__ # 类的父类构成的元组 class.__dict__ # 以字典的形式存储对象的属性 # 新式类新增的三个特殊属性: class.__mro__ # 返回方法解析顺序的元组 class.__subclasses__() # 返回子类的列表 class.mro() 内置类的方法(BIM)的特殊属性:\nbim.__doc__ bim.__name__ bim.__module__ # __builtin__ (Python 3: builtins) bim.__self__ # bim 自定义的方法的特殊属性(UDM):\n'__doc__', '__name__', '__module__', '__self__', '__func__', 实例/Instances 实例化：\nins = ClassName() 实例属性 实例属性：\n实例严格来说只有数据属性(方法属性应该属于类属性)，数据属性就是和某个实例相关联的数据值，这些值独立于其它实例或类，当一个实例被释放，相应的数据属性也被释放。通常通过init方法来设置实例的数据属性。\nclass ClassName(object): DATA = \u0026quot;in class\u0026quot; # 类的数据属性 def __init__(self, default=\u0026quot;default\u0026quot;, *args, **kwargs): self.default = default # 当前实例的数据属性 区别类的数据属性和实例的数据属性。\nobj1 = ClassName() print(obj1.DATA) # \u0026quot;in class\u0026quot;, 当实例没有同名的数据属性，会访问类的数据属性。 obj1.DATA = \u0026quot;in obj1\u0026quot; # 相当于给实例新建了一个数据属性，会覆盖类的数据属性。 print(obj1.DATA) # \u0026quot;in obj1\u0026quot; 访问的是实例的数据属性，覆盖了类的数据属性。 print(ClassName.DATA) # \u0026quot;in class\u0026quot; 访问类的数据属性。 查看实例属性:\ninstance.__dict__ 实例的特殊属性：\ninstance.__dict__ # 以字典的形式存储对象的属性 instance.__class__ # 实例对应的类 封装/Encapsulation 封装描述了对数据／信息进行隐藏的观念，对数据属性提供接口和访问函数．\n默认情况下，数据属性和类属性都是public的．类所在的模块和导入了类的其它模块都可以使用．\nvar # public def method_name(self): 一个下划线开头的属性是protected,能在类本身和子类使用，类的实例可以直接访问，不可以用from module import *导入．\n用于把属性限制在一个模块中．\n_xxx # protected def _xxx(self): 双下划线开头的属性是private, 只能类本身使用，类的实例不能直接访问，子类和其它类都不能使用,子类也不能覆盖．\n用于把属性限制在一个类中.\n__xxx # private def __xxx(self): 系统已经定义的特殊方法，也称魔法方法．\ndef __xxx__(self): # 系统定义的名字 Composition 类之间的关系只有两种继承和包含.\n创建复合对象时可以通过composition组合来增加功能和代码的重用性．\n当类之间有显著不同，并且较小的类是较大的类所需的组件时一般使用组合．\nfrom .company import Company from .home import Home class Emp(object): def __init__(self, *args, **kwargs): self.comp = Company(args) self.home = Home(kwargs) 继承/Inheritance 利用类的两种方式就是包装和继承．\n子类和派生 对于相同的类但是有不同的功能，可以通过derivation派生来实现．\n通过使用一个已经定义好的类，扩展它或者修改，而不会影响系统中使用现存类的其它代码片段．\nclass Father(object): def woman(self): ... class Mother(object); def man(self): ... class Child(Father, Mother): def child(self): ... 继承 继承描述了基类的属性如何遗传给派生类．\n派生类（子类）继承自基类（父类）\npython中的类需要继承一个或多个父类．\nobject类是所有类的父类．\n子类继承了基类的属性和方法．\n文档字符串__doc__是唯一的，不能继承．\n一个类的__bases__属性可以查看它的父类组成的元组．不包括父类的父类．\nclass.__bases__ # 类的父类构成的元组 实例调用方法时，默认调用的该对象的类的本身的方法，如果该类没有实现该方法才会调用父类的方法．\nclass Parent(object): def foo(self): print(\u0026quot;in parent.\u0026quot;) class Child(Parent): def foo(self): print(\u0026quot;in child.\u0026quot;) 从内置类继承 可以从内置类型继承子类，修改一些属性．\nclass RoundFloat(float): def __new__(cls, val): return super(RoundFloat, cls).__new__(cls, round(val, 2)) class SortedKeyDict(dict): def keys(self): return sorted(super(SortedKeyDict, self).keys()) Multiple inheritance多重继承 由于类，类型，内建类型的子类都重新架构，新的类采用MRO算法来查找子类中使用的属性．\nMRO: Method Resolution Order, 方法解释顺序．采用广度优先，从左至右边，来获取在子类中的属性．\n可以通过新式类的特殊属性查看子类的属性的查找顺序：\nclass.__mro__ # 返回方法解析顺序的元组 多继承，mro和super的用法：\nsuper每次只调用MRO中的第一个父类，和getattr的顺序一样．并且相同的父类只调用一次．\n数据属性，普通方法属性，特殊方法属性都是按照MRO顺序来查找．\nhttps://github.com/crazy-canux/python/tree/master/python/multiple_inheritance\n多态/Polymorphism python不支持方法重载，但是可以通过对参数的判断，对不同的参数进行不同的处理。以此来实现重载的功能。\npython可以重载魔法方法。\nmagicmethod python类有一些可自定义的特殊方法集，它们中的一些有预定义的默认行为，一些没有，留到需要的时候去实现。\n这些特殊方法是python中用来扩充类的方法。可以用来模拟标准类型或者重载操作符。\n这些特殊方法都是用双下划线开头和结尾的，也被称为魔法方法。\n基本特殊方法：\n__init__(self, *args, **kwargs) # 构造器，带一些可选的参数 __new__(cls, *args, **kwargs) # 构造器，带一些可选的参数，通常用来设置不可变数据类型的子类。 __del__(self) # 解构器 __str__(self) # 可打印的字符输出，str(), print obj = ClassName() print(obj) # 默认的类的__str__会调用__repr__ # 可以通过重写__str__或__repr__来改变打印的内容 __repr__(self) # 运行时的字符串输出，repr(), `` obj = ClassName() obj # 默认的打印对象的运行时的字符串，\u0026lt;test.RoundFloat at 0x7fb715253e90\u0026gt; # 可以通过重写__repr__()改变打印的内容 # Python 2: __unicode__，Python 3: 字符串默认unicode，无需 __unicode__ # Python 2: __nonzero__，Python 3: __bool__ __bool__(self) # 为object定义False值，bool() __hash__(self) # 返回对象hash值，hash() 可调用对象的特殊方法：\n__call__(self, *args) # 表示可调用的实例, callable(object) 会返回true. class TestClass(object): def __call__(self, *args): print(\u0026quot;Instance is callable after implement call method in class.\u0026quot;) print(\u0026quot;Args come from instance invoke is: {}\u0026quot;.format(args)) tc = TestClass() callable(tc) # True tc() tc('arg1') 实例和类的检查相关特殊方法：\n可以控制内置方法的反射(自省)行为．\n__instancecheck__(self, instance) # isinstance(instance, class) __subclasscheck__(self, subclass) # issubclass(subclass, class) 属性相关特殊方法：\n__getattr__(self, name) # getattr(), 仅当属性没有在实例／类／父类的__dict__中找到才会调用． __setattr__(self, name, value) __delattr__(self, name) 新式类的特殊方法：\n# 属性相关 __getattribute__(self, name) # 总是被调用, 会覆盖__getattr__() # 描述符相关 __get__(self, instance, owner) __set__(self, instance, value) __delete__(self, instance) __slots__ __metaclass__ with上下文管理特殊方法：\n__enter__(self) # return self, 需要返回self __exit__(self, exc_type, exc_value, traceback) 对象比较特殊方法：\n__cmp__(self, other) # cmp() __lt__(self, other) __le__(self, other) __eq__(self, other) __ne__(self, other) __gt__(self, other) __ge__(self, other) 容器类型相关特殊方法:\n__len__(self) #　len() __getitem__(self, key) # __setitem__(self, key, value) # __delitem__(self, key) # del __reversed__(self) # reversed() __iter__(self) # iter() __contains__(self, item) __missing__(self, key) https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py\n数值类型相关特殊方法：\n__add__(self, other) __sub__(self, other) __mul__(self, other) __div__(self, other) __truediv__(self, other) __floordiv__(self, other) __mod__(self, other) __divmod__(self, other) __pow__(self, other[, module]) __lshift__(self, other) __rshift__(self, other) __and__(self, other) __xor__(self, other) __or__(self, other) __rxxx__(self, other) # 原位运算必须返回self. __ixxx__(self, other) # self += other -\u0026gt; self = self + other __neg__(self) __pos__(self) __abs__(self) __invert__(self) __complex__(self) __int__(self) __long__(self) __float__(self) __oct__(self) __hex__(self) __index__(self) __coerce__(self, other) Delegation \u0026amp; Wrapping Wrapping包装就是对一个已经存在的对象增加，删除或修改已经存在的功能．\nDelegation授权(代理)是Wrapping包装的一个特性,用于简化处理相关命令性功能，最大化重用代码．\n实现delegation的关键在于覆盖__getattr__()特殊方法．通过调用内置函数getattr()得到一个对象的默认行为．\nclass Wrapper(object): def __init__(self, obj): self.__data = obj def __getattr__(self, attr): return getattr(self.__data, attr) 新式类的特性 随着类和类型的合并，所有类对应的内置函数都是工厂函数，调用工厂函数实际上就是类型实例化。\n属性相关的可定制特殊属性：\n旧式类和新式类都有__dict__属性用字典的方式存储属性，但是字典占用大量内存。\n新式类定义了一个新的属性__slots__用于取代__dict__属性, 是一个类的特殊变量属性。\n__slots__ 属性相关的特殊方法：\n__getattribute__(self, name) # 新式类新增，总是被调用, 会覆盖__getattr__() metaclass 元类用来定义某些类是如何被创建的。改变类的默认行为和创建方式。\n大多数情况下不需要创建元类，一般使用系统的元类的默认方式。\n在执行类定义的时候，解释器必须知道这个类的元类；\nPython 2: class ClassName(object): metaclass = MetaClassName Python 3 推荐： class ClassName(metaclass=MetaClassName):\n在执行类定义时候检查元类，元类传递三个参数到构造器：\n类名 从基类继承数据的元组, __bases__ 类的属性字典, __dict__ 元类相关的可定制属性：\n__metaclass__ 定义一个元类：\nclass MetaClassName(type): def __new__(cls, name, bases, dicts): super().__new__(cls, name, bases, dicts) # 在这里做一些你希望使用该元类的类在定义时做的操作 class ClassName(metaclass=MetaClassName): ... https://github.com/crazy-canux/python/tree/master/python/metaclass\nabstractmethod 抽象方法，类似于java的interface.\n最简单的抽象方法：\n# 如果子类没有实现同名的该方法，就会抛出异常． def base_method(self): raise NotImplementedError 或者使用abc标准库来实现：\nhttps://github.com/crazy-canux/python/tree/master/python/psl/myabc.py\ndescriptors 研究描述符之前先搞清楚普通对象访问属性的优先级．\n普通对象访问(set/get/delete)属性的优先级：\nobj.__dict__['attr'] # 先访问实例对象 obj.__class__.__dict__['attr'] # 再访问类对象 obj.__class__.__base__.__dict__['attr'] # 接着访问基类的对象,不包括metaclass. __getattr__ # 如果实现了的话，优先级最低 descriptors描述符是python新式类的最关键的新特性．\n描述符是具有绑定行为的对象属性，属性访问被描述符协议中的方法覆盖．\n任何实现了下面三个描述符协议方法中的一个的新式类都是描述符.这三个特殊方法充当描述符协议．\n描述符相关的特殊方法：\n__get__(self, obj, type=None) # 返回一个属性的值 __set__(self, obj, value) # 设置一个属性的值，返回None __delete__(self, obj) # 属性的引用递减，返回None 描述符是数据property，class，staticmethod，classmethod, 以及super的机制．\ndata descriptor:定义了__get__和__set__的对象是数据描述符, 主要用于数据属性．\nnon data descriptor:仅仅定义了__get__的对象是非数据描述符，主要用于方法属性．\n如果实例的字典(obj.dict)具有与数据描述符相同名称的条目，则数据描述符优先。\n如果实例的字典(obj.dict)具有与非数据描述符相同名称的条目，则字典条目优先。\nclass DescriptorName(object): def __init__(self, name): self.name = name def __get__(self, instance, typ): print('__get__', instance, typ) return self.name def __set__(self, instance, value): print('__set__', instance, value) self.name = value class TestClass(object): name = DescriptorName('canux') tc = TestClass() print(tc.name) # __get__(tc, type(tc))被调用 print(TestClass.name) # __get__(None, TestClass)被调用 tc.__dict__['name'] = 'test' # 无效 tc.name = 'test' # __set__被调用 TestClass.name = 'test' # 仅仅是重新定义类的属性，覆盖了描述符 # 此时tc.__dict__有同名属性，如果定义了__set__ print(tc.name) # __get__被调用，属性已经修改 print(TestClass.name) # __get__被调用,属性已经修改 # 如果没有定义__set__，就是调用的tc.__dict__里面的． 描述符访问属性的优先级：\n数据描述符(__set__, __get__) # 对于访问实例属性obj.__getattribute__调用方式：type(obj).__dict__['attr'].__get__(obj, type(obj)) # 对于访问类属性class.__getattribute__调用方式：ClassName.__dict__['attr'].__get__(None, ClassName) instance.__dict__ 非数据描述符(__get__) __getattr__ # 如果实现了的话，在描述符中优先级最低 描述符是由__getattribute__特殊方法调用，覆盖该方法可以防止描述符自动调用.\nobj.__getattribute__和class.__getattribute__的调用方式不同．\n描述符的三个特殊方法一般是通过属性访问自动调用．\n函数和方法的描述符：\n在属性访问期间函数包括了__get__方法用于绑定方法．因此函数和方法是非数据描述符．\nclass TClass(object): def __get__(self, obj, typ=None): return types.MethodType(self, obj, typ) def tmethod(self, args): return args class Foo(object): @Tclass def bar(self): print('in bar') obj = TClass() TClass.__dict__['tmethod'] # function __main__.f TClass.tmethod # unbound method TClass.tmethod obj.tmethod # bound method TClass.tmethod of \u0026lt;__main__.TClass object at 0x7f8a4f084c10\u0026gt; obj.function(*args) -\u0026gt; function(obj, *args) Class.function(*args) -\u0026gt; function(*args) property property属性是一种有用的特殊类型的描述符． 也是descriptor的主要用途．\nproperty(fget=None, fset=None, fdel=None, doc=None) # 返回一个property类型的对象 通过上面的descriptor的普通方式实现纯pytho写的property:\nclass Property(object): def __init__(self, fget, fset, fdelete): self.fget = fget self.fset = fset self.fdelete = fdelete def __get__(self, obj, typ=None): return self.fget(obj) def __set__(self, obj, val): self.fset(obj, val) def __delete__(self, obj): self.fdelete(obj) class Foo(object): def fget(self): print 'fget called' def fset(self, val): print 'fset called' def fdelete(self): print 'fdelete called' bar = Property(fget, fset, fdelete) 通过装饰器@property来实现：\nclass Person(object): def __init__(self): self._email = None @property def email(self): return self._email @email.setter def email(self, value): m = re.match('\\W+@\\W+\\.\\W+', value) if not m: raise Exception('email not valid') self._email = value @email.deleter def email(self): del self._email https://github.com/crazy-canux/python/tree/master/python/descriptor\nsuper super只能用于新式类。\n因为同名的方法子类会覆盖父类，在子类中调用父类的同名方法可以通过super内置函数。\nsuper()方法实际是一个构造器。自动找到基类方法，同时传入self参数。\nPython 2: super(type, obj) -\u0026gt; bound super object; requires isinstance(obj, type), obj是实例 super(type, type2) -\u0026gt; bound super object; requires issubclass(type2, type), type2是类。 super(type) -\u0026gt; unbound super object Python 3 推荐： super().init() # 不需要传递参数\n对于单继承, super用来调用父类同名方法。\nclass Child(Parent): def foo(self): Parent.foo(self) # 可以手动调用父类同名的方法，调用非绑定方法，传入self参数。 class Child(Parent): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # Python 3 推荐写法 ... def foo(self, *args, **kwargs): super().foo(*args, **kwargs) # Python 3 推荐写法 ... 对于多继承，super用法参考上面的多继承．\nsuper()返回的对象有一个用于调用Descriptor的定制__getattribute__()方法．\nsuper(B, obj).method() -\u0026gt; obj.__class__.__mro__ -\u0026gt; A.__dict__['method'].__get__(obj, B) https://rhettinger.wordpress.com/2011/05/26/super-considered-super/\nclassmethod 要写一个只在类中运行，而不在实例中运行的方法,可以使用类方法．\n通过classmethod装饰器来装饰该方法，并且方法的第一个参数是一个类cls.\n类方法通常用于替代类构造函数．\nclass ClassName(object): @classmethod def demo_cm(cls, *args, **kwargs): ... # 可以通过类来调用, 也就是可以直接调用非绑定方法．自动传入类作为第一个参数． ClassName.demo_cm(args, kwargs) # 也可以通过实例来调用, 自动传入类作为第一个参数 ClassName().demo_cm(args, kwargs) 描述符相关：\nobj.function(*args) -\u0026gt; function(type(obj), *args) Class.function(*args) -\u0026gt; function(Class, *args) staticmethod 有一些跟类有关的功能，但在运行时又不需要类和实例参与的情况需要用到静态方法．\n通过staticmethod装饰器来装饰该方法，并且第一个参数不需要是类cls或实例self.\n比如修改环境变量或修改其它类的属性，相当于是在类中定义的一个普通函数．\nclass ClassName(object): @staticmethod def demo_sm(): ... # 可以直接调用非绑定方法,但是不会自动传入类． ClassName.demo_sm() # 也可以通过实例调用．但是不会自动传入实例． ClassName().demo_sm() 描述符相关：\nobj.function(*args) -\u0026gt; function(*args) Class.function(*args) -\u0026gt; function(*args) Class Decorators 类装饰器比函数装饰器更灵活，高内聚，封装性等优点．\n类装饰器用于装饰一个类.\ndef deco_name(cls): class WrapperName(cls, ...): def __init__(self, *args, **kwargs): cls.__init__() ....__init__() ... return WrapperName @deco_name class ClassName(object): def __init__(self, *args, **kwargs): ... ... https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py\n其它常见Python 2/3差异 print 语句 → print() 函数 xrange → range raw_input → input basestring → str long/int → int Exception 捕获: except Exception as e dict(instance) → instance.dict 方法属性: Python 3 移除 im_class, im_func, im_self，使用 self、func 等 ",
    "categories": ["Python"],
    "tags": ["oop"]
  },
  {
    "title": "Python",
    "permalink": "https://canuxcheng.com/post/python/",
    "date": "2016-06-21",
    "summary": "\u003ch1 id=\"python概述\"\u003e\u003cstrong\u003ePython概述\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.python.org/2.7/index.html\"\u003ehttps://docs.python.org/2.7/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://python.usyiyi.cn/translate/python_278/index.html\"\u003ehttp://python.usyiyi.cn/translate/python_278/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.python.org/3.5/index.html\"\u003ehttps://docs.python.org/3.5/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://python.usyiyi.cn/translate/python_352/index.html\"\u003ehttp://python.usyiyi.cn/translate/python_352/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003epython是一门优雅而健壮的语言.\u003c/p\u003e\n\u003cp\u003e继承了编译语言(静态语言)的强大性和通用性.\u003c/p\u003e\n\u003cp\u003e同时也借鉴了脚本语言(动态语言)的易用性．\u003c/p\u003e\n\u003cp\u003epython特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高级\u003c/li\u003e\n\u003cli\u003e面向对象\u003c/li\u003e\n\u003cli\u003e可升级\u003c/li\u003e\n\u003cli\u003e可扩展\u003c/li\u003e\n\u003cli\u003e可移植性\u003c/li\u003e\n\u003cli\u003e易学\u003c/li\u003e\n\u003cli\u003e易读\u003c/li\u003e\n\u003cli\u003e易维护\u003c/li\u003e\n\u003cli\u003e健壮性\u003c/li\u003e\n\u003cli\u003e高效的快速原型开发工具\u003c/li\u003e\n\u003cli\u003e内存管理器\u003c/li\u003e\n\u003cli\u003e解释性和编译性\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"python基本语法\"\u003e\u003cstrong\u003epython基本语法\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003epython源程序叫xxx.py\u003c/p\u003e\n\u003cp\u003epython中一切皆对象．\u003c/p\u003e\n\u003cp\u003epython大小写敏感．\u003c/p\u003e\n\u003cp\u003epython通过缩进和冒号:区分语法块，而不是大括号{}.\u003c/p\u003e\n\u003cp\u003epython中的表达式(条件/循环表达式等)不需要用小括号()括起来．\u003c/p\u003e\n\u003cp\u003epython标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．\u003c/p\u003e\n\u003cp\u003epython不支持方法或函数重载．\u003c/p\u003e\n\u003cp\u003epython不支持char和type类型．\u003c/p\u003e\n\u003cp\u003epython没有switch语句．\u003c/p\u003e\n\u003cp\u003epython支持多继承．\u003c/p\u003e\n\u003cp\u003epython不支持++/\u0026ndash;自增和自减运算符．\u003c/p\u003e\n\u003cp\u003epython支持连续比较，a\u0026lt;b\u0026lt;c.\u003c/p\u003e\n\u003ch2 id=\"lexical-analysis\"\u003elexical analysis\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://docs.python.org/2/reference/lexical_analysis.html\"\u003ehttps://docs.python.org/2/reference/lexical_analysis.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLogical lines and physical lines：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# python通过行尾的令牌NEWLINE表示逻辑行\nexpression\n# 以操作系统的换行符表示物理行．\n\\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eencoding declarations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# python脚本中的第一行或第二行的\ncoding[=:]\\s*([-\\w.]+)\n# 注释与正则表达式匹配将被作为编码申明处理．\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e[Deprecated] explicit line joining:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 多个物理行通过反斜线backslash续行进行显示换行\n# 推荐用隐式换行．\nif a == b \\\n       and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释.\n    print('more than one physical line.')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eimplicit line joining：\u003c/p\u003e",
    "content": "Python概述 https://docs.python.org/2.7/index.html\nhttp://python.usyiyi.cn/translate/python_278/index.html\nhttps://docs.python.org/3.5/index.html\nhttp://python.usyiyi.cn/translate/python_352/index.html\npython是一门优雅而健壮的语言.\n继承了编译语言(静态语言)的强大性和通用性.\n同时也借鉴了脚本语言(动态语言)的易用性．\npython特点：\n高级 面向对象 可升级 可扩展 可移植性 易学 易读 易维护 健壮性 高效的快速原型开发工具 内存管理器 解释性和编译性 python基本语法 python源程序叫xxx.py\npython中一切皆对象．\npython大小写敏感．\npython通过缩进和冒号:区分语法块，而不是大括号{}.\npython中的表达式(条件/循环表达式等)不需要用小括号()括起来．\npython标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．\npython不支持方法或函数重载．\npython不支持char和type类型．\npython没有switch语句．\npython支持多继承．\npython不支持++/\u0026ndash;自增和自减运算符．\npython支持连续比较，a\u0026lt;b\u0026lt;c.\nlexical analysis https://docs.python.org/2/reference/lexical_analysis.html\nLogical lines and physical lines：\n# python通过行尾的令牌NEWLINE表示逻辑行 expression # 以操作系统的换行符表示物理行． \\n encoding declarations:\n# python脚本中的第一行或第二行的 coding[=:]\\s*([-\\w.]+) # 注释与正则表达式匹配将被作为编码申明处理． [Deprecated] explicit line joining:\n# 多个物理行通过反斜线backslash续行进行显示换行 # 推荐用隐式换行． if a == b \\ and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释. print('more than one physical line.') implicit line joining：\n# 在括号(parentheses),方括号(square brackets)，大括号(curly braces)中的表达式可以分割多个物理行而不需要显示换行． test_list = [ 'a', # 每一行都可以注释 'b' ] indentation:\n# 逻辑行的开头的空格和跳格用于缩进，python根据行的缩进级别区分语法块． # 缩进级别用于生成INDENT和DEDENT两个令牌 pep8建议用四个空格表示一个缩进级别． python2.7源代码格式:\n#!/usr/bin/env python2.7 # -*- coding: utf-8 -*- 执行python代码：\n$ python mycode.py # OR $ chmod u+x mycode.py $ ./mycode.py python注释 单行注释：\n# comment 多行注释：\n\u0026quot;\u0026quot;\u0026quot; comment1 comment2 comment3 \u0026quot;\u0026quot;\u0026quot; python3键字 def lambda class import from if elif else while for continue break try except finally return pass global raise assert del yield with as and or not is in nonlocal False None True python运算符和优先级 优先级从高到底：\n# 函数调用 f(x) # 序列的切片 seq[ind1:ind2:step] # 序列下标索引 seq[index] # 属性运算. object.attribute # 算术运算符 ** 幂运算，乘方运算符, 等效内置函数pow(), 优先级高于单目运算符 # 位运算(只能用于整数) ~ 按位取反 # 单目运算符． +expr # 结果符号不变 -expr # 对结果符号取负 # 算术运算符, 优先级一样 * / python2两个操作数都是整数时，结果是商舍去小数后的整数,也就是地板除; 只要有一个以上的浮点操作数,结果就是浮点数，也就是真正的除法． / python3会自动转化成两个浮点数出发，结果永远是浮点数，永远是真正的除法． // 地板除，结果总是舍去小数部分． % # 算术运算符, 优先级一样 + - # 位运算(只能用于整数), 优先级一样． \u0026lt;\u0026lt; 左移位运算 \u0026gt;\u0026gt; 右移位运算 # 位运算(只能用于整数) \u0026amp; 按位与 # 位运算(只能用于整数), 优先级一样 ^ 按位异或 | 按位或 # 关系运算, 优先级一样 \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= # 关系运算, 优先级一样 == != # Python2的\u0026lt;\u0026gt;不再支持，使用!= # 赋值运算符和增量赋值 = += -= *= /= %= **= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026amp;= |= ^= # [New] 对象运算符, 优先级一样 is is not # [New] 序列的元素/字典的键/集合的元素 成员运算符, 优先级一样 in not in # boolean逻辑运算符 not 逻辑非 # boolean逻辑运算符, 优先级一样 and 逻辑与 or 逻辑或 python数据类型 python中一切皆对象，每个对象都有身份(id()), 类型(type()) 和 值三个属性．\npython中对象的类型和内存占用都是在运行时确定的．\nis和is not可以判断两个变量是否指向同一个对象：\na is b # 等价于 id(a) == id(b), 表示a和b是同一个对象 a is not b # 等价于 id(a) != id(b), 表示a和b不是同一个对象 is和is not可以判断变量的类型:\nimport types type(a) is types.IntType 垃圾回收 Garbage Collector垃圾回收机制是引用计数为主，标记清除和分代收集为辅．\n当对象被引用，包括对象在被创建，对象被作为参数传递给函数，对象成为容器对象的一个元素时，引用值增加．\n当对象的引用被销毁，包括一个本地引用离开其作用域，对象的别名被del显示销毁，对象的别名被赋值给其它对象，对象被从一个窗口对象中移除，窗口对象本身被del显示销毁，引用值减少．\ndel语句会删除对象的一个引用．\n变量和常量 python是动态类型语言，变量不需要先申明，变量的类型和值在赋值的时候被初始化．\n用全部小写表示变量：\ncounter = 0 miles = 100.03 name = \u0026quot;canux\u0026quot; 用全部大写表示常量：\nPIE = 3.14 类型总结 更新模型：\n不可变类型:immutable不可变类型就是变量的值是固定的，再次赋值就是重新创建了新的对象: 数字类型，字符串str，元组tuple，不可变集合frozenset. 可变类型:mutable可变类型就是变量的值是可以改变的: 列表list，字典dict，可变集合set. 存储模型：\nscalar标量/原子类型:只能容纳单个对象：数字类型，字符串str container容器类型:可以容纳多个对象：元组tuple，列表list，字典dict,集合set/frozenset. 访问模型：\n直接存取:数字类型 索引访问:sequence序列是顺序访问：字符串str，元组tuple，列表list. 映射访问:mapping映射类型是映射访问,元素无序存放，通过唯一的key来访问：字典dict. 数据拷贝 浅拷贝:\n只拷贝顶层数据. 对不可变对象不开辟新空间,相当于赋值操作;修改原数据,相当于定义了一个新的数据.拷贝的数据不变. a=10 b=copy.copy(a) old_id = id(a) == id(b) a=5 # 修改a相当于定义了新变量 id(a) != old_id id(b) == old_id # id(b) 不变 id(b) == 10 对可变对象会在内存开辟新空间保存拷贝的数据;只拷贝第一层中的引用,原数据被修改,拷贝的对象也被修改. a=[1,2,3] b=copy.copy(a) id(a) != id(b) a[0]=5 # 改变a的数据 b == a # b的数据也改变 copy.copy() 深拷贝:\n逐层拷贝数据,直到拷贝的所有引用都是不可变引用. 深拷贝,一份数据改变,不影响另一份数据. copy.deepcopy() Sequences序列类型 sequence序列是指成员有序排列，可以通过下标偏移量访问，同时可以进行切片操作．序列是可迭代的．\nsequence索引操作：\nseq[ind] # 获取下标为ind的元素，下标从0开始． seq[-1] # 取最后一个元素 sequence切片操作：\nseq[ind1:ind2] # 获取下标从ind1到ind2间的元素的集合．不包括ind2. seq[:ind2] # ind1缺省默认为０. seq[ind1:] # ind2缺省表示从ind1到最后一个元素 seq[ind1:ind2:step] # 以步长为step来切片 seq[:ind2:step] seq[::step] # ind1缺省为０，ind2缺省为整个序列长度． seq[::-1] # 翻转序列 seq[::-step] # 以步长为step翻转序列． sequence算术运算：\nseq * number # 序列重复number次 sql1 + seq2 # 两个序列连接 sequence成员运算：\nobj in seq # obj在包含在序列中,返回True obj not in seq # obj不包含在序列中返回True 数字类型 数字类型是不可变类型(immutable),是标量(scalar),是直接存储的．\n0b开头表示二进制\n0开头表示八进制\n0x开头表示十六进制\n数字类型转换的关系是整数转换成浮点数，非复数转换成复数．\nint\nPython3的int类型整合了short、int、long三种长度，统一为int类型，且没有长度限制。\nbool(int)\nbool类继承自int.\nbool类型只有True和False两个值．\nbool类型取反: a = True b = bool(1-a) # b=False float\npython中的float其实就包括了单精度和双精度，相当于float和double都可以用．\ncomplex\npython中有复数类型．\nstr python2中str和unicode继承自basestring, basestring继承自object.\npython3中unicode和basestring在python3中被废弃．str直接继承自object.\npython3中不再需要u/U来表示unicode字符串．\nstr类型是不可变类型(immutable),是标量(scalar),是序列(sequence)通过索引访问．\n字符串表示方法：\n'This is a string' \u0026quot;This is a string\u0026quot; \u0026quot;\u0026quot;\u0026quot;This is a string\u0026quot;\u0026quot;\u0026quot; 字符串的续行：\n下面都表示一个只有一行的字符串．\n# 一个引号的情况,需要在引号内部空格表示和下一行有空格，续行符前的空格可有可无． a = 'This is a ' \\ 'string' b = 'This is a \\ string' c = \u0026quot;This is a \u0026quot; \\ \u0026quot;string\u0026quot; d = \u0026quot;This is a \\ string\u0026quot; # 三引号续行符前的空格就表示和下一行有空格． c = \u0026quot;\u0026quot;\u0026quot;This is a \\ string\u0026quot;\u0026quot;\u0026quot; \u0026gt; This is a string c = \u0026quot;\u0026quot;\u0026quot;line1 line2\u0026quot;\u0026quot;\u0026quot; \u0026gt; line1\\nline2 没有续行符会在行尾加换行符号. 编译时字符串连接：\nfoo = \u0026quot;hello\u0026quot; 'world' urllib.urlopen('http://' # protocol 'localhost' # hostname ':8000' # port '/') # path 原始字符串：\n# 正常情况下在字符串中的特殊字符串(\\加一个字符)表示特殊含义．是不可打印的． print('\\n') # 如果需要表示正常含义需要转译(\\用来转意)． print('\\\\n') # 需要转译． # 也可以使用原始字符串来表示正常含义．r''和R''都可以． print(r'\\n') open(r'C:\\windows\\test.txt') 字符串编码解码:\nUnicode: Universal Multiple-Octet Coded Character Set. 使用十六进制表示．加上前缀U+\nASCII: American Standard Code for Information\nUFT-8: Unicode Transformation Format\npython2因为比unicode出现要早，所以python2默认使用的是ASCII编码．\npython3 默认使用utf-8编码。\n# 获取默认编码 import sys print(sys.getdefaultencoding()) // python2 a = u'测试' type(a) # unicode a # u'\\u6d4b\\u8bd5',　十六进制表示 // python2 # str类型 b = '测试' type(b) # str b # \\xe6\\xb5\\x8b\\xe8\\xaf\\x95 // python2 # encode将unicode类型编码成str类型用于数据传输． encode([encoding[,errors]]) # 编码 c = a.encode('uft-8') type(c) # str c # \\xe6\\xb5\\x8b\\xe8\\xaf\\x95 // python2 # decode将str类型根据原来的编码类型解码成unicode类型进行阅读． decode([encoding[,errors]]) # 解码 d = c.decode('utf-8') # 参数必须是原来的编码的类型 type(d) # unicode d # u'\\u6d4b\\u8bd5' // python2 # python2默认ascii编码，所以encode和decode默认都是ascii. 不能处理中文 u'测试'.encode() # UnicodeEncodeError // python2 # str+unicode, str会隐式的转换成unicode. '测' + u'试' -\u0026gt; '测'.decode() + u'试' # 因为decode默认是ascii不能解码中文,UnicodeDecodeError． '测'.decode('uft-8') + u'试' // python2 # 对非unicode进行encode编码，会先隐式解码成unicode再编码 '测试'.encode('utf-8') # UnicodeDecodeError, 因为'测试'.decode()默认用ascii解码 '测试'.decode('utf-8').decode('utf-8') # python2程序中出现字符串一定加前缀u.表示成unicode格式 u'hello world' # 不要用str(), 用unicode(). # 只在写入文件／数据库／网络时才调用编码函数encode(). # 只在读回数据时才调用解码函数decode(). # 始终使用utf-8编码．否则容易出现乱码． // python3 默认类型非str，而是bytes。 str.encode() # str类型通过encode编码成types类型 bytes.decode() # bytes类型通过decode解码成str类型 可迭代对象转换成字符串：\n''.join(('a', 'b')) # 可迭代对象的元素需要是str类型. ''.join(['a', 'b']) # 可迭代对象的元素需要是str类型. ''.join({'a': 'b'}) # 字典迭代键，可迭代对象的元素需要是str类型. tuple tuple类型是不可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．\n元组是不可变类型，不能对元组的元素进行增删操作．\nlist list类型是可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．\n列表元素增删修改：\n# 除了使用内置方法还可以使用序列的索引． lst[index] = value del lst[index] list comprehensions列表解析 List Comprehensions列表解析,来自函数式编程语言Haskell.\n列表解析使用中括号，列表解析返回一个列表。\nlst = [expression for item in iterable] # 嵌套if lst = [expression for item in iterable if condition] # 嵌套for lst = [expression for item in iterable for item1 in iterable1] [x ** 2 for x in range(10)] 等效于,python2的内置函数map(), filter()都是函数式编程的应用． map(lambda x: x**2, range(10)) [(x+1, y+1) for x in range(10) for y in range(10)] range bytes bytearray memoryview dict dict类型是可变类型(immutable),是容器(container),是映射(mapping)类型,是无序的,通过映射访问．\n字典迭代键，字典的键必须是可哈希的，字典的键必须是不可变类型．列表/字典/可变集合等不可哈希对象不能用作字典的键．\n所有不可变类型都是可哈希的，都可以作为字典的键．\n可用内置函数hash()获取或判断是否能用作字典的键．\n字典的键必须是唯一的，不能一个键对应多个值．有这种情况取最后一个赋值．\n字典的键操作符：\n# 字典通过键操作符来读取元素的值 dic['key'] 键成员操作符:\n# 取代has_key()和keys()内置方法 'key' in dic # 推荐用 'key' in dic 判断键是否存在 'key' not in dic # Python3中dict.keys()、dict.values()、dict.items()返回的是视图对象（可迭代），如需列表可用list(dict.keys())等。 字典元素增删修改：\ndic['key'] = 'value' del dic['key'] Sets集合 集合是一组无序排列的值，不能进行索引和切片操作，也不能进行键操作，只能通过for循环迭代集合元素．\n集合分为可变集合和不可变集合.\n集合运算符：\n'element' in st 是成员 'element' not in st 不是成员 == 等于 != 不等于 \u0026lt; 严格子集 \u0026lt;= 非严格子集, 等效于issubset() \u0026gt; 严格超集 \u0026gt;= 非严格超集, 等效于issuperset() | 联合, OR操作，等效于union()内置方法 \u0026amp; 交集, AND操作，等效于intersection()内置方法 - 差补或相对补集, 等效于difference()内置方法 ^ 对称差分或异或, XOR操作，等效于symmetric_difference()内置方法 仅用于可变集合的运算符： |= 等效于update()内置方法 \u0026amp;= 等效于intersection_update()内置方法 -= 等效于difference_update()内置方法 ^= 等效于symmetric_difference_update()内置方法 集合运算返回结果的类型与左操作数的类型相同，左边是可变集合，结果就是可变集合，否则是不可变集合．\nfrozenset frozenset类型是不可变类型(immutable),是容器(container).\nset set类型是可变类型(mutable)，是容器(container).\npython控制流 continue语句:表示立即终止本次循环，启动循环的下一次迭代．\nbreak语句：表示结束当前循环块，跳转到后面的语句．\npass语句： 表示不做任何事情，NOP.\nif条件语句 if condition: expression elif condition: expression else: expression python中的三目运算：\nX if C else Y 等效于 if C: X else: Y # 三目运算符高于赋值运算符． a = b if c else d # 等效于 a = (b if c else d) while循环语句 while condition: expression # while执行完会执行else(包括while不执行)，break会跳过else． while condition: expression else: expression for循环语句 for循环可以用于遍历序列，字典的键 和 文件的行，集合，列表解析，生成器表达式.\nfor循环会自动调用迭代器的next()方法，捕获StopIteration异常结束循环．\n用for迭代可变对象的时候，不应该改变可变对象的元素的值．\nfor condition: expression # for执行完成会执行else, break会跳过else. for condition: expression else: expression # 字典有两种写法 for loop in dic.keys() 等效于 for loop in dic # 文件有两种写法 for loop in open('file', 'r').readlines(): 等效于 for loop in open('file','r'): iterator迭代器 类型 Iterable: 能直接用于for循环的对象为可迭代对象Iterable.\nIterator: 能被next(g)内置函数调用并不断返回下一个值的对象为迭代器Iterator,迭代完成后抛出StopIteration异常．\nfile，enumerate和reversed内置类类型的工厂函数返回的都是迭代器类型．\n创建迭代器的3种方法：\n# 通过内建函数iter() iter() # 通过工厂函数 file() enumerate() reversed() # 自定义类，需要实现 __iter__() 和__next__() 两个方法(python3) class TestIterator(object): def __iter__(self): return self def __next__(self): if condition: ... else: raise StopIteration() i = TestIterator() type(i) \u0026gt; iterator generator生成器类型 生成器就是一个迭代器对象，在每次调用next()方法时返回一个值．直到抛出StopIteration异常, 生成器通常用于迭代一个巨大的数据集．\ngenerator类类型,是一个迭代器，可以用for循环迭代:\ngenerator.close() # 在生成器内部抛出GeneratorExit异常要求生成器退出． generator.send(arg) # 将值回送给生成器． generator.throw(typ[,val[,tb]]) # 在生成器抛出异常 创建生成器的两种方法：\n使用列表解析的变种\ng = (expression for item1 in iterable1 if condition1) type(g)\ngenerator\nnext(g)\n使用yield关键字\n有yield的函数返回的就是一个生成器．\nyield函数能记住上一次返回时在函数体中的位置，迭代生成器会跳转至该函数中间，而且上次调用的所有局部变量保持不变．\nyield函数和普通函数执行顺序不一样，普通函数顺序执行，遇到return或最后一行语句返回．\nyield函数遇到yield语句返回，下次执行从上次返回的yield语句开始继续执行．遇到return语句抛出StopIteration异常．\ndef gena(): yield 'first' yield 'second' g = gena() type(g) \u0026gt; generator next(g) # first next(g) # second next(g) # StopIteration generator expressions生成器表达式 Generator Expressions生成器表达式, 是列表解析的一个扩展．\n列表解析的缺点就是要迭代整个对象用来创建列表，对大的对象来说性能差.\n生成器表达式就是结合生成器和列表解析解决这个问题．\n生成器表达式不必创建完整的列表，而是一边循环一边计算，返回一个生成器对象。\ng = (expression for item1 in iterable1 if condition1) python文件和输入输出 python2使用open()内置函数打开文件，返回file类类型的对象，出错返回IOError异常.\nfile类类型对象是迭代器，同时也是上下文管理器．\npython3废弃了file类类型，open()内置函数返回IO流．\n# python2 open(name[, mode='r'[, buffering=-1]]) mode r: 读，文件必须存在 w: 写，文件不存在则创建，否则先清空文件再写入． a: 追加，文件存在就追加到文件结尾,否则就创建． t: text模式，这个是默认模式．不用指定． rb/wb/ab: 二进制读写． r+/w+/a+: 以读写模式打开文本文件． rb+/wb+/ab+: 以读写模式打开二进制文件． U: 提供通用换行符支持，文件必须存在 buffering 0: 不缓冲 1: 只缓冲一行数据 \u0026lt;0: 使用系统默认缓冲机制 \u0026gt;1: 使用给定值作为缓冲区大小 通用换行符UNS:\nUniversal Newline Support.\n如果是二进制文件读写rb/wb/ab，不会有换行符的问题，如果是文本文件建议用rU/wU/aU来读写.\n# UNS会把 \\r\\n \\r \\n # 都被替换为 \\n 文件可以使用with上下文管理器，并且迭代文件的行:\nwith open('file', 'rU') as f: for line in f: ... 标准文件:\n系统默认的三个标准文件: sys.stdin, sys.stdout, sys.stderr.\n# python2的关键字print会把语句打印到sys.stdout,并默认在语句结尾加换行符. print(expression) print(expression, end='') # 可以避免默认加换行符 # 内置函数input()会从sys.stdin接受输入 a = input() python错误和异常 参考内置的错误和异常.\nBaseException是所有异常的基类． Exception是常规错误的基类.\n错误和异常的检测和处理：\ntry: try_suite except Exception0[ as reason]: # reason可以用于在except_suite中打印具体的异常信息，reason是一个Exception0类型的实例． except_suite except Exception1[ as reason]: # 可以有多个except用来捕获不同的异常，但是只有一个except会被执行. except_suite except (Exception2, Exception3)[ as reason]: # 也可以在一个except中同时检测多个异常．放入一个tuple中. reason是一个实例的元组． except_suite except Exception[, reason]: # 可以用Exception来捕获所有异常，而不用区分具体的异常．不推荐用逗号，应该用as代替． except_suite [Deprecated] except: # 不推荐此用法，和上面一个等效 except_suite ... else: # 可选， 没有异常触发except时运行else,　except和else只能运行一个． expression finally: # 可选，无论是否捕捉到异常都会执行的． expression # 也可以不对异常处理 try: try_suite finally: finally_suite # 异常的参数 reason.__clas__.__name__ # 就是异常类的名字 print(reason) # 打印异常参数． raise触发异常 除了上面捕获解释器触发的异常，用户还可以用raise自己触发异常:\nraise [SomeException [, args [, traceback]]] SomeException可以是字符串，内置异常，第三方库异常类，自定义异常类, 或实例.\nraise ExceptionClass[, args[, traceback]] # 类 raise ExceptionClass(arguments)[, args[, traceback]] # 实例 raise ExceptionClass, instance # [TODO] raise instance # 触发实例异常, raise reason 就是跑出一个ExceptionClass类型的instance. raise string # 触发字符串异常 raise # 重新触发前一个异常，如果之前没有异常触发TypeError. 自定义异常和错误 自定义异常需要继承一个标准异常或者第三方库的异常来实现一个类．\n通过raise来触发自定义的异常．\nclass MyError(Exception/StandardError/Warning): def __init__(self, msg): super(...).__init__(self, ...) ... ... raise MyError, args assert断言 断言语句等效assert表达式, 如果断言成功不采取任何措施，否则触发AssertionError异常．\nassert expression[, arguments] 可以提供一个异常参数和捕获AssertionError异常:\ntry: assert expression, \u0026quot;If raise AssertionError, print this message.\u0026quot; except AssertionError as e: print('%s: %s' % (e.__class__.__name__, e)) with上下文管理 CMP: context management protocol.\nwith上下文管理仅用于支持上下文管理协议(CMP)的对象．\nwith context_expr [as var]: with_suite with语句执行时就执行上下文符号（with和as之间的内容）来获得一个上下文管理器．\n上下文管理器调用__context__()方法来返回一个上下文对象．\n上下文对象会调用__enter_()方法完成with语句块执行前的准备工作．返回值赋给as后面的var变量．\nwith语句块执行完毕后调用__exit__()方法，exit()有三个参数，如果没有异常都是None,否则是sys.exc_info()的三个返回值．\n自定义上下文管理器:\nclass CMPTest(object): def __init__(self): pass def __enter__(self): ... return self def __exit__(self, type, value, traceback): ... 父类实现了上下文管理协议，子类可以直接使用with.\npython函数 定义/申明一个函数:\npython对函数的申明和定义是一起的．\n函数必须先定义/申明才能引用/调用.\n通过关键字def来定义一个函数.\ndef function_name(arguments) expression\n函数引用：\n引用一个函数名并不会执行函数内容．\nfunction_copy = function_name # 可以将函数作为参数传给另外一个函数，然后在另外一个函数调用该函数 def fun_name(arg): print(arg(10)) fun_name(str) 函数调用:\n调用一个函数才会执行函数内容.\nfunction_name(arguments) # 可以通过引用的副本来调用函数 function_copy(args) 函数的返回值：\n省略return表示返回None. 单个return表示返回None.其它表示返回一个对象．\nreturn return return_value 函数的实参：\n位置参数，调用的时候通过先后顺序传递的参数,函数定义时需要放在前面．\n默认参数，在函数定义时就已经初始化的参数，调用时可以不再赋值．\n默认参数在函数定义时需要放在位置参数的后面．否则抛出SytaxError.\ndef function_test(position_args, keyword_args, *args, **kwargs): pass 函数的形参：\n位置参数，在函数调用时根据定义的参数的顺序来传递．\n默认参数，在函数调用时如果没有传值则使用定义的默认值．\n关键字参数，在函数调用时，根据定义时的参数名称来传值.\n非关键字参数的传值不能在关键字参数后面．\ndef func_test(arg1, arg2, arg3=\u0026quot;val1\u0026quot;, arg4=\u0026quot;val2\u0026quot;): pass func_test(1, 2, 3, 4) # 位置参数 func_test(1, 2) # 使用默认参数 func_test(arg2=2, arg1=1) # 关键字传参 可变长度参数:\n当函数参数不确定时，可以使用可变长度参数．\n一个星号表示一个非关键字参数组成的元组(可以是其它序列，会自动转换成元组)．\n两个星号表示一个关键字参数组成的字典．\n函数定义时可变长度参数必须在位置参数和默认参数后面．而且关键字变长参数应该在最后.\ndef func_test(position, default='value', *args, **kwargs): pass 调用可变长度参数时，可以把非关键字变长参数放到一个元组，把关键字变长参数放到一个字典．\n也可以在元组和字典中放部分参数，另外一部分直接传递, 非关键字参数的传值不能在关键字参数后面．\n# 注意，函数定义的时候星号是必须的，函数调用的时候也需要星号． args = ('val1', 'val2') kwargs = {key1: 'val1', key2: 'val2'} func_test('position', 'default', *args, **kwargs) # 部分传递，多出来的非关键字参数属于变长非关键字参数，多出来的关键字参数属于变长关键字参数． func_test('position', 'default', 'non-keyword', key='keyword', *(1,2), **{3: 'three'}) 函数的属性：\n通过小数点来调用函数的属性．\n内置函数的特殊属性(BIF)：\nfunction_test.__doc__ function_test.__name__ function_test.__module__ # __builtin__ function_test.__self__ # None 自定义函数的属性(UDF)：\ndir(function_test) '__doc__', '__name__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name' 偏函数:\nfrom functools import partial partial(func, *args, **keywords) # 一个偏函数的类 变量作用域:\npython搜索一个标识符先从局部作用域开始搜索，如果没有找到就在全局作用域找，否则抛出NameError异常．\n# 当在函数外部和内部都定义了同一个变量，局部变量会覆盖全局变量 var = 'global' def func_test(*args, **kwargs): var = 'local' print(var) func_test() # local # 如果在函数内部使用一个不在函数内部定义的变量，就会在函数外部查找． var = 'global' def func_test(*args, **kwargs): print(var) func_test() # global # 在函数内部不能修改外部变量,只能引用. var = 'global' def func_test(*args, **kwargs): var += 'local' print(var) func_test() # UnboundLocalError: local variable 'var' referenced before assignment # 如果需要在局部引用全局变量需要使用global关键字 var = 'global' def func(*args, **kwargs): global var var = 'local' print(var) func() # local print(var) # local # 全局变量在局部被修改． lambda匿名函数 lambda匿名函数就是一个只有一行表达式，不需要通过def来命名的函数.\nlambda匿名函数返回一个可调用的函数对象．\nlambda匿名函数支持通过def定义的函数的所有功能．\nlambda匿名函数中不能有return语句, expression的结果就是函数返回值．\nlambda [arg1[, arg2, ...argN]]: expression lambda *args, **kwargs: expression lambda : expression Functional Programming函数式编程 python涉及到函数式编程主要有几个内置函数和lambda匿名函数．\nfilter(function, iterable) result = filter(lambda x: x%2==0, [1,2,3,4,5]) \u0026gt; x=1, 1%2==0 False \u0026gt; x=2, 2%2==0, True \u0026gt; x=3, 3%2==0, False print(list(result)) \u0026gt; [2] map(function, iterable, ...) result = map(lambda x: x**2, [1,2,3]) \u0026gt; x=1, x**2 =1 \u0026gt; x=2, 2**2=4 \u0026gt; x=3, 3**2=9 print(list(result)) \u0026gt; [1,4,9] from functools import reduce reduce(func, iterable[, initializer]) reduce(lambda x,y: x*y, [1,2,3,4] \u0026gt; x=1,y=2, x*y=2 \u0026gt; x=2, y=3, x*y=6 \u0026gt; x=6, y=4, x*y=24 内嵌函数 可以在函数内部定义函数，内部函数不能在外部函数以外的地方调用．\ndef outer(*args, **kwargs): expression def inner(arg): # 内嵌函数的参数不能是外部函数的参数．内部函数必须完全独立． expression inner(args) def outer(*args, **kwargs): filter(lambda arg: expression, sequence) map(lambda arg: expression, sequence) functools.reduce(lambda arg: expression, sequence) 可以在函数内部内嵌匿名函数，匿名函数可以使用外部函数的参数:\ndef foo(x, y): bar = lambda :x + y print(bar()) foo(4,3) 递归：\n在函数中调用函数本身是一种递归方法 def fib(n): if n in[0, 1]: val = 1 else: val = fib(n-1) + fib(n-2) return val closure闭包 在一个内部函数里对在外部作用域的变量进行引用，内部函数被认为是closure.\n定义在外部函数内的但由内部函数引用的变量称为自由变量．\n当自由变量是一个函数时，闭包就是一个装饰器，decorator是closure最常见的应用．\ndef outer(free): def clos(*args, **kwargs): print(free) print(args, kwargs) return clos # 调用外部函数，返回一个内部函数的引用,　传入外部函数的就是自由变量,返回的内部函数就是闭包. first_clos = outer(1) # 调用closure first_clos(*args, **kwargs) decorator装饰器 装饰器分为函数(方法)装饰器和类装器．函数中再定义函数是函数装饰器，函数中再定义类是类装饰器．\n函数装饰器修饰函数和类中的方法，类装饰器修饰类．类装饰器参考OOP．\n装饰器本质是一个函数，可以让其它函数在不做修改的情况下增加额外的功能．\n常用于插入日志，性能测试，事务处理，缓存，权限校验等场景．\n装饰器是用来装饰函数的包装，返回一个修改后的函数对象．将其重新赋值给原来的标识符，并永久失去对原始函数对象的访问．\n符号@是装饰器的语法糖.\n不带参数的装饰器：\ndef deco_name(func): def wrapper_name(*args, **kwargs): # 抽象出相同的部分进行包装 \u0026quot;\u0026quot;\u0026quot;Docs for wrapper_name.\u0026quot;\u0026quot;\u0026quot; print(func.__name__) # 抽象出来的部分在这里实现 print(args, kwargs) # 可以引用func传入的参数 return func(*args, **kwargs) # 最后调用新增加的功能 return wrapper_name # 返回包装函数的引用. # 增加新功能,装饰后返回包装函数的一个引用,赋值给原来的foo．此时包装函数wrapper_name并不会执行 @deco_name def foo(*args, **kwargs): \u0026quot;\u0026quot;\u0026quot;Docs for foo.\u0026quot;\u0026quot;\u0026quot; print('call foo') # 等效于 foo = deco_name(foo) # 调用装饰后的函数,　调用的是装饰后的新的函数． foo(*args, **kwargs) 带参数的装饰器:\ndef deco_name(arg): def deco_inner(func): def wrapper_name(*args, **kwargs): \u0026quot;\u0026quot;\u0026quot;Docs for wrapper_name.\u0026quot;\u0026quot;\u0026quot; print(arg) # 通过装饰器的参数arg来做一些判断 print(func.__name__) print(func.__doc__) print(args, kwargs) return func(*args, **kwargs) return wrapper_name return deco_inner # deco_name(arg)(foo) -\u0026gt; deco_inner(foo) -\u0026gt; wrapper_name @deco_name(arg=\u0026quot;value\u0026quot;) def foo(*args, **kwargs): \u0026quot;\u0026quot;\u0026quot;Docs for foo.\u0026quot;\u0026quot;\u0026quot; pass # wrapper_name(*args, **kwargs) foo(*args, **kwargs) 装饰器的属性：\nfoo.__name__ # wrapper_name, 并非foo foo.__doc__ # \u0026quot;Docs for wrapper_name.\u0026quot;, 并非foo的doc. # 可以通过import functools.wraps来修饰wrapper_name改变这一属性． https://github.com/crazy-canux/python/blob/master/python/psl/myfunctools.py\n多层装饰器：\n@foo @bar def func(*args, **kwargs): ... func = foo(bar(func)) https://github.com/crazy-canux/python/blob/master/python/decorator/function_decorator.py\npython模块和包 名称空间：\n局部名称空间 全局名称空间 内建名称空间 python解释器最先加载内建名称空间，也就是__builtins__模块．\n然后加载执行模块的全局名称空间，在模块执行时是活动名称空间．\n最后加载局部名称空间，在执行期间是不断变化的．\n名称空间和变量的作用域是有区别的．\n变量／函数／方法先从局部名称空间开始查找，在找全局名称空间，最后查找内建名称空间．\n如果都没找到就抛出NameError异常．\n无限制名称空间，可以通过属性运算小数点来指定名称空间．\nmodule.var module.function() module.method() 搜索路径:\n搜索路径在不同的操作一同一般不同.\n搜索路径通过两个变量来设置\nshell的环境变量PYTHONPATH． python解释器的变量sys.path列表里. 在代码里修改搜索路径sys.path\nsys.path.append(os.path.abspath(..)) sys.path.insert(0, os.path.abspath(..)) # 插入到最前面，也就是在sys.path的第一个\u0026rsquo;\u0026rsquo;(当前路径)的前面． 所有导入并加载的模块会存放在sys.modules中，导入模块时的搜索顺序\n先搜索当前目录.(会覆盖同名的标准库), 其实是在运行过程中动态添加到sys.path中第一个\u0026rsquo;\u0026lsquo;的位置． 没有的话再搜索sys.path,按照这个列表的顺序搜索找到第一个，然后加载该模块. 没搜到抛出ImportError异常． module模块 模块就是一个python程序的源文件．模块是用来组织python代码的方法．\n把其他模块中属性附加到你的模块中的操作叫做导入(import).\n那些自我包含并且有组织的代码片断就是模块( module ).\npackage 包就是把多个模块放在一个目录中，然后必须加上__init__.py文件．包是用来组织模块的．\n# 包支持模糊导入. [Deprecated] from package.module import * # 会导入包里面所有的变量，函数，类． 在__init__.py导入属性，导入时可以省略模块名：\nrobot/__init__.py from robot.run import run, run_cli test.py from robot import run, run_cli # 可以省略属性所在的模块名 run() run_cli() 等效: test.py from robot.run import run, run_cli # 通过包名和模块名直接导入． run() run_cli() 在__init__.py定义__all__变量来决定导入哪些属性．\nfrom robot.run import run, run_cli __all__ = [run, run_cli] from robot import * # 仅仅导入__all__指定的属性 import导入模块和包 如果模块第一次被导入，就会被加载并执行．也就是说模块被加载时顶层的代码会被执行，一般包括全局变量，类和函数的申明．\n一个模块无论被导入(import)多少次，只在第一次导入时被加载一次．除非用reload()函数．\nimport导入顺序(中间空一格)：\n标准库模块 第三方库模块 自定义模块 import关键字导入模块/包：\nimport module import package # 包可以多层嵌套 import package.subpackage import package.subpackage.module from-import关键字导入模块中的属性：\nfrom module import function/method/variable from package.module import function/method/variable from package.subpackage.module import function/method/variable from-import关键字导入包中的的包/模块到当前的名称空间：\nfrom package import subpackage from package...subpackage import sub-subpackage from package import module as关键字可以给模块/包/属性取别名：\nimport module/package/package.subpackage as alias from module/package.module/package.subpackage.module import function/method/variable as alias from package/package.subpackage import module/subpackage/sub-subpackage alias 相关的内置函数:\nlocals() global() [Deprecated] reload() # 推荐用from imp import reload(), 重新导入一个已经导入的模块． 模块的特殊属性：\n__name__ # 模块的特殊属性 # 如果模块直接运行，也就是作为top-level脚本运行．值为__main__. # 如果作为module,也就是(import/python -m)，值为模块名称. # 一般用来做单元测试. if __name__ == \u0026quot;__main__\u0026quot;: main() PEP0328 多行导入：\n# 通过续行符 from module import a, b, c, \\ d, e, f # 通过分成两行导入 from module import a, b, c from module import d, e, f # PEP328建议使用分组导入 from module import (a, b, c, d, e, f) # 不推荐使用模糊导入． [Deprecated] from module import * 绝对导入：\n默认采用绝对导入，也就是通过完整的包路径来导入，避免和标准库模块冲突．\n默认的包路径就是sys.path或PYTHONPATH.\n只有import没有from的一定是绝对导入．\nimport package/module 相对导入： [TODO]\n小数点开头表示相对导入，一个小数点表示当前的包，两个小数点表示上一层的包，以此类推．\n相对导入一定是import-from结构．\n相对导入的优先级低于绝对导入，也就是先去sys.path中查找，然后根据当前模块的相对位置查找．\nfrom . import package/module from .foo import bar from ..foo import bar from ...foo import bar python文档 文档注释:\npython的文档注释采用reST风格的注释.\n包/模块文档:\n包括作者,版权,模块的信息.\n\u0026quot;\u0026quot;\u0026quot; File Summary Copyright License :author: :version: :since: Description \u0026quot;\u0026quot;\u0026quot; 类/函数/方法文档:\n包括作用,初始化方法参数和类型,函数和方法的参数和类型,返回类型和抛出异常,以及用法用例.\n\u0026quot;\u0026quot;\u0026quot;Summary :param param1: param1 used for what :type param1: param1 type :param param2: param2 used for what :type param2: param2 type ... :returns param: return what :rtype param: return type ... :raise exceptionname: raise what exception Usage/Description \u0026quot;\u0026quot;\u0026quot; 文档的特殊属性:\n__doc__ # 函数/类/方法的特殊属性，用来表示文档的属性 # 文档字符串不能被子类继承． ",
    "categories": ["Python"],
    "tags": ["python"]
  },
  {
    "title": "Tmux",
    "permalink": "https://canuxcheng.com/post/devops_tmux/",
    "date": "2016-06-19",
    "summary": "\u003ch1 id=\"tmux\"\u003etmux\u003c/h1\u003e\n\u003cp\u003etmux是终端复用工具，类似于gnu screen。\u003c/p\u003e\n\u003cp\u003etmux三个基本概念：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e会话（session）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e窗口（window）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e面板（pane）\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003etmux使用c/s架构，tmux命令启动tmux服务器，一个tmux服务有多个session，\n每个session就是tmux管理下的伪终端集合，一个session有多个window与之关联，\n每个window就是一个伪终端，占据整个屏幕，一个window可以被分割成多个pane。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tmux安装和配置\"\u003etmux安装和配置\u003c/h1\u003e\n\u003cp\u003etmux依赖libevent和ncurses库。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://libevent.org/\"\u003ehttp://libevent.org/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo yum install libevent-devel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"http://invisible-island.net/ncurses/\"\u003ehttp://invisible-island.net/ncurses/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo yum install ncurese-devel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"http://tmux.github.io/\"\u003ehttp://tmux.github.io/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo apt-get install tmux\nsudo yum install tmux\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用户配置文件： ~/.tmux.conf\u003c/p\u003e\n\u003cp\u003e系统配置文件： /etc/tmux.conf\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tmux相关项目\"\u003etmux相关项目\u003c/h1\u003e\n\u003ch2 id=\"tpm\"\u003eTPM\u003c/h2\u003e\n\u003cp\u003eTmux Plugins Manager.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/tmux-plugins/tpm\"\u003ehttps://github.com/tmux-plugins/tpm\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"tmux用法\"\u003etmux用法\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eman tmux\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e开启tmux：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etmux\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e退出tmux：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexit\nctrl + d\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e列出tmux会话：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etmux ls\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"tmux快捷键\"\u003etmux快捷键\u003c/h2\u003e\n\u003cp\u003etmux的prefix是ctrl-b\u003c/p\u003e\n\u003cp\u003e按下ctrl-b然后松开，通知tmux下面的按键是快捷键。\u003c/p\u003e\n\u003cp\u003e查看所有快捷键：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ectrl-b + ?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e显示时间：\u003c/p\u003e",
    "content": "tmux tmux是终端复用工具，类似于gnu screen。\ntmux三个基本概念：\n会话（session）\n窗口（window）\n面板（pane）\ntmux使用c/s架构，tmux命令启动tmux服务器，一个tmux服务有多个session， 每个session就是tmux管理下的伪终端集合，一个session有多个window与之关联， 每个window就是一个伪终端，占据整个屏幕，一个window可以被分割成多个pane。\ntmux安装和配置 tmux依赖libevent和ncurses库。\nhttp://libevent.org/\n$ sudo yum install libevent-devel http://invisible-island.net/ncurses/\n$ sudo yum install ncurese-devel http://tmux.github.io/\nsudo apt-get install tmux sudo yum install tmux 用户配置文件： ~/.tmux.conf\n系统配置文件： /etc/tmux.conf\ntmux相关项目 TPM Tmux Plugins Manager.\nhttps://github.com/tmux-plugins/tpm\ntmux用法 man tmux 开启tmux：\ntmux 退出tmux：\nexit ctrl + d 列出tmux会话：\ntmux ls tmux快捷键 tmux的prefix是ctrl-b\n按下ctrl-b然后松开，通知tmux下面的按键是快捷键。\n查看所有快捷键：\nctrl-b + ? 显示时间：\nctrl-b + t session操作 交互式选择一个session:\nctrl-b + s 选择一个session来detach：\nctrl-b + D detach当前session:\nctrl-b + d 重命名当前的session：\nctrl-b + $ window操作 交互式选择一个window:\nctrl-b + w 创建一个新window:\nctrl-b + c 关闭当前window:\nctrl-b + \u0026amp; 切换到上一个window:\nctrl-b + p 切换到下一个window:\nctrl-b + n 移到之前选中的window：\nctrl-b + l 使用window号切换window:\nctrl-b + [number] 重命名window:\nctrl-b + , pane操作 横向分屏:\nctrl-b + % 纵向分屏:\nctrl-b + \u0026quot; 选择pane:\nctrl-b + [方向键] 关闭当前pane:\nctrl-b + x 显示pane号:\nctrl-b + q 把当前的pane变成一个window：\nctrl-b + ! 移动到之前的活跃的pane：\nctrl-b + ; 选择当前window的下一个pane：\nctrl-b + o tmux使用鼠标和粘贴复制 复制：\nshift-鼠标左键 粘贴：\nshift-鼠标右键 列出所有粘贴缓冲区：\nctrl-b + # 交互式选择一个缓冲区的内容粘贴：\nctrl-b + = 使用复制模式：\nctrl-b + [ 使用粘贴模式：\nctrl-b + ] ",
    "categories": ["DevOps"],
    "tags": ["tmux"]
  },
  {
    "title": "Jaeger",
    "permalink": "https://canuxcheng.com/post/tracing_jaeger/",
    "date": "2016-06-08",
    "summary": "\u003ch1 id=\"jaeger\"\u003eJaeger\u003c/h1\u003e\n\u003cp\u003e一款uber贡献给cncf的微服务tracing监控工具.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.jaegertracing.io/\"\u003ehttps://www.jaegertracing.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jaegertracing/jaeger\"\u003ehttps://github.com/jaegertracing/jaeger\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"deploy-jaeger-on-k8s\"\u003eDeploy Jaeger on K8S\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jaegertracing/jaeger-operator\"\u003ehttps://github.com/jaegertracing/jaeger-operator\u003c/a\u003e\u003c/p\u003e",
    "content": "Jaeger 一款uber贡献给cncf的微服务tracing监控工具.\nhttps://www.jaegertracing.io/\nhttps://github.com/jaegertracing/jaeger\nDeploy Jaeger on K8S https://github.com/jaegertracing/jaeger-operator\n",
    "categories": ["DevOps"],
    "tags": ["tracing"]
  },
  {
    "title": "Metrics",
    "permalink": "https://canuxcheng.com/post/metrics/",
    "date": "2016-06-08",
    "summary": "\u003ch1 id=\"monitoring\"\u003eMonitoring\u003c/h1\u003e\n\u003cp\u003eTranditional monitoring is for Datacenter, like nagios, zabbix.\u003c/p\u003e\n\u003cp\u003eModern monitoring is for Cloud and Container.\u003c/p\u003e\n\u003cp\u003eModern monitoring based on metrics, logs and tracing.\u003c/p\u003e\n\u003ch1 id=\"tick-stack\"\u003eTICK stack\u003c/h1\u003e\n\u003cp\u003einfluxdb: tsdb.\u003c/p\u003e\n\u003cp\u003ekapacitor: alerting.\u003c/p\u003e\n\u003cp\u003echronograf: GUI.\u003c/p\u003e\n\u003cp\u003etelegraf(agent): metrics collector.\u003c/p\u003e\n\u003ch1 id=\"prometheus\"\u003ePrometheus\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"graphing\"\u003eGraphing\u003c/h1\u003e\n\u003cp\u003e最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.\u003c/p\u003e",
    "content": "Monitoring Tranditional monitoring is for Datacenter, like nagios, zabbix.\nModern monitoring is for Cloud and Container.\nModern monitoring based on metrics, logs and tracing.\nTICK stack influxdb: tsdb.\nkapacitor: alerting.\nchronograf: GUI.\ntelegraf(agent): metrics collector.\nPrometheus Graphing 最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.\n",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Monitoring",
    "permalink": "https://canuxcheng.com/post/monitoring/",
    "date": "2016-06-08",
    "summary": "\u003ch1 id=\"monitoring\"\u003eMonitoring\u003c/h1\u003e\n\u003cp\u003eTranditional monitoring is for Datacenter, like nagios, zabbix.\u003c/p\u003e\n\u003cp\u003eModern monitoring is for Cloud and Container.\u003c/p\u003e\n\u003cp\u003eModern monitoring based on metrics, logs and tracing.\u003c/p\u003e\n\u003cp\u003e现代的监控系统在DevOps的基础上，除了传统的metrics和logging的采集，还需要tracing应用。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"metrics\"\u003emetrics\u003c/h1\u003e\n\u003ch2 id=\"tick-stack\"\u003eTICK stack\u003c/h2\u003e\n\u003cp\u003einfluxdb: tsdb.\u003c/p\u003e\n\u003cp\u003ekapacitor: alerting.\u003c/p\u003e\n\u003cp\u003echronograf: GUI.\u003c/p\u003e\n\u003cp\u003etelegraf(agent): metrics collector.\u003c/p\u003e\n\u003ch2 id=\"prometheus\"\u003ePrometheus\u003c/h2\u003e\n\u003ch2 id=\"graphing\"\u003eGraphing\u003c/h2\u003e\n\u003cp\u003e最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"logging\"\u003eLogging\u003c/h1\u003e\n\u003ch2 id=\"elk\"\u003eELK\u003c/h2\u003e\n\u003ch2 id=\"lokigrafana\"\u003eLoki+Grafana\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"tracing\"\u003eTracing\u003c/h1\u003e\n\u003ch2 id=\"jeager\"\u003eJeager\u003c/h2\u003e",
    "content": "Monitoring Tranditional monitoring is for Datacenter, like nagios, zabbix.\nModern monitoring is for Cloud and Container.\nModern monitoring based on metrics, logs and tracing.\n现代的监控系统在DevOps的基础上，除了传统的metrics和logging的采集，还需要tracing应用。\nmetrics TICK stack influxdb: tsdb.\nkapacitor: alerting.\nchronograf: GUI.\ntelegraf(agent): metrics collector.\nPrometheus Graphing 最流行的监控绘图软件是grafana, 支持influxdb,elasticsearch和prometheus.\nLogging ELK Loki+Grafana Tracing Jeager ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Sentry",
    "permalink": "https://canuxcheng.com/post/tracing_sentry/",
    "date": "2016-06-08",
    "summary": "\u003ch1 id=\"sentry\"\u003eSentry\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/getsentry/sentry\"\u003ehttps://github.com/getsentry/sentry\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"deploy-sentry-on-k8s\"\u003eDeploy Sentry on K8S\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/getsentry/onpremise\"\u003ehttps://github.com/getsentry/onpremise\u003c/a\u003e\u003c/p\u003e",
    "content": "Sentry https://github.com/getsentry/sentry\nDeploy Sentry on K8S https://github.com/getsentry/onpremise\n",
    "categories": ["DevOps"],
    "tags": ["tracing"]
  },
  {
    "title": "Tracing",
    "permalink": "https://canuxcheng.com/post/tracing/",
    "date": "2016-06-08",
    "summary": "\u003ch1 id=\"tracing\"\u003eTracing\u003c/h1\u003e\n\u003cp\u003eAPM 监控，也叫全链路监控。\u003c/p\u003e\n\u003ch1 id=\"sentry\"\u003esentry\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/getsentry/sentry\"\u003ehttps://github.com/getsentry/sentry\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"zipkin\"\u003ezipkin\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/openzipkin/zipkin\"\u003ehttps://github.com/openzipkin/zipkin\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"open-telemetry\"\u003eopen-telemetry\u003c/h1\u003e\n\u003cp\u003eopentracing和opencensus 合并成open-telemetry.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/opentracing\"\u003ehttps://github.com/opentracing\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/census-instrumentation\"\u003ehttps://github.com/census-instrumentation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/open-telemetry\"\u003ehttps://github.com/open-telemetry\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"jaeger\"\u003ejaeger\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jaegertracing/jaeger\"\u003ehttps://github.com/jaegertracing/jaeger\u003c/a\u003e\u003c/p\u003e",
    "content": "Tracing APM 监控，也叫全链路监控。\nsentry https://github.com/getsentry/sentry\nzipkin https://github.com/openzipkin/zipkin\nopen-telemetry opentracing和opencensus 合并成open-telemetry.\nhttps://github.com/opentracing\nhttps://github.com/census-instrumentation\nhttps://github.com/open-telemetry\njaeger https://github.com/jaegertracing/jaeger\n",
    "categories": ["DevOps"],
    "tags": ["tracing"]
  },
  {
    "title": "Package",
    "permalink": "https://canuxcheng.com/post/linux_package/",
    "date": "2016-06-07",
    "summary": "\u003ch1 id=\"dpkg\"\u003eDPKG\u003c/h1\u003e\n\u003cp\u003edebian的包管理机制。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"dpkg-1\"\u003edpkg\u003c/h2\u003e\n\u003cp\u003edpkg的本地前端工具。\u003c/p\u003e\n\u003ch3 id=\"deb---debian-binary-package-format\"\u003edeb - Debian binary package format\u003c/h3\u003e\n\u003ch3 id=\"dpkg---package-manager-for-debian\"\u003edpkg - package manager for Debian\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003edpkg\ndpkg -X  ./xxx.deb  xxx  # 将deb包解压到xxx目录\ndpkg -e  ./xxx.deb  xxx/DEBIAN # 将control信息解压\ndpkg -l | grep pkg # 查看安装的包\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"dpkg-reconfigure---reconfigure-an-already-installed-package\"\u003edpkg-reconfigure - reconfigure an already installed package\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003edpkg-reconfigure\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"dpkg-deb---debian-package-archive-deb-manipulation-tool\"\u003edpkg-deb - Debian package archive (.deb) manipulation tool\u003c/h3\u003e\n\u003cp\u003e目录结构, DEBIAN/control是必需的\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e|- debian_root\n   |- DEBIAN\n      |- control\n      |- preinst/preinstallation # 解压deb包之前执行\n      |- prerm/preremove\n      |- postinst/postinstallation # 解压完成之后执行，通常用来配置\n      |- postrm/postremove\n      |- copyright\n      |- changelog\n      |- conffiles\n   |- etc\n      |- init.d/systemd\n         |- \u0026lt;service\u0026gt;\n      |- logrotate.d\n         |- \u0026lt;service\u0026gt;\n   |- user/local/...\n   |- opt/...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003econtrol:\u003c/p\u003e",
    "content": "DPKG debian的包管理机制。\ndpkg dpkg的本地前端工具。\ndeb - Debian binary package format dpkg - package manager for Debian dpkg dpkg -X ./xxx.deb xxx # 将deb包解压到xxx目录 dpkg -e ./xxx.deb xxx/DEBIAN # 将control信息解压 dpkg -l | grep pkg # 查看安装的包 dpkg-reconfigure - reconfigure an already installed package dpkg-reconfigure dpkg-deb - Debian package archive (.deb) manipulation tool 目录结构, DEBIAN/control是必需的\n|- debian_root |- DEBIAN |- control |- preinst/preinstallation # 解压deb包之前执行 |- prerm/preremove |- postinst/postinstallation # 解压完成之后执行，通常用来配置 |- postrm/postremove |- copyright |- changelog |- conffiles |- etc |- init.d/systemd |- \u0026lt;service\u0026gt; |- logrotate.d |- \u0026lt;service\u0026gt; |- user/local/... |- opt/... control:\nPackage Version Description Maintain: Section: utils/net/mail/text/x11/... Priority: required/standard/optional/extra/... Essential: yes/no Architecture: i386/amd64/... Source: Depends: # 运行该process需要的依萊, 只能安装之前安装好，或者用gdebi安装 Pre-Depends: Recommends: Suggests: ... postrm:\ncase \u0026quot;$1\u0026quot; in remove) remove echo \u0026quot;Remove complete\u0026quot; ;; purge) purge echo \u0026quot;Purge complete\u0026quot; ;; upgrade|failed-upgrade|disappear) echo \u0026quot;Do nothing\u0026quot; ;; abort-install|abort-upgrade) echo \u0026quot;Do nothing\u0026quot; ;; *) echo \u0026quot;$0 called with unknown argument \\`$1'\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 ;; esac 创建debian包\n$ dpkg-deb -b|--build \u0026lt;directory\u0026gt; [\u0026lt;deb\u0026gt;] 查看包信息\n$ dpkg-deb -I XXX.deb dpkg-query - a tool to query the dpkg database dpkg-query gdebi - Simple tool to install deb files dpkg的本地前端工具。\n使用gdebi安装deb包会自动解决依赖问题:\n安装gdebi:\n$ sudo apt-get install gdebi-core $ sudo apt-get install gdebi-gtk $ sudo aptitude install gdebi-core # install gdebi itself $ sudo aptitude install gdebi-gtk # install gdebi GUI 使用gdebi:\nsudo gdebi XXX.deb # install package apt - command-line interface dpkg的远程前端工具。\napt - command-line interface\n$ apt install package apt-get - APT package handling utility \u0026ndash; command-line interface\n$ sudo apt-get option command package # command: install remove purge download source update # install # 可以通过apt-cache madison查看version apt-get install \u0026lt;package\u0026gt;=\u0026lt;version\u0026gt; # option: -d, --download-only --print-uris -y,--yes,--assume-yes # 交互时确认 -f,--force-yes --reinstall --allow-unauthenticated --allow-downgrades (\u0026gt;= ubuntu1604) # 打印在当前环境安装该包需要的所有以来的下载连接信息 apt-get --print-uris install package aptitude - high-level interface to the package manager\n$ sudo aptitude install package apt-cache - query the APT cache\n$ apt-cache showpkg \u0026lt;pkg\u0026gt; $ apt-cache showsrc \u0026lt;pkg\u0026gt; $ apt-cache search \u0026lt;pkg\u0026gt; $ apt-cache madison \u0026lt;pkg\u0026gt; # 查看当前源可以安装的版本 $ apt-cache policy \u0026lt;pkg\u0026gt; # 查看哪些包依赖该包 $ apt-cache rdepends \u0026lt;pkg\u0026gt; # 查看该包依赖哪些包 $ apt-cache depends \u0026lt;pkg\u0026gt; # 查看依赖，　以及依赖的依赖 $ apt-cache --recurse depends \u0026lt;pkg\u0026gt; RPM redhat的包管理机制。\nrpm rpm的本地前端工具。\nrpm - RPM Package Manager\nyum rpm的远程前端工具。\nyum - redirecting to DNF Command Reference\nzypper suse的包管理机制。\nAlien alien is a program that converts between Red Hat rpm, Debian deb, Stampede slp, Slackware tgz, and Solaris pkg file formats.\ngbp 通过git来管理deb或rpm包．\nhttps://github.com/agx/git-buildpackage\n$sudo -E pip install gbp fpm 通过fpm来创建deb/rpm包\nhttps://github.com/jordansissel/fpm\npatch ",
    "categories": ["Linux"],
    "tags": ["package"]
  },
  {
    "title": "Oracle",
    "permalink": "https://canuxcheng.com/post/oracle/",
    "date": "2016-06-01",
    "summary": "\u003ch1 id=\"oracle\"\u003eOracle\u003c/h1\u003e\n\u003cp\u003eoracle的GUI：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eoracle sql developer(officer)\u003c/li\u003e\n\u003cli\u003epl/sql\u003c/li\u003e\n\u003cli\u003etoad\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eoracle的CLI：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003esqlplus\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"oracle命令\"\u003eOracle命令\u003c/h1\u003e\n\u003cp\u003esys是oracle默认管理员权限\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sqlplus / as sysdba\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esystem是oracle的默认最高权限，默认密码是manager，需要sys授权才能登陆\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sqlplus / as sysdba\n\u0026gt; alter user system account unlock;\n\u0026gt; alter user system identified by manager;\n\u0026gt; conn system/manager\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003escott是oracle的默热你的普通用户，默认密码是tiger，需要sys授权才能登陆\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sqlplus / as sysdba\n\u0026gt; alter user scott account unlock;\n\u0026gt; alter user scott identified by tiger;\n\u0026gt; conn scott/tiger\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e本地命令行执行sql语句：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ \u0026lt;sql query\u0026gt; | \u0026lt;sqlplus\u0026gt; \u0026lt;db user\u0026gt;/\u0026lt;db password\u0026gt;@\u0026lt;db sid\u0026gt; | sudo ORACLE_HOME=\u0026lt;oracle home\u0026gt; -i -u \u0026lt;oracle user\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edbsnmp是oracle的用户智能代理用户，用来监控和管理数据库相关性能。\u003c/p\u003e",
    "content": "Oracle oracle的GUI：\noracle sql developer(officer) pl/sql toad oracle的CLI：\nsqlplus Oracle命令 sys是oracle默认管理员权限\n$ sqlplus / as sysdba system是oracle的默认最高权限，默认密码是manager，需要sys授权才能登陆\n$ sqlplus / as sysdba \u0026gt; alter user system account unlock; \u0026gt; alter user system identified by manager; \u0026gt; conn system/manager scott是oracle的默热你的普通用户，默认密码是tiger，需要sys授权才能登陆\n$ sqlplus / as sysdba \u0026gt; alter user scott account unlock; \u0026gt; alter user scott identified by tiger; \u0026gt; conn scott/tiger 本地命令行执行sql语句：\n$ \u0026lt;sql query\u0026gt; | \u0026lt;sqlplus\u0026gt; \u0026lt;db user\u0026gt;/\u0026lt;db password\u0026gt;@\u0026lt;db sid\u0026gt; | sudo ORACLE_HOME=\u0026lt;oracle home\u0026gt; -i -u \u0026lt;oracle user\u0026gt; dbsnmp是oracle的用户智能代理用户，用来监控和管理数据库相关性能。\nsysman是oracle的数据库用户EM管理用户。\n监听管理：\nsu - oracle lsnrctl start lsnrctl stop lsnrctl status CLI 先用sqlplus命令进入oracle的命令行．\nhelp index ? index 查看命令帮助信息：\nhelp \u0026lt;command\u0026gt; 登陆和退出sqlplus：\nsqlplus exit/quit 调用sql语句：\n@ 不退出sqlplus执行shell命令：\nhost 用户登陆和退出：\nconnect/conn \u0026lt;username\u0026gt;/\u0026lt;password\u0026gt; disconnect 清屏：\nclear ! clear clear scr 修改密码：\npassword 查看变量：\nshow 数据类型 函数 isnull函数:\nNVL(column, 0) column为null函数返回0\nSQL 创建用户：\nCREATE USER \u0026lt;username\u0026gt; IDENTIFIED BY \u0026lt;password\u0026gt;; 用户授权：\nGRANT DBA TO \u0026lt;username\u0026gt;; GRANT UNLIMITED TABLESPACE TO \u0026lt;username\u0026gt;; GRANT SELECT ANY TABLE TO \u0026lt;username\u0026gt;; GRANT SELECT ANY DICTIONARY TO \u0026lt;username\u0026gt;; 常用查询：\nSELECT * FROM global_name; 查看默认数据库 SELECT * FROM dba_tables; DBA权限查询数据所有表 SELECT * FROM all_users; 查看所有用户 SELECT username FROM dba_users; 查看所有DBA用户 SELECT user FROM dual; 查看当前登陆用户 SELECT * FROM user_tables; 查询当前用户有哪些表 SELECT * FROM all_tables; 查询当前用户可以访问的所有表 SELECT banner FROM sys.v_$version; 查询数据库版本 SELECT count(*) FROM v$version; 查询oracle连接数 SELECT count(*) FROM v$version WHERE STATUS = 'ACTIVE'; 查询oracle并发连接数 ALTER system SET processes = \u0026lt;number\u0026gt; scope = spfile; 修改数据库允许最大连接数 SELECT value FROM v$parmeter WHERE name = 'processes'; 查询数据库允许最大连接数 SELECT value FROM v$parmeter WHERE name = 'open_cursor'; 查询数据库允许最大游标数 python cx_Oracle http://cx-oracle.sourceforge.net/\n需要安装oracle数据库或者oracle instant client并设置环境变量。\n参考oracle网站下载安装配置oracle instant client\nhttp://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\nimport cx_Oracle ",
    "categories": ["Database"],
    "tags": ["oracle"]
  },
  {
    "title": "SQL",
    "permalink": "https://canuxcheng.com/post/sql/",
    "date": "2016-05-25",
    "summary": "\u003ch1 id=\"sql\"\u003eSQL\u003c/h1\u003e\n\u003cp\u003esql是结构化查询语言。\u003c/p\u003e\n\u003cp\u003esql是一种标准，几乎所有关系型数据库都遵守。\u003c/p\u003e\n\u003cp\u003e但是不同的数据库又有自己的扩展。\u003c/p\u003e\n\u003cp\u003eSQL分为两部分，DML和DDL。\u003c/p\u003e\n\u003cp\u003eSQL大小写敏感，文本使用单引号，数值不需要引号。\u003c/p\u003e\n\u003ch1 id=\"sql语法\"\u003esql语法\u003c/h1\u003e\n\u003cp\u003esql注释:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 多行注释\n/*\ncomment multi lines\nin a sql file.\n*/\n\n# 单行注释\n/* comment single line */\n\n# 单行注释还可以直接用 -- 表示\nselect * from table -- where condition;\n-- select * from table where condition;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"ddl\"\u003eDDL\u003c/h1\u003e\n\u003cp\u003eDDL: 数据定义语言\u003c/p\u003e\n\u003ch2 id=\"create\"\u003ecreate\u003c/h2\u003e\n\u003cp\u003e创建数据库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCREATE DATABASE database_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e建表：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCREATE TABLE table(\n    column1 type1,\n    column2 type2,\n    ...\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecreate也可以用来创建索引和视图．\u003c/p\u003e\n\u003ch2 id=\"drop\"\u003edrop\u003c/h2\u003e\n\u003cp\u003e删除数据库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDROP DATABASE database_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e删表：\u003c/p\u003e",
    "content": "SQL sql是结构化查询语言。\nsql是一种标准，几乎所有关系型数据库都遵守。\n但是不同的数据库又有自己的扩展。\nSQL分为两部分，DML和DDL。\nSQL大小写敏感，文本使用单引号，数值不需要引号。\nsql语法 sql注释:\n# 多行注释 /* comment multi lines in a sql file. */ # 单行注释 /* comment single line */ # 单行注释还可以直接用 -- 表示 select * from table -- where condition; -- select * from table where condition; DDL DDL: 数据定义语言\ncreate 创建数据库：\nCREATE DATABASE database_name; 建表：\nCREATE TABLE table( column1 type1, column2 type2, ... ); create也可以用来创建索引和视图．\ndrop 删除数据库：\nDROP DATABASE database_name; 删表：\nDROP TABLE table; # 仅仅删除表中的数据，保留表 TRUNCATE TABLE table; drop也可以用来删除索引和视图．\nalter 变更表：\n# 添加列 ALTER TABLE table ADD COLUMN column type; # 删除列 ALTER TABLE table DROP COLUMN column; # 改变列的数据类型 # sql server ALTER TABLE table ALTER COLUMN column type; # mysql ALTER TABLE table MODIFY COLUMN column type; # mysql/oracle ALTER TABLE table MODIFY column type; DML DML: 数据操作语言\nselect 查询操作:\nSELECT * FROM table; # 单表查询 SELECT column FROM table; # 多表查询 SELECT table1.column1, table2.column2 FROM table1, table2; where子句选取数据：\nSELECT column FROM table WHERE condition; 引号的使用：\n# 文本使用单引号，大部分数据库也接受双引号 SELECT column FROM table WHERE name='text'; # 数字不能使用引号． SELECT column FROM table WHERE id=number; where子句条件表达式可用的运算符：\n= \u0026lt;\u0026gt; != \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= BETWEEN [value1, value2] BETWEEN value1 AND value2 NOT BETWEEN IN (value1, value2) NOT IN IS NULL IS NOT NULL LIKE NOT LIKE like运算符的通配符：\n% 替代一个或多个字符 _ 替代一个字符 [char list] 字符列中的任何单一字符 [^char list] 不在字符列中的任何单一字符 [!char list] 和上面一个等效 SELECT * FROM table WHERE name LIKE '[abc]%' # 以abc开头的name where子句多个条件可以使用的运算符：\nAND 与运算 SELECT * FROM table WHERE name='canux' AND id=10; OR 或运算 SELECT * FROM table WHERE name='canux' OR id=10; order by子句对结果进行排序,默认升序(ASC)：\n# 默认升序 SELECT column, column1 FROM table ORDER BY column; SELECT column, column1 FROM table ORDER BY column, column1; SELECT column, column1 FROM table ORDER BY column ASC; # DESC降序 SELECT column, column1 FROM table ORDER BY column DESC; SELECT column, column1 FROM table ORDER BY column DESC, column1 ASC; # 根据第几个字段排序 SELECT column, column1 FROM table ORDER BY number; # 多个字段排序，优先级从前到后 SELECT column FROM table ORDER BY column1, column2 SELECT column FROM table ORDER BY column1 DESC, column2 DESC top子句用于规定要返回的记录数目：\n# SQL Server SELECT TOP number * FROM table; # mysql SELECT * FROM table LIMIT number; # oracle SELECT * FROM table WHERE ROWNUM \u0026lt;= number; Top 一般需要order by # number最小的10个 select top 10 from table order by number # number最大的10个 select top 10 from table order by number desc group by子句用来分组，放在where子句后面如果有的话:\ngroup by一定要用合计函数(count, max, min, sum, avg, \u0026hellip;).\nSELECT column1, aggregate_function(column2) FROM table GROUP BY column1; having子句用来过滤group by的结果(相当where)，放在group by子句后面：\n因为where不能和合计函数一起使用，所以使用having子句．\nSELECT column1, aggregate_function(column2) FROM table GROUP BY column1 HAVING aggregate_function(column) condition; distinct关键字排除重复：\nSELECT DISTINCT column FROM table; as关键字指定别名：\n# 指定表的别名 SELECT alias_table1.column1, alias_table2.column2 FROM table1 AS alias_table1, table2 AS alias_table2 WHERE alias_table1.column2='test'; # 指定字段别名 SELECT column1 AS alias1, column2 AS alias2 FROM table; 执行顺序：\nfrom -\u0026gt; where -\u0026gt; group by -\u0026gt; having -\u0026gt; select -\u0026gt; distinct -\u0026gt; union -\u0026gt; order by -\u0026gt; top insert into 向表格插入新的行：\n# 一次插入完整行 INSERT INTO table VALUES (value1, value2, ...); # 一次插入多行 INSERT INTO table VALUES (val11, val12, ...) (val21, val22, ...) ... # 一次插入一行的一部分 INSERT INTO table (column1, column2, ...) VALUES (value1, value2, ...); # 一次插入多行的一部分 INSERT INTO table (col1, col2, ...) VALUES (val11, val12, ...) (val21, val22, ...) update set 修改表中数据：\nUPDATE table SET column1=value1 WHERE condition; delete from 删除表中的行：\nDELETE FROM table WHERE condition; DELETE FROM table; # 删除所有行 TRUNCATE TABLE table; # mysql清空表的内容，不可恢复 函数 不同的数据库内置的部分函数不同．下面只列出大部分数据库都有的函数．\nsql内置两种函数：合计(aggregate)函数　和　标量(scalar)函数.\nsql函数的语法：\nSELECT FUNCTION(args) FROM table ...; aggregate function AVG()：　求平均值 COUNT(): 统计行数 FIRST(): 返回指定字段中第一个记录的值 LAST():　返回指定字段中最后一个记录的值 MAX():　返回一列中的最大值 MIN():　返回一列中的最小值 SUM():　返回一列的和 scalar function UCASE():　把字段的值转换为大写 LCASE():　把字段的值转换为小写 MID(column, start[, length]):　从文本字段中提取字符，start从１开始 LEN(): 返回文本字段中的长度 FORMAT(column, format): 对字段进行格式化 ROUND(column, decimals): 把数值字段舍入为指定的小数位数 NOW() 返回当前的日期和时间 join 为了从多个表中获取结果，就需要用join.\ninner join inner join也就是默认的join.\n全部匹配才返回．相当于table1和table2与.\n# 两张表连接 SELECT table1.column, table2.column FROM table1 INNER JOIN table2 ON table1.column = table2.column; # 三张表连接 SELECT column FROM ((table1 INNER JOIN table2 ON table1.column1 = table2.column1) INNER JOIN table3 ON table1.column2 = table3.column2); left join 左连接．返回左表table1的所有行，和右表table2匹配的行\nSELECT column FROM table1 LEFT JOIN table2 ON table1.column = table2.column; right join 右连接，返回右表table2的所有行，和左表table1匹配的行\nSELECT column FROM table1 RIGHT JOIN table2 ON table1.column = table2.column; full join 返回两张表的所有行．\nSELECT column FROM table1 FULL JOIN table2 ON table1.column = table2.column; union union操作符用于合并两个或多个select语句的结果集．\nunion只选取不同的值,也就是说table1和table2中的相同column只出现一次．\nSELECT column FROM table1 UNION SELECT column FROM table2; union all会列出所有的值，包括重复的．\nSELECT column FROM table1 UNION ALL SELECT column FROM table2; select into 创建表的备份复件．\n把table1的所有列插入到table2:\nSELECT * INTO table2 FROM table1 WHERE condition; # table2属于另外一个数据库externaldatabase SELECT * INTO table2 IN externaldatabase FROM table1 WHERE condition; 把table1的部分列插入到table2:\nSELECT column INTO table2 FROM table1 WHERE condition; # table2属于另外一个数据库externaldatabase SELECT column INTO table2 IN externaldatabase FROM table1 WHERE condition; mysql需要用insert into \u0026hellip; select:\n# 如果table2已经存在 INSERT INTO table2 SELECT * FROM table1 WHERE condition; # 如果table2不存在 CREATE TABLE table2 AS SELECT * FROM table1 WHERE condition; constraints constraints约束用于限制加入表的数据的类型．\nNOT NULL not null强制约束列不能接受null值．\nCREATE TABLE tablename ( id int NOT NULL, name varchar(255) ); UNIQUE unique约束唯一标识数据库表中的每条记录．\n每个表可以有多个unique约束．\n# mysql: CREATE TABLE table ( id int NOT NULL, name varchar(255), UNIQUE (id) ); # sql server/oracle: CREATE TABLE table( id int NOT NULL UNIQUE, name varchar(255) ); 给约束命名，并且标记多个列到unique:\nCREATE TABLE table ( id int NOT NULL, firstname varchar(255), lastname varchar(255), CONSTRAINT constraintname UNIQUE (id, lastname) ); 给已经存在的表添加约束：\nALTER TABLE table ADD UNIQUE (id); # 给约束命名，并且标记多个列到unique ALTER TABLE table ADD CONSTRAINT constraintname UNIQUE (id, lastname); 撤销约束：\n# mysql: ALTER TABLE table DROP INDEX constraintname; # sql server/oracle: ALTER TABLE table DROP CONSTRAINTNAME constraintname; PRIMARY KEY primary key主键必须包含唯一的值，主键列不能包含NULL值．\n每张表最多只能有一个主键．\n# mysql: CREATE TABLE table ( id int NOT NULL, firstname varchar(255), lastname varchar(255), PRIMARY KEY (id) ); # sql server/oracle: CREATE TABLE table ( id int NOT NULL PRIMARY KEY, firstname varchar(255), lastname varchar(255) ); 给主键命名，并且添加多个列到primary key:\nCREATE TABLE table ( id int NOT NULL, firstname varchar(255), lastname varchar(255), CONSTRAINT constraintname PRIMARY KEY (id, lastname) ); 给已经存在的表添加约束：\nALTER TABLE table ADD PRIMARY KEY (id); # 给约束命名，并且添加多个列到主键： ALTER TABLE table ADD CONSTRAINT constraintname PRIMARY KEY (id, lastname); 撤销约束：\n# mysql: ALTER TABLE table DROP PRIMARY KEY; # sql server/oracle: ALTER TABLE talbe DROP CONSTRAINT constraintname; FOREIGN KEY 一个表中的外键指向另一个表中的主键．\n# mysql: CREATE TABLE table1 ( id_1 int NOT NULL, id_2 int, PRIMARY KEY (id_1), FOREIGN KEY (id_2) REFERENCES table2(id_2) ); # sql server/oracle: CREATE TABLE table1 ( id_1 int NOT NULL PRIMARY KEY, id_2 int FOREIGN KEY REFERENCES table2(id_2) ); 给外键命名，并且添加多个列到foreign key:\nCREATE TABLE table1 ( id_1 int NOT NULL, id_2 int, PRIMARY KEY (id_1), CONSTRAINT constraintname FOREIGN KEY (id_2) REFERENCES table2(id_2) ); 给已经存在的表添加约束：\nALTER TABLE table1 ADD FOREIGN KEY (id_2) REFERENCES table2(id_2); # 给外键命名，并且添加多列到外键 ALTER TABLE table1 ADD CONSTRAINT constraintname FOREIGN KEY (id_2) REFERENCES table2(id_2); 撤销约束：\n# mysql: ALTER TABLE table1 DROP FOREIGN KEY constraintname; # sql server/oracle: ALTER TABLE table1 DROP CONSTRAINT constraintname; CHECK check用于限制列中的值的范围．\n# mysql: CREATE TABLE table ( id int NOT NULL, firstname varchar(255), lastname varchar(255), CHECK (id\u0026gt;0) ); # sql server/oracle: CREATE TABLE table ( id int NOT NULL CHECK (id\u0026gt;0), firstname varchar(255), lastname varchar(255) ); 给约束命名，并且添加多个列到约束：\nCREATE TABLE table ( id int NOT NULL, firstname varchar(255), lastname varchar(255), CONSTRAINT constraintname CHECK (id\u0026gt;0 AND lastname='cheng') ); 给已经存在的表添加约束：\nALTER TABLE table ADD CHECK (id\u0026gt;0); # 给约束命名，并且添加多列到约束 ALTER TABLE table ADD CONSTRAINT constraintname CHECK (id\u0026gt;0 AND lastname='cheng'); 撤销约束：\n# mysql: ALTER TABLE table DROP CONSTRAINT constraintname; # sql server/oracle: ALTER TABLE table DROP CHECK constraintname; DEFAULT default约束用于向列中插入默认值．\nCREATE TABLE table ( id int NOT NULL, country varcha(255) DEFAULT 'china' ); 给已经存在的表添加约束：\n# mysql ALTER TABLE table ALTER country SET DEFAULT 'china'; # sqlserver/oracle ALTER TABLE table ALTER COLUMN country SET DEFAULT 'china'; 撤销约束：\n# mysql: ALTER TABLE table ALTER country DROP DEFAULT; # sql server/oracle: ALTER TABLE table ALTER COLUMN country DROP DEFAULT; increment auto increment在每次插入新记录时，自动创建主键字段的值．\n# mysql使用auto_increment CREATE TABLE table ( id int NOT NULL AUTO_INCREMENT, firstname varchar(255), lastname varchar(255), PRIMARY KEY (id) ); # sql server使用identity: CREATE TABLE table ( id int PRIMARY KEY IDENTITY; firstname varchar(255), lastname varchar(255) ); # oracle使用sequence对: CREATE SEQUENCE sequencename MINVALUE 1 START WITH 1 INCRREMENT BY 1 CACHE 10 # 使用nextval函数获取下一个值： INSERT INTO table (id, firstname, lastname) VALUES (sequencename.nextval, 'canux', 'cheng'); auto increment的默认起始值是1,每次插入一行默认加一，可以修改起始值：\nALTER TABLE table AUTO_INCREMENT=10; index 创建索引可以快速高效查询数据，但是用户无法看到索引．\n# 在表中创建简单索引，允许使用重复的值: CREATE INDEX indexname ON table (column, column1, ...); # 在表中创建唯一索引，两个行不能有相同索引值: CREATE UNIQUE INDEX indexname ON table (column, column1, ...); 删除索引：\n# mysql: ALTER TABLE table DROP INDEX indexname; # sql server: DROP INDEX table.indexname; # oracle: DROP INDEX indexname; view 视图是基于sql语句的结果集的可视化的表：\nCREATE VIEW viewname AS SELECT * FROM table WHERE condition; 更新视图：\nCREATE OR REPLACE VIEW viewname AS SELECT column FROM table WHERE condition; 查询视图：\nSELECT * FROM viewname; 删除视图：\nDROP VIEW viewname; ",
    "categories": ["Database"],
    "tags": ["sql"]
  },
  {
    "title": "Mysql",
    "permalink": "https://canuxcheng.com/post/mysql/",
    "date": "2016-05-25",
    "summary": "\u003ch1 id=\"mysql\"\u003eMysql\u003c/h1\u003e\n\u003cp\u003e安装mysql服务器\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install mysql-server\n$ sudo yum install mysql-community-server\n\n$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n# 注意mysql的/etc/mysql/my.cnf和相关文件如果设置了bind-address = 127.0.0.1就无法远程访问，需要注释掉．\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装mysql客户端\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install mysql-client\n$ sudo yum install mysql-community-client\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装开发工具：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install libmysqlclient-dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCLI工具： mysql\u003c/p\u003e\n\u003cp\u003eGUI工具： mysql workbench\u003c/p\u003e\n\u003cp\u003e安装完成默认的数据库是 mysql。\u003c/p\u003e\n\u003cp\u003emysqld的默认端口是3306.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"mysql命令\"\u003emysql命令\u003c/h1\u003e\n\u003cp\u003etips: 用户名密码有特殊字符用引号.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mysql [OPTIONS] [database]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e初始化时需要用root用户进入mysql命令行\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mysql -uroot -p\n$ mysql -h\u0026lt;host\u0026gt; -P\u0026lt;port\u0026gt; -uroot -p\u0026lt;password\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建用户后用其它用户操作：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mysql -u\u0026lt;user\u0026gt; -p\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e本地执行sql语句或mysql客户端命令:\u003c/p\u003e",
    "content": "Mysql 安装mysql服务器\n$ sudo apt-get install mysql-server $ sudo yum install mysql-community-server $ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf # 注意mysql的/etc/mysql/my.cnf和相关文件如果设置了bind-address = 127.0.0.1就无法远程访问，需要注释掉． 安装mysql客户端\n$ sudo apt-get install mysql-client $ sudo yum install mysql-community-client 安装开发工具：\n$ sudo apt-get install libmysqlclient-dev CLI工具： mysql\nGUI工具： mysql workbench\n安装完成默认的数据库是 mysql。\nmysqld的默认端口是3306.\nmysql命令 tips: 用户名密码有特殊字符用引号.\n$ mysql [OPTIONS] [database] 初始化时需要用root用户进入mysql命令行\n$ mysql -uroot -p $ mysql -h\u0026lt;host\u0026gt; -P\u0026lt;port\u0026gt; -uroot -p\u0026lt;password\u0026gt; 创建用户后用其它用户操作：\n$ mysql -u\u0026lt;user\u0026gt; -p 本地执行sql语句或mysql客户端命令:\n$ mysql -u\u0026lt;username\u0026gt; -p\u0026lt;password\u0026gt; \u0026lt;database\u0026gt; -e/--execute \u0026lt;sql query\u0026gt; $ mysql -u\u0026lt;username\u0026gt; -p\u0026lt;password\u0026gt; \u0026lt;database\u0026gt; \u0026lt; test.sql 远程执行sql语句或mysql客户端命令:\n$ mysql -h\u0026lt;host\u0026gt; -P\u0026lt;port\u0026gt; -u\u0026lt;username\u0026gt; -p\u0026lt;password\u0026gt; \u0026lt;database\u0026gt; -e/--execute \u0026lt;sql query\u0026gt; $ mysql -h\u0026lt;host\u0026gt; -P\u0026lt;port\u0026gt; -u\u0026lt;username\u0026gt; -p\u0026lt;password\u0026gt; \u0026lt;database\u0026gt; \u0026lt; test.sql 启用\u0026rsquo;load data local\u0026rsquo;命令：\n# 交互式 $ mysql --local-infile=1 -uroot -ppassword # 非交互式 $ mysql --local-infile=1 -uroot -pchengca w3c -e \u0026quot;LOAD DATA LOCAL INFILE '/home/user/customers.txt' INTO TABLE Customers COLUMNS TERMINATED BY '\\t' LINES TERMINATED BY '\\n';\u0026quot; 导出数据命令:\n$ mysqldump -u\u0026lt;username\u0026gt; -p\u0026lt;password\u0026gt; \u0026lt;databasename\u0026gt; \u0026gt; dump.sql mycli:\nA command line client for MySQL that can do auto-completion and syntax highlighting.\nhttps://github.com/dbcli/mycli\n$ pip install -U mycli CLI 先用mysql命令进入mysql的命令行。\n? (\\?) Synonym for help. help (\\h) Display this help. exit (\\q) Exit mysql. Same as quit. quit (\\q) Quit mysql. clear (\\c) Clear the current input statement. connect (\\r) Reconnect to the server. Optional arguments are db and host. delimiter (\\d) Set statement delimiter. edit (\\e) Edit command with \\$EDITOR. ego (\\G) Send command to mysql server, display result vertically. go (\\g) Send command to mysql server. nopager (\\n) Disable pager, print to stdout. notee (\\t) Don't write into outfile. pager (\\P) Set PAGER [to_pager]. Print the query results via PAGER. print (\\p) Print current command. prompt (\\R) Change your mysql prompt. rehash (\\#) Rebuild completion hash. source (\\.) Execute an SQL script file. Takes a file name as an argument. mysql\u0026gt; source /path/to/dump.sql # 从sql导入数据 status (\\s) Get status information from the server. system (\\!) Execute a system shell command. tee (\\T) Set outfile [to_outfile]. Append everything into given outfile. use (\\u) Use another database. Takes database name as argument. mysql\u0026gt; use database # 切换到数据库 charset (\\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets. warnings (\\W) Show warnings after every statement. nowarning (\\w) Don't show warnings after every statement. 其它可以在mysql客户端执行的命令：\n# 从本地一个文件导入数据，列分隔符为\\t,行分隔符为\\n LOAD DATA LOCAL INFILE '/home/user/customers.txt' INTO TABLE Customers COLUMNS TERMINATED BY '\\t' LINES TERMINATED BY '\\n'; 数据类型 函数和运算符 date and time：\nhttps://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html\nNOW() // '2018-11-18 16:00:28' UTC_TIMESTAMP() // '2018-11-18 08:01:04' CURDATE() // '2018-11-18' UTC_DATE() // '2018-11-18' CURTIME() // '16:02:18' UTC_TIME() // '08:03:36' UNIX_TIMESTAMP() // '1542528051' DATE() // '2021-1-12' TIME() // '14:28:00' DATEDIFF() date_format(column, '%Y-%m-%d') control flow:：\nCASE IF() IFNULL(column, 0) NULLIF() comparison:\nCOALESCE(column, 0) ISNULL() IS NULL IN() NOT IN() SQL 注意：hostname 指定能连接的server，%表示任何server．\n查看版本：\nSELECT VERSION(); 查看所有用户：\nSELECT DISTINCT(USER) FROM mysql.user; SELECT user,host,plugin FROM mysql.user; 查看当前用户：\nSELECT USER(); 创建/删除用户：\nCREATE USER 'username'@'%' IDENTIFIED BY 'password'; DROP USER 'username'@'%'; 设置和更改密码：\nUPDATE mysql.user SET PASSWORD('password') WHRER USER='username' AND HOST='hostname'; 查看所有数据库：\nshow databases; 查看当前数据库：\nSELECT DATABASE(); 创建/删除数据库：\nCREATE DATABASE databasename; DROP DATABASE databasename; 指定数据库对用户授权：\nGRANT ALL PRIVILEGES ON databasename.* TO 'username'@'%'; FLUSH PRIVILEGES; 查看权限：\nSHOW GRANTS FOR 'username'@'%'; 使用数据库：\nuse databasename 查看所有表：\nshow tables; 查看表结构：\ndesc tablename; 正则：\n// 类似like，特殊字符要用双反斜杠转义. select * from tablename where colume REGEXP '...' 查看系统配置:\nshow variables like 'version'; select @@version; Issue mysql8 workbench 连不上的问题 : issue:\nauthentication plugin 'caching_sha2_password' cannot be loaded: the specified module could not be found。 fix：\nmysql8 开始默认授权插件改成caching_sha2_password. 可以指定为--default-authentication-plugin=mysql_native_password， alter user 'sandbox'@'%' identified with mysql_native_password by 'password'; max_commection 问题: issue:\n当连接池连接数量超过最大连接数就无法再建立连接 fix:\nshow processlist; show variables like 'max_connections'; set global max_connections = 2048; 1153, \u0026ldquo;Got a packet bigger than \u0026lsquo;max_allowed_packet\u0026rsquo; bytes\u0026rdquo; issue:\n请求数据超过限制，默认可能是4M fix:\n// 设置成最大值1G select @@max_allowed_packet; SET GLOBAL max_allowed_packet = 1024 * 1024 * 1024; 1205, \u0026lsquo;Lock wait timeout exceeded; try restarting transaction\u0026rsquo; issue:\n后提交的事务等待前面处理的事务释放锁，但是在等待的时候超过了mysql的锁等待时 fix:\n// 首先优化表索引. select @@innodb_lock_wait_timeout set global innodb_lock_wait_timeout=100; 5. 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.\nfix:\n\u0026quot;mysql\u0026gt; reset master\u0026quot;. Monitoring ",
    "categories": ["Database"],
    "tags": ["mysql"]
  },
  {
    "title": "Builtins",
    "permalink": "https://canuxcheng.com/post/ps_builtins/",
    "date": "2016-05-24",
    "summary": "\u003ch1 id=\"get-help和help\"\u003eGet-Help和Help:\u003c/h1\u003e\n\u003cp\u003eget-help查看帮助信息,help分页查看帮助信息，man是help的别名\u003c/p\u003e\n\u003cp\u003e命令说明：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help\nHelp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看所有命令和概念：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help *\nHelp *\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模糊查找命令和概念：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help *\u0026lt;name\u0026gt;*\nHelp *\u0026lt;name\u0026gt;*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看具体命令帮助：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help {\u0026lt;CmdletName\u0026gt; | \u0026lt;TopicName\u0026gt;}\nHelp {\u0026lt;CmdletName\u0026gt; | \u0026lt;TopicName\u0026gt;}\n\u0026lt;CmdletName\u0026gt; -?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eget-help/help的选项:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eget-help get-help\n-examples # 查看示例\n-full # 查看所有帮助\n-parameter # 查看选项的帮助\n-detailed # 查看详细信息\n-online # 打开文档中的link\n-showwindow # 用窗口打开\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"helpfile\"\u003eHelpfile\u003c/h1\u003e\n\u003cp\u003e3.0/4.0 需要先下载帮助手册：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eupdate-help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所有helpfile：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help/Help about_*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看具体helpfile：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGet-Help/Help about_\u0026lt;name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"cmdlets\"\u003eCmdlets\u003c/h1\u003e\n\u003cp\u003ecmdlets是powershell的内置命令,类型是System.Management.Automation.CmdletInfo\u003c/p\u003e\n\u003cp\u003ecmdlets的方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEquals\nGetHashCode\nGetType\nToString\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecmdlets的属性：\u003c/p\u003e",
    "content": "Get-Help和Help: get-help查看帮助信息,help分页查看帮助信息，man是help的别名\n命令说明：\nGet-Help Help 查看所有命令和概念：\nGet-Help * Help * 模糊查找命令和概念：\nGet-Help *\u0026lt;name\u0026gt;* Help *\u0026lt;name\u0026gt;* 查看具体命令帮助：\nGet-Help {\u0026lt;CmdletName\u0026gt; | \u0026lt;TopicName\u0026gt;} Help {\u0026lt;CmdletName\u0026gt; | \u0026lt;TopicName\u0026gt;} \u0026lt;CmdletName\u0026gt; -? get-help/help的选项:\nget-help get-help -examples # 查看示例 -full # 查看所有帮助 -parameter # 查看选项的帮助 -detailed # 查看详细信息 -online # 打开文档中的link -showwindow # 用窗口打开 Helpfile 3.0/4.0 需要先下载帮助手册：\nupdate-help 所有helpfile：\nGet-Help/Help about_* 查看具体helpfile：\nGet-Help/Help about_\u0026lt;name\u0026gt; Cmdlets cmdlets是powershell的内置命令,类型是System.Management.Automation.CmdletInfo\ncmdlets的方法：\nEquals GetHashCode GetType ToString cmdlets的属性：\nCommandType DefaultParameterSet Definition HelpFile ImplementingType Module ModuleName Name Noun OutputType Parameters ParameterSets PSSnapln Verb Visibility DLL HelpUri 常用cmdlets命令：\nGet-Command -CommandType cmdlet # 查看所有cmdlet Get-Command Invoke-Command Measure-Command Show-Command Trace-Command Get-Service New-Service Restart-Service Resume-Service Set-Service Stop-Service Suspend-Service Get-Process Debug-Process Start-Process Stop-Process Wait-Process Get-Member # 查看属性 Add-Member Get-Host Read-Host Write-Host Out-Host Out-Default Out-File # 重定向，也可以用\u0026gt;, \u0026gt;\u0026gt; Out-GridView Out-Null Out-Printer Out-String Write-Debug Write-Error Write-EventLog Write-Output Write-Progress Write-Verbose Write-Warning Function powershell内置函数\nGet-Command -CommandType function # 查看所有function ls function: 所有function：\nprompt TabExpansion2 Clear-Host more help mkdir Get-Verb oss cd.. cd\\ ImportSystemModules Pause A: ... Z: Get-FileHash Alias powershell内置别名\nGet-Command -CommandType alias # 查看所有alias dir alias: # 查看所有alias ls alias: | where {$_.Definition.Startswith(\u0026quot;Start\u0026quot;)} Get-Alias # 查看所有alias Set-Alias New-Alias Import-Alias Export-Alias 常用alias：\nForEach-Object %/foreach Where-Object ?/where Select-Object select Compare-Object compare/diff Tee-Object tee Sort-Object sort Set-Location cd/chdir/sl Get-Location pwd/gl Clear-Content clc Get-Content cat/type/gc Clear-History clhy Get-History h/history/ghy Invoke-History ihy/r Clear-Variable clv Set-Variable set/sv Clear-Item cli Clear-ItemProperty clp Copy-Item copy/cp/cpi Remove-Item del/erase/rd/ri/rm/rmdir Move-Item mv/move/mi Get-ChildItem dir/ls/gci Get-Process ps/gps Stop-Process kill/spps Start-Process start/saps Clear-Host clear/cls Write-Output echo/write New-PSDrive mount Invoke-WebRequest curl/wget Start-Sleep sleep help man mkdir md Provider provider相关cmdlet：\nGet-PSProvider # 查看provider Get-PSDrive # 查看驱动器 New-PSDrive # 新建驱动器 Remove-PSDrive # 删除驱动器 所有provider：\n# 这三个驱动器可以用ls或dir直接查看内容 ls alias: dir function: Alias # 别名驱动器 Function # 函数驱动器 Variable # 变量驱动器 # 这三个驱动器需要具体的驱动器,然后cd进去查看 FileSystem # 文件系统驱动器 Environment Registry help/get-help \u0026lt;provider_name\u0026gt; # 查看provider帮助 object object主要通过管道|使用。\nobject相关的cmdlet：\nCompare-Object ForEach-Object Group-Object Measure-Object New-Object Select-Object Sort-Object Tee-Object Where-Object object转化：\nget-command -verb *convert* ... 导出object：\nget-command -verb *export* ... 导入object：\nget-command -verb *import* ... module Get-Module get-module -listavailable # 查找安装的模块 Import-Module import-module sqlps # 导入第三方mssql模块 get-command -module sqlps # 查看模块中所有命令 New-Module Remove-Module format 安装路径有一些xml文件已经做了一些默认的格式化。\n格式化的数据只能传给Out-File/out-host/out-printer/out-null/out-string/out-default.\nExport-FormatData Get-FormatData Update-FormatData Format-Custom Format-List Format-Table Format-Wide ",
    "categories": ["Windows"],
    "tags": ["builtins"]
  },
  {
    "title": "Snmp",
    "permalink": "https://canuxcheng.com/post/snmp/",
    "date": "2016-04-26",
    "summary": "\u003ch1 id=\"snmp\"\u003eSNMP\u003c/h1\u003e\n\u003cp\u003eSimple Network Management Protocol, 简单网络管理协议\u003c/p\u003e\n\u003cp\u003eMIB\u003c/p\u003e\n\u003cp\u003eSMI\u003c/p\u003e\n\u003cp\u003e安装和配置snmp:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$sudo apt-get install snmp snmpd snmp-mibs-downloader\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"snmp命令\"\u003esnmp命令\u003c/h1\u003e\n\u003chr\u003e",
    "content": "SNMP Simple Network Management Protocol, 简单网络管理协议\nMIB\nSMI\n安装和配置snmp:\n$sudo apt-get install snmp snmpd snmp-mibs-downloader snmp命令 ",
    "categories": ["Network"],
    "tags": ["snmp"]
  },
  {
    "title": "Admin",
    "permalink": "https://canuxcheng.com/post/win_admin/",
    "date": "2016-04-26",
    "summary": "",
    "content": "",
    "categories": ["Windows"],
    "tags": ["admin"]
  },
  {
    "title": "PowerShell",
    "permalink": "https://canuxcheng.com/post/ps/",
    "date": "2016-04-26",
    "summary": "\u003ch1 id=\"powershell\"\u003ePowerShell\u003c/h1\u003e\n\u003cp\u003eConsole: command line interface\u003c/p\u003e\n\u003cp\u003eISE: script editor and console combination\u003c/p\u003e\n\u003cp\u003eVersion:\u003c/p\u003e\n\u003cp\u003e2.0,3.0,4.0,5.0\u003c/p\u003e\n\u003cp\u003eC:\\Windows\\System32\\powershell 存放64位powershell\u003c/p\u003e\n\u003cp\u003eC:\\Windows\\SysWOW64\\powershell 存放32位powershell\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;$PSVersionTable\n\u0026gt;$HOST\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInstall/Update:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.microsoft.com/zh-CN/download/details.aspx?id=40855\"\u003ehttps://www.microsoft.com/zh-CN/download/details.aspx?id=40855\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装Windows Management Framework4.0即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;$PSHOME\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多版本时切换版本:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;powershell -version 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"powershell相关项目\"\u003epowershell相关项目\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Microsoft\"\u003ehttps://github.com/Microsoft\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/PowerShell\"\u003ehttps://github.com/PowerShell\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/PowerShellOrg\"\u003ehttps://github.com/PowerShellOrg\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"win32-openssh\"\u003ewin32-openssh\u003c/h2\u003e\n\u003cp\u003ewindows的SSH。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/PowerShell/Win32-OpenSSH\"\u003ehttps://github.com/PowerShell/Win32-OpenSSH\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"powershell命令\"\u003epowershell命令\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;powershell -?\n\u0026gt;powershell /?\n\u0026gt;powershell -help\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"powershell-script\"\u003epowershell script\u003c/h1\u003e\n\u003cp\u003epowershell是默认大小写不敏感的。\u003c/p\u003e\n\u003cp\u003e同一行多个命令需要用分号;隔开。\u003c/p\u003e\n\u003cp\u003epowershell的安全策略：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003erestricted(default)\u003c/li\u003e\n\u003cli\u003eallsigned\u003c/li\u003e\n\u003cli\u003eremotesigned\u003c/li\u003e\n\u003cli\u003eunrestricted\u003c/li\u003e\n\u003cli\u003ebypass\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"注释\"\u003e注释\u003c/h1\u003e\n\u003cp\u003e单行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# comment\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多行注释(文档注释)：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;#\ncomment1\ncomment2\n...\n#\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e帮助文档:\u003c/p\u003e",
    "content": "PowerShell Console: command line interface\nISE: script editor and console combination\nVersion:\n2.0,3.0,4.0,5.0\nC:\\Windows\\System32\\powershell 存放64位powershell\nC:\\Windows\\SysWOW64\\powershell 存放32位powershell\n\u0026gt;$PSVersionTable \u0026gt;$HOST Install/Update:\nhttps://www.microsoft.com/zh-CN/download/details.aspx?id=40855\n安装Windows Management Framework4.0即可。\n\u0026gt;$PSHOME 多版本时切换版本:\n\u0026gt;powershell -version 2 powershell相关项目 https://github.com/Microsoft\nhttps://github.com/PowerShell\nhttps://github.com/PowerShellOrg\nwin32-openssh windows的SSH。\nhttps://github.com/PowerShell/Win32-OpenSSH\npowershell命令 \u0026gt;powershell -? \u0026gt;powershell /? \u0026gt;powershell -help powershell script powershell是默认大小写不敏感的。\n同一行多个命令需要用分号;隔开。\npowershell的安全策略：\nrestricted(default) allsigned remotesigned unrestricted bypass 注释 单行注释：\n# comment 多行注释(文档注释)：\n\u0026lt;# comment1 comment2 ... #\u0026gt; 帮助文档:\n在脚本开头的注释中用下面关键字插入文档。\n\u0026lt;# .SYNOPSIS Write your synopsis here. .DESCRIPTION Write your description here. .PARAMETER param1 Write your param1 information here. .EXAMPLE Write your example1 here. .NOTES Write your notes here. .LINK http://test.com #\u0026gt; 数据类型 变量 所有的变量都存储在Variable驱动器中,可以用Variable驱动器对变量操作。\nls Variable: # 查看所有变量 系统变量：\n$_ # 表示管道中的当前对象 ? # True表示上一个命令成功执行,False失败 自定义变量：\n变量以$开头定义,但是$不是变量名的一部分。\n变量包含数字，字母和小划线。\n$var1=\u0026quot;test\u0026quot; $var1 # 交换两个变量的值 $var1,$var2=$var2,$var1 变量类型：\n可以不用指定变量类型。\n[string]$str=\u0026quot;123\u0026quot; [int]$num=123 [boolean]bool=\u0026quot;True\u0026quot; 判断变量类型：\n$str -is [string] $num -as [int] 数组 包含多个变量就是一个数组。\n$var2=1,2,3 $var2[index] $var2[0] # 数组第一个元素 $var2[-1] # 数组最后一个元素 字典： hash类型。\n@{L=\u0026lt;key\u0026gt;; E={$_.\u0026lt;value\u0026gt;}; formatstring=\u0026lt;format\u0026gt;} @{N=\u0026lt;key\u0026gt;;E={$_.\u0026lt;value\u0026gt;}} @{Label=\u0026lt;key\u0026gt;;E={$_.\u0026lt;value\u0026gt;}} @{Name=\u0026lt;key\u0026gt;;E={$_.\u0026lt;value\u0026gt;}} 运算符 基本运算符：\n= # 赋值运算符，可以把任何数据类型包括对象赋值给变量 + # 加法和字符串拼接 - # 减法 * # 乘法 / # 除法 () # 优先运算符 特殊运算符：\n$($procs[0].name) # 子变量 '$var' # 单引号中的变量原样输出 \u0026quot;$var\u0026quot; # 双引号中的变量被替换 \u0026quot;`$var\u0026quot; # `重音符可以用在双引号中转义 `t # 制表符 `n # 换行符 kb/mb/gt/tb/pb # 单位可以运算 比较运算符：\n-eq -ne -gt -ge -lt -le -contains 包含 -notcontains 布尔运算符：\n-not 求反 -and -or -xor 控制流 powershell支持foreach循环。\nif条件语句：\nif ($this -eq $that) { expression } elseif ($those -gt $these) { expression2 } else { expression3 } switch条件语句：\nswitch ($condition) { val1 { expression break } val2 { expression2; break } default { default_expression } } foreach循环语句：\nforeach ($name in $names) { expression } for循环语句：\nfor ($loop=1; condition; $loop++) { expression } while循环语句:\nwhile (condition) { expression } do-while循环语句：\ndo { expression } while (condition) break语句：\nbreak用于循环和switch语句。\ncontinue语句：\ncontinue用于循环语句。\n函数 函数：\nfunction name { ... } 调用函数:\n.\\file.ps1 name 选项：\n[CmdletBinding()] Param( [Parameter(Mandatory=$True)] [String]$ComputerName, # ComputerName强制为通过命令行输入参数 [int]$EventID=1234, # EventID有默认参数 [Parameter(Mandatory=$True)][ValidateRange(0,23)] [int]$Number # 给出参数的范围 ) [CmdletBinding(SupportsShouldProcess$True)] # 支持-whatif和-confirm [ValidateSet(1,3,8)] # 给出参数的可选值 [alias(\u0026quot;id\u0026quot;, \u0026quot;nunber\u0026quot;)] # 给参数指定别名 模块 系统模块路径：\nc:\\Windows\\System32\\WindowsPowershell\\v1.0\\Modules\\ 函数可以打包成模块放在系统模块路径或用户自己的模块路径。\n模块放到同名的目录mytools下，取名mytools.psm1\n导入用户自己路径下的模块：\nImport-Module -name C:\\Modules\\mytools 异常和错误处理 调试语句：\nWrite-Verbose \u0026quot;print verbose information.\u0026quot; # 打印调试信息 Write-Debug \u0026quot;print debug information.\u0026quot; # 使用-Debug进入debug模式，exit退出。 调试相关系统变量：\n$ErrorActionPreference='Continue' # 调试的系统变量，默认报错继续执行 $DebugPreference='SilentlyContinue' $ErrorView='NormalView' $Error 存储整个shell的错误。 异常捕获：\nTry { expressions } Catch { \u0026quot;execute when catch the error.\u0026quot; } Finally { \u0026quot;execute anyway.\u0026quot; } 断点调试：\n$Condition = {if ($a -is [int] -and $a -gt 100) {Write-Host \u0026quot;`$a was modified\u0026quot;}} $Breakpoint = Set-PSBreakpoint -Variable a -Mode Write -Script $psise.CurrentFile.FullPath -Action $Condition ",
    "categories": ["Windows"],
    "tags": ["powershell"]
  },
  {
    "title": "Utils",
    "permalink": "https://canuxcheng.com/post/ps_utils/",
    "date": "2016-04-26",
    "summary": "\u003ch1 id=\"windows相关项目\"\u003ewindows相关项目：\u003c/h1\u003e\n\u003ch2 id=\"choco\"\u003echoco\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/chocolatey\"\u003ehttps://github.com/chocolatey\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ewindows的apt/yum。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/chocolatey/choco\"\u003echoco\u003c/a\u003e is replacement of \u003ca href=\"https://github.com/chocolatey/chocolatey\"\u003echocolatey\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003echoco install openssh\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"cmder\"\u003ecmder\u003c/h2\u003e\n\u003cp\u003ecmd的升级版。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cmderdev/cmder\"\u003ehttps://github.com/cmderdev/cmder\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"babun\"\u003ebabun\u003c/h2\u003e\n\u003cp\u003ea linux-shell like on windows.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/babun/babun\"\u003ehttps://github.com/babun/babun\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"flinux\"\u003eflinux\u003c/h2\u003e\n\u003cp\u003erun unmodified linux applications inside windows\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wishstudio/flinux\"\u003ehttps://github.com/wishstudio/flinux\u003c/a\u003e\u003c/p\u003e",
    "content": "windows相关项目： choco https://github.com/chocolatey\nwindows的apt/yum。\nchoco is replacement of chocolatey\nchoco install openssh cmder cmd的升级版。\nhttps://github.com/cmderdev/cmder\nbabun a linux-shell like on windows.\nhttps://github.com/babun/babun\nflinux run unmodified linux applications inside windows\nhttps://github.com/wishstudio/flinux\n",
    "categories": ["Windows"],
    "tags": ["utils"]
  },
  {
    "title": "Tivoli",
    "permalink": "https://canuxcheng.com/post/metrics_tivoli/",
    "date": "2016-04-20",
    "summary": "\u003ch1 id=\"itm\"\u003eITM\u003c/h1\u003e\n\u003cp\u003eITM: IBM Tivoli Monitoring\u003c/p\u003e\n\u003cp\u003e是IBM的Cloud \u0026amp; Smart Infrastructure监控解决方案。\u003c/p\u003e\n\u003cp\u003eArchitecture Overview:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/tivoli.png\" alt=\"pic\"\u003e\u003c/p\u003e\n\u003cp\u003eITM主要由管理组件和可选组件组成。\u003c/p\u003e\n\u003cp\u003eTivoli Management Services:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTEMS\u003c/li\u003e\n\u003cli\u003eTEPS\u003c/li\u003e\n\u003cli\u003eTEP client\u003c/li\u003e\n\u003cli\u003eHistorical data collection(warehouse agent)\n\u003cul\u003e\n\u003cli\u003ewarehouse proxy\u003c/li\u003e\n\u003cli\u003esummarization and pruning agent\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eOS agent\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eOptional components:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDashboard Application Services Hub\n\u003cul\u003e\n\u003cli\u003eTivoli Monitoring dashboards(Infrastructure Management Dashboards for Servers)\u003c/li\u003e\n\u003cli\u003eTivoli Common Reporting\u003c/li\u003e\n\u003cli\u003eTivoli Enterprise Monitoring Automation Server\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTivoli Event Synchronization component\u003c/li\u003e\n\u003cli\u003eAuthorization Policy Components(tivcmd)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm\"\u003ehttp://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装itm\"\u003e安装ITM\u003c/h2\u003e\n\u003cp\u003eWindows: C:\\IBM\\ITM\u003c/p\u003e\n\u003cp\u003eLinux/Unix: /opt/IBM/ITM\u003c/p\u003e\n\u003cp\u003e分为本地安装和分布式安装。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e需要先为TEPS和TDW安装DB(ODBC/JDBC)。\u003c/p\u003e\n\u003cp\u003eDB2\u003c/p\u003e\n\u003cp\u003eMSSQL\u003c/p\u003e",
    "content": "ITM ITM: IBM Tivoli Monitoring\n是IBM的Cloud \u0026amp; Smart Infrastructure监控解决方案。\nArchitecture Overview:\nITM主要由管理组件和可选组件组成。\nTivoli Management Services:\nTEMS TEPS TEP client Historical data collection(warehouse agent) warehouse proxy summarization and pruning agent OS agent Optional components:\nDashboard Application Services Hub Tivoli Monitoring dashboards(Infrastructure Management Dashboards for Servers) Tivoli Common Reporting Tivoli Enterprise Monitoring Automation Server Tivoli Event Synchronization component Authorization Policy Components(tivcmd) http://www.ibm.com/support/knowledgecenter/SSTFXA_6.3.0/com.ibm.itm.doc_6.3/welcome_63.htm\n安装ITM Windows: C:\\IBM\\ITM\nLinux/Unix: /opt/IBM/ITM\n分为本地安装和分布式安装。\n需要先为TEPS和TDW安装DB(ODBC/JDBC)。\nDB2\nMSSQL\nOracle\n在windows/linux/unix安装ITM framework\nTEMA\nWarehouse Proxy agent\nSummarization and Pruning agent\nTivoli performance Analyzer\nTEMS\nTEPS\nTEPD\nTEMAS\n安装agent\n安装操作系统的agent：\nmonitoring agent for your OS。\n安装数据库的agent：\nTEMA/TEMS/TEPS同时勾选DB的agent。\n安装agent builder的agent。\nhttp://www-933.ibm.com/support/fixcentral/swg/downloadFixes?parent=ibm%2FTivoli\u0026amp;product=ibm/Tivoli/IBM+Tivoli+Monitoring\u0026amp;release=All\u0026amp;platform=All\u0026amp;function=fixId\u0026amp;fixids=6.3.0-TIV-ITM-FP0005\u0026amp;includeRequisites=1\u0026amp;includeSupersedes=0\u0026amp;downloadMethod=http\n\u0026hellip;\nTEMS TEMS: Tivoli Enterprise Monitoing Server\nTEMS分为remote和hub，remote最后都汇总到hub。\nHTEMS: Hub Tivoli Enterprise Monitoring Server\nRTEMS: Remote Tivoli Enterprise Monitoring Server\n一个TEMS建议管理700个agent\nTEMA TEMA: Tivoli Enterprise Monitoring Agent\n安装agent之后通过GUI工具Tivoli Enterprise Monitoring Service来配置和启动agent。\n也可以通过命令行来配置和启动agent。\nagent配置需要指定HTEMS服务器。\nAgentless TEMS -\u0026gt; Agentless server -\u0026gt; servers\n就是用一个中间服务器通过snmp等协议来监控不需要安装agent的被监控服务器。\n一个agentless可以设置10个实例(操作系统)，一个实例可以监控100个节点(被监控服务器)。\nAgentless OS agents:\nAgentless Monitoring for AIX OS - SNMP Agentless Monitoring for HP-UX OS - SNMP Agentless Monitoring for Linux OS - SNMP Agentless Monitoring for Solaris OS - SNMP,CIM-XML Agentless Monitoring for Windows OS - SNMP,WMI Agent TEMS -\u0026gt; servers(agent)\n一个agent连2个TEMS,一个primary，一个backup。\nagent分为：\nOperating System agent specialized agent Application agent OS agent：\nWindows Unix Linux IBM i5/OS specialized agent：\nwarehouse proxy agent warehouse summarization and pruning agent Log file agent System p® agents (AIX Premium, CEC Base, HMC Base, VIOS Premium) Systems Director base agent Tivoli zEnterprise® Agent Performance Analyzer TEPS+DB TEPS: Tivoli Enterprise Portal Server\n使用MTEMS来配置TEPS,添加DB。\nTEPD(TEP client) TEP -\u0026gt; TEPS\nTEP: Tivoli Enterprise Portal client\nTEP是GUI界面，分为：\nDesktop Browser JavaWS: java web start 需要安装IBM的java，在C:\\Program Files\\IBM\\Java70。\n使用TEP来查看监控结果。\n默认用户是sysadmin, 需要为TEPD指定TEPS服务器。\nBrowser版本\nhttp://\u0026lt;TEPS Server\u0026gt;:15200/cnp.html Desktop版本\nhttp://\u0026lt;TEPS Server\u0026gt;:15200/tep.jnlp 安装ITM可以选择安装桌面版,也可以从Java Web Start获取桌面版。\nJava Web Start版本\n结合了desktop和browser的优点,从web下载，在桌面运行。\nTEP的结构：\nNavigator view\nEnterprise\nOperating Platform(操作系统类型)\nNode(一台服务器一个节点)\nAgent(一个节点上的agent)\nSituation(一个agent上的situation)\nEvent(一个situation有多个event)\nAttribute group(相同的Situation是一个group)\nNavigator workspace\n每个view项目都有一个默认的workspace。\n\u0026hellip;\nHistory data collection(TDW) TDW: Tivoli Data Warehouse\n存储历史数据。支持DB2，Oracle， MSSQL。\n也就是将agent收集的数据存到数据库。\nWarehouse Proxy TDW使用该agent从agents收集和加载数据。\n使用MTEMS配置warehouse proxy。\nSummarization and Pruning agent TDW使用该agent控制数据库大小。\n使用MTEMS配置summarization and pruning agent。\nJazz for Service Management(Visualization) Dashboard Application Services Hub(DASH)(visualization services) IBM Tivoli Common Reporting(reporting services) Registry Services Security Services Administration Services Tivoli Directory Integrator IBM HTTP Server IBM WebSphere® Application Server Web Server Plug-ins for IBM WebSphere Application Server \u0026hellip;\nManagement 管理所有组件一般使用GUI叫manage tivoli monitoring services\nwindows/linux/unix都可以用GUI。\n也可以使用CLI（命令行）,见后文.\n一般使用GUI来启动、停止和配置组件。\nCLI Command Line Interface\ntacmd 支持windows/linux/unix。\n/opt/IBM/ITM/bin/tacmd\nC:\\IBM\\ITM\\BIN\\tacmd\n查看tacmd手册：\n./tacmd help ./tacmd ? 登陆和登出HTEMS:\n./tacmd login -s [PROTOCOL://]HOST[:PORT] -u [USERNAME] -p [PASSWORD] -t [TIMEOUT] ./tacmd logout 登陆和登出TEPS：\n./tacmd tepsLogin -s [TEPS_HOSTNAME] -u [USERNAME] -p [TEPS_PASSWORD] -t [TIMEOUT] -i [IGNORE] ./tacmd tepsLogout 管理agent：\n./tacmd startAgent/stopAgent/restartAgent/viewAgent/updateAgent ... 刷新Netcool/OMNIbus：\n./tacmd refreshTECinfo {-t|--type} {eif|maps|attr|all} itmcmd 用于Linux/Unix系统的命令\n/opt/IBM/ITM/bin/itmcmd\n查看itmcmd手册：\n./itmcmd help ./itmcmd ? 启动或停止TEMS:\n./itmcmd server [-options] {start|stop} tems_name 启动或停止agent：\n./itmcmd agent [-options] {start|stop} {pc ...|all} 启动MTEMS:\n./itmcmd manage \u0026amp; tivcmd \u0026hellip;\nAdvanced Administration Queries(query editor) DB agent -\u0026gt; normal way to get data source from database servers.\nODBC -\u0026gt; get data source from windows database\nJDBC -\u0026gt; get data source from linux/unix database\nAdvanced link topics Simple link:\nJust used to navigate portal workspaces without using the navigator.\nAdvanced link:\nCan be used to manipulate data that is displayed in the target workspace.\nAdvanced situation techniques(situation editor) Agent autonomy Policy(workflow editor) Agentless monitoring TEPS -\u0026gt; Agentless Monitoring Serve -\u0026gt; Servers\nAgent Managent Services(AMS) Agent Builder IBM Agent Builder agents\nwindows:\nC:\\Program Files(x86)\\IBM\\AgentBuilder aix/linux:\n/opt/ibm/AgentBuilder Data source:\nJDBC HTTP SOAP Ping Socket Java API WMI Perfmon CIM SNMP JMX command return code output from a script A log file AIX Binary Log windows event log A process A Windows service create agent Every agent have a unique produce code.\nLike: k00-k99, k{0-9}{A-Z}.\nCreate the agent in the Agent Builder agent information data source runtime configuration\nInstall and test the agent output and install the agent config and start agent in MTEMS. confirm agent data revise and retest as needed\nAdd application support create in TEP, including queries, workspaces, situations, and take actions. Import application support into agent in Agent Builder. Retest the agent and application support\nCreate an installation solution. Create solution install package from the agent. Create solution install package from the package. Run the image on the target location.\ninstall agent Three ways to instal the agent.\nYou must install the TEMS and TEPS support on TEMS(HTEMS) and TEPS server.\ngenerate the agent files in an ITM installation on this machine\n通过GUI快速安装，Agent Builder和ITM（TEMS和TEPS）安装在同一台机器上。\ngenerate a solution install package\n创建安装镜像来安装，windows的.exe和linux/unix的.bin。\ncreate a compressed file so that the agent can be installed on another system\n命令行安装。 生成一个.zip和一个.tgz文件。 包括windows的.bat和linux/unix的.sh安装文件\n安装下面三个包(等效方法一）：\nInstallIra.bat/.sh itm_install_location [[-h Hub_TEMS_hostname] -u HUB_TEMS_username -p Hub_TEMS_password] InstallIra.bat C:\\IBM\\ITM -h \u0026lt;HTEMS\u0026gt; -u \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; # for windows ./InstallIra.sh /opt/IBM/ITM -h \u0026lt;HTEMS\u0026gt; -u \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; # for linux 在被监控机器安装agent:\ninstallIraAgent.bat/.sh itm_install_location installIraAgent.bat C:\\IBM\\ITM # for windows ./installIraAgent.sh /opt/IBM/ITM # for linux 在TEMS(HTEMS)服务器安装对agent的支持：\ninstallIraAgentTEMS.bat/.sh itm_install_location [[-h Hub_TEMS_hostname] -u HUB_TEMS_username -p Hub_TEMS_password] installIraAgentTEMS.bat C:\\IBM\\ITM # for local HTEMS windows server. ./installIraAgentTEMS.sh /opt/IBM/ITM # for local HTEMS linux server. 在TEPS服务器安装对agent的支持：\ninstallIraAgentTEPS.bat/.sh itm_install_location [[-h TEPS_hostname] -u TEPS_username -p TEPS_password] installIraAgentTEPS.bat C:\\IBM\\ITM # for local TEPS windows server. ./installIraAgentTEPS.sh /opt/IBM/ITM # for local TEPS linux server. config agent 需要为agent指定HTEMS服务器，并重启agent，然后重启TEPD。\n可以通过Tivoli Enterprise Monitoring Service来配置和启动，也可以通过命令行。\n查看所有agent信息：\n/opt/IBM/ITM/bin/cinfo -i # check the productcode and platformCode. config agent:\n./itmcmd config -A productcode start agent:\n./tacmd agent start productcode uninstall agent uninstall from commandline.\nwindows:\ncd ITM_INSTALL/TMAITM6 cd C:\\IBM\\ITM\\TMAITM6_x64 kxx_uninstall.vbs ITM_INSTALL K\u0026lt;product code\u0026gt;_uninstall.vbs C:\\IBM\\ITM linux/unix:\n/opt/IBM/ITM/bin/uninstall.sh [-f] [-i] [-h install_dir] productcode platformCode Remove from TEP client(clear offline entry)\nMonitoring windows resources Windows Management Instrumentation(WMI)\nWindows Performance Monitor(Perfmon)\nWindows Event Log\nMonitoring process and command return codes Monitoring process\nMonitoring command return code\nMonitoring custom data sources Monitoring script output\nMonitoring log file\nMonitoring remote resources Monitoring SNMP\nMonitoring CIM\nMoitoring JMX\nNetcool/OMNIbus IBM Tivoli Netcool/OMNIbus\nTEC: Tivoli Enterprise Console, 已经被Netcool/OMNIbus替代。\nwindows:\nC:\\Program Files(x86)\\IBM\\NCOhome linux/aix:\n/opt/IBM/NCOhome Browser版本需要安装IBM的JRE，在C:\\Program Files\\IBM\\Java70。\nEIF EIF: Event Integration Facility\n",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Find",
    "permalink": "https://canuxcheng.com/post/shell_find/",
    "date": "2016-04-20",
    "summary": "\u003ch1 id=\"find\"\u003efind\u003c/h1\u003e\n\u003cp\u003eFind     查找，用于在目录中查找。\nfind  path  options  tests  actions\npath 路径\noptions 选项\ntests 测试\nactions 动作\u003c/p\u003e\n\u003cp\u003eoptioins选项:\n-follow\n-depth\n-maxdepth\n-mindepth\nfind   dir  -mindepth  n     指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。\nfind   dir   -maxdepth  n      指定最大目录深度，不搜索n级之后的目录。\u003c/p\u003e\n\u003cp\u003etest选项很多：\n-newer   pattern   比pattern文件要新\n-user    pattern      文件属主是pattern\n-name   pattern    查找和type匹配的\n-iname  pattern    查找和type匹配的，会忽略大小写\n-iwholename\n-path   pattern     按照文件路径匹配\n-type   c           c是文件类型，按照文件类型匹配文件\n-size   +/-    nk/c/w/k/b/M/G    匹配大于或小于n  kb/..  的文件\n-perm   XXX       基于文件权限的匹配\nfind dir  –atime/mtime/ctime    +/-n    根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。\n-a/-and   pattern\n-o/-or     pattern\n！/-not    pattern\nfind  dir  !  test   pattern   列出所有没有按照-options  pattern模式的项\n(\u0026hellip;)    使用括号需要用引号来引用。\u003c/p\u003e",
    "content": "find Find 查找，用于在目录中查找。 find path options tests actions path 路径 options 选项 tests 测试 actions 动作\noptioins选项: -follow -depth -maxdepth -mindepth find dir -mindepth n 指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。 find dir -maxdepth n 指定最大目录深度，不搜索n级之后的目录。\ntest选项很多： -newer pattern 比pattern文件要新 -user pattern 文件属主是pattern -name pattern 查找和type匹配的 -iname pattern 查找和type匹配的，会忽略大小写 -iwholename -path pattern 按照文件路径匹配 -type c c是文件类型，按照文件类型匹配文件 -size +/- nk/c/w/k/b/M/G 匹配大于或小于n kb/.. 的文件 -perm XXX 基于文件权限的匹配 find dir –atime/mtime/ctime +/-n 根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。 -a/-and pattern -o/-or pattern ！/-not pattern find dir ! test pattern 列出所有没有按照-options pattern模式的项 (\u0026hellip;) 使用括号需要用引号来引用。\naction选项： -prune 如果是一个指定的目录就忽略这个目录,要用-path指定目录. -print 打印，换行符结尾,所有结果一行一个。 -print0 打印，空字符结尾，所有结果打印到一行。 -delete 删除 -exec command 执行一个命令 exec command {} ;\noperators: find可以用一些运算符来连接多个test条件。 ！expr #取反 expr1 -a expr2 #与运算，可以省略-a expr1 -o expr2 #或运算\n查找当前目录下除了develop里面的文件以外的30天之内修改过的.txt文件 find . -path ./develop -prune -o -mtime -30 -type f -name \u0026ldquo;*.txt\u0026rdquo; -print\n将前面的命令的结果通过管道和xargs作为后面命令的输入，类似于find命令的-exec选项。 格式 ：command1 | xargs -options command2 Xargs -n number 设置每行显示的参数数量为number。 Xargs -d char 指定char为界定符，也就是将char换成空格。 Xargs -I {} 将命令参数用STDIN的参数替换掉。 Xargs -0 以/0为定界符，而不是空格。\nfind . -name “.c” | xargs wc -l find . -name “.c” -exec wc -l {} ; wc -l find . -name “*.c”\n",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Grep",
    "permalink": "https://canuxcheng.com/post/shell_grep/",
    "date": "2016-04-20",
    "summary": "\u003ch1 id=\"grep\"\u003egrep\u003c/h1\u003e\n\u003cp\u003egrep相关的命令：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egrep\negrep == grep -E\nfgrep == grep -F\nrgrep == grep -r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egrep:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egrep [OPTIONS] PATTERN [FILE/DIR...]\ngrep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eoptions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Matcher Selection\n-G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE\n-E, --extended-regexp 选择ERE, 可以使用扩展的RE\n# grep -E \u0026quot;pattern1|pattern2\u0026quot; 比如支持或运算\n-F, --fixed-strings\n-P, --perl-regexp perl RE\n\n# Matching Control\n-e PATTERN, --regexp=PATTERN    可以指定多个pattern\n# grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来\n-f FILE, --file=FILE    文件的每一行就是一个pattern.\n-i, --ignore-case    忽略大小写\n-v, --invert-match   忽略含有pattern的行\n-w, --word-regexp    精确匹配一个单词\n-x, --line-regexp    精确匹配一行\n-y\n\n# General Output Control\n-c, --count    统计匹配到的行数\n--color[=WHEN], --colour[=WHEN]    输出匹配的pattern高亮\n-L, --files-without-match    列出没有匹配到的文件名\n-l, --files-with-matches    列出匹配到的文件的文件名\n# grep -rl pattern1 | xargs grep -r pattern2    相当于与运算，过滤同时满足两个pattern\n-m NUM, --max-count=NUM\n-o, --only-matching    只输出匹配的部分\n# grep -o pattern filename | wc -l 统计匹配的行数\n-q, --quiet, --silent    不打印查找的结果\n-s, --no-messages\n\n# Output Line Prefix Control\n-b, --byte-offset    打印匹配的字符数或偏移量\n-H, --with-filename\n-h, --no-filename\n--label=LABEL\n-n, --line-number    打印匹配的行的行号\n-T, --initial-tab\n-u, --unix-byte-offsets\n-Z, --null\n\n# Context Line Control\n-A NUM, --after-context=NUM    打印匹配到的行的后NUM行\n-B NUM, --before-context=NUM    打印匹配到的行的前NUM行j\n-C NUM, -NUM, --context=NUM    打印匹配到的行的前NUM行和后NUM行\n\n# File and Directory Selection\n-a, --text\n--binary-files=TYPE\n-D ACTION, --devices=ACTION\n-d ACTION, --directories=ACTION\n--exclude=GLOB    排除查找指定的文件\n--exclude-from=FILE\n--exclude-dir=DIR   排除查找指定的目录\n-I\n--include=GLOB     指定查找的文件\n-r, --recursive    递归查找\n-R, --dereference-recursive    递归查找\n# grep -nR/-nr pattern filename    阅读源码可以递归查找并打印行号\n\n# Other Options\n--line-buffered\n--mmap\n-U, --binary\n-z, --null-data\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"ack\"\u003eack\u003c/h1\u003e\n\u003cp\u003eack/ack2是grep的升级版\u003c/p\u003e",
    "content": "grep grep相关的命令：\ngrep egrep == grep -E fgrep == grep -F rgrep == grep -r grep:\ngrep [OPTIONS] PATTERN [FILE/DIR...] grep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...] options:\n# Matcher Selection -G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE -E, --extended-regexp 选择ERE, 可以使用扩展的RE # grep -E \u0026quot;pattern1|pattern2\u0026quot; 比如支持或运算 -F, --fixed-strings -P, --perl-regexp perl RE # Matching Control -e PATTERN, --regexp=PATTERN 可以指定多个pattern # grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来 -f FILE, --file=FILE 文件的每一行就是一个pattern. -i, --ignore-case 忽略大小写 -v, --invert-match 忽略含有pattern的行 -w, --word-regexp 精确匹配一个单词 -x, --line-regexp 精确匹配一行 -y # General Output Control -c, --count 统计匹配到的行数 --color[=WHEN], --colour[=WHEN] 输出匹配的pattern高亮 -L, --files-without-match 列出没有匹配到的文件名 -l, --files-with-matches 列出匹配到的文件的文件名 # grep -rl pattern1 | xargs grep -r pattern2 相当于与运算，过滤同时满足两个pattern -m NUM, --max-count=NUM -o, --only-matching 只输出匹配的部分 # grep -o pattern filename | wc -l 统计匹配的行数 -q, --quiet, --silent 不打印查找的结果 -s, --no-messages # Output Line Prefix Control -b, --byte-offset 打印匹配的字符数或偏移量 -H, --with-filename -h, --no-filename --label=LABEL -n, --line-number 打印匹配的行的行号 -T, --initial-tab -u, --unix-byte-offsets -Z, --null # Context Line Control -A NUM, --after-context=NUM 打印匹配到的行的后NUM行 -B NUM, --before-context=NUM 打印匹配到的行的前NUM行j -C NUM, -NUM, --context=NUM 打印匹配到的行的前NUM行和后NUM行 # File and Directory Selection -a, --text --binary-files=TYPE -D ACTION, --devices=ACTION -d ACTION, --directories=ACTION --exclude=GLOB 排除查找指定的文件 --exclude-from=FILE --exclude-dir=DIR 排除查找指定的目录 -I --include=GLOB 指定查找的文件 -r, --recursive 递归查找 -R, --dereference-recursive 递归查找 # grep -nR/-nr pattern filename 阅读源码可以递归查找并打印行号 # Other Options --line-buffered --mmap -U, --binary -z, --null-data ack ack/ack2是grep的升级版\nack:\nhttps://github.com/beyondgrep/ack\nack2(ack-grep):\nhttps://github.com/beyondgrep/ack2\nag ack/ack2的升级版\nhttps://github.com/ggreer/the_silver_searcher\n安装：\n$sudo apt-get install silversearcher-ag $sudo yum install the_silver_searcher 使用：\n$man ag ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Development",
    "permalink": "https://canuxcheng.com/post/devops_dev/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"development\"\u003eDevelopment\u003c/h1\u003e\n\u003cp\u003e开发相关的工具\u003c/p\u003e\n\u003cp\u003e传统的软件开发采用的是瀑布式开发流程．\u003c/p\u003e\n\u003cp\u003e现代的软件开发采用的是敏捷开发流程(Agile development).\u003c/p\u003e\n\u003cp\u003eAlpha: inner test version.\u003c/p\u003e\n\u003cp\u003eBeta: outer test version.\u003c/p\u003e\n\u003cp\u003eRC: release candidate. 最终版本之前的最后一个版本．也叫gamma.\u003c/p\u003e\n\u003cp\u003eRTM: release to manufacture, 最终版\u003c/p\u003e\n\u003cp\u003eGA: generally avaliable. stable/production.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"怎样选择licenses\"\u003e怎样选择Licenses\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://choosealicense.com/licenses/\"\u003ehttp://choosealicense.com/licenses/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://choosealicense.com/\"\u003ehttps://choosealicense.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/license.jpeg\" alt=\"pic\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"semver\"\u003esemver\u003c/h1\u003e\n\u003cp\u003e语义化版本．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://semver.org/lang/zh-CN/\"\u003ehttp://semver.org/lang/zh-CN/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/mojombo/semver\"\u003ehttps://github.com/mojombo/semver\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e主版本号.次版本号.修订号\nMajor.Minor.Patch\n\nMajor: 做了不兼容的API修改\nMinor: 做了向下兼容的功能性新增\nPatch: 做了向下兼容的问题修正\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"文档阅读工具\"\u003e文档阅读工具\u003c/h1\u003e\n\u003ch2 id=\"zeal\"\u003ezeal\u003c/h2\u003e\n\u003ch2 id=\"dash\"\u003edash\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"cookiecutter\"\u003ecookiecutter\u003c/h1\u003e\n\u003cp\u003e一个快速建立工程模板的命令行工具．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/audreyr/cookiecutter\"\u003ehttps://github.com/audreyr/cookiecutter\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/audreyr/cookiecutter-pypackage\"\u003ehttps://github.com/audreyr/cookiecutter-pypackage\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$sudo -E pip install cookiecutter\n# 创建python项目\n$cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git\n# 创建django格式的python项目\n$cookiecutter https://github.com/pydanny/cookiecutter-django\n# 创建openstack格式的python项目\n$cookiecutter https://git.openstack.org/openstack-dev/cookiecutter.git\n$cookiecutter https://github.com/openstack-dev/cookiecutter.git\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"bumpversion\"\u003ebumpversion\u003c/h1\u003e\n\u003cp\u003e版本管理工具\u003c/p\u003e",
    "content": "Development 开发相关的工具\n传统的软件开发采用的是瀑布式开发流程．\n现代的软件开发采用的是敏捷开发流程(Agile development).\nAlpha: inner test version.\nBeta: outer test version.\nRC: release candidate. 最终版本之前的最后一个版本．也叫gamma.\nRTM: release to manufacture, 最终版\nGA: generally avaliable. stable/production.\n怎样选择Licenses http://choosealicense.com/licenses/\nhttps://choosealicense.com/\nsemver 语义化版本．\nhttp://semver.org/lang/zh-CN/\nhttps://github.com/mojombo/semver\n主版本号.次版本号.修订号 Major.Minor.Patch Major: 做了不兼容的API修改 Minor: 做了向下兼容的功能性新增 Patch: 做了向下兼容的问题修正 文档阅读工具 zeal dash cookiecutter 一个快速建立工程模板的命令行工具．\nhttps://github.com/audreyr/cookiecutter\nhttps://github.com/audreyr/cookiecutter-pypackage\n$sudo -E pip install cookiecutter # 创建python项目 $cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git # 创建django格式的python项目 $cookiecutter https://github.com/pydanny/cookiecutter-django # 创建openstack格式的python项目 $cookiecutter https://git.openstack.org/openstack-dev/cookiecutter.git $cookiecutter https://github.com/openstack-dev/cookiecutter.git bumpversion 版本管理工具\nhttps://github.com/peritus/bumpversion\n$sudo -E pip install bumpversion # put config in setup.cfg [bumpversion] current_version = 1.2.0 files = pymonitoringplugins/__init__.py $bumpversion major/minor/patch --commit # commit新版本 ",
    "categories": ["DevOps"],
    "tags": ["development"]
  },
  {
    "title": "DevOps",
    "permalink": "https://canuxcheng.com/post/devops/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"devops\"\u003eDevOps\u003c/h1\u003e\n\u003cp\u003eDevOps包括ChatOps, 敏捷开发，持续集成,持续交付,持续发布/部署，QA(自动化测试），智能监控和日志管理等内容．\u003c/p\u003e\n\u003cp\u003eDevOps涉及到三个部门：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDevelopment\u003c/li\u003e\n\u003cli\u003eOperations\u003c/li\u003e\n\u003cli\u003eQuality Assurance\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"ci\"\u003eCI\u003c/h1\u003e\n\u003cp\u003eContinuous Integration.\u003c/p\u003e\n\u003cp\u003e持续集成包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e编译代码.\u003c/li\u003e\n\u003cli\u003e静态代码分析.\u003c/li\u003e\n\u003cli\u003e自动化测试，例如selenium.\u003c/li\u003e\n\u003cli\u003e代码覆盖率分析.\u003c/li\u003e\n\u003cli\u003e构建，例如docker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"cd\"\u003eCD\u003c/h1\u003e\n\u003cp\u003eContinuous Delivery.\u003c/p\u003e\n\u003cp\u003e持续交付包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将通过测试的代码部署到Staging.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"continuous-releasedeploy\"\u003eContinuous Release/Deploy\u003c/h1\u003e\n\u003cp\u003e持续部署/发布包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将通过评审的交付代码部署到Production.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cicd的工具\"\u003eCI/CD的工具\u003c/h1\u003e\n\u003cp\u003e持续集成和部署\u003c/p\u003e\n\u003ch2 id=\"jenkins\"\u003eJenkins\u003c/h2\u003e\n\u003ch2 id=\"travis-ci\"\u003etravis CI\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://travis-ci.org/\"\u003ehttps://travis-ci.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003etravis CI是基于github的CI工具, 部署代码然后运行测试代码.\u003c/p\u003e\n\u003cp\u003e在github项目添加.travis.yml文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elanguage: python\npython:\n  - \u0026quot;2.7\u0026quot;\ninstall:\n  - pip install -r requirements.txt\n  - pip install coveralls\nscript:\n  - coverage run --source=pymonitoringplugins setup.py test\nafter_success:\n  - coveralls\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"circleci\"\u003ecircleci\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://circleci.com/\"\u003ehttps://circleci.com/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"coverage的工具\"\u003ecoverage的工具\u003c/h1\u003e\n\u003cp\u003e统计单元测试的覆盖率\u003c/p\u003e\n\u003ch2 id=\"coveralls\"\u003ecoveralls\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://coveralls.io/\"\u003ehttps://coveralls.io/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"codecov\"\u003ecodecov\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://codecov.io/\"\u003ehttps://codecov.io/\u003c/a\u003e\u003c/p\u003e",
    "content": "DevOps DevOps包括ChatOps, 敏捷开发，持续集成,持续交付,持续发布/部署，QA(自动化测试），智能监控和日志管理等内容．\nDevOps涉及到三个部门：\nDevelopment Operations Quality Assurance CI Continuous Integration.\n持续集成包括：\n编译代码. 静态代码分析. 自动化测试，例如selenium. 代码覆盖率分析. 构建，例如docker. CD Continuous Delivery.\n持续交付包括：\n将通过测试的代码部署到Staging. Continuous Release/Deploy 持续部署/发布包括：\n将通过评审的交付代码部署到Production. CI/CD的工具 持续集成和部署\nJenkins travis CI https://travis-ci.org/\ntravis CI是基于github的CI工具, 部署代码然后运行测试代码.\n在github项目添加.travis.yml文件：\nlanguage: python python: - \u0026quot;2.7\u0026quot; install: - pip install -r requirements.txt - pip install coveralls script: - coverage run --source=pymonitoringplugins setup.py test after_success: - coveralls circleci https://circleci.com/\ncoverage的工具 统计单元测试的覆盖率\ncoveralls https://coveralls.io/\ncodecov https://codecov.io/\nstackstorm StackStorm is a platform for integration and automation across services and tools, taking actions in response to events.\nFor DevOps and ChatOps.\nhttps://github.com/StackStorm/st2\nDrone Drone is a Continuous Delivery platform built on Docker, written in Go\nhttps://github.com/drone/drone\nsupervisor Supervisor process control system for UNIX/Linux.\nhttps://github.com/Supervisor/supervisor\n$ pip install supervisor redmine ruby开发的项目管理工具,集成bug和wiki工具．\ndokuwiki php开发的wiki管理工具\nAtlassian Jira for Porject Management.\nBitbucket for Source code management.\nBamboo for CI/CD.\nbugzilla perl开发的bug追踪系统．\nerrbot python开发的ChatOps工具．\nhttps://github.com/errbotio/errbot\nzulip 团队聊天工具介绍\nhttps://github.com/zulip/zulip\n",
    "categories": ["DevOps"],
    "tags": ["devops"]
  },
  {
    "title": "Gitlab",
    "permalink": "https://canuxcheng.com/post/devops_gitlab/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"gitlab\"\u003eGitlab\u003c/h1\u003e\n\u003cp\u003egitlab是开源的有web界面的git服务器．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://about.gitlab.com/\"\u003ehttps://about.gitlab.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装gitlab:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo apt-get install -y curl openssh-server ca-certificates\nsudo apt-get install -y postfix\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash\nsudo EXTERNAL_URL=\u0026quot;http://gitlab.example.com\u0026quot; apt-get install gitlab-ce\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/etc/gitlab/gitlab.rb\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e升级gitlab:\u003c/p\u003e\n\u003cp\u003e需要先升级到下个major版本的最后一个稳定版.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurrent:   9.4.7\npatch: gitlab-ce=9.5.10\npatch: gitlab-ce_10.8.7\npatch: gitlab-ce=11.11.8\npatch: gitlab-ce=12.0.12\ntarget: 12.10.14\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erunner:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64\nsudo chmod +x /usr/local/bin/gitlab-runner\nsudo gitlab-runner install --user=canux --working-directory=/home/canux/gitlab\nsudo gitlab-runner register\nsudo gitlab-runner start\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"cli\"\u003eCLI\u003c/h1\u003e\n\u003cp\u003e备份：\u003c/p\u003e",
    "content": "Gitlab gitlab是开源的有web界面的git服务器．\nhttps://about.gitlab.com/\n安装gitlab:\nsudo apt-get install -y curl openssh-server ca-certificates sudo apt-get install -y postfix curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash sudo EXTERNAL_URL=\u0026quot;http://gitlab.example.com\u0026quot; apt-get install gitlab-ce 配置:\n/etc/gitlab/gitlab.rb 升级gitlab:\n需要先升级到下个major版本的最后一个稳定版.\ncurrent: 9.4.7 patch: gitlab-ce=9.5.10 patch: gitlab-ce_10.8.7 patch: gitlab-ce=11.11.8 patch: gitlab-ce=12.0.12 target: 12.10.14 runner:\n#sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 sudo chmod +x /usr/local/bin/gitlab-runner sudo gitlab-runner install --user=canux --working-directory=/home/canux/gitlab sudo gitlab-runner register sudo gitlab-runner start CLI 备份：\n\u0026gt; 修改备份路径：gitlab_rails['backup_path'] = \u0026quot;/var/opt/gitlab/backups\u0026quot; # gitlab-rake gitlab:backup:create 重新加载配置:\n# gitlab-ctl reconfigure 重启:\n# gitlab-ctl restart/start/stop ",
    "categories": ["DevOps"],
    "tags": ["gitlab"]
  },
  {
    "title": "Jenkins",
    "permalink": "https://canuxcheng.com/post/devops_jenkins/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"jenkins\"\u003eJenkins\u003c/h1\u003e\n\u003cp\u003eJenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks such as building, testing, and deploying software.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/jenkinsci/jenkins\"\u003ehttps://github.com/jenkinsci/jenkins\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装好Jenkins后安装需要的插件．\u003c/p\u003e\n\u003cp\u003e安装jenkins:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# download jenkins.war and install java8.\n$ java -jar jenkins.war --httpPort=8080\n$ firefox http://localhost:8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e设置开机自动启动，不用每次从终端启动:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vim /etc/systemd/system/jenkins.service\n$ systemctl daemon-reload\n$ systemctl enable jenkins.service\n$ systemctl start jenkins\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejinkens主目录:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 默认主目录在/home/canux/.jenkins\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"nodes\"\u003enodes\u003c/h1\u003e\n\u003cp\u003e添加节点需要安装和master版本一样的java.\u003c/p\u003e\n\u003cp\u003eon jenkins agent:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003einstall java.\u003c/li\u003e\n\u003cli\u003ecreate folder and grant permission. (/home/jenkins)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eon jenkins:\u003c/p\u003e",
    "content": "Jenkins Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks such as building, testing, and deploying software.\nhttps://github.com/jenkinsci/jenkins\n安装好Jenkins后安装需要的插件．\n安装jenkins:\n# download jenkins.war and install java8. $ java -jar jenkins.war --httpPort=8080 $ firefox http://localhost:8080 设置开机自动启动，不用每次从终端启动:\n$ vim /etc/systemd/system/jenkins.service $ systemctl daemon-reload $ systemctl enable jenkins.service $ systemctl start jenkins jinkens主目录:\n# 默认主目录在/home/canux/.jenkins nodes 添加节点需要安装和master版本一样的java.\non jenkins agent:\ninstall java. create folder and grant permission. (/home/jenkins) on jenkins:\ncreate credential and node. plugins thinbackup 备份插件，主要备份jenkins主目录.\npipeline https://github.com/jenkinsci/pipeline-plugin\n使用pipeline需要先安装pipeline插件.\npipeline是groovy语法的jenkins的DSL.\nblueocean https://github.com/jenkinsci/blueocean-plugin\ngit plugin https://github.com/jenkinsci/git-plugin\ndocker plugin https://github.com/jenkinsci/docker-workflow-plugin\nhttps://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow\nk8s https://github.com/jenkinsci/kubernetes-plugin\ndocker 在docker上执行流水线\nagent { docker { image 'maven:3-alpine' label 'my-defined-label' args '-v /tmp:/tmp' } } agent { // Equivalent to \u0026quot;docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/ dockerfile { filename 'Dockerfile.build' dir 'build' label 'my-defined-label' additionalBuildArgs '--build-arg version=1.0.2' } } ",
    "categories": ["DevOps"],
    "tags": ["jenkins"]
  },
  {
    "title": "Operations",
    "permalink": "https://canuxcheng.com/post/devops_ops/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"operations\"\u003eOperations\u003c/h1\u003e\n\u003cp\u003e运维相关的工具．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"批量配置管理\"\u003e批量配置管理\u003c/h1\u003e\n\u003ch2 id=\"puppet\"\u003epuppet\u003c/h2\u003e\n\u003ch2 id=\"chef\"\u003echef\u003c/h2\u003e\n\u003ch2 id=\"salt\"\u003esalt\u003c/h2\u003e\n\u003ch2 id=\"ansible\"\u003eansible\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"密码管理工具\"\u003e密码管理工具\u003c/h1\u003e\n\u003ch2 id=\"keepass\"\u003ekeepass\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://keepass.info/\"\u003ehttp://keepass.info/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"keepassx\"\u003eKeePassX\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.keepassx.org/\"\u003ehttps://www.keepassx.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/keepassx/keepassx\"\u003ehttps://github.com/keepassx/keepassx\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e",
    "content": "Operations 运维相关的工具．\n批量配置管理 puppet chef salt ansible 密码管理工具 keepass http://keepass.info/\nKeePassX https://www.keepassx.org/\nhttps://github.com/keepassx/keepassx\n",
    "categories": ["DevOps"],
    "tags": ["operations"]
  },
  {
    "title": "Admin",
    "permalink": "https://canuxcheng.com/post/linux_admin/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"linux-admin\"\u003eLinux Admin\u003c/h1\u003e\n\u003cp\u003edpkg: ubuntu, debian.\u003c/p\u003e\n\u003cp\u003erpm: fedora, centos, redhat.\u003c/p\u003e\n\u003cp\u003ezypper: suse.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"linux系统常用的安装和配置\"\u003eLinux系统常用的安装和配置\u003c/h1\u003e\n\u003ch2 id=\"terminalizer\"\u003eterminalizer\u003c/h2\u003e\n\u003cp\u003e终端录制工具\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/faressoft/terminalizer\"\u003ehttps://github.com/faressoft/terminalizer\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"virtualbox\"\u003evirtualbox\u003c/h2\u003e\n\u003cp\u003e开机自动挂载共享文件夹\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 手动挂在命令, 需要安装增强功能\n$ mount -t vboxsf FolderNameOnWindows /path/on/linux\n\n# 实现开机自动挂载\n$ sudo vim /etc/rc.local\nmount.vboxsf -w ShareFolderNameOnWindows MountPointOnLinux\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"xrdp\"\u003exrdp\u003c/h2\u003e\n\u003cp\u003e从windows的RDP远程连接linux.\u003c/p\u003e\n\u003cp\u003euse RDP on windows to connect to ubuntu16.04.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esudo dpkg -i tigervncserver_1.6...deb # download and install tigervncserver first.\nsudo apt-get install -f\nsudo apt-get instal xrdp -y\necho unity \u0026gt; ~/.xsession\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euse RDP on windows to connect to ubuntu14.04.\u003c/p\u003e",
    "content": "Linux Admin dpkg: ubuntu, debian.\nrpm: fedora, centos, redhat.\nzypper: suse.\nLinux系统常用的安装和配置 terminalizer 终端录制工具\nhttps://github.com/faressoft/terminalizer\nvirtualbox 开机自动挂载共享文件夹\n# 手动挂在命令, 需要安装增强功能 $ mount -t vboxsf FolderNameOnWindows /path/on/linux # 实现开机自动挂载 $ sudo vim /etc/rc.local mount.vboxsf -w ShareFolderNameOnWindows MountPointOnLinux xrdp 从windows的RDP远程连接linux.\nuse RDP on windows to connect to ubuntu16.04.\nsudo dpkg -i tigervncserver_1.6...deb # download and install tigervncserver first. sudo apt-get install -f sudo apt-get instal xrdp -y echo unity \u0026gt; ~/.xsession use RDP on windows to connect to ubuntu14.04.\nsudo apt-get install xrdp sudo apt-get install xfce4 echo xfce4-session \u0026gt; ~/.xsession sudo vim /etc/xrdp/startwm.sh # add 'startxfce4' to last line. sudo service xrdp restart 清理内存的buff/cache echo 3 \u0026gt; /proc/sys/vm/drop_caches # reboot才能改回默认的0 终端现实超大艺术字 $ sudo apt-get install figlet $ figlet \u0026lt;text\u0026gt; Ubuntu/Debian安装后的基本配置 sudo apt-get install build-essential make libssl-dev apt mirror vim /etc/apt/sources.list # deb http://ip:port/path ubuntu16/ # deb [trusted=yes] https://\u0026lt;user\u0026gt;:\u0026lt;pw\u0026gt;@ip:port/path ubuntu16/ deb [trusted=yes] https://user:pw@mirror.com/mirror ubuntu16/ vim /etc/apt/apt.conf Acquire::https::mirror.com::Verify-Peer \u0026quot;false\u0026quot;; Acqhire::https::mirror.com::Verify-Host \u0026quot;false\u0026quot;; 中文输入法 安装一个中文输入法框架fcitx(IBus, SCIM, UIM)：\n$ sudo apt-get install fcitx 安装一种输入法引擎：\nsudo apt-get install fcitx-googlepinyin sudo apt-get install fcitx-sunpinyin sudo apt-get install fcitx-libpinyin sudo apt-get install fcitx-sougoupinyin sudo apt-get install fcitx-cloudpinyin 配置程序：\nkcm-fcitx - for qt - \u0026lt;https://github.com/fcitx/kcm-fcitx\u0026gt; fcitx-configtool - for gtk - \u0026lt;https://github.com/fcitx/fcitx-configtool\u0026gt; 在键盘输入方式系统从ibus改为fcitx，然后重启。\ndconf修改配置 也可以通过系统自带的dconf命令修改．\n$ sudo apt-get install dconf-editor gedit打开txt文件乱码\n# org-\u0026gt;gnome-\u0026gt;gedit-\u0026gt;preferences-\u0026gt;encodings-\u0026gt;auto-detected 添加'GB2312','GBK',... 开启远程桌面无密码登陆\n$ dconf write /org/gnome/desktop/remote-access/require-encryption false or # org-\u0026gt;gnome-\u0026gt;desktop-\u0026gt;remote-access-\u0026gt;require-encryption false 挂载U盘失败 移动硬盘或者u盘不能挂载，删掉/etc/fstab的关于sdb的行，保存后重新插拔。\n创建桌面图标（比如eclipse） cd /usr/share/applications sudo vi XXX.desktop 添加必要属性后拖到桌面或启动栏即可。\n安装QQ sudo apt-get install libgtk2.0-0:i386 sudo apt-get install lib32ncurses5 sudo apt-get install -f sudo dpkg -i fonts-wqy-microhei_0.2.0-beta-2_all.deb sudo dpkg -i ttf-wqy-microhei_0.2.0-beta-2_all.deb sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb 安装文档的包 手册位于/usr/share/man\nsudo apt-get install glibc-doc manpages-dev manpages-posix-dev manpages-zh 记录终端操作 安装相关工具:\n$sudo apt-get install ttyrec $sudo apt-get install imagemagick $hg clone https://bitbucket.org/antocuni/tty2gif 开始记录:\n$ttyrec 在终端播放记录文件ttyrecord:\n$ttyplay ttyrecord 将ttyrecord文件转化成gif文件:\n$tty2gif.py typing ttyrecord 将多个gif文件合并成一个文件:\n$convert -limit memory 2mb -limit map 2mb -delay 2 -loop 0 *.gif example.gif 添加用户为管理员 $ vim /etc/sudoers user ALL = (ALL:ALL) ALL Ubuntu网络设置 查看dns：\n$ systemd-resolve --status ubuntu修改hostname:\n$ sudo vim /etc/hostname new-hostname $ sudo vim /etc/hosts ip-address hostname $ sudo reboot 设置系统代理:\n$ vim /etc/profile.d/sys_proxy.sh http_proxy=\u0026quot;http://proxy-server:port\u0026quot; https_proxy=\u0026quot;http://proxy-server:port\u0026quot; ftp_proxy=\u0026quot;http://proxy-server:port\u0026quot; no_proxy=localhost,127.0.0.1,... export http_proxy ftp_proxy https_proxy no_proxy 设置静态IP:\n$ ifconfig # 查看网卡，ubuntu14.04 eth0, ubuntu16.04 ens160 $ vim /etc/network/interfaces auto eth0 iface eth0 inet static address 192.168.0.1 netmask 255.255.255.0 gateway 192.168.0.0 dns-nameservers 8.8.8.8 $ sudo service networking restart ubuntu18:\nnetplan: $ sudo vim /etc/netplan/*.yaml network: version: 2 renderer: networkd ethernets: ens160: dhcp4: no addresses: [192.168.1.0/23] gateway4: 193.168.0.1 nameservers: addresses: [8.8.8.8] $ sudo netplan apply ubuntu vlan vlan需要内核模块8021q\n$ echo \u0026quot;8021q\u0026quot; \u0026gt;\u0026gt; /etc/modules auto vlan1023 iface vlan1023 inet static address 18.28.4.123 netmask 255.255.255.0 gateway 18.28.4.1 vlan-raw-device eth0 创建vlan\n// 创建vlan(eth0.10), attach到interface(eth0) auto eth0.10 iface eth0.10 inet manual vlan-raw-device eth0 ubuntu bridge # 需要绑定到interface才需要配置interface. auto eth0 iface eth0 inet manual auto br0 iface br0 inet dhcp # For static configuration delete or comment out the above line and uncomment the following: # iface br0 inet static # address 192.168.1.10 # netmask 255.255.255.0 # gateway 192.168.1.1 # dns-nameservers 192.168.1.5 # dns-search example.com bridge_ports eth0 # 不绑定到interface就是none # bridge_ports none bridge_stp off bridge_fd 0 bridge_maxwait 0 创建bridge\n// 创建bridge，attach到vlan. auto br0 iface br0 inet static address 172.16.0.4 netmask 255.255.240.0 bridge_ports eth0.10 bridge_stp off bridge_fd 0 bridge_vlan_aware yes E: Sub-process /usr/bin/dpkg returned an error code (1) method1:\n$ sudo mkdir -p /var/lib/dpkg/info/package $ sudo mv /var/lib/dpkg/info/package.* /var/lib/dpkg/info/package method2:\n$ sudo apt-get purge package $ sudo apt-get install package ubuntu安装配置python3.7 ubuntu16.04自带python3.5, ubuntu18.04自带python3.6.\n测试: ubuntu16.04/18.04安装python3.7\n$ sudo apt-get install software-properties-common $ sudo add-apt-repository ppa:deadsnakes/ppa $ sudo apt-get update $ sudo apt-get install python3.7 python3.7-gdbm python3.7-dev $ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.7 1 $ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1 $ sudo update-alternatives --config python $ sudo update-alternatives --config python3 $ sudo apt-get purge python-pip python3-pip $ sudo rm -rf /usr/bin/pip* /usr/local/bin/pip* /usr/lib/python3*/dist-packages/pip /usr/local/lib/python3.*/dist-packages/pip $ sudo apt-get install python3-pip $ sudo pip3 install -U pip // ubuntu16.04通过apt-get安装的c-binding包默认还是到python3.5. // ubuntu18.04 是到python3.6. #!/usr/bin/env bash for PKG in `find /usr/lib/python3/dist-packages -name \u0026quot;*.so\u0026quot;` do DIR=`dirname ${PKG}` OLD=`basename ${PKG}` NEW=`echo ${OLD} | sed 's/35m/37m/g'` cp -f ${PKG} ${DIR}/${NEW} done Centos/Fedora/Redhat安装后的基本配置 $ sudo yum -y install epel-release kernel-devel gcc gcc-c++ Centos网络配置 安装mini版本之后配置网络：\n$ vi /etc/sysconfig/network-scripts/ifcfg-enxxx ONBOOT=no -\u0026gt; yes # service network restart $ sudo yum install net-tools $ ifconfig 设置静态IP:\n$ vim /etc/sysconfig/network-scripts/ifcfg-enxxx ONBOOT=yes BOOTPROTO=static # dhcp(自动获取), static(固定IP), node(手动设置) PREFIX=\u0026quot;21\u0026quot; IPADDR=\u0026quot;192.168.0.1\u0026quot; NETMASK=\u0026quot;255.255.255.0\u0026quot; GATEWAY=\u0026quot;192.168.0.0\u0026quot; DNS1=\u0026quot;192.168.0.0\u0026quot; $ sudo nmcli c reload 设置可以同时访问外网和本地连接的方法：\n# 网卡１用于外网连接 # settings -\u0026gt; network -\u0026gt; network card1 -\u0026gt; NAT $ cat /etc/sysconfig/network-scripts/ifcfg-en01 BOOTPROTO=dhcp # 自动获取ip ONBOOT=yes UUID # 通过$ nmcli con show 命令查看 HWADDR # 通过 $ ip addr 命令查看, 这个可以不设置 # 网卡２用于本地局域网 setting -\u0026gt; network-\u0026gt; network card2 -\u0026gt; host-only # cp /etc/sysconfig/network-scripts/ifcfg-en01 /etc/sysconfig/network-scripts/ifcfg-en02 $ vim /etc/sysconfig/network-scripts/ifcfg-en02 NAME DEVICE BOOTPROTO=static ONBOOT=yes UUID HWADDR IPADDR=192.168.56.102 $ sudo service network restart 修改hostname,局域网可以根据hostname相互访问：\n$ sudo vim /etc/sysconfig/network NETWORKING=yes HOSTNAME=new-hostname $ sudo vim /etc/hostname new-hostname $ sudo vim /etc/hosts ip-address hostname $ sudo reboot centos安装增强功能 $ sudo mkdir -p /media/cdrom $ sudo mount /dev/cdrom /media/cdrom $ cd /media/cdrom $ sudo ./VBoxLinuxAdditions.run --nox11 ",
    "categories": ["Linux"],
    "tags": ["admin"]
  },
  {
    "title": "Agile",
    "permalink": "https://canuxcheng.com/post/devops_agile/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"agile-methodologies\"\u003eAgile methodologies\u003c/h1\u003e\n\u003cp\u003eAgile的具体方法有Scrum, XP和kanban.\u003c/p\u003e\n\u003cp\u003eThoughtWorks公司的Martin Fowler提出的敏捷方法．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"scrum\"\u003eScrum\u003c/h1\u003e\n\u003cp\u003eScrum方法由Ken Schwaber和Jeff Sutherland 提出.\u003c/p\u003e\n\u003cp\u003escrum是一个用于开发和维护复杂产品的框架，是一个增量的，迭代的开发过程．\u003c/p\u003e\n\u003cp\u003esprint: 一个短的迭代周期．一般２到４周．\u003c/p\u003e\n\u003cp\u003ebacklog: 按商业价值排序的需求列表．\u003c/p\u003e\n\u003ch2 id=\"scrum框架的三个角色\"\u003escrum框架的三个角色\u003c/h2\u003e\n\u003cp\u003eproduct owner: 产品负责人\u003c/p\u003e\n\u003cp\u003escrum master: 敏捷教练和领导者\u003c/p\u003e\n\u003cp\u003escrum team：developer\u003c/p\u003e\n\u003ch2 id=\"scrum框架的三个工件\"\u003escrum框架的三个工件\u003c/h2\u003e\n\u003cp\u003eProduct backlog: 整个产品待开发需求列表\u003c/p\u003e\n\u003cp\u003esprint backlog: 一次迭代的待开发需求列表\u003c/p\u003e\n\u003cp\u003eincrement: 产品增量\u003c/p\u003e\n\u003ch2 id=\"scrum框架的五个事件\"\u003escrum框架的五个事件\u003c/h2\u003e\n\u003cp\u003esprint planning meeting: sprint计划会议\u003c/p\u003e\n\u003cp\u003eDaily Scrum Meeting/DSM: 每日站立会议\u003c/p\u003e\n\u003cp\u003esprint review meeting: sprint评审会议\u003c/p\u003e\n\u003cp\u003esprint retrospective meeting: sprint回顾会议\u003c/p\u003e\n\u003cp\u003eproduct backlog refinement: 产品backlog梳理会议\u003c/p\u003e\n\u003ch2 id=\"scrum框架的五个价值观\"\u003escrum框架的五个价值观\u003c/h2\u003e\n\u003cp\u003e承诺\u003c/p\u003e\n\u003cp\u003e专注\u003c/p\u003e\n\u003cp\u003e开放\u003c/p\u003e\n\u003cp\u003e尊重\u003c/p\u003e\n\u003cp\u003e勇气\u003c/p\u003e\n\u003ch2 id=\"scrum框架的四大支柱\"\u003escrum框架的四大支柱\u003c/h2\u003e\n\u003cp\u003e迭代开发\u003c/p\u003e\n\u003cp\u003e增量交付\u003c/p\u003e\n\u003cp\u003e自组织团队\u003c/p\u003e\n\u003cp\u003e高优先级的需求驱动\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"xp\"\u003eXP\u003c/h1\u003e\n\u003cp\u003eExtreme Programming\u003c/p\u003e",
    "content": "Agile methodologies Agile的具体方法有Scrum, XP和kanban.\nThoughtWorks公司的Martin Fowler提出的敏捷方法．\nScrum Scrum方法由Ken Schwaber和Jeff Sutherland 提出.\nscrum是一个用于开发和维护复杂产品的框架，是一个增量的，迭代的开发过程．\nsprint: 一个短的迭代周期．一般２到４周．\nbacklog: 按商业价值排序的需求列表．\nscrum框架的三个角色 product owner: 产品负责人\nscrum master: 敏捷教练和领导者\nscrum team：developer\nscrum框架的三个工件 Product backlog: 整个产品待开发需求列表\nsprint backlog: 一次迭代的待开发需求列表\nincrement: 产品增量\nscrum框架的五个事件 sprint planning meeting: sprint计划会议\nDaily Scrum Meeting/DSM: 每日站立会议\nsprint review meeting: sprint评审会议\nsprint retrospective meeting: sprint回顾会议\nproduct backlog refinement: 产品backlog梳理会议\nscrum框架的五个价值观 承诺\n专注\n开放\n尊重\n勇气\nscrum框架的四大支柱 迭代开发\n增量交付\n自组织团队\n高优先级的需求驱动\nXP Extreme Programming\n",
    "categories": ["DevOps"],
    "tags": ["agile"]
  },
  {
    "title": "Ansible",
    "permalink": "https://canuxcheng.com/post/devops_ansible/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"ansible\"\u003eAnsible\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ansible/ansible\"\u003ehttps://github.com/ansible/ansible\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.ansible.com.cn/index.html\"\u003ehttp://www.ansible.com.cn/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eansible通过SSH来远程管理Linux/Unix机器．\u003c/p\u003e\n\u003cp\u003eansible通过winrm+powershell来远程管理Windows机器．\u003c/p\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo pip install ansible\n$ sudo apt-get install ansible\n$ sudo yum install ansible\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置：\u003c/p\u003e\n\u003cp\u003e参考Network-SSH实现从controller到所有node的无密码登陆\u003c/p\u003e\n\u003cp\u003e配置文件执行顺序:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eANSIBLE_CONFIG\nansible.cfg\n.ansible.cfg\n/etc/ansible/ansible.cfg\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e手动配置:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo vim /etc/ansible/ansible.cfg\n[defaults]\nask_pass = False\nhost_key_checking = False\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"ansible命令\"\u003eansible命令\u003c/h1\u003e\n\u003cp\u003eansible运行命令的两种方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAd-hoc相当于直接运行shell命令\u003c/li\u003e\n\u003cli\u003eplaybooks相当于运行shell脚本\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eansible:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ansible -i inventory group1:group1:group3/all ...\n\n$ansible --help\n-m MODULE_NAME, --module-name=MODULE_NAME # 执行模块，默认是command\n-M MODULE_PATH, --module-path=MODULE_PATH # 指定模块的路径\n-a MODULE_ARGS, --args=MODULE_ARGS # 模块的参数\n-i INVENTORY, --inventory INVENTORY # 默认/etc/ansible/hosts, 需要指定hosts分组\n-f FORKS, --forks=FORKS # 指定并发进程的数量\n-C, --check\n-D, --diff\n-l SUBSET, --limit=SUBSET\n--syntax-check\n--list-hosts\n-v, --verbose # -v, -vvv, -vvvv\n\n# 提权选项\n-b, --become\n--become-method=BECOME_METHOD # sudo(default)/su/pbrun/pfexec/runas/doas\n--become-user=BECOME_USER # root(default)\n-K, --ask-become-pass\n\n# 连接选项\n-u REMOTE_USER\n--ssh-common-args\n--ssh-extra-args\n-T TIMEOUT # default 10s\n-K, --ask-pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"inventory\"\u003einventory\u003c/h1\u003e\n\u003cp\u003einventory包括主机和分组,以及主机变量和分组变量.\u003c/p\u003e",
    "content": "Ansible https://github.com/ansible/ansible\nhttp://www.ansible.com.cn/index.html\nansible通过SSH来远程管理Linux/Unix机器．\nansible通过winrm+powershell来远程管理Windows机器．\n安装:\n$ sudo pip install ansible $ sudo apt-get install ansible $ sudo yum install ansible 配置：\n参考Network-SSH实现从controller到所有node的无密码登陆\n配置文件执行顺序:\nANSIBLE_CONFIG ansible.cfg .ansible.cfg /etc/ansible/ansible.cfg 手动配置:\n$ sudo vim /etc/ansible/ansible.cfg [defaults] ask_pass = False host_key_checking = False ansible命令 ansible运行命令的两种方式：\nAd-hoc相当于直接运行shell命令 playbooks相当于运行shell脚本 ansible:\n$ ansible -i inventory group1:group1:group3/all ... $ansible --help -m MODULE_NAME, --module-name=MODULE_NAME # 执行模块，默认是command -M MODULE_PATH, --module-path=MODULE_PATH # 指定模块的路径 -a MODULE_ARGS, --args=MODULE_ARGS # 模块的参数 -i INVENTORY, --inventory INVENTORY # 默认/etc/ansible/hosts, 需要指定hosts分组 -f FORKS, --forks=FORKS # 指定并发进程的数量 -C, --check -D, --diff -l SUBSET, --limit=SUBSET --syntax-check --list-hosts -v, --verbose # -v, -vvv, -vvvv # 提权选项 -b, --become --become-method=BECOME_METHOD # sudo(default)/su/pbrun/pfexec/runas/doas --become-user=BECOME_USER # root(default) -K, --ask-become-pass # 连接选项 -u REMOTE_USER --ssh-common-args --ssh-extra-args -T TIMEOUT # default 10s -K, --ask-pass inventory inventory包括主机和分组,以及主机变量和分组变量.\n可以是ini格式，也可以是yaml格式.\n$ sudo vim /etc/ansible/hosts ini格式:\n定义主机和主机变量 [host1] node1 ansible_connection=ssh ansible_host=host ansible_port=port ansible_user=user ansible_ssh_pass=password 定义分组和分组变量 [group1] node1 node2 [group1:vars] ansible_connection=local/smart/ssh/paramiko ansible_host= ansible_port= ansible_user= ansible_ssh_pass= ansible_ssh_common_args= ansible_ssh_extra_args= ansible_become= ansible_become_method= ansible_become_user= ansible_become_pass= ansible_become_exe= ansible_become_flags= 定义分组的分组, children是固定写法 [big-group:children] group1 group2 yaml:\nall: hosts: # 定义主机和主机变量 node1: ansible_host: ip: access_ip: children: # 定义分组和分组变量 group1: hosts: node1: vars: key: value group2: hosts: node2: vars: key: value big-group: # 定义分组的分组 children: group1: hosts: node1: group2: hosts: node2: module module也就是所说的task plugins/library plugins.\n$ ansible-doc -l/--list #　查看所有已经安装的模块 commands modules：\ncommand # 默认模块，用于在远程机器上执行命令 shell # 和command相同，只是该模块支持管道和特殊字符，一般用来执行脚本和复杂命令 raw expect script telnet files modules:\ncopy src dest mode ... synchronize src dest ... package modules:\napt name/deb state=present/absent/latest/build-dep update_cache autoclean autoremove apt_repository repo state=present/absent apt_rpm pkg state=present/absent yum name state=present/absent/latest/installed/removed adhoc $ ansible group -m \u0026lt;module\u0026gt; -a \u0026lt;args\u0026gt; ... copy:\n$ ansible group -m copy -a \u0026quot;src=/sr dest=/dest mode=0655\u0026quot; playbooks playbook的格式是YAML.\n$ ansible-playbook -i inventory playbook.yaml -K -vvv \u0026gt; output.txt -i INVENTORY, --inventory INVENTORY # 默认/etc/ansible/hosts, 在playbook中指定hosts分组，而不是命令行 - hosts: host-or-group remote_user: user task: - name: task name. module: args variables:\nregister: var # 用var来存储task的结果,查看不同模块的返回值． become:\nbecome: true become_user: root become_method: sudo become_flags: debug:\nstrategy: debug awx ansible的web管理界面.\nhttps://github.com/ansible/awx\n",
    "categories": ["DevOps"],
    "tags": ["ansible"]
  },
  {
    "title": "Terraform",
    "permalink": "https://canuxcheng.com/post/cloud_terraform/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"terraform\"\u003eTerraform\u003c/h1\u003e\n\u003cp\u003einstall:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.hashicorp.com/tutorials/terraform/install-cli\"\u003ehttps://learn.hashicorp.com/tutorials/terraform/install-cli\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"cli\"\u003eCLI\u003c/h2\u003e\n\u003cp\u003e操作工作目录\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 初始化目录，会根据配置下载和安装provider.\nterraform init\n\nterraform get\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e操作tf文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 格式化文件\nterraform fmt -recursive\n\n// 验证文件\nterraform validate \n\n// 可以通过终端验证函数.\nterraform console\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e操作基础设施:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eterraform plan\nterraform plan -out test.tfplan\n\nterraform apply -auto-approve\nterraform apply test.tfplan\n\nterraform destroy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e检查基础设施:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eterraform show\nterraform graph\nterraform output\nterraform state list/show\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e认证:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eterraform login\nterraform logout\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2 id=\"tf\"\u003eTF\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.terraform.io/language\"\u003ehttps://www.terraform.io/language\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e注释:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# comment \n// comment\n/* comment */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"backend-and-state\"\u003ebackend and state\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.terraform.io/language/settings/backends\"\u003ehttps://www.terraform.io/language/settings/backends\u003c/a\u003e\u003c/p\u003e",
    "content": "Terraform install:\nhttps://learn.hashicorp.com/tutorials/terraform/install-cli\nCLI 操作工作目录\n// 初始化目录，会根据配置下载和安装provider. terraform init terraform get 操作tf文件\n// 格式化文件 terraform fmt -recursive // 验证文件 terraform validate // 可以通过终端验证函数. terraform console 操作基础设施:\nterraform plan terraform plan -out test.tfplan terraform apply -auto-approve terraform apply test.tfplan terraform destroy 检查基础设施:\nterraform show terraform graph terraform output terraform state list/show 认证:\nterraform login terraform logout TF https://www.terraform.io/language\n注释:\n# comment // comment /* comment */ backend and state https://www.terraform.io/language/settings/backends\nhttps://www.terraform.io/language/state\nprovider data sources data source: 获取服务的参数\nmodule 管理provider上的模块/服务.定义了input, resource/data source, output的就可以认为是module.\nmeta-arguments providers depends_on count for_each resources resources: 创建服务的参数\nmeta-arguments depends_on count for_each provider lifecycle provisioner 特殊的resource，可以在本地或远程机器做一些准备工作。\nVariable https://www.terraform.io/language/values/variables\ninput variable: 输入变量\nlocal variable: 本地变量\noutput variable: 输出参数\n子模块无法引用父模块的local变量， resource属性，input变量。但是可以通过output参数引用。\n父模块无法引用子模块的local变量，resource属性。但是可以通过output参数引用，而且父模块可以通过input变量传值给子模块。\n表达式 函数 workspace 多环境构建（development, UAT, production).\nterraform workspace new dev terraform workspace list terraform select \u0026lt;name\u0026gt; 使用terraform.workspace作为参数.\n",
    "categories": ["Cloud","DevOps"],
    "tags": ["terraform"]
  },
  {
    "title": "Vault",
    "permalink": "https://canuxcheng.com/post/devops_vault/",
    "date": "2016-04-15",
    "summary": "\u003ch1 id=\"vault\"\u003eVault\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/hashicorp/vault\"\u003ehttps://github.com/hashicorp/vault\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eInstall:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.hashicorp.com/tutorials/vault/getting-started-install\"\u003ehttps://learn.hashicorp.com/tutorials/vault/getting-started-install\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"cli\"\u003eCLI\u003c/h1\u003e\n\u003cp\u003e可以通过环境变量或者命令行参数指定server:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-address VAULT_ADDR\n-namespace VAULT_NAMESPACE\nvault [subcommand] -address=\u0026quot;https://server:8200\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eserver:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 启动vault\n$ vault server -config=/etc/vault/config.hcl\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eagent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vault agent\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elogin:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 跟据token登陆.\n$ vault login\n\n$vault login -token-only -method=oidc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eoperator:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// init生成keys和token.\n$ vault operator init\n\n// 通过keys  unseal\n$ vault operator unseal\n\n// 通过token seal\n$ vault operator seal\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eauth:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 查看auth\n$ vault auth list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esecrets\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 查看secrets engine\n$ vault secrets list\n\n// enable kv\n$ vault secrets enable -path=\u0026lt;ns\u0026gt;/\u0026lt;name\u0026gt; kv\n$ vault secrets enable kv\n\n// disable kv\n$ vault secrets disable kv\n\n// 创建一个database engine\nvault secrets enable -path \u0026lt;ns\u0026gt;/mysql database\n// 创建rabbitmq engine\nvault secrets enable -path \u0026lt;ns\u0026gt;/rabbitmq rabbitmq\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epolicy\u003c/p\u003e",
    "content": "Vault https://github.com/hashicorp/vault\nInstall:\nhttps://learn.hashicorp.com/tutorials/vault/getting-started-install\nCLI 可以通过环境变量或者命令行参数指定server:\n-address VAULT_ADDR -namespace VAULT_NAMESPACE vault [subcommand] -address=\u0026quot;https://server:8200\u0026quot; server:\n// 启动vault $ vault server -config=/etc/vault/config.hcl agent:\n$ vault agent login:\n// 跟据token登陆. $ vault login $vault login -token-only -method=oidc operator:\n// init生成keys和token. $ vault operator init // 通过keys unseal $ vault operator unseal // 通过token seal $ vault operator seal auth:\n// 查看auth $ vault auth list secrets\n// 查看secrets engine $ vault secrets list // enable kv $ vault secrets enable -path=\u0026lt;ns\u0026gt;/\u0026lt;name\u0026gt; kv $ vault secrets enable kv // disable kv $ vault secrets disable kv // 创建一个database engine vault secrets enable -path \u0026lt;ns\u0026gt;/mysql database // 创建rabbitmq engine vault secrets enable -path \u0026lt;ns\u0026gt;/rabbitmq rabbitmq policy\n// 查看policy $ vault policy list // 创建policy $ vault policy write \u0026lt;my-policy\u0026gt; ./my-policy.hcl plugin:\n$ vault plugin list database read/write/delete/list:\n$ vault read $ vault write $ vault write my-secret/my-app my-field=value $ vault delete $ vault list API https://www.vaultproject.io/api-docs\n$ curl --header \u0026quot;X-Vault-Token: TOKEN\u0026quot; https://FQDN/v1/\u0026lt;engine-path\u0026gt;/data/\u0026lt;secret-path\u0026gt; $ curl --header \u0026quot;X-Vault-Token: TOKEN\u0026quot; https://FQDN/v1/\u0026lt;engine-path\u0026gt;/data/\u0026lt;secret-path\u0026gt;?version=\u0026lt;version\u0026gt; auth methods https://www.vaultproject.io/docs/auth\nsecrets engine https://www.vaultproject.io/docs/secrets\nvault PKI 通过pki engine来生成和管理证书。\nhttps://learn.hashicorp.com/tutorials/vault/pki-engine\ngenerate:\nvault write -format=json -namespace=\u0026lt;ns\u0026gt; \u0026lt;pki_root\u0026gt;/issue/\u0026lt;role\u0026gt; \\ common_name=\u0026quot;canuxcheng.com\u0026quot; \\ alt_names=\u0026quot;canuxcheng.com,*.canuxcheng.com\u0026quot; \\ ttl=8760h \\ format=pem/der/pem_bundle \\ | tee \\ \u0026gt;(jq -r '.data.certificate' \u0026gt; canuxcheng.crt) \\ \u0026gt;(jq -r '.data.private_key' \u0026gt; private.key) list:\nvault list -namespace=\u0026lt;ns\u0026gt; \u0026lt;pki_root\u0026gt;/certs verify:\nvault read -namespace=iac-phoenix/test it/pki/cert/\u0026lt;sn\u0026gt; curl -s https://vault.canux.com/v1/\u0026lt;ns\u0026gt;/\u0026lt;pki_root\u0026gt;/cert/\u0026lt;serial-num\u0026gt; | jq -r '.data.certificate' | openssl x509 -in - -noout -text revoke:\nvault write \u0026lt;ns\u0026gt;/\u0026lt;pki_root\u0026gt;/revoke serial_number=\u0026quot;******\u0026quot; remove expired ca:\nvault write \u0026lt;pki_root\u0026gt;/tidy tidy_cert_store=true tidy_revoked_certs=true vault + k8s vault提供两种方式在k8s中使用secret.\nVault Sidecar Agent Injector https://www.vaultproject.io/docs/platform/k8s/injector\nhttps://github.com/hashicorp/vault-k8s\nmutating webhook of Bank-Vaults https://banzaicloud.com/docs/bank-vaults/mutating-webhook/\nhttps://github.com/banzaicloud/bank-vaults\nhttps://banzaicloud.com/blog/inject-secrets-into-pods-vault-revisited/\nVault CSI Provider https://www.vaultproject.io/docs/platform/k8s/csi\nhttps://github.com/kubernetes-sigs/secrets-store-csi-driver\n",
    "categories": ["DevOps","Security"],
    "tags": ["vault"]
  },
  {
    "title": "PSL_Test",
    "permalink": "https://canuxcheng.com/post/psl_test/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"development-tools\"\u003eDevelopment Tools\u003c/h1\u003e\n\u003ch2 id=\"typing\"\u003etyping\u003c/h2\u003e\n\u003ch2 id=\"2to3\"\u003e2to3\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$2to3\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"pydoc\"\u003epydoc\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport pydoc\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"test\"\u003etest\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eimport test\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"doctest\"\u003edoctest\u003c/h2\u003e\n\u003cp\u003epython内置的文档测试库．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport doctest\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"unittest\"\u003eunittest\u003c/h2\u003e\n\u003cp\u003epython内置的单元测试库．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport unittest\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"tpl\"\u003eTPL\u003c/h1\u003e\n\u003cp\u003e相关的第三方库\u003c/p\u003e\n\u003ch2 id=\"unittest2\"\u003eunittest2\u003c/h2\u003e\n\u003cp\u003eunittest2是unittest的升级版．\u003c/p\u003e\n\u003cp\u003epython3集成了unittest2到unittest,像使用unittest一样使用即可．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# python2.7\n$pip install unittest2\nimport unittest2\n\n# python3\nimport unittest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eunittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．\u003c/p\u003e\n\u003cp\u003e测试结果：\u003c/p\u003e\n\u003cp\u003eOK 表示测试通过\u003c/p\u003e\n\u003cp\u003eFAIL 表示测试没有通过，并引发一个AssertionError异常．\u003c/p\u003e\n\u003cp\u003eERROR 表示测试过程引发一个不是AssertionError的异常．\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Python2.7 此处用的是标准库的unittest.\nimport unittest\nimport MyClass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclasses:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eunittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．\nunittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.\nunittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.\nunittest.TestResult: 用来保存测试的结果．\n\nunittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．\nfixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．\n\nunittest.TextTestRunner: 用来执行测试用例．\nunittest.TextTestResult: 用来打印格式化的测试结果．\n\n# unittest.TestCase\n# methods:\nassertXXX　系列方法．\nfailXXX 系列方法\nfail(self, msg=None) # test立即失败\naddCleanup(self, function, *args, **kwargs)\naddTypeEqualityFunc(self, typeobj, function)\ncountTestCases(self)\ndebug(self)\ndefaultTestResult() # return unittest.TestResult()\ndoCleanups(self)\nid(self)\nrun(self, result=None) # 可以在子类覆盖该方法．\nshortDescription(self)\nskipTest(self, reason)\nsetUp(self) # 重写之后，每个case运行之前都会调用一次．\ntearDown(self) # 同上\n\n# classmethods:\nsetUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．\ntearDownClass(cls) # 同上\n\n# data:\nfailureException = AssertionError\nlongMessage = False\nmaxDiff = 640\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efunctions:\u003c/p\u003e",
    "content": "Development Tools typing 2to3 $2to3 pydoc import pydoc test import test doctest python内置的文档测试库．\nimport doctest unittest python内置的单元测试库．\nimport unittest TPL 相关的第三方库\nunittest2 unittest2是unittest的升级版．\npython3集成了unittest2到unittest,像使用unittest一样使用即可．\n# python2.7 $pip install unittest2 import unittest2 # python3 import unittest unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．\n测试结果：\nOK 表示测试通过\nFAIL 表示测试没有通过，并引发一个AssertionError异常．\nERROR 表示测试过程引发一个不是AssertionError的异常．\n# Python2.7 此处用的是标准库的unittest. import unittest import MyClass classes:\nunittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试． unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite. unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite. unittest.TestResult: 用来保存测试的结果． unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行． fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法． unittest.TextTestRunner: 用来执行测试用例． unittest.TextTestResult: 用来打印格式化的测试结果． # unittest.TestCase # methods: assertXXX　系列方法． failXXX 系列方法 fail(self, msg=None) # test立即失败 addCleanup(self, function, *args, **kwargs) addTypeEqualityFunc(self, typeobj, function) countTestCases(self) debug(self) defaultTestResult() # return unittest.TestResult() doCleanups(self) id(self) run(self, result=None) # 可以在子类覆盖该方法． shortDescription(self) skipTest(self, reason) setUp(self) # 重写之后，每个case运行之前都会调用一次． tearDown(self) # 同上 # classmethods: setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用． tearDownClass(cls) # 同上 # data: failureException = AssertionError longMessage = False maxDiff = 640 functions:\nfindTestCases(module, prefix='test', sortUsing=\u0026lt;built-in function cmp\u0026gt;, suiteClass=\u0026lt;class 'unittest.suite.TestSuite'\u0026gt;) getTestCaseNames(testCaseClass, prefix, sortUsing=\u0026lt;built-in function cmp\u0026gt;) installHandler() makeSuite(testCaseClass, prefix='test', sortUsing=\u0026lt;built-in function cmp\u0026gt;, suiteClass=\u0026lt;class 'unittest.suite.TestSuite'\u0026gt;) registerResult(result) removeHandler(method=None) removeResult(result) # unittest.case实现了几个函数用来增强unittest.TestCase的方法, 一般当装饰器用． expectedFailure(func) # 如果这个case失败了，不计入失败的数目． # @unittest.expectedFailure skip(reason) # 无条件跳过一个test case. skipIf(condition, reason) # condition为true就跳过一个test case. skipUnless(condition, reason) # 和上面相反 examples:\nclass MyClassTestCase(unittest.TestCase): @classmethod def setUpClass(cls): print 'Just execute before the first test case start.' @classmethod def tearDownClass(cls): print 'Just execute after all test case end.' def setUp(self): \u0026quot;\u0026quot;\u0026quot;重载setUp进行测试之前的初始化工作.运行每个test_func之前都会运行该方法\u0026quot;\u0026quot;\u0026quot; print \u0026quot;start\u0026quot; def tearDown(self): \u0026quot;\u0026quot;\u0026quot;重载tearDown进行测试结束后的清理工作.结束运行每个test_func之后都会运行该方法\u0026quot;\u0026quot;\u0026quot; print \u0026quot;end\u0026quot; def test_func(self): \u0026quot;\u0026quot;\u0026quot;具体的测试用例，需要用test开头,多个test_func会根据func名字中的数字或字母的顺序来执行，和位置无关. 不是用test开头的方法默认不会被执行\u0026quot;\u0026quot;\u0026quot; self.assertEqual(MyClass.method(args), value, \u0026quot;message\u0026quot;) if __name__ == \u0026quot;__main__\u0026quot;: unittest.main() # 自动发现和批量执行testcase/testsuite: def discover_test_case(): test_cases = [] _module = ... tests.append(unittest.defaultTestLoader.loadTestsFromModule(_module)) unittest.defaultTestLoader.discover() return tests def get_test_suite(): \u0026quot;\u0026quot;\u0026quot;打包一个testsuite.\u0026quot;\u0026quot;\u0026quot; return unittest.TestSuite(discover_test_case()) unittest.TextTestRunner if __name__ == \u0026quot;__main__\u0026quot;: runner = unittest.TextTestRunner() result = runner.run(get_test_suite()) mock https://github.com/testing-cabal/mock\npython3集成了mock到unittest模块，导入unittest.mock即可．\n# Python2.7 $pip install mock import mock # Python3 import unittest.mock mock就是在测试中对于不容易构造或获取的对象，用一个虚拟的对象来代替以便测试的方法．\n# Python2.7 此处用的是第三方库mock from mock import Mock, patch, PropertyMock, MagicMock nose2 https://github.com/nose-devs/nose2\nnose是unittest/unittest2的升级版．\nnose2是nose的升级版．\nnose2用于单元测试．\n$ pip install nose import nose pytest https://github.com/pytest-dev/pytest/\npytest用于单元测试．推荐使用．\n$ pip install -U pytest import pytest coverage 分析单元测试的代码覆盖率\nhttps://github.com/nedbat/coveragepy\n$ pip install coverage # 通过命令进行测试，可以集成到其它工具． $ coverage run --source=\u0026lt;package-name\u0026gt; setup.py test tox virtualenv management and test command line tool.\nhttps://github.com/tox-dev/tox\n$ pip install tox # 通过命令进行测试，可以集成unittest, nose2, pytest等工具． $ tox ",
    "categories": ["Python"],
    "tags": ["test"]
  },
  {
    "title": "DevOps",
    "permalink": "https://canuxcheng.com/post/c_devops/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"ide\"\u003eIDE\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eVisual Studio\u003c/li\u003e\n\u003cli\u003eVSCode\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"compilers\"\u003eCompilers\u003c/h2\u003e\n\u003cp\u003e编译器组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efrontend\u003c/li\u003e\n\u003cli\u003eoptimizer\u003c/li\u003e\n\u003cli\u003ebackend\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://zh.cppreference.com/w/cpp/compiler_support\"\u003ehttps://zh.cppreference.com/w/cpp/compiler_support\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ewindows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ellvm clang\u003c/li\u003e\n\u003cli\u003eMingw\u003c/li\u003e\n\u003cli\u003eMsvc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003elinux:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ellvm clang\u003c/li\u003e\n\u003cli\u003egcc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emac:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ellvm clang\u003c/li\u003e\n\u003cli\u003egcc\u003c/li\u003e\n\u003cli\u003eapple clang\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gcc\"\u003egcc\u003c/h3\u003e\n\u003cp\u003egnu gcc,g++\u003c/p\u003e\n\u003ch3 id=\"llvm-clang\"\u003ellvm clang\u003c/h3\u003e\n\u003cp\u003ellvm: low level virtual machine. (backend)\u003c/p\u003e\n\u003cp\u003eclang: c language.(frontend)\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"tools\"\u003etools\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCMake\u003c/li\u003e\n\u003cli\u003eMSBuild\u003c/li\u003e\n\u003cli\u003eMakefile\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"gcc-1\"\u003eGCC\u003c/h2\u003e\n\u003cp\u003e\u0026ldquo;-ansi\u0026rdquo;\u003c/p\u003e\n\u003cp\u003efor c: == -std=c90\nfor cpp: ==-std=c++98\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;-std\u0026rdquo;\u003c/p\u003e\n\u003cp\u003ec++17, gnu++17, gnu17,c17\ngnu2x: 下个ISO C标准。\nc2x:下个ISO C标准。\nc++2a: 下个ISO C++标准\ngnu+2a:下个ISO C++标准\u003c/p\u003e\n\u003cp\u003egcc8 开始支持c++20.\ngcc11开始支持c++23.\u003c/p\u003e\n\u003ch2 id=\"vscode\"\u003evscode\u003c/h2\u003e\n\u003cp\u003efor macOS:\u003c/p\u003e",
    "content": "IDE Visual Studio VSCode Compilers 编译器组成：\nfrontend optimizer backend https://zh.cppreference.com/w/cpp/compiler_support\nwindows:\nllvm clang Mingw Msvc linux:\nllvm clang gcc mac:\nllvm clang gcc apple clang gcc gnu gcc,g++\nllvm clang llvm: low level virtual machine. (backend)\nclang: c language.(frontend)\ntools CMake MSBuild Makefile GCC \u0026ldquo;-ansi\u0026rdquo;\nfor c: == -std=c90 for cpp: ==-std=c++98\n\u0026ldquo;-std\u0026rdquo;\nc++17, gnu++17, gnu17,c17 gnu2x: 下个ISO C标准。 c2x:下个ISO C标准。 c++2a: 下个ISO C++标准 gnu+2a:下个ISO C++标准\ngcc8 开始支持c++20. gcc11开始支持c++23.\nvscode for macOS:\nxcode-select --install extentions:\nc/c++ ",
    "categories": ["C"],
    "tags": ["devops"]
  },
  {
    "title": "Document",
    "permalink": "https://canuxcheng.com/post/c_document/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"document\"\u003eDocument\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"doxygen\"\u003eDoxygen\u003c/h1\u003e",
    "content": "Document Doxygen ",
    "categories": ["C"],
    "tags": ["document"]
  },
  {
    "title": "Hadoop",
    "permalink": "https://canuxcheng.com/post/hadoop/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"hadoop\"\u003eHadoop\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/apache/hadoop\"\u003ehttps://github.com/apache/hadoop\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eapache hadoop是一个框架，允许使用简单的编程模型在大量计算机上对大型数据集进行分布式处理．\u003c/p\u003e\n\u003cp\u003ehadoop1只有HDFS和MapReduce两个模块，hadoop2开始分为HDFS, YARN, MapReduce三个模块．\u003c/p\u003e\n\u003cp\u003ehadoop的版本:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eapache hadoop\u003c/li\u003e\n\u003cli\u003ehortonworks hadoop (HDP)\u003c/li\u003e\n\u003cli\u003ecloudera hadoop (CDH)\u003c/li\u003e\n\u003cli\u003emapr\u003c/li\u003e\n\u003cli\u003etranswarp\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"安装hadoop\"\u003e安装hadoop\u003c/h1\u003e\n\u003cp\u003ehadoop有三种安装模式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单节点模式\u003c/li\u003e\n\u003cli\u003e伪分布式模式\u003c/li\u003e\n\u003cli\u003e分布式模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e参考Linux Admin和Network SSH如何安装多台centos，并且配置局域网，让本地多台机器相互访问．\u003c/p\u003e\n\u003cp\u003e下载hadoop的二进制安装包，然后放到/home/hadoop/目录下并解压．\u003c/p\u003e\n\u003cp\u003e推荐的cluster node:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNameNode(hdfs)\nSecondary NameNode(hdfs)\nDataNode(hdfs)\nResourceManager server(yarn)\nNodeManager server(yarn)\nWebAppProxy server(yarn)\nMapReduceJobHistory server(mapreduce)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e设置环境变量：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vim ~/.bash_profile\nexport JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-.../jre\nexport HADOOP_HOME=/home/hadoop/hadoop-3.0.0-alpha2\nexport PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PATH\n$ source ~/.bash_profile\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改hadoop的环境变量：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd hadoop-3.0.0-alpha2/etc/hadoop\n$ vim hadoop-env.sh\nexport JAVA_HOME='/usr/lib/jvm/java-1.8.0-openjdk-.../jre\n\n# 测试java和hadoop的环境是否可用：\n$ hadoop\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e分布式环境搭建：\u003c/p\u003e",
    "content": "Hadoop https://github.com/apache/hadoop\napache hadoop是一个框架，允许使用简单的编程模型在大量计算机上对大型数据集进行分布式处理．\nhadoop1只有HDFS和MapReduce两个模块，hadoop2开始分为HDFS, YARN, MapReduce三个模块．\nhadoop的版本:\napache hadoop hortonworks hadoop (HDP) cloudera hadoop (CDH) mapr transwarp 安装hadoop hadoop有三种安装模式：\n单节点模式 伪分布式模式 分布式模式 参考Linux Admin和Network SSH如何安装多台centos，并且配置局域网，让本地多台机器相互访问．\n下载hadoop的二进制安装包，然后放到/home/hadoop/目录下并解压．\n推荐的cluster node:\nNameNode(hdfs) Secondary NameNode(hdfs) DataNode(hdfs) ResourceManager server(yarn) NodeManager server(yarn) WebAppProxy server(yarn) MapReduceJobHistory server(mapreduce) 设置环境变量：\n$ vim ~/.bash_profile export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-.../jre export HADOOP_HOME=/home/hadoop/hadoop-3.0.0-alpha2 export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PATH $ source ~/.bash_profile 修改hadoop的环境变量：\n$ cd hadoop-3.0.0-alpha2/etc/hadoop $ vim hadoop-env.sh export JAVA_HOME='/usr/lib/jvm/java-1.8.0-openjdk-.../jre # 测试java和hadoop的环境是否可用： $ hadoop 分布式环境搭建：\nhttp://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/ClusterSetup.html\n$ vim core-site.xml $ vim hdfs-site.xml # namenode, datanode $ vim yarn-site.xml # resourcemanager, nodemanager, webappproxy $ vim mapred-site.xml # mr application, mr jobhistory # slaves file $ vim workers namenode secondnamenode datanode datanode2 yarnserver mjhserver # hadoop rack awareness # logging $ vim log4j.properties CLI for hadoop cluster:\n启动一个hadoop　cluster需要同时启动hdfs和yarn, 推荐用单独的用户分别启动这两个组件．\n# 第一次启动hdfs，需要格式化hdfs $ hdfs namenode -format \u0026lt;cluster_name\u0026gt; # 启动hdfs namenode 和　datanode $ hdfs --daemon start namenode $ hdfs --daemon start datanode # 如果ssh已经实现无密码连接，可以一次启动cluster的所有node $ $HADOOP_HOME/sbin/start-dfs.sh # 启动yarn resourcemanager　和　nodemanager $ yarn --daemon start resourcemanager $ yarn --daemon start nodemanager # 如果配置了slaves file 并且cluster node实现ssh无密码登陆，可以一次启动 $ $HADOOP_HOME/sbin/start-yarn.sh # 启动webappproxy server $ yarn --daemon start proxyserver # 启动MapReduce Jobhistory server. $ mapred --daemon start historyserver # stop namenode $ hdfs --daemon stop namenode # stop datanode $ hdfs --daemon stop datanode # stop at the same time $ $HADOOP_HOME/sbin/stop-dfs.sh # stop resourcemanager $ yarn --daemon stop resourcemanager # stop nodemanager $ yarn --daemon stop nodemanager # stop at the same time $ $HADOOP_HOME/sbin/stop-yarn.sh # stop webappproxy server $ yarn stop proxyserver # stop jobhistory server $ mapred --daemon stop historyserver GUI for hadoop cluster:\n# namenode http://nn:9870 # resource manager http:rm:8080 # mapreduce job history server http://jhs:19888 Hadoop Commands hadoop [--config confdir] [--loglevel loglevel] [COMMAND] [GENERIC_OPTIONS] [COMMAND_OPTIONS] user command:\n$ hadoop archive $ hadoop fs ... admin command:\n$ hadoop daemonlog ... fs commands file system command:\n支持本地文件系统，hdfs文件系统，还有其它文件系统．\n$ hadoop fs $ hadoop fs -cat URI [URI ...] ... ",
    "categories": ["BigData"],
    "tags": ["hadoop"]
  },
  {
    "title": "Hadoop HDFS",
    "permalink": "https://canuxcheng.com/post/hadoop_hdfs/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"hdfs\"\u003eHDFS\u003c/h1\u003e\n\u003cp\u003eHadoop Distributed File System: hadoop分布式文件系统\u003c/p\u003e\n\u003cp\u003ehadoop hdfs分为三部分:\u003c/p\u003e\n\u003cp\u003eNameNode -\u0026gt; JobTracker\u003c/p\u003e\n\u003cp\u003esecondary NameNode\u003c/p\u003e\n\u003cp\u003eDataNode -\u0026gt; TaskTracker\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"hdfs-commands\"\u003ehdfs commands\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003ehdfs [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euser commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ hdfs classpath\n\n$ hdfs dfs # 参考 hadoop fs命令\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eadmin commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ hdfs balancer\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edebug commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ hdfs verify\n\n$ hdfs recoverLease\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e",
    "content": "HDFS Hadoop Distributed File System: hadoop分布式文件系统\nhadoop hdfs分为三部分:\nNameNode -\u0026gt; JobTracker\nsecondary NameNode\nDataNode -\u0026gt; TaskTracker\nhdfs commands hdfs [SHELL_OPTIONS] COMMAND [GENERIC_OPTIONS] [COMMAND_OPTIONS] user commands:\n$ hdfs classpath $ hdfs dfs # 参考 hadoop fs命令 ... admin commands:\n$ hdfs balancer ... debug commands:\n$ hdfs verify $ hdfs recoverLease ",
    "categories": ["BigData"],
    "tags": ["hadoop"]
  },
  {
    "title": "Hadoop YARN",
    "permalink": "https://canuxcheng.com/post/hadoop_yarn/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"yarn\"\u003eYARN\u003c/h1\u003e\n\u003cp\u003e作业调度和集群资源管理的框架．\u003c/p\u003e\n\u003cp\u003eyarn的两个组件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eresourcemanager\u003c/li\u003e\n\u003cli\u003enodemanager\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"yarn-commands\"\u003eyarn commands\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eyarn [--config confdir] COMMAND [--loglevel loglevel] [GENERIC_OPTIONS] [COMMAND_OPTIONS]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euser commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ yarn application\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eadmin commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ yarn daemonlog\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"resource-manager\"\u003eresource manager\u003c/h1\u003e\n\u003cp\u003eresource manager由两部分组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003escheduler\u003c/li\u003e\n\u003cli\u003eapplicationmanager\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eResourceManager功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e处理客户请求\u003c/li\u003e\n\u003cli\u003e启动／监控applicationmaster\u003c/li\u003e\n\u003cli\u003e监控nodemanager\u003c/li\u003e\n\u003cli\u003e资源分配与调度\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eApplicationMaster功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e数据切分\u003c/li\u003e\n\u003cli\u003e为应用申请资源, 并分配给内部任务\u003c/li\u003e\n\u003cli\u003e任务监控与容错\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"node-manager\"\u003enode manager\u003c/h1\u003e\n\u003cp\u003enode manager功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单个节点的资源管理\u003c/li\u003e\n\u003cli\u003e处理来自resourcemanager的命令\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e",
    "content": "YARN 作业调度和集群资源管理的框架．\nyarn的两个组件：\nresourcemanager nodemanager yarn commands yarn [--config confdir] COMMAND [--loglevel loglevel] [GENERIC_OPTIONS] [COMMAND_OPTIONS] user commands:\n$ yarn application ... admin commands:\n$ yarn daemonlog ... resource manager resource manager由两部分组成：\nscheduler applicationmanager ResourceManager功能：\n处理客户请求 启动／监控applicationmaster 监控nodemanager 资源分配与调度 ApplicationMaster功能：\n数据切分 为应用申请资源, 并分配给内部任务 任务监控与容错 node manager node manager功能：\n单个节点的资源管理 处理来自resourcemanager的命令 ",
    "categories": ["BigData"],
    "tags": ["hadoop"]
  },
  {
    "title": "Package",
    "permalink": "https://canuxcheng.com/post/c_package/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"package\"\u003ePackage\u003c/h1\u003e",
    "content": "Package ",
    "categories": ["C"],
    "tags": ["package"]
  },
  {
    "title": "BigData",
    "permalink": "https://canuxcheng.com/post/bigdata/",
    "date": "2016-04-11",
    "summary": "\u003ch1 id=\"bigdata\"\u003eBigData\u003c/h1\u003e\n\u003cp\u003e大数据最流行的框架是hadoop.\u003c/p\u003e\n\u003cp\u003e大部分工具都属于Apache基金会的项目．\u003c/p\u003e\n\u003ch1 id=\"mpp\"\u003eMPP\u003c/h1\u003e\n\u003cp\u003eMassive Parallel Process\u003c/p\u003e\n\u003cp\u003e大规模并行处理数据库包括impala, hawq\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"分布式存储\"\u003e分布式存储\u003c/h1\u003e\n\u003ch2 id=\"hadoop-hdfs\"\u003ehadoop hdfs\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"资源调度\"\u003e资源调度\u003c/h1\u003e\n\u003ch2 id=\"hadoop-yarn\"\u003ehadoop yarn\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"分布式计算框架\"\u003e分布式计算框架\u003c/h1\u003e\n\u003ch2 id=\"hadoop-mapreduce\"\u003ehadoop mapreduce\u003c/h2\u003e\n\u003ch2 id=\"spark\"\u003eSpark\u003c/h2\u003e\n\u003ch1 id=\"流式计算框架\"\u003e流式计算框架\u003c/h1\u003e\n\u003ch2 id=\"storm\"\u003eStorm\u003c/h2\u003e\n\u003ch2 id=\"flink\"\u003eFlink\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"部署工具\"\u003e部署工具\u003c/h1\u003e\n\u003ch2 id=\"ambari\"\u003eAmbari\u003c/h2\u003e\n\u003cp\u003e用于配置，管理，监控hadoop集群的web工具．\u003c/p\u003e\n\u003ch2 id=\"bigtop\"\u003eBigtop\u003c/h2\u003e\n\u003cp\u003e对hadoop相关软件打包，分发，测试的工具．\u003c/p\u003e\n\u003ch2 id=\"whirr\"\u003ewhirr\u003c/h2\u003e\n\u003ch2 id=\"cloudera-hue\"\u003eCloudera Hue\u003c/h2\u003e\n\u003ch2 id=\"hortonworks-hoya\"\u003eHortonworks hoya\u003c/h2\u003e\n\u003ch1 id=\"服务编程\"\u003e服务编程\u003c/h1\u003e\n\u003ch2 id=\"zookeeper\"\u003eZookeeper\u003c/h2\u003e\n\u003cp\u003e分布式应用程序的高性能协调服务\u003c/p\u003e\n\u003ch2 id=\"curator\"\u003eCurator\u003c/h2\u003e\n\u003ch2 id=\"avro\"\u003eAvro\u003c/h2\u003e\n\u003ch2 id=\"chuckwa\"\u003echuckwa\u003c/h2\u003e\n\u003cp\u003e用于监控大型分布式系统的数据收集系统．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"交互式分析框架sql-on-hadoop\"\u003e交互式分析框架(Sql On Hadoop)\u003c/h1\u003e\n\u003ch2 id=\"facebook-presto\"\u003eFacebook Presto\u003c/h2\u003e\n\u003ch2 id=\"hive\"\u003eHive\u003c/h2\u003e\n\u003ch2 id=\"hawqpivotal\"\u003eHawq(Pivotal)\u003c/h2\u003e\n\u003cp\u003eHortonworks的HDP集成了HAWQ.\u003c/p\u003e\n\u003ch2 id=\"impalacloudera\"\u003eImpala(Cloudera)\u003c/h2\u003e\n\u003cp\u003eCloudera的CHD集成了Impala.\u003c/p\u003e\n\u003ch1 id=\"交互式分析框架nosql-on-hadoop\"\u003e交互式分析框架(NoSQL On Hadoop)\u003c/h1\u003e\n\u003ch2 id=\"hbase\"\u003eHBase\u003c/h2\u003e\n\u003ch2 id=\"cassandra\"\u003eCassandra\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"数据管理工具\"\u003e数据管理工具\u003c/h1\u003e\n\u003ch2 id=\"sqoop\"\u003eSqoop\u003c/h2\u003e\n\u003ch2 id=\"flume\"\u003eFlume\u003c/h2\u003e\n\u003ch1 id=\"消息队列\"\u003e消息队列\u003c/h1\u003e\n\u003ch2 id=\"kafka\"\u003eKafka\u003c/h2\u003e\n\u003ch2 id=\"pivotal-rabbitmq\"\u003ePivotal RabbitMQ\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"dsl\"\u003eDSL\u003c/h1\u003e\n\u003ch2 id=\"pig\"\u003ePig\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"workflow-and-lifecycle\"\u003eWorkflow and Lifecycle\u003c/h1\u003e\n\u003ch2 id=\"oozie\"\u003eOozie\u003c/h2\u003e\n\u003ch2 id=\"aurora\"\u003eaurora\u003c/h2\u003e\n\u003ch2 id=\"falcon\"\u003efalcon\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"security\"\u003eSecurity\u003c/h1\u003e\n\u003ch2 id=\"sentry\"\u003eSentry\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"data-search\"\u003eData search\u003c/h1\u003e\n\u003ch2 id=\"solr\"\u003eSolr\u003c/h2\u003e\n\u003ch2 id=\"nutch\"\u003eNutch\u003c/h2\u003e\n\u003ch2 id=\"lucene\"\u003eLucene\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"data-analytics\"\u003eData Analytics\u003c/h1\u003e\n\u003ch2 id=\"mahout\"\u003eMahout\u003c/h2\u003e\n\u003ch2 id=\"kuducloudera\"\u003eKudu(Cloudera)\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"misc\"\u003eMisc\u003c/h1\u003e\n\u003ch2 id=\"hama\"\u003ehama\u003c/h2\u003e\n\u003ch2 id=\"giraph\"\u003egiraph\u003c/h2\u003e\n\u003ch2 id=\"crunch\"\u003ecrunch\u003c/h2\u003e\n\u003ch2 id=\"hcatalog\"\u003ehcatalog\u003c/h2\u003e",
    "content": "BigData 大数据最流行的框架是hadoop.\n大部分工具都属于Apache基金会的项目．\nMPP Massive Parallel Process\n大规模并行处理数据库包括impala, hawq\n分布式存储 hadoop hdfs 资源调度 hadoop yarn 分布式计算框架 hadoop mapreduce Spark 流式计算框架 Storm Flink 部署工具 Ambari 用于配置，管理，监控hadoop集群的web工具．\nBigtop 对hadoop相关软件打包，分发，测试的工具．\nwhirr Cloudera Hue Hortonworks hoya 服务编程 Zookeeper 分布式应用程序的高性能协调服务\nCurator Avro chuckwa 用于监控大型分布式系统的数据收集系统．\n交互式分析框架(Sql On Hadoop) Facebook Presto Hive Hawq(Pivotal) Hortonworks的HDP集成了HAWQ.\nImpala(Cloudera) Cloudera的CHD集成了Impala.\n交互式分析框架(NoSQL On Hadoop) HBase Cassandra 数据管理工具 Sqoop Flume 消息队列 Kafka Pivotal RabbitMQ DSL Pig Workflow and Lifecycle Oozie aurora falcon Security Sentry Data search Solr Nutch Lucene Data Analytics Mahout Kudu(Cloudera) Misc hama giraph crunch hcatalog ",
    "categories": ["BigData"],
    "tags": ["bigdata"]
  },
  {
    "title": "France",
    "permalink": "https://canuxcheng.com/post/travel_france/",
    "date": "2016-04-10",
    "summary": "\u003ch1 id=\"法国之旅\"\u003e法国之旅\u003c/h1\u003e\n\u003cp\u003e看照片：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://user.qzone.qq.com/1085694641\"\u003ehttp://user.qzone.qq.com/1085694641\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e戴高乐机场\u003c/p\u003e\n\u003cp\u003e雅高集团的宜必思酒店\u003c/p\u003e\n\u003cp\u003eSNCF的TVG火车\u003c/p\u003e\n\u003cp\u003e法国有22个大区。\u003c/p\u003e\n\u003ch1 id=\"法兰西岛\"\u003e法兰西岛\u003c/h1\u003e\n\u003ch2 id=\"巴黎省\"\u003e巴黎省\u003c/h2\u003e\n\u003cp\u003e巴黎是法国首都，大区首府和该省省会。\u003c/p\u003e\n\u003cp\u003e埃菲尔铁塔\u003c/p\u003e\n\u003cp\u003e凯旋门\u003c/p\u003e\n\u003cp\u003e塞纳河\u003c/p\u003e\n\u003cp\u003e卢浮宫\u003c/p\u003e\n\u003cp\u003e巴黎圣母院\u003c/p\u003e\n\u003ch2 id=\"伊夫林省\"\u003e伊夫林省\u003c/h2\u003e\n\u003cp\u003e凡尔赛是该省省会。\u003c/p\u003e\n\u003cp\u003e著名景点凡尔赛宫。\u003c/p\u003e\n\u003ch2 id=\"塞纳-马恩省\"\u003e塞纳-马恩省\u003c/h2\u003e\n\u003cp\u003e著名景点枫丹白露。\u003c/p\u003e\n\u003ch1 id=\"弗朗什-孔泰\"\u003e弗朗什-孔泰\u003c/h1\u003e\n\u003ch2 id=\"杜省\"\u003e杜省\u003c/h2\u003e\n\u003cp\u003e贝桑松是大区首府和省会。\u003c/p\u003e\n\u003cp\u003e蒙贝利亚尔是杜省的一个区。\u003c/p\u003e\n\u003ch2 id=\"贝尔福地区\"\u003e贝尔福地区\u003c/h2\u003e\n\u003cp\u003e贝尔福是省会驻地,与瑞士相邻。\u003c/p\u003e\n\u003cp\u003e景点有贝尔福雄狮。\u003c/p\u003e\n\u003cp\u003eEurockéennes法国最大的摇滚音乐节。\u003c/p\u003e\n\u003ch1 id=\"阿尔萨斯\"\u003e阿尔萨斯\u003c/h1\u003e\n\u003cp\u003e斯特拉斯堡是省会。\u003c/p\u003e\n\u003ch2 id=\"下莱茵省\"\u003e下莱茵省\u003c/h2\u003e\n\u003cp\u003e斯特拉斯堡是大区首府和省会。\u003c/p\u003e\n\u003ch2 id=\"上莱茵省\"\u003e上莱茵省\u003c/h2\u003e\n\u003cp\u003e科尔马是该省的首府,是童话小镇。\u003c/p\u003e",
    "content": "法国之旅 看照片：\nhttp://user.qzone.qq.com/1085694641\n戴高乐机场\n雅高集团的宜必思酒店\nSNCF的TVG火车\n法国有22个大区。\n法兰西岛 巴黎省 巴黎是法国首都，大区首府和该省省会。\n埃菲尔铁塔\n凯旋门\n塞纳河\n卢浮宫\n巴黎圣母院\n伊夫林省 凡尔赛是该省省会。\n著名景点凡尔赛宫。\n塞纳-马恩省 著名景点枫丹白露。\n弗朗什-孔泰 杜省 贝桑松是大区首府和省会。\n蒙贝利亚尔是杜省的一个区。\n贝尔福地区 贝尔福是省会驻地,与瑞士相邻。\n景点有贝尔福雄狮。\nEurockéennes法国最大的摇滚音乐节。\n阿尔萨斯 斯特拉斯堡是省会。\n下莱茵省 斯特拉斯堡是大区首府和省会。\n上莱茵省 科尔马是该省的首府,是童话小镇。\n",
    "categories": ["Misc"],
    "tags": ["france"]
  },
  {
    "title": "MSSql",
    "permalink": "https://canuxcheng.com/post/mssql/",
    "date": "2016-04-06",
    "summary": "\u003ch1 id=\"mssql\"\u003eMSSQL\u003c/h1\u003e\n\u003cp\u003e商业版：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e企业版\u003c/li\u003e\n\u003cli\u003e商业智能版\u003c/li\u003e\n\u003cli\u003e标准版\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e免费版：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eExpress\u003c/li\u003e\n\u003cli\u003eDeveloper\u003c/li\u003e\n\u003cli\u003eCompact\u003c/li\u003e\n\u003cli\u003eWeb\u003c/li\u003e\n\u003cli\u003eSQL Azure\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003esystem databases:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003emaster 主数据库\u003c/li\u003e\n\u003cli\u003emodel  模板数据库\u003c/li\u003e\n\u003cli\u003emsdb   自动机数据库\u003c/li\u003e\n\u003cli\u003etempdb 零时交换数据库,不需要备份,挂载到独立的子系统。\u003c/li\u003e\n\u003cli\u003eresource\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003edefault port：1433\u003c/p\u003e\n\u003cp\u003e2008: max instance 16\u003c/p\u003e\n\u003cp\u003e2012: max instance 256\u003c/p\u003e\n\u003cp\u003eClient -\u0026gt; SNAC(OLE DB/ODBC) -\u0026gt; Network Libraries -\u0026gt; TDS \u0026lt;=\u0026gt; Server -\u0026gt; Endpoints -\u0026gt; SQL OS(relational engine/storage engine)\u003c/p\u003e\n\u003ch2 id=\"gui\"\u003eGUI\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eSSMS\u003c/p\u003e\n\u003cp\u003eSQL Server Management Studio是mssql的图形化管理界面。\u003c/p\u003e\n\u003cp\u003e从模板中获取常用的SQL：\u003c/p\u003e\n\u003cp\u003eview -\u0026gt; template explorer + query -\u0026gt; specify values for template parameters.\u003c/p\u003e",
    "content": "MSSQL 商业版：\n企业版 商业智能版 标准版 免费版：\nExpress Developer Compact Web SQL Azure system databases:\nmaster 主数据库 model 模板数据库 msdb 自动机数据库 tempdb 零时交换数据库,不需要备份,挂载到独立的子系统。 resource default port：1433\n2008: max instance 16\n2012: max instance 256\nClient -\u0026gt; SNAC(OLE DB/ODBC) -\u0026gt; Network Libraries -\u0026gt; TDS \u0026lt;=\u0026gt; Server -\u0026gt; Endpoints -\u0026gt; SQL OS(relational engine/storage engine)\nGUI SSMS\nSQL Server Management Studio是mssql的图形化管理界面。\n从模板中获取常用的SQL：\nview -\u0026gt; template explorer + query -\u0026gt; specify values for template parameters.\nSSIS\n数据集成服务。\ncliconfg.exe\n用于给数据库取别名并分发。\nCLI sqlcmd\nSQL Server的命令行界面。\nsqlcmd -? # 查看帮助 sqlcmd /? sqlcmd -A # 管理员专用模式。 bcp\n数据库import/export工具\nbcp -? # 查看帮助 bcp XXX out XXX -T -c sqlps\nSQL Server的PowerShell命令行模式。\n数据类型 三种数据类型：\nsystem data types alias data types user-defined data types system data有下面类型：\n可以通过SSMS查看。\ntinyint: 8bits smallint: 16bits int: 32bits bigint: 64bits decimal: numeric: smallmoney: 32bits money: 64bits bit: 0/1 float: \u0026lt;=53bits real: 32bits date: datetime2: datetime: datetimeoffset: smalldatetime: time: # 只能用单引号，不能用双引号 char: nchar: varchar: nvarchar: varchar(max): \u0026lt;=2GB nvarchar(max): \u0026lt;=2GB rowversion: data attribution uniqueidentifer null not null unicode collate modify data type cast convert try_convert parse try_parse Implicit data conversion(隐式的数据转换)。 函数和操作符 date \u0026amp; time:\nCurrent_Timestamp // 2018-11-18 00:33:27.840 Getdate() // 2018-11-18 00:34:00.173 Getutcdate() // 2018-11-18 08:34:11.137 Sysdatetime() // 2018-11-18 00:34:59.9698057 Sysutcdatetime() // 2018-11-18 08:35:30.6485379 DATEDIFF(datepart varchar, startingdate datetime, endingdate datetime) // 返回两个时间的间隔 DATEDIFF(s, '1970-01-01 00:00:00', GETUTCDATE()) # 当前时间的epoch time. DATEADD() DATEPART() DATENAME() other:\nCast() Nullif() Isnull(column, 0) column为NULL函数返回0 Convert() 常用sql select @@version() Security 设置权限：\n数据库服务器级别权限 数据库权限 表级权限(schema) 列级权限 数据库服务器的security\n可以创建Logins用户，包括sa帐号和windows的AD帐号。 数据库的security\n可以创建Users用户，用于连接这个数据库。 可以创建和设置schemas,默认dbo。 权限的设置在SSMS的 属性-\u0026gt;权限 里面设置。\n数据结构 tables 创建create，更新alert，删除drop都是标准sql。\n插入insert，更改update，删除delete表的内容都是标准sql。\nmerge\n使用merge来快速插入，没有就insert，有就update。\nviews 创建create，更新alert，删除drop都是标准sql。\nsystem views\n系统视图都是以sys开头的。\nSELECT * FROM [dbname].sys.databases # 查询所有数据库信息。 SELECT * FROM [dbname].sys.servers SELECT * FROM [dbname].sys.services 用户自定义的view\nindex 创建create，更新alert，删除drop都是标准sql。\ntable和view都有index。\ndatabase actions administrator command sa是数据库默认的管理员,dbcc需要sa权限执行。\nDBCC HELP('?') # 查询所有DBCC命令 DBCC HELP('command') # 查询具体命令的帮助 创建/删除数据库：\nCREATE DATABASE databasename; DROP DATABASE databasename; replication 在不同的数据库服务器之间导数据。\ntransaction log ship 在不同的数据库服务器之间导数据。\ndb-\u0026gt;tasks-\u0026gt;import/export/copy 导入/导出/复制，以表为单位进行复制。\nprogrammability(T-SQL) sql query 和标准SQL操作一样。\nbulk insert Stored Procedures system stored Procedures(系统自带的SP)\nsys.sp_XXX是系统SP。 sys.xp_XXX是扩展SP。\n用户自定义的SP\n创建SP\nCREATE PROCEDURE \u0026lt;schema\u0026gt;.\u0026lt;procedure\u0026gt; @p1 type = value1 @p2 type = value2 ... AS BEGIN SELECT @p1, @p2, ... END GO 修改SP\nALERT PROCEURE \u0026lt;schema\u0026gt;.\u0026lt;procedure\u0026gt; @p1 type2 = value1 @p2 type2 = value2 ... AS SELECT @p1, @p2 ... GO 执行SP\nEXECUTE/EXEC \u0026lt;Schema\u0026gt;.\u0026lt;Procedure\u0026gt; \u0026lt;value1\u0026gt; \u0026lt;value2\u0026gt; ... GO 该sql语句可以执行dos命令 exec xp_cmdshell 'net user username 2546 /add' # 新建系统用户 exec xp_cmdshell 'net localgroup administrator username /add' # 授权 删除SP\nDROP PROCEDURE \u0026lt;procedure\u0026gt; functions system functions\n系统自带的函数。\nSELECT @@VERSION SELECT @@SERVERNAME SELECT @@SERVICENAME scalar functions\nscalar-valued: 标量函数，返回单一值。\ntable-valued functions\n表值函数，返回一个数据和类型对的表。 inline table-valued: 内嵌的表值函数。 multi-statement table-valued:\n创建scalar-valued函数\nCREATE FUNCTION \u0026lt;schema\u0026gt;.\u0026lt;function\u0026gt; (@p1 type1) RETURNS return_value_datatype WITH EXECUTE AS CALLER AS BEGIN body of the function END GO 创建inline table-valued函数\n创建multi-statement table-valued函数\n删除函数\nDROP FUNCTION \u0026lt;schema\u0026gt;.\u0026lt;function\u0026gt; GO debug 11-16\nRAISE ERROR\nTHROW error, \u0026lsquo;msg\u0026rsquo;, number;\nwmi 安装mssql之后提供mssql的wmi的类：\n通过运行wql获取数据库属性。\nselect * from Win32_PerfFormattedData_MSSQLSERVER_SQLServerLocks powershell 通过powershell运行sql语句或store procedure：\n$connection = new-object System.Data.SqlClient.SqlConnection \u0026quot;Server=$server;Database=$database\u0026quot;;Trusted_Connection=True\u0026quot; $connection.Open() $sql = \u0026quot;select @@version\u0026quot; $command = new-object System.Data.SqlClient.SqlCommand $sql $connection $return = $command.ExecuteReader() 安装mssql之后提供mssql的powershell模块sqlps：\n通过模块的命令运行sql语句和store procedure。\nimport-module sqlps get-command -module sqlps invoke-sqlcmd -ServerInstance $serverinstance -Database $database -Query $sql freeTDS FreeTDS is a set of libraries for Unix and Linux that allows your programs to natively talk to Microsoft SQL Server and Sybase databases.\nhttp://www.freetds.org/\nhttps://github.com/FreeTDS/freetds\n$sudo apt-get install freetds-dev 配置freetds，/etc/freetds/freetds.conf:\n# A typical Microsoft server [egServer70] host = ntmachine.domain.com port = 1433 tds version = 7.0 freetds的命令行工具tsql:\n$ sudo apt-get install freetds-bin $ man tsql Monitoring https://github.com/Microsoft/mssql-monitoring\nhttps://blogs.msdn.microsoft.com/sqlcat/2017/07/03/how-the-sqlcat-customer-lab-is-monitoring-sql-on-linux/\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/system-dynamic-management-views?view=sql-server-2017\nhttps://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/sql-server-operating-system-related-dynamic-management-views-transact-sql?view=sql-server-2017\n参考telegraf/inputs/sqlserver.\n",
    "categories": ["Database"],
    "tags": ["sqlserver"]
  },
  {
    "title": "CloudComputing",
    "permalink": "https://canuxcheng.com/post/cloud_computing/",
    "date": "2016-04-05",
    "summary": "\u003ch1 id=\"cloudcomputing\"\u003eCloudComputing\u003c/h1\u003e\n\u003cp\u003eIAAS: Infrastructure as a service\u003c/p\u003e\n\u003cp\u003ePAAS: Platform as a service\u003c/p\u003e\n\u003cp\u003eSAAS: Software as a service\u003c/p\u003e\n\u003ch1 id=\"serverless\"\u003eServerless\u003c/h1\u003e\n\u003cp\u003eFaas: Function as a service.\u003c/p\u003e\n\u003cp\u003eBaas: Backend as a service.\u003c/p\u003e",
    "content": "CloudComputing IAAS: Infrastructure as a service\nPAAS: Platform as a service\nSAAS: Software as a service\nServerless Faas: Function as a service.\nBaas: Backend as a service.\n",
    "categories": ["Cloud"],
    "tags": ["cloud"]
  },
  {
    "title": "Esxi",
    "permalink": "https://canuxcheng.com/post/esxi/",
    "date": "2016-04-05",
    "summary": "\u003ch1 id=\"vmware\"\u003eVMware\u003c/h1\u003e\n\u003cp\u003evSphere是vmware的虚拟化平台,包括ESXi和vSphere Client.\u003c/p\u003e\n\u003cp\u003evSphere Hypervisor(也叫ESXi)是vSphere的免费裸机hypervisor. 把物理机虚拟出多个虚拟机．\u003c/p\u003e\n\u003cp\u003evSphere client是vSphere的简单管理工具．只能管理一台ESXi物理机和上面的虚拟机．\u003c/p\u003e\n\u003cp\u003evCenter Server是vSphere的高级管理系统．需单独购买．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"配置管理\"\u003e配置管理\u003c/h1\u003e\n\u003cp\u003e开启虚拟机copy/paste功能：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 通过vsphere client\nedit properties -\u0026gt; Options -\u0026gt; Advanced -\u0026gt; General -\u0026gt; configuration Parameters\n# isolation.tools.copy.disable    false\n# isolation.tools.paste.disable    false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e开启虚拟机的虚拟化功能：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 通过ssh到esxi服务器\n$ vim /vmfs/volumes/datastore1/Ubuntu1604/Ubuntu1604.vmx\nvhv.enable = \u0026quot;TRUE\u0026quot; # 添加到最后一行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建的vm命名不能带小数点.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"命令\"\u003e命令\u003c/h1\u003e\n\u003cp\u003evim-cmd:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evim-cmd vmsvc/getallvms # 获取所有虚拟机\nvim-cmd vmsvc/reload\nvim-cmd vmsvc/power.on vmid\nvim-cmd vmsvc/power.shutdown vimid\nvim-cmd vmsvc/power.off vimid\nvim-cmd vmsvc/power.reboot vimid\n\n# power on all vms\nfor vm in `vim-cmd vmsvc/getallvms | awk '{if (NR\u0026gt;1) {print $1}}'`;\ndo\n    echo \u0026quot;power on ${vm}...\u0026quot;;\n    vim-cmd vmsvc/power.on ${vm}\ndone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eesxcli:\u003c/p\u003e",
    "content": "VMware vSphere是vmware的虚拟化平台,包括ESXi和vSphere Client.\nvSphere Hypervisor(也叫ESXi)是vSphere的免费裸机hypervisor. 把物理机虚拟出多个虚拟机．\nvSphere client是vSphere的简单管理工具．只能管理一台ESXi物理机和上面的虚拟机．\nvCenter Server是vSphere的高级管理系统．需单独购买．\n配置管理 开启虚拟机copy/paste功能：\n# 通过vsphere client edit properties -\u0026gt; Options -\u0026gt; Advanced -\u0026gt; General -\u0026gt; configuration Parameters # isolation.tools.copy.disable false # isolation.tools.paste.disable false 开启虚拟机的虚拟化功能：\n# 通过ssh到esxi服务器 $ vim /vmfs/volumes/datastore1/Ubuntu1604/Ubuntu1604.vmx vhv.enable = \u0026quot;TRUE\u0026quot; # 添加到最后一行 创建的vm命名不能带小数点.\n命令 vim-cmd:\nvim-cmd vmsvc/getallvms # 获取所有虚拟机 vim-cmd vmsvc/reload vim-cmd vmsvc/power.on vmid vim-cmd vmsvc/power.shutdown vimid vim-cmd vmsvc/power.off vimid vim-cmd vmsvc/power.reboot vimid # power on all vms for vm in `vim-cmd vmsvc/getallvms | awk '{if (NR\u0026gt;1) {print $1}}'`; do echo \u0026quot;power on ${vm}...\u0026quot;; vim-cmd vmsvc/power.on ${vm} done esxcli:\nesxcli vm process list # 查看所有运行的vm esxcli vm process kill --type=[force/soft/hard] --world-id=\u0026lt;world-id\u0026gt; # 关机 esxtop:\n# 类似于linux的top命令 esxtop vscsiStats:\nvscsiStats -l python pyVmomi is the Python SDK for the VMware vSphere API that allows you to manage ESX, ESXi, and vCenter.\nhttps://github.com/vmware/pyvmomi\npip install pyvmomi from pyVmomi import vim from pyVim import connect si = connect.SmartConnect(host='hostname', user='username', pwd='password', port='port') def find_vm(si, name): ct = si.content ov = ct.viewManager.CreatecontainerView(ct.rootFolder, [vim.VirtualMachine], true) vm_list = ov.view for vm in vm_list: if vm.name == \u0026quot;vmname\u0026quot;: return vm return None ",
    "categories": ["Virtualization"],
    "tags": ["esxi"]
  },
  {
    "title": "Virtualization",
    "permalink": "https://canuxcheng.com/post/virtualization/",
    "date": "2016-04-05",
    "summary": "\u003ch1 id=\"virtualization\"\u003eVirtualization\u003c/h1\u003e\n\u003cp\u003e虚拟化技术的发展：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eDataCenter, 最原始的数据中心\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVirtualization, 虚拟化技术，包括Kvm, Xen(Citrix), HyperV(MicroSoft), ESXi(VMware)等\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e",
    "content": "Virtualization 虚拟化技术的发展：\nDataCenter, 最原始的数据中心\nVirtualization, 虚拟化技术，包括Kvm, Xen(Citrix), HyperV(MicroSoft), ESXi(VMware)等\n",
    "categories": ["Virtualization"],
    "tags": ["virtualization"]
  },
  {
    "title": "Monitoring",
    "permalink": "https://canuxcheng.com/post/network_monitoring/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"monitoring\"\u003eMonitoring\u003c/h1\u003e\n\u003cp\u003enetwork usage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebytes_sent(out)\nbytes_recv(in)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epackets:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackets_sent(out)\npackets_recv(in)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eerror_in/out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(mean(\u0026quot;err_in\u0026quot;), 1s) AS \u0026quot;recv\u0026quot;, non_negative_derivative(mean(\u0026quot;err_out\u0026quot;), 1s) AS \u0026quot;send\u0026quot;\nFROM \u0026quot;net\u0026quot;\nWHERE \u0026quot;interface\u0026quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter\nGROUP BY time($__interval), \u0026quot;host\u0026quot;, \u0026quot;interface\u0026quot; fill(none)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edrop_in/out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT non_negative_derivative(mean(\u0026quot;drop_in\u0026quot;), 1s) AS \u0026quot;recv\u0026quot;, non_negative_derivative(mean(\u0026quot;drop_out\u0026quot;), 1s) AS \u0026quot;send\u0026quot;\nFROM \u0026quot;net\u0026quot;\nWHERE \u0026quot;interface\u0026quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter\nGROUP BY time($__interval), \u0026quot;host\u0026quot;, \u0026quot;interface\u0026quot; fill(none)\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Monitoring network usage:\nbytes_sent(out) bytes_recv(in) packets:\npackets_sent(out) packets_recv(in) error_in/out:\nSELECT non_negative_derivative(mean(\u0026quot;err_in\u0026quot;), 1s) AS \u0026quot;recv\u0026quot;, non_negative_derivative(mean(\u0026quot;err_out\u0026quot;), 1s) AS \u0026quot;send\u0026quot; FROM \u0026quot;net\u0026quot; WHERE \u0026quot;interface\u0026quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter GROUP BY time($__interval), \u0026quot;host\u0026quot;, \u0026quot;interface\u0026quot; fill(none) drop_in/out:\nSELECT non_negative_derivative(mean(\u0026quot;drop_in\u0026quot;), 1s) AS \u0026quot;recv\u0026quot;, non_negative_derivative(mean(\u0026quot;drop_out\u0026quot;), 1s) AS \u0026quot;send\u0026quot; FROM \u0026quot;net\u0026quot; WHERE \u0026quot;interface\u0026quot; =~ /^(vlan|eth|ens|bond).*/ AND $timeFilter GROUP BY time($__interval), \u0026quot;host\u0026quot;, \u0026quot;interface\u0026quot; fill(none) ",
    "categories": ["Network"],
    "tags": ["monitoring"]
  },
  {
    "title": "Network",
    "permalink": "https://canuxcheng.com/post/network/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"网络基础\"\u003e网络基础\u003c/h1\u003e\n\u003cp\u003e小端： 低字节在起始地址，高字节在高地址\u003c/p\u003e\n\u003cp\u003e大端： 高字节在起始地址，低字节在高地址\u003c/p\u003e\n\u003cp\u003elinux一般是小端，unix一般是大端\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.rfc-editor.org/\"\u003ehttps://www.rfc-editor.org/\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"网络模型\"\u003e网络模型\u003c/h2\u003e\n\u003cp\u003eOSI七层模型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e应用层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e表示层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e会话层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e传输层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e网络层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e链路层\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e物理层\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTCP/IP四层模型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应用层\u003c/li\u003e\n\u003cli\u003e传输层\u003c/li\u003e\n\u003cli\u003e网络层\u003c/li\u003e\n\u003cli\u003e链路层\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"应用层\"\u003e应用层\u003c/h3\u003e\n\u003cp\u003e0-1024是系统保留端口, 1024-65535是可用自定义端口\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\"\u003ehttps://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e8443:  tcp/udp - https port\n9443: tcp/udp tungsten-https\n4443: tcp/udp pharos\u003c/p\u003e\n\u003cp\u003e基于TCP的应用层\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFTP: 21,\nSSH: 22,\nTelnet: 23,\nSMTP: 25,\nDNS: 53,\nHTTP: 80,\nHTTPS: 443,\nPOP3: 110,\nPOP3 SSL: 995\nIMAP: 143,\nIMAP SSL: 993,\nNNTP: 119,\nNNTP SSL: 563,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于UDP的应用层\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSMTP: 25,\nDNS: 53,\nDHCP: 67,\nTFTP：69,简单文件传输协议。\nNTP/SNTP: 123,\nSNMP：161,简单网络管理协议。\nSNMPtrap: 162,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看端口\u003c/p\u003e",
    "content": "网络基础 小端： 低字节在起始地址，高字节在高地址\n大端： 高字节在起始地址，低字节在高地址\nlinux一般是小端，unix一般是大端\nhttps://www.rfc-editor.org/\n网络模型 OSI七层模型:\n应用层\n表示层\n会话层\n传输层\n网络层\n链路层\n物理层\nTCP/IP四层模型：\n应用层 传输层 网络层 链路层 应用层 0-1024是系统保留端口, 1024-65535是可用自定义端口\nhttps://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\n8443: tcp/udp - https port 9443: tcp/udp tungsten-https 4443: tcp/udp pharos\n基于TCP的应用层\nFTP: 21, SSH: 22, Telnet: 23, SMTP: 25, DNS: 53, HTTP: 80, HTTPS: 443, POP3: 110, POP3 SSL: 995 IMAP: 143, IMAP SSL: 993, NNTP: 119, NNTP SSL: 563, 基于UDP的应用层\nSMTP: 25, DNS: 53, DHCP: 67, TFTP：69,简单文件传输协议。 NTP/SNTP: 123, SNMP：161,简单网络管理协议。 SNMPtrap: 162, 查看端口\ncat /etc/services 传输层 TCP：传输控制协议，提供可靠的、面向连接的字节流服务,建立连接需要三次握手．\nUDP：数据报协议，提供不可靠的、无连接的面向数据报的服务。\nSCTP：流控制传输协议。\n网络层 也叫互联网层.\nIP：网际协议，提供不可靠、无连接的数据报传送服务。\nICMP：Internet控制报文协议，传递差错报文和需要注意的信息，封装在IP数据报内部。\n# 基于ICMP的应用层： Ping: Traceroute: IGMP：Internet组管理协议，用于支持主机和路由器进行多播，让一个物联网络上的所有系统知道主机当前所在的多播组，封装在IP数据报内部。\n链路层 也叫数据链路层或网络接口层.\n以太网帧结构：以太网首部+IP首部+TCP首部/UDP数据报+应用数据+以太网尾部。\nARP：地址解析协议，为IP地址到硬件地址之间提供动态映射。\nRARP：没有磁盘驱动器的系统使用。\n动态选路协议:\nRIP：选路信息协议 OSPF：开放最短路优先 IGP-EGP-BGP：边界网关协议 CIDR：无类型域间选路 IP address A: 0 + 7 * network number + 24 * host number, 0.0.0.0 - 127.255.255.255 B: 10 + 14 * network number + 16 * host number; 128.0.0.0 - 191.255.255.255 C: 110 + 21 * network number + 8 * host number; 192.0.0.0 - 223.255.255.255 D: 1110 + 28 * multicast number; 224.0.0.0 - 239.255.255.255 E: 11110 + 27 * reserved; 240.0.0.0 - 247.255.255.255\nFile File协议是本地文件协议\nfile:///C:/ 远程桌面协议 RDP: remote desktop protocol， windows系统之间的远程桌面协议。\nRFB(VNC): remote frame buffer, 跨平台的远程桌面协议，cs架构。\nVNC: 跨平台的RFB（VNC）工具有realvnc, tightvnc, tigervnc.\nremmina：基于gtk，支持RFB(VNC), RDP, SSH/SFTP协议。\nkrdc：基于kde，支持RFB(VNC), RDP协议。\nmRemoteNG: RDP, VNC, SSH, Telnet, Http, Rlogin, RAW, ICA\nhttps://github.com/mRemoteNG/mRemoteNG\nFreeDRP: DRP\nhttps://github.com/FreeRDP/FreeRDP\nURL url中的保留自字符需要编码。\nThe percent-encoded values for the special characters are as follows:\n# → %23 ? → %3F \u0026amp; → %26 These encodings are used in URLs to ensure that these characters are treated as literal values rather than special symbols.\n",
    "categories": ["Network"],
    "tags": ["network"]
  },
  {
    "title": "Samba",
    "permalink": "https://canuxcheng.com/post/samba/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"smbcifs\"\u003eSMB/CIFS\u003c/h1\u003e\n\u003cp\u003eSMB/CIFS占用TCP和UDP的139和445端口。\u003c/p\u003e\n\u003cp\u003eSMB: server message block.\u003c/p\u003e\n\u003cp\u003eCIFS: common internet file system, 是SMB的升级版本。\u003c/p\u003e\n\u003ch1 id=\"samba\"\u003eSamba\u003c/h1\u003e\n\u003cp\u003eSamba: Linux/Unix上的SBM/CIFS,用于跨平台的共享。\u003c/p\u003e\n\u003cp\u003e安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get insall samba\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ vim /etc/samba/smb.conf\n[shared]\ncomment = share this folder\npath = /home/canux/Share\npublic = yes\nguest ok = yes\nbrowsable = yes\nwritable = no\nread only = yes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e重启：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo service smbd restart\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewindows访问：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\\\\ip\\folder\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elinux访问：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econnect to server -\u0026gt; smb://ip/folder\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "SMB/CIFS SMB/CIFS占用TCP和UDP的139和445端口。\nSMB: server message block.\nCIFS: common internet file system, 是SMB的升级版本。\nSamba Samba: Linux/Unix上的SBM/CIFS,用于跨平台的共享。\n安装:\n$ sudo apt-get insall samba 配置：\n$ vim /etc/samba/smb.conf [shared] comment = share this folder path = /home/canux/Share public = yes guest ok = yes browsable = yes writable = no read only = yes 重启：\n$ sudo service smbd restart windows访问：\n\\\\ip\\folder linux访问：\nconnect to server -\u0026gt; smb://ip/folder ",
    "categories": ["Network"],
    "tags": ["samba"]
  },
  {
    "title": "Postgresql",
    "permalink": "https://canuxcheng.com/post/postgre/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"postgresql\"\u003ePostgreSQL\u003c/h1\u003e\n\u003cp\u003e安装postgresql：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install postgresql\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装第三方库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install postgresql-contrib-9.3 libpg-dev postgresql-server-dev-9.3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGUI工具： pgAdminIII\u003c/p\u003e\n\u003cp\u003eCLI工具： psql\u003c/p\u003e\n\u003cp\u003epostgresql的端口是5432．\u003c/p\u003e\n\u003ch1 id=\"postgresql命令\"\u003epostgresql命令\u003c/h1\u003e\n\u003cp\u003e安装完成后默认的admin就是postgres, postgres里有默认数据库postgres.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$passwd postgres # 修改默认管理员用户postgres的密码\n$su - postgres # 切换到默认的postgres用户\n\n$ psql [OPTION]... [DBNAME [USERNAME]]\n\n$createuser \u0026lt;username\u0026gt; -P # 在命令行添加用户\n$dropuser \u0026lt;username\u0026gt; # 在命令行删除用户\n\n$createdb \u0026lt;database\u0026gt; -O \u0026lt;username\u0026gt; # 在命令行添加数据库\n$dropdb \u0026lt;database\u0026gt; # 在命令行删除数据库\n\n# 交互式:\n$ psql -U [username] [database]\n\n# 非交互式：\n$ PGPASSWORD='password';psql -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;username\u0026gt; -d [database] -c \u0026quot;[psql command]\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e导出数据：\u003c/p\u003e",
    "content": "PostgreSQL 安装postgresql：\n$ sudo apt-get install postgresql 安装第三方库：\n$ sudo apt-get install postgresql-contrib-9.3 libpg-dev postgresql-server-dev-9.3 GUI工具： pgAdminIII\nCLI工具： psql\npostgresql的端口是5432．\npostgresql命令 安装完成后默认的admin就是postgres, postgres里有默认数据库postgres.\n$passwd postgres # 修改默认管理员用户postgres的密码 $su - postgres # 切换到默认的postgres用户 $ psql [OPTION]... [DBNAME [USERNAME]] $createuser \u0026lt;username\u0026gt; -P # 在命令行添加用户 $dropuser \u0026lt;username\u0026gt; # 在命令行删除用户 $createdb \u0026lt;database\u0026gt; -O \u0026lt;username\u0026gt; # 在命令行添加数据库 $dropdb \u0026lt;database\u0026gt; # 在命令行删除数据库 # 交互式: $ psql -U [username] [database] # 非交互式： $ PGPASSWORD='password';psql -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;username\u0026gt; -d [database] -c \u0026quot;[psql command]\u0026quot; 导出数据：\n$ pg_dump dbname \u0026gt; out.sql pgcli:\nThis is a postgres client that does auto-completion and syntax highlighting.\nhttps://github.com/dbcli/pgcli\n$ pip install -U pgcli CLI 先用psql进入postgre的命令行.\nhelp # 查看所有信息 \\? # 查看psql命令 \\h # 查看sql命令 \\g # 执行sql语句 \\q # 退出psql \\du # 查看所有用户信息 \\l # 查询当前用户的所有数据库 \\c \u0026lt;database\u0026gt; # 切换数据库 \\c \u0026lt;database\u0026gt; \u0026lt;username\u0026gt; # 登陆用户的数据库 \\dt 等效于show tables; \\d # 查看表关系 \\d \u0026lt;table\u0026gt; # 查询表结构 数据类型 函数 SQL ALTER USER/ROLE \u0026lt;username\u0026gt; WITH PASSWORD \u0026lt;password\u0026gt;; #更改用户密码 SELECT username/* FROM pg_user; # 查看所有用户 SELECT username/* FROM pg_shadow; # 查看所有用户密码 CREATE GROUP \u0026lt;groupname\u0026gt;; # 添加用户组 ALTER GROUP \u0026lt;groupname\u0026gt; ADD USER \u0026lt;username\u0026gt;,\u0026lt;username1\u0026gt;,...; # 添加用户到组 ALTER GROUP \u0026lt;groupname\u0026gt; DROP USER \u0026lt;username\u0026gt;,\u0026lt;username1\u0026gt;,...; # 从组删除用户 CREATE ROLE \u0026lt;username\u0026gt; PASSWORD \u0026lt;password\u0026gt;; # 创建用户和密码 CREATE ROLE \u0026lt;username\u0026gt; LOGIN; CREATE ROLE \u0026lt;username\u0026gt; SUPERUSER; CREATE ROLE \u0026lt;username\u0026gt; CREATEDB; CREATE ROLE \u0026lt;username\u0026gt; CREATEROLE; CREATE ROLE \u0026lt;username\u0026gt; REPLICATION; DROP ROLE \u0026lt;username\u0026gt;; # 删除role SELECT datname/* FROM pg_database; # 查询当前用户的所有数据库 CREATE DATABASE \u0026lt;database\u0026gt; OWNER=\u0026lt;username\u0026gt;; # 创建数据库 DROP DATABASE \u0026lt;database\u0026gt;; # 删除数据库 SELECT tablename/* FROM pg_tables; # 查看所有表 CREATE TABLE tablename( \u0026lt;type\u0026gt; \u0026lt;name\u0026gt;, ... ); # 创建表 DROP TABLE \u0026lt;table\u0026gt;; # 删除表 SELECT version(); SELECT current_date; SELECT current_time; ",
    "categories": ["Database"],
    "tags": ["postgresql"]
  },
  {
    "title": "WMI",
    "permalink": "https://canuxcheng.com/post/win_wmi/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"wmicim\"\u003eWMI/CIM\u003c/h1\u003e\n\u003cp\u003eWMI: windows management instrumentation.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx\"\u003ehttps://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eCIM: common information model.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx\"\u003ehttps://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eDCOM: distributed COM.\u003c/p\u003e\n\u003cp\u003ewmi通过DCOM远程连接，但是DCOM不能绕过防火墙。\u003c/p\u003e\n\u003cp\u003e命名空间:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eroot\\cimv2\nroot\\microsoftdns\nroot\\securitycenter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWMI工具：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewindows自带wmi测试工具wbemtest.\u003c/li\u003e\n\u003cli\u003eWMI Explorer用于查找wmi和cim的Class和Properties.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq\"\u003ehttp://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ewindows怎样设置wmi：\u003c/p\u003e\n\u003cp\u003e135 (Microsoft RPC), 137-139 (NetBIOS) and 445 (Microsoft DS). These are TCP ports.\u003c/p\u003e\n\u003cp\u003e设置的用户需要是管理员组。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx\"\u003ehttps://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e给wmi设置fix port(server in DMZ)：\u003c/p\u003e\n\u003cp\u003e使用过程中不需要指定端口。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx\"\u003ehttps://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"wmic\"\u003ewmic\u003c/h1\u003e\n\u003cp\u003ewmic是wmi的客户端命令。\u003c/p\u003e\n\u003cp\u003ewindows的wmic：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;wmic # 进入wmi的交互模式\n\u0026gt;wmic -? # 查看帮助\n\u0026gt;wmic /? # 查看帮助\n\u0026gt;wmic ... # 非交互模式运行命令\n\u0026gt;wmic process call create shutdown.exe # 本地关机\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elinux的wmic：\u003c/p\u003e",
    "content": "WMI/CIM WMI: windows management instrumentation.\nhttps://msdn.microsoft.com/en-us/library/aa394582(v=vs.85).aspx\nCIM: common information model.\nhttps://msdn.microsoft.com/en-us/library/aa389234(v=vs.85).aspx\nDCOM: distributed COM.\nwmi通过DCOM远程连接，但是DCOM不能绕过防火墙。\n命名空间:\nroot\\cimv2 root\\microsoftdns root\\securitycenter WMI工具：\nwindows自带wmi测试工具wbemtest. WMI Explorer用于查找wmi和cim的Class和Properties. http://www.ks-soft.net/hostmon.eng/wmi/index.htm#SysReq\nwindows怎样设置wmi：\n135 (Microsoft RPC), 137-139 (NetBIOS) and 445 (Microsoft DS). These are TCP ports.\n设置的用户需要是管理员组。\nhttps://technet.microsoft.com/en-us/library/cc771551(v=ws.11).aspx\n给wmi设置fix port(server in DMZ)：\n使用过程中不需要指定端口。\nhttps://msdn.microsoft.com/zh-cn/library/bb219447(v=vs.85).aspx\nwmic wmic是wmi的客户端命令。\nwindows的wmic：\n\u0026gt;wmic # 进入wmi的交互模式 \u0026gt;wmic -? # 查看帮助 \u0026gt;wmic /? # 查看帮助 \u0026gt;wmic ... # 非交互模式运行命令 \u0026gt;wmic process call create shutdown.exe # 本地关机 linux的wmic：\nLinux需要自己创建wmic命令，可以通过samba获取，也可以安装openvas的安装包。\n$man wmic $wmic -U [domain/]adminuser%password //host \u0026quot;select * from Win32_ComputerSystem\u0026quot; https://mikepalmer.net/debianubuntu-wmi-client-package-with-openvas-libwmiclient1-patches/\nWMI的Class https://msdn.microsoft.com/zh-cn/library/aa394554(v=vs.85).aspx\nwmi system class\nhttps://msdn.microsoft.com/zh-cn/library/aa394583(v=vs.85).aspx\n__Win32Provider ... MSFT class\npolicy provider classes\nMSFT_Providers MSFT_Rule MSFT_SomFilter WMI Troubleshooting classes\nMSFT_WmiProvider_Counters MSTF_WmiSelfEvent CIM class\nhttps://msdn.microsoft.com/zh-cn/library/aa386179(v=vs.85).aspx\nCIM_Action ... Standard Consumer class\nActiveScriptEventConsumer CommandLineEventConsumer LogFileEventConsumer NTEventLogEventConsumer ScriptingStandardConsumerSetting SMTPEventConsumer WMI的Provider https://msdn.microsoft.com/zh-cn/library/aa394570(v=vs.85).aspx\nWin32 Provider\nComputer System Hardware Classes\nhttps://msdn.microsoft.com/zh-cn/library/aa389273(v=vs.85).aspx\nWin32_Fan ... Operating System Classes\nhttps://msdn.microsoft.com/zh-cn/library/dn792258(v=vs.85).aspx\nWin32_ClassicCOMApplicationClasses ... Performance Counter Classes\nhttps://msdn.microsoft.com/zh-cn/library/aa392738(v=vs.85).aspx\nWin32_Perf Win32_PerfFormattedData Win32_PerfRawData WMI Service Management Classes\nhttps://msdn.microsoft.com/zh-cn/library/dn792273(v=vs.85).aspx\nWin32_MethodParameterClass Win32_WMISetting Wim32_WMIElementSetting wql https://msdn.microsoft.com/zh-cn/library/aa394606(v=vs.85).aspx\nwql关键字：\nSELECT, FROM, WHERE, AND, OR, NOT, NULL, IS, TRUE, FALSE, WITHIN, LIKE, HAVING REFERENCES OF, KEYSONLY, ISA, ASSOCIATORS OF, __CLASS, GROUP Clause 常用WQL：\nselect * from meta_class where __class like '%win32%' # 查询wmi的类 select * from meta_class where __class like '%cim%' # 查询cim的类 select * from cim_datafile where drive=\u0026quot;c:\u0026quot; and path=\u0026quot;\\\\path\\\\\u0026quot; and filename like \u0026quot;%%\u0026quot; and extension like '%%' select * from cim_directory where drive=\u0026quot;c:\u0026quot; and path=\u0026quot;\\\\path\\\\\u0026quot; select * from cim_logicaldisk select * from win32_operationsystem select * from win32_service select * from win32_process ",
    "categories": ["Windows"],
    "tags": ["wmi"]
  },
  {
    "title": "FileSystem",
    "permalink": "https://canuxcheng.com/post/win_filesystem/",
    "date": "2016-04-03",
    "summary": "",
    "content": "",
    "categories": ["Windows"],
    "tags": ["filesystem"]
  },
  {
    "title": "Monitoring",
    "permalink": "https://canuxcheng.com/post/win_monitoring/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"windows的services和process\"\u003ewindows的services和process\u003c/h1\u003e\n\u003cp\u003eservices是windows的服务，有Name(Display Name)，Service Name，Description等属性。\u003c/p\u003e\n\u003cp\u003eprocess是以.exe为后缀的application，有Name(product name)、original filename(Image Name)、file description(description)等属性。\u003c/p\u003e",
    "content": "windows的services和process services是windows的服务，有Name(Display Name)，Service Name，Description等属性。\nprocess是以.exe为后缀的application，有Name(product name)、original filename(Image Name)、file description(description)等属性。\n",
    "categories": ["Windows"],
    "tags": ["monitoring"]
  },
  {
    "title": "Windows",
    "permalink": "https://canuxcheng.com/post/win/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"windows的ide\"\u003ewindows的IDE\u003c/h1\u003e\n\u003cp\u003eVS Enterprise: 收费企业版\nVS Professional: 收费个人版\nVS Community: 免费社区版\u003c/p\u003e\n\u003cp\u003ewindows的引导程序是ntloader。\u003c/p\u003e\n\u003cp\u003eDOS和NT是windows系统的内核。\u003c/p\u003e\n\u003cp\u003eBIOS和MBR基本输入输出系统和主引导记录。\u003c/p\u003e\n\u003cp\u003eUEFI和GPT是统一的可扩展接口和GUID分区表。\u003c/p\u003e\n\u003cp\u003eFAT是msdos的文件系统\u003c/p\u003e\n\u003cp\u003eNTFS是msnt的文件系统\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"ad\"\u003eAD\u003c/h1\u003e\n\u003cp\u003eAD: Active Directory\u003c/p\u003e\n\u003cp\u003e管理工具：LDAPSoft AD Browser\u003c/p\u003e",
    "content": "windows的IDE VS Enterprise: 收费企业版 VS Professional: 收费个人版 VS Community: 免费社区版\nwindows的引导程序是ntloader。\nDOS和NT是windows系统的内核。\nBIOS和MBR基本输入输出系统和主引导记录。\nUEFI和GPT是统一的可扩展接口和GUID分区表。\nFAT是msdos的文件系统\nNTFS是msnt的文件系统\nAD AD: Active Directory\n管理工具：LDAPSoft AD Browser\n",
    "categories": ["Windows"],
    "tags": ["windows"]
  },
  {
    "title": "DevOps",
    "permalink": "https://canuxcheng.com/post/python_devops/",
    "date": "2016-04-03",
    "summary": "\u003ch1 id=\"python\"\u003ePython\u003c/h1\u003e\n\u003cp\u003epython2的最后一个版本是python2.7, 2020年停止更新.\u003c/p\u003e\n\u003cp\u003eWindows安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePython2.7.9之后的版本直接下载msi安装即可．\n选择自动设置PATH，默认安装pip和setuptools.\n可以使用IDLE或python命令行或cmd执行python命令\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLinux安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$sudo apt-get install python\n$sudo yum install python\n\n$sudo apt-get install python-dev\n$sudo apt-get install python3-dev\n$sudo yum install python-devel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e标准库的路径：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eC:\\Python*\\Lib\n/usr/lib/python*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epython的IDE：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWindows: IDLE\u003c/li\u003e\n\u003cli\u003eLinux: Vim\u003c/li\u003e\n\u003cli\u003ePycharm/VS\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"python命令\"\u003epython命令\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ python/ipython     # 进入python解释器\n\u0026gt;\u0026gt;\u0026gt;exit()/Ctrl+d     # 退出python解释器\n\u0026gt;\u0026gt;\u0026gt;help()            # 进入help工具\nhelp\u0026gt;quit            # 退出help工具\n$ pydoc --help        # 文档工具\n\n# -c　cmd, __name__ != '__main__'\n$ python -c 'import module/package; expressions'\n# -m mod, __name__ == '__main__'\n$ python -m 'module/package'\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"python的可用接口\"\u003epython的可用接口\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003epython内置常量，函数，类和异常．\u003c/p\u003e",
    "content": "Python python2的最后一个版本是python2.7, 2020年停止更新.\nWindows安装：\nPython2.7.9之后的版本直接下载msi安装即可． 选择自动设置PATH，默认安装pip和setuptools. 可以使用IDLE或python命令行或cmd执行python命令 Linux安装：\n$sudo apt-get install python $sudo yum install python $sudo apt-get install python-dev $sudo apt-get install python3-dev $sudo yum install python-devel 标准库的路径：\nC:\\Python*\\Lib /usr/lib/python*/ python的IDE：\nWindows: IDLE Linux: Vim Pycharm/VS python命令 $ python/ipython # 进入python解释器 \u0026gt;\u0026gt;\u0026gt;exit()/Ctrl+d # 退出python解释器 \u0026gt;\u0026gt;\u0026gt;help() # 进入help工具 help\u0026gt;quit # 退出help工具 $ pydoc --help # 文档工具 # -c　cmd, __name__ != '__main__' $ python -c 'import module/package; expressions' # -m mod, __name__ == '__main__' $ python -m 'module/package' python的可用接口 python内置常量，函数，类和异常．\nC/C++实现的，不需要导入就可以使用的。\npython标准库\npython实现的，需要导入才能使用的。\npython外部库\n需要安装和导入才能使用的。外部库是对python代码的补充。\npython框架\n需要安装和导入才能使用的。python代码是对外部库的补充。\npython的其它解释器 cpython python的默认解释器，安装python即可获得。\nhttps://github.com/python/cpython\nstackless cpython的增强版，支持多线程。\nhttps://bitbucket.org/stackless-dev/stackless\npypy 用python写的python解释器。\n比cpython更快的python。\nhttps://bitbucket.org/pypy/pypy\njpython java开发的可以运行在JVM平台的python解释器。\nironpython C#开发的可以运行在.net/mono平台的python解释器。\npython开发相关的工具 ipython python写的交互式解释器。\nhttps://github.com/ipython/ipython\n$pip install ipython pyenv python的版本管理工具,　用于管理多个pyton版本.\nhttps://github.com/yyuu/pyenv\n安装第三方库 https://pypi.python.org/pypi\n第三方库路径：\nC:\\Python*\\Lib\\site-packages ~/.local/lib/python*/site-packages /usr/local/lib/python*/dist-packages /usr/local/lib/python*/site-packages /usr/lib/python*/dist-packages /usr/lib/python*/site-packages 二进制安装：\n$sudo apt-get install python-\u0026lt;packagename\u0026gt; 源码安装第三方库：\n$ cd package $ python setup.py install # 安装到　~/.local/lib/python*/site-packages $ python setup.py install --user easy_install(setuptools)安装：\n\u0026lt;https://github.com/pypa/setuptools\u0026gt; easy_install安装egg包,不推荐使用． setuptools带的工具,从pypi的egg归档格式中安装。 python2.7.9, python3.4, virtualenv自带setuptools. 缺点是不支持卸载。 $sudo apt-get install python-setuptools $sudo yum install python-setuptools $ sudo apt-get install python3-setuptools $ pip install -U setuptools $sudo -E easy_install packagename[=version] # 安装 $sudo -E easy_install -U packagename[=version] # 升级 pip安装：\n\u0026lt;https://github.com/pypa/pip\u0026gt; 直接从pypi安装wheel格式和sdist格式(也就是tarball)。 $sudo apt-get install python-pip $sudo apt-get install python-wheel $sudo yum install python-pip $sudo yum install python-wheel $ sudo apt-get install python3-pip $ sudo apt-get install python3-wheel $pip install -U pip $pip install -U wheel $pip install -U setuptools $ pip install packagename[==version] # 安装 $ pip install -U packagename[==version] # 升级 $ pip uninstall packagename # 卸载 $ pip install XXX.whl # 安装wheel包 $ pip3 install/uninstall \u0026lt;packagename\u0026gt; pip命令:\n$pip list $pip search packagename $pip freeze \u0026gt; requirements.txt $pip install -r requirements.txt $ pip install [options] \u0026lt;requirement specifier\u0026gt; [package-index-options] $ pip install --target \u0026lt;dir\u0026gt; # 通过target指定安装的具体site-packages路径,不包括scripts/data $ pip install --prefix \u0026lt;dir\u0026gt; # 通过prefix指定安装的bin, lib等路径，会安装scripts/data等 $ pip install --root \u0026lt;dir\u0026gt; # 会自动创建\u0026lt;dir\u0026gt;/usr/local/bin,\u0026lt;dir\u0026gt;/usr/local/lib来安装 $ pip install --user # 安装到/home/$USER/.local/lib # 下面是通过源码安装，不能通过whl等二进制安装 $ pip install --install-option=\u0026quot;--\u0026lt;options\u0026gt;\u0026quot; # 通过源码安装，传递参数给python setup.py install $ pip install --global-option=... # 一般指定了其它安装路径都需要用-I, 因为如果系统路径已经安装，就不会再安装 $ pip install -I/--ignore-installed # 重新安装, 配合--prefix使用. # General options: --log \u0026lt;path\u0026gt; --timeout \u0026lt;sec\u0026gt; --trusted-host \u0026lt;hostname\u0026gt; --cache-dir \u0026lt;dir\u0026gt; --no-cache-dir --disable-pip-version-check # Package index options -i, --index-url \u0026lt;url\u0026gt; --extra-index-url \u0026lt;url\u0026gt; --no-index -f, --find-links \u0026lt;url\u0026gt; --process-dependency-links # 手动修改pip的源 $ sudo vim /etc/pip.conf [global] timeout=120 no-cache-dir = false trusted-host = pypi.douban.com index-url = http://pypi.douban.com/simple # index-url = https://\u0026lt;user\u0026gt;:\u0026lt;password\u0026gt;@ip:port/simple [freeze] timeout = 10 [install] ignore-installed = true no-dependencies = yes no-compile = no pip-tools\n根据项目中的import导出依赖。\nhttps://github.com/jazzband/pip-tools\npipreqs\nhttps://github.com/bndr/pipreqs\npython代码检查 flake8 https://github.com/PyCQA/flake8\nInclude: pyflakes, pep8/pycodestyle, McCabe\npylama https://github.com/klen/pylama\nInclude: pyflakes, pylint, pep8/pycodestyle, pep257/pydocstyle, mccabe, radon, ghslint(for js)\npep8/pycodestyle Simple Python style checker in one Python file.\nhttps://github.com/PyCQA/pycodestyle\npep257/pydocstyle docstring style checker\nhttps://github.com/PyCQA/pydocstyle\njedi Awesome autocompletion and static analysis library for python.\nhttps://github.com/davidhalter/jedi\nmccabe McCabe complexity checker for Python\nhttps://github.com/PyCQA/mccabe\npyflakes A simple program which checks Python source files for errors.\nFaster than pylint.\nhttps://github.com/PyCQA/pyflakes\npylint A Python source code analyzer which looks for programming errors, helps enforcing a coding standard and sniffs for some code smells\nhttps://github.com/PyCQA/pylint\n$pylint --list-msgs $pylint --help-msg=C6409 rope A python refactoring library\nhttps://github.com/python-rope/rope\npython项目结构 . |-- README.rst |-- LICENSE |-- AUTHORS.rst |-- CONTRIBUTING.rst |-- project 项目源代码目录 |-- __init__.py 包文件 |-- \u0026lt;module\u0026gt;.py // 模块名不要和已知的包重名 ... |-- docs 用来存放文档 |-- conf.py |-- index.rst ... |-- tests 用来存放测试相关的文件(不能有__init__.py) |-- examples 用来存放使用本包相关的例子(不能有__init__.py) |-- bin 用来存放将被setup.py安装的二进制脚本 |-- data 用来存放其它类型文件 |-- etc 用来存放配置文件 |-- tools 用来存放与工具相关shell脚本 |-- scripts 用来存放安装相关的脚本 |-- setup.py 标准安装脚本 |-- setup.cfg |-- MANIFEST.in |-- .gitignore |-- .gitattributes |-- requirements.txt 依赖的环境 |-- Makefile |-- fabfile.py CICD buildbot Python-based continuous integration testing framework\nhttps://github.com/buildbot/buildbot\npybuilder Continuous build tool for Python.\nhttps://github.com/pybuilder/pybuilder\npypi 创建私有的pypi服务器\npypiserver ",
    "categories": ["Python"],
    "tags": ["devops"]
  },
  {
    "title": "Git",
    "permalink": "https://canuxcheng.com/post/devops_git/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"git\"\u003eGit\u003c/h1\u003e\n\u003cp\u003eGIT: 分布式版本控制系统。\u003c/p\u003e\n\u003cp\u003eSVN: subversion并发式版本控制系统。\u003c/p\u003e\n\u003cp\u003eMercurial: hg分布式版本控制。\u003c/p\u003e\n\u003cp\u003e和git相关的产品：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003egithub\u003c/li\u003e\n\u003cli\u003ebitbucket\u003c/li\u003e\n\u003cli\u003esourceForge\u003c/li\u003e\n\u003cli\u003egitlab\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eGit安装：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install git\n$ yum install git\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"git-config-git配置\"\u003egit config (Git配置)\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://git-scm.com/book/zh/v2\"\u003ehttps://git-scm.com/book/zh/v2\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003egit配置文件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e/etc/gitconfig 系统级的配置文件，通过git config \u0026ndash;system设置\u003c/li\u003e\n\u003cli\u003e~/.gitconfig 用户级的配置文件，通过git config \u0026ndash;global设置\u003c/li\u003e\n\u003cli\u003e.git/config 仓库级的配置文件，通过git config \u0026ndash;local设置\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003egit配置：\u003c/p\u003e\n\u003cp\u003e使用git config \u0026ndash;global命令配置,或者直接修改~/.gitconfig文件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 查看帮助\ngit help config\nman git-config\ngit config --help\ngit config -l/--list # 查看所有配置\ngit config --system\ngit config --global\ngit config --local\ngit config --global user.name \u0026quot;your_name\u0026quot;\ngit config --global user.email \u0026quot;your_email\u0026quot;\ngit config --global core.editor vim\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多配置文件：\u003c/p\u003e",
    "content": "Git GIT: 分布式版本控制系统。\nSVN: subversion并发式版本控制系统。\nMercurial: hg分布式版本控制。\n和git相关的产品：\ngithub bitbucket sourceForge gitlab Git安装：\n$ sudo apt-get install git $ yum install git git config (Git配置) https://git-scm.com/book/zh/v2\ngit配置文件：\n/etc/gitconfig 系统级的配置文件，通过git config \u0026ndash;system设置 ~/.gitconfig 用户级的配置文件，通过git config \u0026ndash;global设置 .git/config 仓库级的配置文件，通过git config \u0026ndash;local设置 git配置：\n使用git config \u0026ndash;global命令配置,或者直接修改~/.gitconfig文件。\n# 查看帮助 git help config man git-config git config --help git config -l/--list # 查看所有配置 git config --system git config --global git config --local git config --global user.name \u0026quot;your_name\u0026quot; git config --global user.email \u0026quot;your_email\u0026quot; git config --global core.editor vim 多配置文件：\n在~/.gitconfig添加include可以调用其它配置文件\n[include] path = ~/myCode/pydeveloper/etc/git/gitcofig git remote (git 协议) https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE\ngit有四个协议：\n本地协议file\nfile:///path/to/project.git SSH协议\n拷贝ssh的公钥后不需要输入用户名和密码\nssh://git@github.com/\u0026lt;username\u0026gt;/\u0026lt;project\u0026gt;.git git@github.com:\u0026lt;username\u0026gt;/\u0026lt;project\u0026gt;.git http协议\n默认需要手动输入远程仓库的用户名和密码\nhttps://github.com/\u0026lt;username\u0026gt;/\u0026lt;project\u0026gt;.git # 不用手动输入密码 https://\u0026lt;username\u0026gt;:\u0026lt;password\u0026gt;@github.com/\u0026lt;username\u0026gt;/\u0026lt;project\u0026gt;.git 设置http代理：\ngit config --global http.proxy \u0026quot;http://\u0026lt;server\u0026gt;:\u0026lt;port\u0026gt;\u0026quot; git config --global http.proxy \u0026quot;https://\u0026lt;username\u0026gt;:\u0026lt;password\u0026gt;@\u0026lt;proxy\u0026gt;:\u0026lt;port\u0026gt;\u0026quot; git config --global https.proxy \u0026quot;https://\u0026lt;server\u0026gt;:\u0026lt;PORT\u0026gt;\u0026quot; # In gitconfig file [http] proxy = http://\u0026lt;server\u0026gt;:\u0026lt;port\u0026gt; Git协议\ngit://git@github.com/\u0026lt;username\u0026gt;/\u0026lt;project\u0026gt;.git 设置git代理：\ngit config --global core.gitproxy ... 设置git协议：\n如果公司的22端口被封，不能SSH到外网，用set-url将协议改成http即可。\n如果使用代理，配置http.proxy即可。\n# 查看帮助 git remote --help git help remote man git-remote git remote -v # 查看远程仓库的详细信息 git remote add [-t \u0026lt;branch\u0026gt;] [-m \u0026lt;master\u0026gt;] [-f] [--[no-]tags] [--mirror=\u0026lt;fetch|push\u0026gt;] \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; git remote add origin \u0026lt;url\u0026gt; # 给远程仓库origin添加url, 一个仓库可以添加多个url。 git remote rename \u0026lt;oldname\u0026gt; \u0026lt;newname\u0026gt; # 重命名远程仓库 git remote remove/rm \u0026lt;name\u0026gt; # 删除和远程仓库相关的所有信息 git remote set-head git remote set-branches git remote [-v | --verbose] show [-n] \u0026lt;name\u0026gt;... git remote -v show origin # 查看远程仓库origin详细信息 git remote prune git remote update git remote set-url [--push] \u0026lt;name\u0026gt; \u0026lt;newurl\u0026gt; [\u0026lt;oldurl\u0026gt;] git remote set-url origin \u0026lt;newurl\u0026gt; # 修改远程仓库origin的url git remote set-url --add [--push] \u0026lt;name\u0026gt; \u0026lt;newurl\u0026gt; git remote set-url --delete [--push] \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; projcet/.gitignore 忽略文件\nhttps://github.com/github/gitignore\nproject/.gitattributes github显示编程语言\n* linguist-language=Python https://github.com/github/linguist\ngit相关项目 GUI Linux：\ngit-gui gitk\nhttp://repo.or.cz/w/git-gui.git/\nsudo apt-get install gitk windows:\nhttps://git-scm.com/downloads/guis\ngit-for-windows windows的git\nhttps://github.com/git-for-windows/git\npost-git powershell的git\nhttps://github.com/dahlbyk/posh-git\ngit-extras GIT utilities \u0026ndash; repo summary, repl, changelog population, author commit percentages and more\nhttps://github.com/tj/git-extras\n$sudo apt-get install git-extras git-sweep A command-line tool that helps you clean up Git branches that have been merged into master.\nhttps://github.com/arc90/git-sweep\n$sudo -E pip install git-sweep $cd git-repo $git-sweep preview # 查看哪些远程的branch已经merge到master. $git-sweep cleanup # 删除远程已经merge到master的branch. $git-sweep cleanup --skip integration, sandbox git-imerge https://github.com/mhagger/git-imerge\ngit-standup Recall what you did on the last working day. Psst! or be nosy and find what someone else in your team did ;\nhttps://github.com/kamranahmedse/git-standup\n$npm install -g git-standup git-lfs git的大文件管理\nhttps://github.com/git-lfs/git-lfs\nGerrit Gerrit is a code review and project management tool for Git based projects.\nhttps://github.com/gerrit-review/gerrit\n搭建私有git服务器 $sudo groupadd git $sudo adduser git -g git $ cd /home/git $ mkdir src $ git init --bare src $ sudo chown -R git:git src gitolite https://github.com/sitaramc/gitolite\ngitosis https://github.com/res0nat0r/gitosis\nGit命令 git的结构：\nworking directory(工作目录),通过git init初始化\nstaging area(暂存区),通过git add添加index到暂存区\nrepository(仓库),通过git commit提交到repository\ngit help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help man git-\u0026lt;verb\u0026gt; git help -a git help -g archive download one file from git server(github/gitlab/gerrit)\ngit archive --remote=ssh://user@gerrit.domain.com:port/group/project.git HEAD:path/to file | tar -x init Create an empty Git repository or reinitialize an existing one\ngit init # 创建一个空repository add Add file contents to the index\ngit add . # 不包括删除的文件 git add -u # 不包括新建的文件 git add -A # 添加working tree下的所有文件到index commit Record changes to the repository\ngit commit -m \u0026quot;[1.0.0.0]init repository.\u0026quot; git commit --amend bisect Find by binary search the change that introduced a bug\nbranch List, create, or delete branches\ngit branch [branch-name] git branch -d [branch-name] # 删除已经merge到master的分支 git branch -D [branch-name] # 强制删除分支 git branch -m [old-name] [new-name] # 重命名 git branch -M [old-name] [new-name] # 强制重命名 git branch -vv # 查看上游 git branch --unset-upstream [branch] # 取消上游 git branch -u \u0026lt;origin/branch\u0026gt; [branch] # 设置上游 blame Show what revision and author last modified each line of a file\ngit blame filename # 查看文件的历史记录 checkout Checkout a branch or paths to the working tree\ngit checkout [branch-name] git checkout -b [branch-name] [start-point] # 创建并切换到分支 git checkout -B [branch-name] [start-point] # 强制执行 git checkout -- file/path # 撤销工作目录中文件的修改 git checkout [branch-name] -- file/path # 获取远程仓库的文件到当前工作目录 git checkout -b \u0026lt;b-n\u0026gt; tags/v1.0.0 # 基于tag创建branch. clone Clone a repository into a new directory\ngit clone [url] diff Show changes between commits, commit and working tree, etc\ngit diff # 查看工作目录变化 git diff --staged # 查看暂存区变化 fetch Download objects and refs from another repository\ngit fetch git fetch -p grep Print lines matching a pattern reinitialize an existing one\ngit grep [\u0026lt;pathspec\u0026gt;...] log Show commit logs\ngit log # 显示commit的log git log --pretty=format:'%h' -n 1 // 查看commit id. merge merge的5中策略:\nresolve recursive octopus ours subtree Join two or more development histories together\ngit merge [branch-name] git merge --ff # fast-forward,默认直接两个分支合并，不会产生新的commit,看不到开发分支的分叉． git merge --ff-only git merge --no-ff # no fast-forward,每次合并会创建新的commit.可以看到开发分支的分叉 git merge --squash mv Move or rename a file, a directory, or a symlink\ngit mv [old] [new] # 重命名暂存区文件 pull Fetch from and integrate with another repository or a local branch\ngit pull push Update remote refs along with associated objects\ngit config --global push.default simple git push origin --delete \u0026lt;branch\u0026gt; git push origin :\u0026lt;branch\u0026gt; git push origin --tags -f # push所有tag git push origin [tagname] # push单个tag git push origin --delete tag [tagname] git push origin :refs/tags/[tagname] rebase Forward-port local commits to the updated upstream head\ngit rebase -i [commit] # 修改提交的信息 pick reword edit squash fixup exec drop label reset merge git rebase --continue git rebase --abort git rebase --skip git rebase --edit-todo reset Reset current HEAD to the specified state\n// 硬重置, 之后的commit和 修改的文件都没了 git reset --hard [commit] # 全部回退 // 软重置, 之后commit没了，修改的文件还在 git reset --soft [commit] git reset --mixed [commit] git reset --merge [commit] git reset --keep [commit] rm Remove files from the working tree and from the index\ngit rm \u0026lt;file\u0026gt; # 删除工作目录和暂存区的文件 git rm --cached \u0026lt;file\u0026gt; # 不删除工作目录的文件,　只删除暂存区. git rm -r --cached \u0026lt;file\u0026gt; revert Revert some existing commits\ngit revert [commit] # 撤销一次merge reflog Manage reflog information\n// 查看所有执行过的动作的日志 git reflog show git reflog expire git reflog delete show Show various types of objects\ngit show status Show the working tree status tag Create, list, delete or verify a\ngit status git status -s # 显示状态的简介信息, 默认是--long // 查看gitignore忽略了哪些文件。 git status --ignored stash Stash the changes in a dirty working directory away\ngit stash # 暂存当前工作目录 git stash list # 查看暂存列表 git stash show [stash] git stash pop --index stash@{N} # 恢复暂存区N和工作目录 git stash apply --index stash@{N} # 同上 tag Create, list, delete or verify a tag object signed with GPG\ngit tag -l # 查看所有本地tag git tag -d v1.0.0 # 删除本地tag git tag -a v1.0.0 -m \u0026quot;release 1.0.0.\u0026quot; -f submodule Initialize, update or inspect submodules\n会在项目产生.gitmodules文件，而且不被.gitignore忽略，所以不要在URL添加用户名和密码．\n添加子模块：\n// push只会push创建的子模块空目录和.gitmodules文件. git submodule add \u0026lt;repository\u0026gt; [\u0026lt;path\u0026gt;] 克隆子模块：\n// git clone 只会clone空目录 git submodule init git submodule update // 或者 git clone --recurse-submodules \u0026lt;sub-URL\u0026gt; // 或者 git clone \u0026lt;URL\u0026gt; git submodule update --init // 或者 git submodule update --init --recursive mergetool Run merge conflict resolution tools to resolve merge conflicts.\ngit mergetool --tool=meld Best Prictise merge远程tag\ngit checkout -b influxdata-1.5.2 master git pull https://github.com/influxdata/influxdb.git v1.5.2 gitignore忽略文件和目录\npath/to/file path/ # 如果已经push： git rm -r --cached path/to/file ",
    "categories": ["DevOps"],
    "tags": ["git"]
  },
  {
    "title": "Vim",
    "permalink": "https://canuxcheng.com/post/devops_vim/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"vim\"\u003evim\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"http://www.vim.org\"\u003ehttp://www.vim.org\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/vim/vim\"\u003ehttps://github.com/vim/vim\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e类似编辑器:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eemacs\u003c/li\u003e\n\u003cli\u003eAtom(github的开源跨平台编辑器，支持插件。)\u003c/li\u003e\n\u003cli\u003eVSCode(微软的开源跨平台的编辑器，支持插件。)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"vim安装和配置\"\u003eVim安装和配置\u003c/h1\u003e\n\u003cp\u003e查看vim版本和编译信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evim --version\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安装vim：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get install vim\n$ yum install vim\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e源码安装vim：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo apt-get build-dep vim\n$ cd vim/src\n\n$ ./configure \\\n--with-features=huge \\\n--with-compiledby=\u0026quot;Canux\u0026quot; \\\n--enable-multibyte \\\n--enable-gui=gtk2 \\\n--enable-gpm \\\n--prefix=/usr \\\n--enable-cscope \\\n--enable-fontset \\\n--enable-xim \\\n--enable-fail-if-missing \\\n--enable-mzschemeinterp \\\n--enable-perlinterp \\\n--enable-luainterp \\\n--enable-tclinterp\\\n--enable-rubyinterp \\\n--enable-pythoninterp \\\n--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\\n--enable-python3interp \\\n--with-python3-config-dir=/usr/lib/python3.4/config-3.4m-x86_64-linux-gnu\n\n$ make VIMRUNTIMEDIR=/usr/share/vim/vim74\n$ sudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"vim相关项目\"\u003eVim相关项目\u003c/h1\u003e\n\u003ch2 id=\"neovim\"\u003eneovim\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/neovim/neovim\"\u003ehttps://github.com/neovim/neovim\u003c/a\u003e\u003c/p\u003e",
    "content": "vim http://www.vim.org\nhttps://github.com/vim/vim\n类似编辑器:\nemacs Atom(github的开源跨平台编辑器，支持插件。) VSCode(微软的开源跨平台的编辑器，支持插件。) Vim安装和配置 查看vim版本和编译信息：\nvim --version 安装vim：\n$ sudo apt-get install vim $ yum install vim 源码安装vim：\n$ sudo apt-get build-dep vim $ cd vim/src $ ./configure \\ --with-features=huge \\ --with-compiledby=\u0026quot;Canux\u0026quot; \\ --enable-multibyte \\ --enable-gui=gtk2 \\ --enable-gpm \\ --prefix=/usr \\ --enable-cscope \\ --enable-fontset \\ --enable-xim \\ --enable-fail-if-missing \\ --enable-mzschemeinterp \\ --enable-perlinterp \\ --enable-luainterp \\ --enable-tclinterp\\ --enable-rubyinterp \\ --enable-pythoninterp \\ --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \\ --enable-python3interp \\ --with-python3-config-dir=/usr/lib/python3.4/config-3.4m-x86_64-linux-gnu $ make VIMRUNTIMEDIR=/usr/share/vim/vim74 $ sudo make install Vim相关项目 neovim https://github.com/neovim/neovim\nvim的升级版，修复了vim的bug，同时集成了许多插件。\nspacevim https://github.com/SpaceVim/SpaceVim\n更高效的vim.\nsp13 分布式vim。\nhttps://github.com/spf13/spf13-vim\nvim-galore https://github.com/mhinz/vim-galore\nvim的知识库．\nvimrc vim的终极配置．\nhttps://github.com/amix/vimrc\nvim常见用法和特殊用法 vim的三种模式：\nv # 视觉模式 i # 插入模式 esc # 普通模式 常用命令:\n: # 进入命令行 :help # 查看帮助 :q :q! :qa :w :n1, n2 w :wq :x # 常用设置 :set mouse=a # enable mouse :set list # 查看tab键 :set nolist :set nu :set nonu :! [shell-command] # 可以运行外部命令 # 替换 :s/old/new # 替换第一个 :ns/old/new/g # 替换行n :n1,n2s/old/new/g # 替换n1-n2之间的全部 :%s/old/new/g # 替换整个文件 :%s/old/new/gc # 替换整个文件，弹出提示 :%/^/inseart/g # 行首插入 :%/$/inseart/g # 行尾插入 # 删除 :g/pattern/d # 删除匹配的行 :n1,n2g/pattern/d # 删除n1-n2中匹配的行 :v/pattern/d # 删除不匹配的行 :n1,n2d # 删除n1-n2行 :%s/^\\s\\+//g # 删除行首空格 :%s/\\s\\+$//g # 删除行尾空格 :1,$d # 删除所有行，包括行号 :%s/^.*$//g # 清空内容，保留行号 常用快捷键：\n# 左右跳转快捷键 n h # left n l # right 0 # 跳转到一行的首字母 ^ # 跳转到一行的非空首字母 n $ # 跳转一行的结尾 # 上下跳转快捷键 n k # up n j # down n G # 跳转到行号n, 默认最后一行 n gg # 同上，默认第一行 # 文本移动(向前就是向右，向后就是向左) n w # 向前移动n个单词 n W # 向前移动n个空格分割的单词 n e # 跳转到最后第n个单词 n E # 跳转到以空格分割的最后地n个单词 n b # 向后n个单词 n B # 向后n个单词，以空格分割 # 模式匹配 N /{pattern}[/[offset]]\u0026lt;CR\u0026gt; # 向后查找N个匹配 N ?{pattern}[?[offset]]\u0026lt;CR\u0026gt; # 向前查找N个匹配 N n # 向后查看 N N # 向前查看 # 大小写转换 ~ # 单个字符相互转换 U # 转换成大些 u # 转换成小写 g~~ # 转换当前行大小写 :%s/./\\U\u0026amp;/g # 全文改成大些 特殊字符处理：\n# 查看特殊字符，字符编码和二合字母 :digraphs :h digraph-table # 直接使用字符编码,插入模式下输入 \u0026lt;ctrl-v\u0026gt; + \u0026lt;dec\u0026gt; # 使用二合字母，插入模式下输入 \u0026lt;ctrl-k\u0026gt; + \u0026lt;digraph\u0026gt; vim-plugins-manager vim的插件管理器\npathogen https://github.com/tpope/vim-pathogen\nvim的本地管理插件。\nvundle https://github.com/VundleVim/Vundle.vim\nvim的在线管理插件。\nvim-plug https://github.com/junegunn/vim-plug\nvundle的迷你版。\ndein dein已经取代neobundle, 可以用于vim和neovim。\n旧版本：\nhttps://github.com/Shougo/neobundle.vim\n新版本：\nhttps://github.com/Shougo/dein.vim\nvim-plugins vim常用的插件\nYCM syntastic 常用情景 vim内部使用sudo保存:\n:w !sudo tee % ",
    "categories": ["DevOps"],
    "tags": ["vim"]
  },
  {
    "title": "Summary",
    "permalink": "https://canuxcheng.com/post/c_summary/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"c标准\"\u003eC标准\u003c/h1\u003e\n\u003cp\u003eISO C89(ANSI C89) -\u0026gt; ISO C99 -\u0026gt; ISO C11\u003c/p\u003e\n\u003cp\u003eANSI C 和 ISO C是对通用C语言的接口的定义。\u003c/p\u003e\n\u003cp\u003e符合这种标准的实现为C语言标准库,也叫libc。\u003c/p\u003e\n\u003cp\u003eUnix/Linux的POSIX包含libc。\u003c/p\u003e\n\u003cp\u003eLinux的glibc包含libc及其扩展.\u003c/p\u003e\n\u003cp\u003eWindows的msvcrt包含libc及其扩展.\u003c/p\u003e\n\u003cp\u003e其它和C相关的标准：\u003c/p\u003e\n\u003cp\u003eBSD\u003c/p\u003e\n\u003cp\u003eSystem V\u003c/p\u003e\n\u003cp\u003eXPG\u003c/p\u003e\n\u003cp\u003eSUS\u003c/p\u003e\n\u003ch1 id=\"glibc\"\u003eglibc\u003c/h1\u003e\n\u003cp\u003eLinux的标准C库glibc\u003c/p\u003e\n\u003cp\u003e遵循ISO C11 和 POSIX.1-2008, 还包括一些其它标准。\u003c/p\u003e\n\u003cp\u003e关于ISO C 和 POSIX参考另外两篇博文。\u003c/p\u003e\n\u003ch1 id=\"msvcrt\"\u003emsvcrt\u003c/h1\u003e\n\u003cp\u003ewindows的标准c库msvcrt.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"c注释\"\u003eC注释\u003c/h1\u003e\n\u003cp\u003e单行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// comment\n\n/* comment */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/*\n * comment1\n * commenet2\n */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"文档\"\u003e文档\u003c/h1\u003e\n\u003cp\u003eC程序可以用doxygen从程序中提取文档。\u003c/p\u003e\n\u003cp\u003e文档注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/**\n * @file\n * @brief\n * @author\n * @date\n * @version\n * @copyright\n */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"编译和链接\"\u003e编译和链接\u003c/h1\u003e\n\u003cp\u003e编译只检查语法错误和函数以及变量是否申明．将*.c源文件编译成*.o目标文件．\u003c/p\u003e",
    "content": "C标准 ISO C89(ANSI C89) -\u0026gt; ISO C99 -\u0026gt; ISO C11\nANSI C 和 ISO C是对通用C语言的接口的定义。\n符合这种标准的实现为C语言标准库,也叫libc。\nUnix/Linux的POSIX包含libc。\nLinux的glibc包含libc及其扩展.\nWindows的msvcrt包含libc及其扩展.\n其它和C相关的标准：\nBSD\nSystem V\nXPG\nSUS\nglibc Linux的标准C库glibc\n遵循ISO C11 和 POSIX.1-2008, 还包括一些其它标准。\n关于ISO C 和 POSIX参考另外两篇博文。\nmsvcrt windows的标准c库msvcrt.\nC注释 单行注释：\n// comment /* comment */ 多行注释：\n/* * comment1 * commenet2 */ 文档 C程序可以用doxygen从程序中提取文档。\n文档注释：\n/** * @file * @brief * @author * @date * @version * @copyright */ 编译和链接 编译只检查语法错误和函数以及变量是否申明．将*.c源文件编译成*.o目标文件．\ngcc -g -Wall -I/head/file/path -c -o helloworld.o helloworld.c 链接检查函数和变量的定义．将*.o目标文件链接之后生成可执行文件，或者打包成库文件*.a或*.so.\n# normal gcc -g -Wall -o helloworld helloworld.o # static library *.a gcc -g -Wall -o libstatic.a helloworld.o -L/static/lib/path -lstatic # dynamic library *.o gcc -g -Wall -o libdynamic.so helloworld.o -L/dynamic/lib/path -ldynamic -Wl, -rpath=/dynamic/lib/path ",
    "categories": ["C"],
    "tags": ["summary"]
  },
  {
    "title": "Posix",
    "permalink": "https://canuxcheng.com/post/c_posix/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"posix标准\"\u003ePOSIX标准\u003c/h1\u003e\n\u003cp\u003ePortable Operating System Interface\u003c/p\u003e\n\u003cp\u003e可移植性操作系统接口, POSIX兼容ISO C。\u003c/p\u003e\n\u003cp\u003e所有Unix都遵循，几乎所有Linux都遵循，Windows部分支持。\u003c/p\u003e\n\u003cp\u003ePOSIX.1/IEEE 1003.1-1990\u003c/p\u003e\n\u003cp\u003ePOSIX.2/IEEE Std 1003.2-1992/ISO IEC 9945-2:1993)\u003c/p\u003e\n\u003cp\u003ePOSIX.1.b/IEEE Std 1003.1b-1993/ISO IEC 9945-1:1996)\u003c/p\u003e\n\u003cp\u003ePOSIX.1.c/IEEE Std 1003.1c-1995\u003c/p\u003e\n\u003cp\u003ePOSIX.1.d/IEEE  Std  1003.1c-1999\u003c/p\u003e\n\u003cp\u003ePOSIX.1.g/IEEE Std 1003.1g-2000\u003c/p\u003e\n\u003cp\u003ePOSIX.1.j/IEEE  Std  1003.1j-2000\u003c/p\u003e\n\u003cp\u003ePOSIX.1-2001/SUSv3(包括了所有C99的API)\u003c/p\u003e\n\u003cp\u003ePOSIX.1-2008/SUSv4\u003c/p\u003e\n\u003cp\u003e官方网站：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.opengroup.org/austin/\"\u003ehttp://www.opengroup.org/austin/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"cygwin\"\u003eCygwin\u003c/h1\u003e\n\u003cp\u003e提供POSIX的API用于windows上开发Linux/Unix程序。\u003c/p\u003e\n\u003cp\u003e源代码不能在windows运行。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://cygwin.com/index.html\"\u003ehttps://cygwin.com/index.html\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"posix标准定义的必须头文件\"\u003ePOSIX标准定义的必须头文件\u003c/h1\u003e\n\u003ch2 id=\"direnth\"\u003e\u0026lt;dirent.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"fcntlh\"\u003e\u0026lt;fcntl.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"globh\"\u003e\u0026lt;glob.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"netdbh\"\u003e\u0026lt;netdb.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"pwdh\"\u003e\u0026lt;pwd.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"regexh\"\u003e\u0026lt;regex.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"tarh\"\u003e\u0026lt;tar.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"termiosh\"\u003e\u0026lt;termios.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"unistdh\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"utimeh\"\u003e\u0026lt;utime.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"utimeh-1\"\u003e\u0026lt;utime.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"wordexph\"\u003e\u0026lt;wordexp.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"arpaineth\"\u003e\u0026lt;arpa/inet.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"netifh\"\u003e\u0026lt;net/if.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"netinetinh\"\u003e\u0026lt;netinet/in.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"netinettcph\"\u003e\u0026lt;netinet/tcp.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysmmanh\"\u003e\u0026lt;sys/mman.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysselecth\"\u003e\u0026lt;sys/select.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"syssocketh\"\u003e\u0026lt;sys/socket.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysstath\"\u003e\u0026lt;sys/stat.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"systimesh\"\u003e\u0026lt;sys/times.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"systypesh\"\u003e\u0026lt;sys/types.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysunh\"\u003e\u0026lt;sys/un.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysutsnameh\"\u003e\u0026lt;sys/utsname.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"waith\"\u003e\u0026lt;wait.h\u0026gt;\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"posix标准定义的可选头文件\"\u003ePOSIX标准定义的可选头文件\u003c/h1\u003e\n\u003ch2 id=\"aioh\"\u003e\u0026lt;aio.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"pthreadh\"\u003e\u0026lt;pthread.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"semaphoreh\"\u003e\u0026lt;semaphore.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"mqueueh\"\u003e\u0026lt;mqueue.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"schedh\"\u003e\u0026lt;sched.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"spawnh\"\u003e\u0026lt;spawn.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stropsh\"\u003e\u0026lt;strops.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"traceh\"\u003e\u0026lt;trace.h\u0026gt;\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"posix标准定义的xsi扩展头文件\"\u003ePOSIX标准定义的XSI扩展头文件\u003c/h1\u003e\n\u003ch2 id=\"sysipch\"\u003e\u0026lt;sys/ipc.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysmsgh\"\u003e\u0026lt;sys/msg.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"syssemh\"\u003e\u0026lt;sys/sem.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysshmh\"\u003e\u0026lt;sys/shm.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"cpioh\"\u003e\u0026lt;cpio.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"dlfcnh\"\u003e\u0026lt;dlfcn.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"fmtmsgh\"\u003e\u0026lt;fmtmsg.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"ftwh\"\u003e\u0026lt;ftw.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"iconvh\"\u003e\u0026lt;iconv.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"langinfoh\"\u003e\u0026lt;langinfo.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"libgenh\"\u003e\u0026lt;libgen.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"monetaryh\"\u003e\u0026lt;monetary.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"ndbmh\"\u003e\u0026lt;ndbm.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"nl_typesh\"\u003e\u0026lt;nl_types.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"pollh\"\u003e\u0026lt;poll.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"searchh\"\u003e\u0026lt;search.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stringsh\"\u003e\u0026lt;strings.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"syslogh\"\u003e\u0026lt;syslog.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"ucontexth\"\u003e\u0026lt;ucontext.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"ulimith\"\u003e\u0026lt;ulimit.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"utmpxh\"\u003e\u0026lt;utmpx.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysresourceh\"\u003e\u0026lt;sys/resource.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysstatvfsh\"\u003e\u0026lt;sys/statvfs.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"systimeh\"\u003e\u0026lt;sys/time.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"systimebh\"\u003e\u0026lt;sys/timeb.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"sysuioh\"\u003e\u0026lt;sys/uio.h\u0026gt;\u003c/h2\u003e",
    "content": "POSIX标准 Portable Operating System Interface\n可移植性操作系统接口, POSIX兼容ISO C。\n所有Unix都遵循，几乎所有Linux都遵循，Windows部分支持。\nPOSIX.1/IEEE 1003.1-1990\nPOSIX.2/IEEE Std 1003.2-1992/ISO IEC 9945-2:1993)\nPOSIX.1.b/IEEE Std 1003.1b-1993/ISO IEC 9945-1:1996)\nPOSIX.1.c/IEEE Std 1003.1c-1995\nPOSIX.1.d/IEEE Std 1003.1c-1999\nPOSIX.1.g/IEEE Std 1003.1g-2000\nPOSIX.1.j/IEEE Std 1003.1j-2000\nPOSIX.1-2001/SUSv3(包括了所有C99的API)\nPOSIX.1-2008/SUSv4\n官方网站：\nhttp://www.opengroup.org/austin/\nCygwin 提供POSIX的API用于windows上开发Linux/Unix程序。\n源代码不能在windows运行。\nhttps://cygwin.com/index.html\nPOSIX标准定义的必须头文件 \u0026lt;dirent.h\u0026gt; \u0026lt;fcntl.h\u0026gt; \u0026lt;glob.h\u0026gt; \u0026lt;netdb.h\u0026gt; \u0026lt;pwd.h\u0026gt; \u0026lt;regex.h\u0026gt; \u0026lt;tar.h\u0026gt; \u0026lt;termios.h\u0026gt; \u0026lt;unistd.h\u0026gt; \u0026lt;utime.h\u0026gt; \u0026lt;utime.h\u0026gt; \u0026lt;wordexp.h\u0026gt; \u0026lt;arpa/inet.h\u0026gt; \u0026lt;net/if.h\u0026gt; \u0026lt;netinet/in.h\u0026gt; \u0026lt;netinet/tcp.h\u0026gt; \u0026lt;sys/mman.h\u0026gt; \u0026lt;sys/select.h\u0026gt; \u0026lt;sys/socket.h\u0026gt; \u0026lt;sys/stat.h\u0026gt; \u0026lt;sys/times.h\u0026gt; \u0026lt;sys/types.h\u0026gt; \u0026lt;sys/un.h\u0026gt; \u0026lt;sys/utsname.h\u0026gt; \u0026lt;wait.h\u0026gt; POSIX标准定义的可选头文件 \u0026lt;aio.h\u0026gt; \u0026lt;pthread.h\u0026gt; \u0026lt;semaphore.h\u0026gt; \u0026lt;mqueue.h\u0026gt; \u0026lt;sched.h\u0026gt; \u0026lt;spawn.h\u0026gt; \u0026lt;strops.h\u0026gt; \u0026lt;trace.h\u0026gt; POSIX标准定义的XSI扩展头文件 \u0026lt;sys/ipc.h\u0026gt; \u0026lt;sys/msg.h\u0026gt; \u0026lt;sys/sem.h\u0026gt; \u0026lt;sys/shm.h\u0026gt; \u0026lt;cpio.h\u0026gt; \u0026lt;dlfcn.h\u0026gt; \u0026lt;fmtmsg.h\u0026gt; \u0026lt;ftw.h\u0026gt; \u0026lt;iconv.h\u0026gt; \u0026lt;langinfo.h\u0026gt; \u0026lt;libgen.h\u0026gt; \u0026lt;monetary.h\u0026gt; \u0026lt;ndbm.h\u0026gt; \u0026lt;nl_types.h\u0026gt; \u0026lt;poll.h\u0026gt; \u0026lt;search.h\u0026gt; \u0026lt;strings.h\u0026gt; \u0026lt;syslog.h\u0026gt; \u0026lt;ucontext.h\u0026gt; \u0026lt;ulimit.h\u0026gt; \u0026lt;utmpx.h\u0026gt; \u0026lt;sys/resource.h\u0026gt; \u0026lt;sys/statvfs.h\u0026gt; \u0026lt;sys/time.h\u0026gt; \u0026lt;sys/timeb.h\u0026gt; \u0026lt;sys/uio.h\u0026gt; ",
    "categories": ["C"],
    "tags": ["posix"]
  },
  {
    "title": "Regular Expression",
    "permalink": "https://canuxcheng.com/post/regularexpression/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"re\"\u003eRE\u003c/h1\u003e\n\u003cp\u003e在线检测：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.regexpal.com/\"\u003ehttps://www.regexpal.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).\u003c/p\u003e\n\u003cp\u003e在BRE中+?(){}|没有特殊含义，除非用\\转义．\u003c/p\u003e\n\u003cp\u003e在ERE中+?(){}被保留有特殊含义，除非用\\转义才表示普通字符．\u003c/p\u003e\n\u003cp\u003e命令find, grep, sed, awk等都可以使用正则表达式．\u003c/p\u003e\n\u003cp\u003e特殊字符含义：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e()      对正则表达式分组, ERE\n\\n      再匹配前面的分组n次\n\n.       匹配任意单个字符, 换行符除外\n^tux    匹配以tux开始的行\ntux$    匹配以tux结束的行\n\n*+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配\n*           匹配前面一个字符0次或多次，包括前面这个字符本身\n+           匹配前面一个字符1次或多次，包括前面这个字符, ERE\n?           匹配前面一个字符0次或1次，包括前面这个字符, ERE\n{n}         匹配前面一个字符n次，包括前面这个字符, ERE\n{min,}      匹配前面一个字符至少min次，包括前面这个字符, ERE\n{min,max}   匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE\n\n下面是非贪婪匹配模式\n*?    匹配0个或多个\n+?    匹配1个或多个\n??    匹配０个或１个\n{n}?        只匹配n个\n{min,}?     至少min个\n{min,max}?  至少min个，最多max个\n\n[abc]   匹配包含在[]中的任意一个字符，除了\\, ^, -三个特殊字符\n[^abc]  匹配不包含在[]中的任意一个字符(和上面相反)\n[a-z]   匹配[]中指定范围内的任意一个字符\n[abc\\?] 用＼转义[]中的特殊字符\n\n|       表示逻辑或, ERE\n\n\\       转义字符，将特殊字符转义成普通字符\n\n小括号表示分组\n(...)\n(?...)\n(?iLmsux)\n(?:...)\n(?P\u0026lt;name\u0026gt;...)\n(?P=name)\n(?#...)\n(?=...)\n(?!...)\n(?\u0026lt;=...)\n(?\u0026lt;!...)\n(?(id/name)yes-pattern|no-pattern)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．\u003c/p\u003e",
    "content": "RE 在线检测：\nhttps://www.regexpal.com/\nRE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).\n在BRE中+?(){}|没有特殊含义，除非用\\转义．\n在ERE中+?(){}被保留有特殊含义，除非用\\转义才表示普通字符．\n命令find, grep, sed, awk等都可以使用正则表达式．\n特殊字符含义：\n() 对正则表达式分组, ERE \\n 再匹配前面的分组n次 . 匹配任意单个字符, 换行符除外 ^tux 匹配以tux开始的行 tux$ 匹配以tux结束的行 *+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配 * 匹配前面一个字符0次或多次，包括前面这个字符本身 + 匹配前面一个字符1次或多次，包括前面这个字符, ERE ? 匹配前面一个字符0次或1次，包括前面这个字符, ERE {n} 匹配前面一个字符n次，包括前面这个字符, ERE {min,} 匹配前面一个字符至少min次，包括前面这个字符, ERE {min,max} 匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE 下面是非贪婪匹配模式 *? 匹配0个或多个 +? 匹配1个或多个 ?? 匹配０个或１个 {n}? 只匹配n个 {min,}? 至少min个 {min,max}? 至少min个，最多max个 [abc] 匹配包含在[]中的任意一个字符，除了\\, ^, -三个特殊字符 [^abc] 匹配不包含在[]中的任意一个字符(和上面相反) [a-z] 匹配[]中指定范围内的任意一个字符 [abc\\?] 用＼转义[]中的特殊字符 | 表示逻辑或, ERE \\ 转义字符，将特殊字符转义成普通字符 小括号表示分组 (...) (?...) (?iLmsux) (?:...) (?P\u0026lt;name\u0026gt;...) (?P=name) (?#...) (?=...) (?!...) (?\u0026lt;=...) (?\u0026lt;!...) (?(id/name)yes-pattern|no-pattern) 匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．\n字符集:\n下列字符集是posix标准，用在[]中，也就是[[:alnum:]].\n[:alnum:] 可打印的字符，包括空白字符 [:alpha:]　字母字符 [:blank:]　空格和制表符，space, \\t [:cntrl\u0026quot;] 控制字符 [:digit:]　数字字符 [:graph:]　图形字符，不包括空白字符 [:lower:]　小写字符 [:print:]　可打印字符，包括空白字符 [:punct:]　标点符号字符 [:space:]　空白字符 [:upper:]　大写字符 [:xdigit:]　十六进制字符 字符集的简写(不同的编程语言可能不同)：\n\\b 匹配单词边界 \\B 匹配单词的非边界 \\A 匹配字符串的起始 \\Z　匹配字符串的结束 \\d 匹配任何数字０－９ \\D 匹配任何非数字，等效[^\\d] \\w 匹配任何数字和字母，a-z,A-Z,0-9 \\W 匹配任何非数字和非字母 \\s 匹配任何空白字符,包括space,\\t,\\n,\\r,\\f \\S 匹配任何非空白字符 \\h 匹配横向空白，包括space,\\t \\v 匹配纵向空白，包括\\f,\\r,\\n \\r 回车 \\R　匹配任何类型的断行 \\a \\f \\t \\n 常用正则表达式 .* 匹配任意字符０次或多次，除了换行符 ^$ 匹配空白行 [\\s\\S] 匹配任何空白字符和非空白字符 ^\\s\\+ 行首空格 \\s\\+$ 行尾空格 ^[^\u0026lt;] 不以\u0026lt;开头的字符串 ",
    "categories": ["Linux","Windows"],
    "tags": ["re"]
  },
  {
    "title": "Sed",
    "permalink": "https://canuxcheng.com/post/shell_sed/",
    "date": "2016-04-02",
    "summary": "\u003ch1 id=\"sed\"\u003esed\u003c/h1\u003e\n\u003cp\u003esed：stream editor  流编辑器 ，主要用于文本处理。\u003c/p\u003e\n\u003cp\u003esed命令格式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esed   -options   ’expression1;expression2’     file           执行多个命令\nsed   -options   [-e ‘expression1’] [-e ‘expression2’]  file  执行多个命令\nsed   -options   [-f   scriptfile]   file                     通过脚本执行命令\nsed   -options   [-f   scriptfile]   file  \u0026gt;  newfile  #sed修改后重定向到新文件。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esed指令需要用单引号包围。使用双引号“”可以传递变量。\nSed默认并没有修改文件file中的数据。\nsed默认在stdout输出文件的所有行。\nSed地址需要使用/address/来包围。\nsed使用正则表达式可以用\\BRE\\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。\u003c/p\u003e\n\u003cp\u003eoptions：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e-e：指定多个命令或脚本\n-f：指定执行命令的脚本\n-n：阻止自动输出，p可以打印匹配的行。\n-i: 直接修改读入的文件的内容.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eexperssion：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexpression：指令由模式和过程组成。\n[address]/[line-address][!]command[arguments]\n[address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。\n[line-address]表示只能是一个地址。\n[!] 表示不匹配该地址的所有行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCommand:\u003c/p\u003e\n\u003cp\u003esed有25个命令。\u003c/p\u003e\n\u003cp\u003e使用大括号{}在一个地址中做嵌套操作：例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/address1/,/address2/{\n    /^$/d\n    s/string1/string2/\n    …\n}             // 单独一行，后面不能有空格\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003es命令：替换，替换模式空间中的行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esed '[address]s/oldpattern/newpattern/[flag]' filename\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eflag:\u003c/p\u003e",
    "content": "sed sed：stream editor 流编辑器 ，主要用于文本处理。\nsed命令格式：\nsed -options ’expression1;expression2’ file 执行多个命令 sed -options [-e ‘expression1’] [-e ‘expression2’] file 执行多个命令 sed -options [-f scriptfile] file 通过脚本执行命令 sed -options [-f scriptfile] file \u0026gt; newfile #sed修改后重定向到新文件。 sed指令需要用单引号包围。使用双引号“”可以传递变量。 Sed默认并没有修改文件file中的数据。 sed默认在stdout输出文件的所有行。 Sed地址需要使用/address/来包围。 sed使用正则表达式可以用\\BRE\\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。\noptions：\n-e：指定多个命令或脚本 -f：指定执行命令的脚本 -n：阻止自动输出，p可以打印匹配的行。 -i: 直接修改读入的文件的内容. experssion：\nexpression：指令由模式和过程组成。 [address]/[line-address][!]command[arguments] [address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。 [line-address]表示只能是一个地址。 [!] 表示不匹配该地址的所有行 Command:\nsed有25个命令。\n使用大括号{}在一个地址中做嵌套操作：例如：\n/address1/,/address2/{ /^$/d s/string1/string2/ … } // 单独一行，后面不能有空格 s命令：替换，替换模式空间中的行。\nsed '[address]s/oldpattern/newpattern/[flag]' filename flag:\nn:替换每个寻址行的第n个匹配模式。默认n=1. n在1-512之间。 g:替换每个寻址行的所有匹配模式。 p:打印模式空间的内容 w file：如果发生替换就将这一行写入file。只写入替换的行,不写入其它行. 用反斜杠\\转义换行符：\n因为反斜杠在newpattern中也用于包含换行符。\n// 将匹配的项替换成两个换行符。 sed ' s/pattern/\\ (换行） \\ （换行） string/' filename 等价于： sed 's/pattern/\\n\\n/' filename 用反斜杠\\转义与符号\u0026amp;：\n// 结果是： string1 pattern string2 sed 's/pattern/string1 \u0026amp; string2/g' filename 如果不转义\u0026amp;匹配整个pattern:\n// 结果是：string1 \u0026amp; string2 sed 's/pattern/string1 \\\u0026amp; string2/g' filename 用反斜杠\\转义\\n:\n// 将pattern中匹配到的第一个字串回调到newpattern中使用。 sed 's/pattern/\\1/' filename d命令：删除，删除模式空间中的行，并不删除文件中的行。\n'[address]d' '1d' 删除第一行 '$d' 删除最后一行 ’/^$/d' 删除空行 ‘/^\\s\\+$/d’ 删除空白行（没有数字字符） ‘/^\\s*$/d’ 删除空白行（没有数字字符） a/i/c命令：追加/插入/更改.\n// 在匹配到的行下面添加追加的内容 '[line-address]a string' filename '[line-address]a\\ string1\\ string2\\ string3' filename （追加三行） i:同上，在匹配到的行上面插入内容。\n// 将匹配到的行替换掉。 '[address]c string' filename '[address]c\\ string1\\ string2\\ string3' filename l：列表命令\nsed '[address]l' filename 打印模式空间内容，将非打印字符显示为ASCII码 p：打印命令\nsed '[address]p' filename 打印模式空间内容 =：打印行号\nsed -n '[line-address]=' filename 只打印行号 n：下一步\nsed '[address]n' filename q:退出命令\n// 一旦找到和line-address匹配的行，脚本立即退出。 sed '[line-address]q' filename r/w:读/写命令\n// 读file文件追加在匹配到的行后面。 sed '[line-address]r file' filename // 将匹配到的行写入到file文件中 sed '[address]w file' filename sed –I 's/.*/\\L\u0026amp;/g' urfile 全部转换成小写 sed -I 's/.*/\\U\u0026amp;/g' urfile 全部转换成大写。 sed ‘/pattern/{{n; p;}}’ urfile 读取pattern下一行并打印。 n：追加下一个输入行到匹配后面并在两者间嵌入新行，改变行号。\np：打印匹配的第一行。\n常用 sed ‘$a string’ filenames #批量往文件最后一行添加内容 sed ‘$i string’ filenames #批量往文件倒数第二行添加内容 string里面有空格用\\开头。 ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "ISO",
    "permalink": "https://canuxcheng.com/post/c_iso/",
    "date": "2016-04-01",
    "summary": "\u003ch1 id=\"c标准库\"\u003eC标准库\u003c/h1\u003e\n\u003cp\u003eISO C89(ANSI C89) -\u0026gt; ISO C95 -\u0026gt; ISO C99 -\u0026gt;\u003c/p\u003e\n\u003cp\u003e-\u0026gt; ISO C11 -\u0026gt; ISO C17 -\u0026gt; ISO C23\u003c/p\u003e\n\u003cp\u003eANSI C 和 ISO C是对通用C语言的接口的定义。\u003c/p\u003e\n\u003cp\u003e符合这种标准的实现为C语言标准库,也叫libc。\u003c/p\u003e\n\u003cp\u003e官方网站：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.open-std.org/jtc1/sc22/wg14/www/standards\"\u003ehttp://www.open-std.org/jtc1/sc22/wg14/www/standards\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"c89和c99支持的头文件和函数\"\u003eC89和C99支持的头文件和函数\u003c/h1\u003e\n\u003ch2 id=\"asserth\"\u003e\u0026lt;assert.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"ctypeh\"\u003e\u0026lt;ctype.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"complexh\"\u003e\u0026lt;complex.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"errnoh\"\u003e\u0026lt;errno.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"floath\"\u003e\u0026lt;float.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"fenvh\"\u003e\u0026lt;fenv.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"inttypeh\"\u003e\u0026lt;inttype.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"iso646h\"\u003e\u0026lt;iso646.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"limitsh\"\u003e\u0026lt;limits.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"localeh\"\u003e\u0026lt;locale.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"mathh\"\u003e\u0026lt;math.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"setjmph\"\u003e\u0026lt;setjmp.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"signalh\"\u003e\u0026lt;signal.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdargh\"\u003e\u0026lt;stdarg.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stddefh\"\u003e\u0026lt;stddef.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdioh\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdlibh\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stringh\"\u003e\u0026lt;string.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdboolh\"\u003e\u0026lt;stdbool.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdinth\"\u003e\u0026lt;stdint.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"timeh\"\u003e\u0026lt;time.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"tgmathh\"\u003e\u0026lt;tgmath.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"wcharh\"\u003e\u0026lt;wchar.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"wctypeh\"\u003e\u0026lt;wctype.h\u0026gt;\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"c11支持的头文件和函数\"\u003eC11支持的头文件和函数\u003c/h1\u003e\n\u003ch2 id=\"stdalignh\"\u003e\u0026lt;stdalign.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"stdatomich\"\u003e\u0026lt;stdatomic.h\u0026gt;\u003c/h2\u003e\n\u003ch2 id=\"threadsh\"\u003e\u0026lt;threads.h\u0026gt;\u003c/h2\u003e\n\u003chr\u003e\n\u003ch1 id=\"c标准\"\u003eC++标准\u003c/h1\u003e\n\u003cp\u003eC++98, C++11, C++14, C++17, C++20, C++23\u003c/p\u003e\n\u003cp\u003ec++ 头文件不带.h用来和C区分。\u003c/p\u003e\n\u003ch2 id=\"核心功能\"\u003e核心功能\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zh.cppreference.com/w/cpp/language\"\u003ehttps://zh.cppreference.com/w/cpp/language\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"标准库\"\u003e标准库\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zh.cppreference.com/w/cpp/standard_library\"\u003ehttps://zh.cppreference.com/w/cpp/standard_library\u003c/a\u003e\u003c/p\u003e",
    "content": "C标准库 ISO C89(ANSI C89) -\u0026gt; ISO C95 -\u0026gt; ISO C99 -\u0026gt;\n-\u0026gt; ISO C11 -\u0026gt; ISO C17 -\u0026gt; ISO C23\nANSI C 和 ISO C是对通用C语言的接口的定义。\n符合这种标准的实现为C语言标准库,也叫libc。\n官方网站：\nhttp://www.open-std.org/jtc1/sc22/wg14/www/standards\nC89和C99支持的头文件和函数 \u0026lt;assert.h\u0026gt; \u0026lt;ctype.h\u0026gt; \u0026lt;complex.h\u0026gt; \u0026lt;errno.h\u0026gt; \u0026lt;float.h\u0026gt; \u0026lt;fenv.h\u0026gt; \u0026lt;inttype.h\u0026gt; \u0026lt;iso646.h\u0026gt; \u0026lt;limits.h\u0026gt; \u0026lt;locale.h\u0026gt; \u0026lt;math.h\u0026gt; \u0026lt;setjmp.h\u0026gt; \u0026lt;signal.h\u0026gt; \u0026lt;stdarg.h\u0026gt; \u0026lt;stddef.h\u0026gt; \u0026lt;stdio.h\u0026gt; \u0026lt;stdlib.h\u0026gt; \u0026lt;string.h\u0026gt; \u0026lt;stdbool.h\u0026gt; \u0026lt;stdint.h\u0026gt; \u0026lt;time.h\u0026gt; \u0026lt;tgmath.h\u0026gt; \u0026lt;wchar.h\u0026gt; \u0026lt;wctype.h\u0026gt; C11支持的头文件和函数 \u0026lt;stdalign.h\u0026gt; \u0026lt;stdatomic.h\u0026gt; \u0026lt;threads.h\u0026gt; C++标准 C++98, C++11, C++14, C++17, C++20, C++23\nc++ 头文件不带.h用来和C区分。\n核心功能 https://zh.cppreference.com/w/cpp/language\n标准库 https://zh.cppreference.com/w/cpp/standard_library\nhttps://cplusplus.com/reference/iostream/\nhttps://cplusplus.com/reference/string/\nSTL containers ",
    "categories": ["C"],
    "tags": ["iso"]
  },
  {
    "title": "Shell",
    "permalink": "https://canuxcheng.com/post/shell/",
    "date": "2016-04-01",
    "summary": "\u003ch1 id=\"shell\"\u003eShell\u003c/h1\u003e\n\u003cp\u003eLinux的shell有很多种,大多数linux发行版的默认登录shell是BASH。\u003c/p\u003e\n\u003cp\u003e查看当前使用的shell：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eecho $SHELL\necho $0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看安装了哪些shell：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecat /etc/shells\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e设置登陆shell:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$chsh -s $(which shellname)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eshell分为登陆shell和交互式shell:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 输出有i的就是交互shell\n$echo $-\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非交互登陆shell:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh)\u003c/li\u003e\n\u003cli\u003e然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin)\u003c/li\u003e\n\u003cli\u003e最后退出用户登陆~/.bash_logout\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e交互非登陆shell:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh))\u003c/li\u003e\n\u003cli\u003e然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"shell相关项目\"\u003eshell相关项目\u003c/h1\u003e\n\u003ch2 id=\"bash-it\"\u003ebash-it\u003c/h2\u003e\n\u003cp\u003e大部分发行版默认使用bash,无需额外安装。\u003c/p\u003e\n\u003cp\u003ebash的优化项目bash-it：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Bash-it/bash-it\"\u003ehttps://github.com/Bash-it/bash-it\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"zsh\"\u003ezsh\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://www.zsh.org/\"\u003ehttp://www.zsh.org/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"oh-my-zsh\"\u003eoh-my-zsh\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/robbyrussell/oh-my-zsh\"\u003ehttps://github.com/robbyrussell/oh-my-zsh\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"fish-shell\"\u003efish-shell\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/fish-shell/fish-shell\"\u003ehttps://github.com/fish-shell/fish-shell\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"oh-my-fish\"\u003eoh-my-fish\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/oh-my-fish/oh-my-fish\"\u003ehttps://github.com/oh-my-fish/oh-my-fish\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"thefuck\"\u003ethefuck\u003c/h2\u003e\n\u003cp\u003e一个纠正shell命令输错的命令\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/nvbn/thefuck\"\u003ehttps://github.com/nvbn/thefuck\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"shellcheck\"\u003eshellcheck\u003c/h2\u003e\n\u003cp\u003e一个debug脚本的工具．\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/koalaman/shellcheck\"\u003ehttps://github.com/koalaman/shellcheck\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"shell-script\"\u003eshell script\u003c/h1\u003e\n\u003cp\u003e基本语法\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#!/usr/bin/env bash\n\ncommand1 \u0026amp;\u0026amp; command2    # 当command1执行成功（返回0)才会执行command2\ncommand1 || command2    # 当command1执行失败（返回非0)才会执行command2\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"shell注释\"\u003eshell注释\u003c/h2\u003e\n\u003cp\u003e单行注释：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# comment\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e多行注释：\u003c/p\u003e",
    "content": "Shell Linux的shell有很多种,大多数linux发行版的默认登录shell是BASH。\n查看当前使用的shell：\necho $SHELL echo $0 查看安装了哪些shell：\ncat /etc/shells 设置登陆shell:\n$chsh -s $(which shellname) shell分为登陆shell和交互式shell:\n# 输出有i的就是交互shell $echo $- 非交互登陆shell:\n先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh) 然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin) 最后退出用户登陆~/.bash_logout 交互非登陆shell:\n先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh)) 然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin) shell相关项目 bash-it 大部分发行版默认使用bash,无需额外安装。\nbash的优化项目bash-it：\nhttps://github.com/Bash-it/bash-it\nzsh http://www.zsh.org/\noh-my-zsh https://github.com/robbyrussell/oh-my-zsh\nfish-shell https://github.com/fish-shell/fish-shell\noh-my-fish https://github.com/oh-my-fish/oh-my-fish\nthefuck 一个纠正shell命令输错的命令\nhttps://github.com/nvbn/thefuck\nshellcheck 一个debug脚本的工具．\nhttps://github.com/koalaman/shellcheck\nshell script 基本语法\n#!/usr/bin/env bash command1 \u0026amp;\u0026amp; command2 # 当command1执行成功（返回0)才会执行command2 command1 || command2 # 当command1执行失败（返回非0)才会执行command2 shell注释 单行注释：\n# comment 多行注释：\n:\u0026lt;\u0026lt;!EOF! comment !EOF! can be any symbol and character. !EOF! shell关键字和特殊符号 三个特殊命令\necho printf test 关键字\nfunction shell运算符和优先级 原生shell不支持数学运算，可以通过expr来实现．\n# expr表达式内部运算符前后要空格. val=`expr 2 + 2` 算术运算符\n+ - * # `expr $a \\* $b`, 不要转义 / % = # a=$b == # [ $a == $b ] , 需要中括号，需要空格 != # [ $a != $b ], 同上 关系运算符\n# 只支持数字，不支持字符串．需要中括号和空格 -eq -ne -gt -lt -ge -le 布尔运算符\n# 符合短路和斷路原则 ! # [ !false ] -o # [ exp1 -o exp2 ], 有一个为true就返回true -a # [ exp1 -a exp2], 两个都是true才返回true 逻辑运算\n|| \u0026amp;\u0026amp; 字符串运算符\n= != -Z # 字符串长度为0返回true -n # 字符串长度为0返回false str # [ $a ], 字符串不为空返回true 文件测试运算符\n-b -c -d -f -g -k -p -u -r -w -x -s -e shell数据结构和变量 变量类型：\n局部变量 环境变量 shell变量 定义变量:\n等号前后不能有空格 不能用数字开头命名变量 不能用标点符号和关键字 var=`ls /etc` # 返回的是stdout+stderr var=$(ls /etc) # 返回的是stdou+stderr 使用变量：\n$var ${var} # 使用双引号 var1=\u0026quot;pre${var}suf var2=\u0026quot;$var\u0026quot; 只读变量:\n使用readonly定义只读变量，不能再重新赋值 var=value readonly var 删除变量:\n使用unset删除变量，被删除的变量不能使用. var=value unset var 变量操作：\n${var/old/new} # 将变量中的old替换成new. ${var:start:end} # 获取变量的start到end个字符，相当于var[start:end],下标从0开始. 字符串类型：\n单引号的字符串是原样输出，其中的变量是无效的，里面不能有单引号. var='this is string' 双引号的字符串里面可以有变量，可以出现转义字符. var=\u0026quot;this is string\u0026quot; \u0026quot;outer \\\u0026quot;inner string\\\u0026quot; string\u0026quot; 获取字符串长度 var=\u0026quot;this is tring\u0026quot; echo ${#var} 字符串切片 var=\u0026quot;this is string\u0026quot; ${var:start:end} # 相当于var[start:end], 下标从0开始 获取pattern在string中的起始下标 string=\u0026quot;this is string\u0026quot; `expr index \u0026quot;$string\u0026quot; pattern` 数字类型：\n数组:\nshell控制流 # [[ 里面不能用 -o/-a ]] if [[ $status1 -eq 0 ]] || [[ $status2 -eq 0 ]] if [[ $status1 -eq 0 ]] \u0026amp;\u0026amp; [[ $status2 -eq 0 ]] # [ 单层可以用-o/-a ] if [ $status1 -eq 0 -o $status2 -eq 0 ] if\nif []; then command; ...; fi if condition then command fi []/test 中必须为执行的命令的stdout+stderr. if [ ! `cat file | grep pattern | wc -l` ] if [ ! 0 ] 此时0为真, [ ! 0 ]为假 if command 看返回码$?, 0表示真,其它表示假. if-else\nif condition; then command; ...; else command; fi if condition then command else command fi if-elif-else\nif condition; then command; ...; elif condition; then command; ...; else command; fi if condition then command elif condition then command else command fi while\nwhile condition; do command;...; done while condition do command done # 无限循环 while : do command done # 无限循环 while true do command done for\nfor ((i=1; i\u0026lt;=100; i++)) for i in {1..100} for i in `seq 1 100` for VAR in ${1,2,3,...}; do command; ...; done for var in item1 item2 ... itemN do command done # 无限循环 for (( ; ; )) until\nuntil condition; do command; ...; done until condition do command done case\ncase $VAR in val1) command ... ;; val2) command ... ;; esac break\ncontinue\nshell函数 return只是返回当前函数，不退出主程序\nexit直接退出主程序\n通过关键字function定义函数:\nfunction Name { // ()可省略 function Name() { ... # 如果不显示调用return返回，则函数返回最后一条命令的结果 return $? } 也可以直接定义函数:\nName() { ... } 函数返回码:\n$? 函数参数：\n$1 - $9 可以在函数内部获取调用函数时候传递进来的９个参数 ${10} - ${100} 获取第十个参数和后面的参数 特殊字符：\n$# 表示传递到脚本的参数个数,不包括程序本身 $* 传入所有参数 $@ 传入所有参数 $$ $! $- 输入输出和重定向 stdout和stdin重定向到一个地方:\n1\u0026gt; 只重定向stdout 2\u0026gt; 只重定向stderr 2\u0026gt;\u0026amp;1 同时重定向stdout+stderr main \u0026gt; 2\u0026gt;\u0026amp;1 log1.log | tee log2.log # 同时重定向到两个文件 main 2\u0026gt;\u0026amp;1 | tee ${LOG} # 同时将stdout和stderr输出到终端和日志文件. 文件包含 ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Coreutils",
    "permalink": "https://canuxcheng.com/post/shell_coreutils/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"linux的外部命令\"\u003eLinux的外部命令\u003c/h1\u003e\n\u003cp\u003eLinux外部命令的项目是coreutils。\u003c/p\u003e\n\u003cp\u003e外部命令在coreutils目录中\u003c/p\u003e\n\u003cp\u003e查看外部命令所在目录：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eecho $PATH\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e外部命令在下列目录中：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e~/bin # 用户自定义\n\n/sbin\n\n/bin\n\n/usr/sbin\n\n/usr/bin\n\n/usr/local/sbin\n\n/usr/local/bin\n\n/usr/games\n\n/usr/local/games\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看外部命令手册的在线手册：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eman [command]\ninfo [command]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e自定义外部命令：\u003c/p\u003e\n\u003cp\u003e添加$PATH变量，然后放到该目录。\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"系统管理\"\u003e系统管理\u003c/h1\u003e\n\u003cp\u003ecpu/mem/load\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 查看cpu/mem/swap/system信息\nvmstat\nvmstat 1\n\n# 查看进程消耗的cpu/mem/swap/system等系统信息\ntop\ntop -H  # 查看线程\n%cpu = cputime/realtime * 100%\ncpu_usage = %cpu/cpu-number\n%mem = RES/physicalMem * 100%\n\nhtop\n$ sudo apt-get install htop\n\n$ sudo apt-get install sysstat (包括pidstat)\npidstat -u -p pid // cpu\npidstat -r -p pid //mem\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecpu/load:\u003c/p\u003e",
    "content": "Linux的外部命令 Linux外部命令的项目是coreutils。\n外部命令在coreutils目录中\n查看外部命令所在目录：\necho $PATH 外部命令在下列目录中：\n~/bin # 用户自定义 /sbin /bin /usr/sbin /usr/bin /usr/local/sbin /usr/local/bin /usr/games /usr/local/games 查看外部命令手册的在线手册：\nman [command] info [command] 自定义外部命令：\n添加$PATH变量，然后放到该目录。\n系统管理 cpu/mem/load\n# 查看cpu/mem/swap/system信息 vmstat vmstat 1 # 查看进程消耗的cpu/mem/swap/system等系统信息 top top -H # 查看线程 %cpu = cputime/realtime * 100% cpu_usage = %cpu/cpu-number %mem = RES/physicalMem * 100% htop $ sudo apt-get install htop $ sudo apt-get install sysstat (包括pidstat) pidstat -u -p pid // cpu pidstat -r -p pid //mem cpu/load:\n$ sudo apt-get install sysstat (包括mpstat) mpstat -P ALL 1 5 // cpu uptime lscpu # 显示cpu架构的信息 cat /proc/cpuinfo # 查看cpu信息 cat /proc/cpuinfo | grep \u0026quot;processor\u0026quot; | wc -l # 逻辑cpu总数 cat /proc/cpuinfo | grep \u0026quot;physical id\u0026quot; | sort | uniq | wc -l # 物理cpu个数 cat /proc/cpuinfo | grep \u0026quot;cpu cores\u0026quot; | uniq # 物理cpu核数 cat /proc/cpuinfo | grep -e \u0026quot;cpu cores\u0026quot; -e \u0026quot;siblings\u0026quot; | sort | uniq # 和cpu cores一样说明没有启用超线程. processor: 逻辑cpu总数=物理cpu个数*物理cpu核数（非超线程）， 物理cpu个数*物理cpu核数*2（超线程cpu). physical id :物理cpu个数(每个socket/插槽可以放一个物理cpu). cpu cores: 物理cpu有几个核(如果是超线程技术的cpu,每个核可以运行两个线程，或者说每个核对应两个逻辑cpu）。 siblings： 每个物理cpu单个核心上的逻辑cpu个数 strace strace -c -p pid strace -T -e epoll_wait -p pid dmesg mem:\nfree free -m cat /proc/meminfo # 查看内存信息 pmap pmap -d pid system:\nuname # 打印linux系统信息 $ uname -a cat /etc/issue cat /proc/version lsb_release # 查看发行版本信息 $ lsb_release -a getconf # 查询系统配置的变量，LONG_BIT表示系统位数 process:\nps # 格式化输出，逗号后面不能有空格 ps -eo/-Ao %cpu/pcpu,%mem/pmem,stat,start/start_time/lstart,pid,ppid,cmd/args/command ps --ppid 1 -o pid,command | grep -v grep | grep daemon # 获取多进程程序主进程的pid pstree -a pkill pkill -f \u0026lt;pattern\u0026gt; # 杀死args匹配的进程 pgrep -P pid # 内核也有一个kill命令 kill killall killall -e \u0026lt;deamon\u0026gt; # 杀死匹配的守护进程. crontab:\n$ sudo apt-get install cron # /etc/crontab 设置了环境变量 crontab crontab -l # 列出 crontab -e # 编辑 crontab -u \u0026lt;user\u0026gt; file # 导入配置/etc/cron.d/my-cron-file editor:\n# 修改默认编辑器nano select-editor 时区管理\ntimedatectl list-timezones # 查看所有时区 sudo timedatectl set-timezone Asia/Shanghai # 设置时区 ls -l /etc/localtime # 应该是一个链接 update-alternatives:\nupdate-alternatives --display python // 查看候选项 update-alternatives --config python // 选择候选项 update-alternatives --set python /usr/bin/python // 添加候选项 update-alternatives --install /usr/bin/python python /usr/bin/python3.7 1 // 设置候选项的link update-alternatives --remove python /usr/bin/python3.5 // 删除候选项的link 用户和权限管理 id id -u 打印当前用户uid(root uid=0) chmod:\n# 当文件的owner的x位置为s,表示设置了SUID, 仅对二进制可执行文件有效. # 如果执行者对该文件有可执行权限，那么执行者在执行该文件期间，就拥有了该文件的owner的权限. -rwsr-xr-x file chmod u+s \u0026lt;file\u0026gt; # 加SUID chmod 4777 \u0026lt;file\u0026gt; -rwxr-sr-x file/dir chmod g+s \u0026lt;file\u0026gt;/\u0026lt;dir\u0026gt; # 加SGID chmod 2777 \u0026lt;dir\u0026gt; drwxrwxrwt dir chmod o+t \u0026lt;dir\u0026gt; # 加SBIT chmod 1777 \u0026lt;dir\u0026gt; chown chgrp chattr usermod\n# 禁止root登录 usermod --shell /sbin/nologin root adduser:\nadduser addgroup useradd:\nuseradd useradd -r -m -U -G sudo -s /bin/bash \u0026lt;user\u0026gt; -U, --user-group create a group with the same name as the user -m, --create-home create the user's home directory -s, --shell SHELL login shell of the new account -r, --system create a system account -G, --groups GROUPS list of supplementary groups of the new account userdel usermod usermod -G g1,g2 -a user // 将用户追加到组 users # 查看当前登陆的用户 groupadd groupdel groupmod groups # 查看指定用户所属的组，默认当前用户的组 gpasswd:\n$ gpasswd -d \u0026lt;user\u0026gt; \u0026lt;group\u0026gt; // 从组里删除用户 chpasswd:\necho \u0026quot;username:password\u0026quot; | chpasswd # 修改username的密码 passwd\npasswd su:\nsu \u0026lt;user\u0026gt; -c \u0026lt;command\u0026gt; sudo:\nsudo -i 文件和目录管理 mkdir tree cat col colrm comm csplit ed ex fmt fold join look mtype pico sort tr expr uniq wc cksum cmp diff diffstat file cut less more locate lsattr mattrib mdel mdir mktemp mmove mren mtools mtoolstest mv od paste patch rcp rm split touch umask which cp whereis mcopy mshowfat lprm lpr lpq rev toilet aafire xeyes pv yes cal factor typeset\ntypeset -u VAR // 变量大写 VAR='test' echo $VAR # TEST typeset -l VAR // 变量小写 tee\nmain \u0026gt; 2\u0026gt;\u0026amp;1 log1.log | tee log2.log # 同时重定向到两个文件 main 2\u0026gt;\u0026amp;1 | tee ${LOG} # 同时将stdout和stderr输出到终端和日志文件. $ echo \u0026quot;content\u0026quot; | sudo tee filename # 写入到root权限的文件 $ echo \u0026quot;text\u0026quot; | sudo tee -a filename # append lsof查看打开的文件资源:\nlsof # lsof -i # 查看 sudo lsof -i :port # 查看端口是否被使用 readlink:\nreadlink 获取符号连接信息 sudo readlink /proc/1/exe ln:\nln TARGET LINK_NAME # 创建文件的硬链接,目录不能创建硬链接 -s, --symbolic ln -s TARGET LINK_NAME # 创建文件或目录的软链接 dirname:\ndirname dirname $0 # 获取当前文件所在目录的相对路径, 也就是. $(cd $(dirname $0) \u0026amp;\u0026amp; pwd) # 获取当前文件所在目录的绝对路径 rsync:\nrsync rsync [OPTION]... SRC [SRC]... DEST rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST rsync [OPTION]... [USER@]HOST:SRC [DEST] rsync -rtvzuOPH --delete -e \u0026quot;ssh -o StrictHostKeyChecking=no\u0026quot; -v verbose -a archive == -rlptgoD -u --update # 跳过目的地址上modification time更新的文件 --inplace --append --append-verify -r --recursive -z --compress --progress --partial -P == --partial --progress --devices --specials -D == --devices --specials -H --hard-links preserve hard-link -l --links copy symlinks as symlinks 保留软链接 -L copy symlinks to dest 复制原始文件 --delete 从dest删除src没有的文件 -h --human-readable -g --group preserve group -o --owner preserve owner -p --perms preserve permissions -t --times preserve modification times -O, --omit-dir-times 忽略目录的modification times. --exclude 排除文件 计算文件空间使用:\ndu $ du -sh 四个用到正则表达式的重要命令：\nsed awk grep/ack/ag find 压缩备份 tar(.tar)\ntar -c, --create # 创建归档 -u, --update # 更新归档文件 -x, --extract, --get # 提取归档 tar cvf name.tar folder tar xvf name.tar compression options: -j, --bzip2 -J, --xz -z, --gzip, --gunzip, --ungzip -Z, --compress, --uncompress device selection and switching: -f, --file=ARCHIVE informative output: -v, --verbose gzip(.gz)\ngzip gunzip tar zxvf file.tar.gz tar zcvf file.tar.gz dir bzip2(.bz2)\nbzip2 bunzip2 tar jxvf file.tar.bz2 tar jcvf file.tar.bz2 dir compress(.z)\ncompress uncompress tar Zxvf file.tar.z xz(.xz)\nxz unxz tar Jxvf file.tar.xz gzip/gunzip\ngunzip name.gz gzip -d name.gz zip(.zip)\nzip unzip 7z(.7z)\n$ sudo apt-get install p7zip/p7zip-full/p7zip-rar 7z 数据处理 base64\n// 生成basic authentication. echo -n \u0026quot;user:pw\u0026quot; | base64 ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Utils",
    "permalink": "https://canuxcheng.com/post/shell_utils/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"linux的第三方命令\"\u003eLinux的第三方命令\u003c/h1\u003e\n\u003cp\u003eLinux外部命令的项目是coreutils.\u003c/p\u003e\n\u003cp\u003e外部命令在coreutils目录中.\u003c/p\u003e\n\u003cp\u003e第三方命令(相当于外部命令)．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"文件和目录管理\"\u003e文件和目录管理\u003c/h1\u003e\n\u003cp\u003eautojump:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wting/autojump\"\u003ehttps://github.com/wting/autojump\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003efasd:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/clvv/fasd\"\u003ehttps://github.com/clvv/fasd\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003efzf:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/junegunn/fzf\"\u003ehttps://github.com/junegunn/fzf\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"压缩备份\"\u003e压缩备份\u003c/h1\u003e\n\u003ch1 id=\"磁盘管理\"\u003e磁盘管理\u003c/h1\u003e\n\u003ch1 id=\"设备管理\"\u003e设备管理\u003c/h1\u003e\n\u003chr\u003e",
    "content": "Linux的第三方命令 Linux外部命令的项目是coreutils.\n外部命令在coreutils目录中.\n第三方命令(相当于外部命令)．\n文件和目录管理 autojump:\nhttps://github.com/wting/autojump\nfasd:\nhttps://github.com/clvv/fasd\nfzf:\nhttps://github.com/junegunn/fzf\n压缩备份 磁盘管理 设备管理 ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "Builtins",
    "permalink": "https://canuxcheng.com/post/shell_builtins/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"linux内置命令\"\u003eLinux内置命令\u003c/h1\u003e\n\u003cp\u003e内置命令在bash/builtins目录中\u003c/p\u003e\n\u003cp\u003eshell命令分为内置命令和外部命令.\u003c/p\u003e\n\u003cp\u003e查看一个命令是内置命令还是外部命令：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype -a [command]\n\n提示\u0026quot;[command] is a shell builtin\u0026quot;就表示是内置命令，否则就是外部命令。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看所有内置命令：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehelp\nenable -a\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e查看内置命令的帮助：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehelp [command]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cpre\u003e\u003ccode\u003etype\nenable\nhelp\n\ncaller\nalias\nbg\nbind\nbreak\nbuiltin\ncommand\ncompgen\ncomplete\ncompopt\ncontinue\ndeclare\ndisown\nlet\nlocal\nlogout\nmapfile\npopd\nprintf\npushd\nread\nreadarray\nreadonly\nreturn\nshift\nshopt\nsource\nsuspend\ntimes\ntrap\ntrue\ntypeset\nulimit\numask\nunalias\nunset\nwait\neval\nexec\nexit\nexport\nfalse\nfc\nfg\ngetopts\nhash\nhistory\njobs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e路径相关:\u003c/p\u003e",
    "content": "Linux内置命令 内置命令在bash/builtins目录中\nshell命令分为内置命令和外部命令.\n查看一个命令是内置命令还是外部命令：\ntype -a [command] 提示\u0026quot;[command] is a shell builtin\u0026quot;就表示是内置命令，否则就是外部命令。 查看所有内置命令：\nhelp enable -a 查看内置命令的帮助：\nhelp [command] type enable help caller alias bg bind break builtin command compgen complete compopt continue declare disown let local logout mapfile popd printf pushd read readarray readonly return shift shopt source suspend times trap true typeset ulimit umask unalias unset wait eval exec exit export false fc fg getopts hash history jobs 路径相关:\ncd dirs pwd test:\ntest set:\nset set -e 命令失败立即退出 set -x 执行前打印每行命令 set -u 未定义的变量会报错 set -o pipefail 对于有管道的操作，返回最后一个非零返回值的命令的返回码. set +e 取消前面设置的-e echo:\necho echo 'origin' # 不打印变量 echo \u0026quot;_${VAR}_\u0026quot; # 查看变量前后是否有空格. kill:\nkill # 查看所有信号 kill -l ",
    "categories": ["Linux"],
    "tags": ["shell"]
  },
  {
    "title": "FileSystem",
    "permalink": "https://canuxcheng.com/post/linux_filesystem/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"vfs\"\u003eVFS\u003c/h1\u003e\n\u003cp\u003eLinux采用虚拟文件系统，支持多个文件系统协议．\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"extext2ext3ext4\"\u003eext/ext2/ext3/ext4\u003c/h1\u003e\n\u003ch1 id=\"jfs2\"\u003eJFS2\u003c/h1\u003e\n\u003ch1 id=\"ramfs\"\u003eramfs\u003c/h1\u003e\n\u003cp\u003elinux的VM(虚拟内存)包括ramfs和swap.\u003c/p\u003e\n\u003cp\u003e对内存的支持\u003c/p\u003e\n\u003ch1 id=\"swap\"\u003eswap\u003c/h1\u003e\n\u003cp\u003e交换分区，当内存不足，会把内存上暂时不运行的程序保存到swap，获取部分内存空间运行．\u003c/p\u003e\n\u003ch1 id=\"tmpfs\"\u003etmpfs\u003c/h1\u003e\n\u003cp\u003e临时文件系统, 优先使用ramfs,　其次使用swap.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 挂载tmpfs\nmount -t tmpfs -o size=1024m tmpfs /path/to/mount\n# /etc/fstab　\ntmpfs /dev/shm tmpfs,defaults,size=512m 0 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"vfatfatntfs\"\u003evfat/fat/ntfs\u003c/h1\u003e\n\u003cp\u003ewindows文件系统\u003c/p\u003e\n\u003ch1 id=\"cifssmbfs\"\u003ecifs/smbfs\u003c/h1\u003e\n\u003ch1 id=\"nfs\"\u003enfs\u003c/h1\u003e",
    "content": "VFS Linux采用虚拟文件系统，支持多个文件系统协议．\next/ext2/ext3/ext4 JFS2 ramfs linux的VM(虚拟内存)包括ramfs和swap.\n对内存的支持\nswap 交换分区，当内存不足，会把内存上暂时不运行的程序保存到swap，获取部分内存空间运行．\ntmpfs 临时文件系统, 优先使用ramfs,　其次使用swap.\n# 挂载tmpfs mount -t tmpfs -o size=1024m tmpfs /path/to/mount # /etc/fstab　tmpfs /dev/shm tmpfs,defaults,size=512m 0 0 vfat/fat/ntfs windows文件系统\ncifs/smbfs nfs ",
    "categories": ["Linux"],
    "tags": ["filesystem"]
  },
  {
    "title": "Firewall",
    "permalink": "https://canuxcheng.com/post/linux_firewall/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"firewall\"\u003eFirewall\u003c/h1\u003e\n\u003cp\u003eUFW: linux防火墙配置工具，底层还是调用iptables.\u003c/p\u003e\n\u003cp\u003efilewall: centos的防火墙命令, 底层还是调用iptables.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"selinux\"\u003eSELinux\u003c/h1\u003e\n\u003cp\u003eSecurity-Enhanced-Linux\u003c/p\u003e\n\u003cp\u003e本地安全\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"netfilter\"\u003eNetfilter\u003c/h1\u003e\n\u003cp\u003e网络安全\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"iptables\"\u003eiptables\u003c/h1\u003e\n\u003cp\u003e通过iptables操作Netfilter实现应用层安全.\u003c/p\u003e\n\u003cp\u003etable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efilter 默认表\nnat\nmangle\nraw\nsecurity\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"filter\"\u003efilter\u003c/h2\u003e\n\u003cp\u003echain:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eINPUT\nFORWARD\nOUTPUT\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"nat\"\u003enat\u003c/h2\u003e\n\u003cp\u003echain:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eINPUT\nOUTPUT\nPREROUTING\nPOSTROUTING\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epostrouting:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esnat: 内网主机访问外网经过路由时，源ip会发生变化。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprerouting:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ednat:  外网访问内网经过路由时，目的ip会发生变化。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"iptables命令\"\u003eiptables命令\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e-L/--list  [chain [ rulenum]]\n-S/--list-rules [chain [rulenum]]\n-Z/--zero [chain [rulenum]]\n\n-A/--append chain\n-C/--check chain\n-N/--new chain\n\n-F/--flush [chain] // 删除chain中的rules.\n-X/--delete-chain [chain] // 删除自定义chain.\n\n-R/--replace chain rulenum\n-D/--delete chain [rulenum]\n-I/--insert chain [rulenum]\n\n-P/--policy chain target\n\n-E/--rename-chain old-chain new-chain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etables:\u003c/p\u003e",
    "content": "Firewall UFW: linux防火墙配置工具，底层还是调用iptables.\nfilewall: centos的防火墙命令, 底层还是调用iptables.\nSELinux Security-Enhanced-Linux\n本地安全\nNetfilter 网络安全\niptables 通过iptables操作Netfilter实现应用层安全.\ntable:\nfilter 默认表 nat mangle raw security filter chain:\nINPUT FORWARD OUTPUT nat chain:\nINPUT OUTPUT PREROUTING POSTROUTING postrouting:\nsnat: 内网主机访问外网经过路由时，源ip会发生变化。 prerouting:\ndnat: 外网访问内网经过路由时，目的ip会发生变化。 iptables命令 -L/--list [chain [ rulenum]] -S/--list-rules [chain [rulenum]] -Z/--zero [chain [rulenum]] -A/--append chain -C/--check chain -N/--new chain -F/--flush [chain] // 删除chain中的rules. -X/--delete-chain [chain] // 删除自定义chain. -R/--replace chain rulenum -D/--delete chain [rulenum] -I/--insert chain [rulenum] -P/--policy chain target -E/--rename-chain old-chain new-chain tables:\n-t/--table filter/nat/mangle options:\n[!] -p/--protocol [!] -s/--source [!] -d/--destination [!] -o/--out-interface [!] -i/--in-interface [!] -f/--fragment --dport destination-port --sport source-port -m, --match -j, --jump -g, --goto -c, --set-counters --line-number # 显示rulenum -v/--verbose -n/--numeric others:\n# 保存规则 iptables-save \u0026gt; firewall.txt # 加载规则 iptables-restore firewall.txt 开机启动:\niptables-save \u0026gt; /etc/iptables.rules vim /etc/network/if-pre-up.d/iptables #!/bin/bash iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables-restore /etc/iptables.rules ",
    "categories": ["Linux","Security"],
    "tags": ["firewall"]
  },
  {
    "title": "Grub",
    "permalink": "https://canuxcheng.com/post/linux_grub/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"grub\"\u003eGrub\u003c/h1\u003e\n\u003cp\u003e引导程序。\u003c/p\u003e\n\u003cp\u003elinux/unix的引导程序有lilo和grub。\u003c/p\u003e\n\u003ch1 id=\"配置\"\u003e配置\u003c/h1\u003e\n\u003cp\u003e修改grub:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo vim /boot/grub/grub.cfg\n\u003c/code\u003e\u003c/pre\u003e",
    "content": "Grub 引导程序。\nlinux/unix的引导程序有lilo和grub。\n配置 修改grub:\n$ sudo vim /boot/grub/grub.cfg ",
    "categories": ["Linux"],
    "tags": ["grub"]
  },
  {
    "title": "Linux",
    "permalink": "https://canuxcheng.com/post/linux/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"linux\"\u003eLinux\u003c/h1\u003e\n\u003cp\u003eLinux严格讲指的是Linux这一类操作系统的内核。\u003c/p\u003e\n\u003cp\u003eLinux内核的github：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux\"\u003ehttps://github.com/torvalds/linux\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLinux内核的站点：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.kernel.org/\"\u003ehttps://www.kernel.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e商业化的linux系统：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eredhat enterprise linux\u003c/li\u003e\n\u003cli\u003esuse enterprise linux\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e免费的服务器版本：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecentos (rhel的免费版服务器版)\u003c/li\u003e\n\u003cli\u003eopen suse\u003c/li\u003e\n\u003cli\u003edebian/ubuntu\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e免费的桌面版本：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003efedora (原来的redhat desktop linux)\u003c/li\u003e\n\u003cli\u003eopen suse\u003c/li\u003e\n\u003cli\u003edebian/ubuntu\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"linux桌面环境\"\u003eLinux桌面环境\u003c/h1\u003e\n\u003cp\u003eX windows\u003c/p\u003e\n\u003cp\u003eKDE\u003c/p\u003e\n\u003cp\u003eGNOME2(Mate)\u003c/p\u003e\n\u003cp\u003eGNOME3(Mate/Cinnamon)\u003c/p\u003e\n\u003cp\u003eUnity\u003c/p\u003e\n\u003cp\u003exface\u003c/p\u003e\n\u003cp\u003elxde\u003c/p\u003e\n\u003cp\u003eenlightenment(\u003ca href=\"https://www.enlightenment.org/start\"\u003ehttps://www.enlightenment.org/start\u003c/a\u003e)\u003c/p\u003e\n\u003ch1 id=\"linux桌面管理器\"\u003eLinux桌面管理器：\u003c/h1\u003e\n\u003cp\u003exDM\u003c/p\u003e\n\u003cp\u003egDM(gnome)\u003c/p\u003e\n\u003cp\u003ekDM(kde)\u003c/p\u003e\n\u003cp\u003elightDM\u003c/p\u003e\n\u003ch1 id=\"linux编程\"\u003eLinux编程\u003c/h1\u003e\n\u003ch2 id=\"linux程序调用结构\"\u003eLinux程序调用结构：\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e应用程序(包括shell外部命令)/Shell命令(也就是shell内部命令)\u003c/li\u003e\n\u003cli\u003eC标准库glibc(包括ISO C和POSIC封装的系统系统调用)\u003c/li\u003e\n\u003cli\u003eLinux系统调用\u003c/li\u003e\n\u003cli\u003eLinux内核\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"查看手册\"\u003e查看手册：\u003c/h2\u003e\n\u003cp\u003e查看man帮助:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ man man\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e手册章节:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eExecutable programs or shell commands\u003c/li\u003e\n\u003cli\u003eSystem calls (functions provided by the kernel)\u003c/li\u003e\n\u003cli\u003eLibrary calls (functions within program libraries)\u003c/li\u003e\n\u003cli\u003eSpecial files (usually found in /dev)\u003c/li\u003e\n\u003cli\u003eFile formats and conventions eg /etc/passwd\u003c/li\u003e\n\u003cli\u003eGames\u003c/li\u003e\n\u003cli\u003eMiscellaneous (including macro packages and conventions), e.g. man(7), groff(7)\u003c/li\u003e\n\u003cli\u003eSystem administration commands (usually only for root)\u003c/li\u003e\n\u003cli\u003eKernel routines [Non standard]\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e查看shell命令\u003c/p\u003e",
    "content": "Linux Linux严格讲指的是Linux这一类操作系统的内核。\nLinux内核的github：\nhttps://github.com/torvalds/linux\nLinux内核的站点：\nhttps://www.kernel.org/\n商业化的linux系统：\nredhat enterprise linux suse enterprise linux 免费的服务器版本：\ncentos (rhel的免费版服务器版) open suse debian/ubuntu 免费的桌面版本：\nfedora (原来的redhat desktop linux) open suse debian/ubuntu Linux桌面环境 X windows\nKDE\nGNOME2(Mate)\nGNOME3(Mate/Cinnamon)\nUnity\nxface\nlxde\nenlightenment(https://www.enlightenment.org/start)\nLinux桌面管理器： xDM\ngDM(gnome)\nkDM(kde)\nlightDM\nLinux编程 Linux程序调用结构： 应用程序(包括shell外部命令)/Shell命令(也就是shell内部命令) C标准库glibc(包括ISO C和POSIC封装的系统系统调用) Linux系统调用 Linux内核 查看手册： 查看man帮助:\n$ man man 手册章节:\nExecutable programs or shell commands System calls (functions provided by the kernel) Library calls (functions within program libraries) Special files (usually found in /dev) File formats and conventions eg /etc/passwd Games Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) System administration commands (usually only for root) Kernel routines [Non standard] 查看shell命令\nman 1 \u0026lt;cmd\u0026gt; 查到的是系统调用（实际上也是POSIX封装的同名函数）\nman 2 \u0026lt;name\u0026gt; // 查看系统调用所有函数宏 man 2 syscalls // 查看未实现的系统调用 man 2 unimplemented 查到的glibc（包括ISO C，POSIX的部分函数，其它库）\nman 3 \u0026lt;name\u0026gt; 查看标准：\nman 7 \u0026lt;name\u0026gt; // 查看glibc标准 man 7 libc // 查看C和Linux的标准 man 7 standards Grub 引导程序。\nwindows的引导程序是NTloader。\nlinux/unix的引导程序有lilo和grub。\n",
    "categories": ["Linux"],
    "tags": ["linux"]
  },
  {
    "title": "Monitoring",
    "permalink": "https://canuxcheng.com/post/linux_monitoring/",
    "date": "2016-03-31",
    "summary": "\u003ch1 id=\"inode\"\u003einode\u003c/h1\u003e",
    "content": "inode ",
    "categories": ["Linux"],
    "tags": ["monitoring"]
  },
  {
    "title": "Markdown",
    "permalink": "https://canuxcheng.com/post/markdown/",
    "date": "2016-03-28",
    "summary": "\u003ch1 id=\"markdown\"\u003eMarkdown\u003c/h1\u003e\n\u003ch2 id=\"markdown简介\"\u003eMarkdown简介\u003c/h2\u003e\n\u003cp\u003eMarkdown是一种轻量级文本标记语言, Markdown的目标是实现易读易写。\nMarkdown和html有很大区别，html是一种发布格式，markdown是一种书写格式。\u003c/p\u003e\n\u003cp\u003eMarkdown 中文手册：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://wowubuntu.com/markdown/index.html\"\u003ehttp://wowubuntu.com/markdown/index.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMarkdown 英文手册：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://daringfireball.net/projects/markdown/syntax\"\u003ehttp://daringfireball.net/projects/markdown/syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMarkdown文件的扩展名是md。\u003c/p\u003e\n\u003ch2 id=\"两个需要特殊处理的字符\"\u003e两个需要特殊处理的字符\u003c/h2\u003e\n\u003cp\u003e\u0026lt; 的表示方法：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026amp; l t ;\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u0026amp; 的表示方法：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026amp; a m p ;\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch1 id=\"区块元素\"\u003e区块元素\u003c/h1\u003e\n\u003ch2 id=\"段落和换行\"\u003e段落和换行\u003c/h2\u003e\n\u003cp\u003e段落前后要有一个或以上的空行（空格或制表符都可以）。\u003c/p\u003e\n\u003ch2 id=\"标题\"\u003e标题\u003c/h2\u003e\n\u003cp\u003emarkdown支持两个语法格式的标题\u003c/p\u003e\n\u003ch3 id=\"setext格式\"\u003esetext格式\u003c/h3\u003e\n\u003cp\u003e任意个数下等号=表示大标题:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTitle\n======\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e任意个数下减号表示副标题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSubtitle\n--------\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"atx格式\"\u003eatx格式\u003c/h3\u003e\n\u003cp\u003e一到六个#表示一到六阶标题,#后面有空格\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 一阶标题\n\n## 二阶标题\n\n### 三阶标题\n\n#### 四阶标题\n\n##### 五阶标题\n\n###### 六阶标题\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"区块引用\"\u003e区块引用\u003c/h2\u003e\n\u003cp\u003e使用\u0026gt;表示单层区块引用：\u003c/p\u003e\n\u003cp\u003e\u0026gt; block\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eblock\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e使用多个\u0026gt;嵌套使用：\u003c/p\u003e\n\u003cp\u003e\u0026gt;\u0026gt; block\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eblock\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\n\u003cp\u003e区块内也可以用标题，列表和代码区块等。\u003c/p\u003e\n\u003ch2 id=\"列表\"\u003e列表\u003c/h2\u003e\n\u003ch3 id=\"无序列表\"\u003e无序列表\u003c/h3\u003e\n\u003cp\u003e无序列表使用星号、加号或是减号作为列表标记,符号和字符之间有空格：\u003c/p\u003e",
    "content": "Markdown Markdown简介 Markdown是一种轻量级文本标记语言, Markdown的目标是实现易读易写。 Markdown和html有很大区别，html是一种发布格式，markdown是一种书写格式。\nMarkdown 中文手册：\nhttp://wowubuntu.com/markdown/index.html\nMarkdown 英文手册：\nhttp://daringfireball.net/projects/markdown/syntax\nMarkdown文件的扩展名是md。\n两个需要特殊处理的字符 \u0026lt; 的表示方法：\n\u0026amp; l t ;\n\u0026amp; 的表示方法：\n\u0026amp; a m p ;\n区块元素 段落和换行 段落前后要有一个或以上的空行（空格或制表符都可以）。\n标题 markdown支持两个语法格式的标题\nsetext格式 任意个数下等号=表示大标题:\nTitle ====== 任意个数下减号表示副标题：\nSubtitle -------- atx格式 一到六个#表示一到六阶标题,#后面有空格\n# 一阶标题 ## 二阶标题 ### 三阶标题 #### 四阶标题 ##### 五阶标题 ###### 六阶标题 区块引用 使用\u0026gt;表示单层区块引用：\n\u0026gt; block\nblock\n使用多个\u0026gt;嵌套使用：\n\u0026gt;\u0026gt; block\nblock\n区块内也可以用标题，列表和代码区块等。\n列表 无序列表 无序列表使用星号、加号或是减号作为列表标记,符号和字符之间有空格：\n* shopping list\nshopping list + shoppint list\nshopping list - shopping list\nshopping list 有序列表 有序列表使用数字和一个英文句点,符号和字符之间有空格：\nnumbered list numbered list 代码区块 简单地缩进 4 个空格或是 1 个制表符,一个代码区块会一直持续到没有缩进的那一行或是文件结尾。\n这是一个普通段落：\n这是一个代码区块。 缩进 代码区块结束。 分割线 三个以上的*-_都可以产生分割线:\n***\n---\n___\n区段元素 链接 行内式链接 [Link](https://github.com/crazy-canux)\nLink\n参考式链接 [Link][id]\n[id]:https://github.com/crazy-canux\n自动链接 网址:\n\u0026lt;https://github.com/crazy-canux\u0026gt;\nhttps://github.com/crazy-canux\n邮箱：\n\u0026lt;canuxcheng@gmail.com\u0026gt;\ncanuxcheng@gmail.com\n强调 用一个*或_表示强调，符号和字符中间没有空格\n斜体：*italic*\nitalic\n斜体： _italic_\nitalic\n粗体： **bold**\nbold\n粗体： __bold__\nbold\n代码 用反引号标记一小段代码：\n`monospace`\nmonospace\n图片 行内式图片 ![pic](/path/to/img.jpg)\n参考式图片 ![pic][id]\n[id]: /path/to/img.jpg\n反斜线 用反斜线\\来转移字符\n\\ 反斜线\n` 反引号\n* 星号\n_ 底线\n{} 花括号\n[] 方括号\n() 括弧\n# 井字号\n+ 加号\n- 减号\n. 英文句点\n! 惊叹号\n",
    "categories": ["Web"],
    "tags": ["markdown"]
  },
  {
    "title": "Nagios",
    "permalink": "https://canuxcheng.com/post/metrics_nagios/",
    "date": "2016-03-25",
    "summary": "\u003ch1 id=\"nagios\"\u003eNagios\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNagios is the industry standard in IT infrastructure monitoring\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNagios offers complete monitoring and alerting for servers, switches, applications, and services.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eNagios官方宣称nagios是IT基础监控的工业标准。\u003c/p\u003e\n\u003cp\u003eNagios提供对服务器，交换机，应用和服务的完整的监控和警报。\u003c/p\u003e\n\u003cp\u003eNagios是无agent的，nagios的plugin通过协议远程获取信息。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.nagios.org/\"\u003ehttps://www.nagios.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.nagios.com/\"\u003ehttps://www.nagios.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://exchange.nagios.org/\"\u003ehttps://exchange.nagios.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/NagiosEnterprises\"\u003ehttps://github.com/NagiosEnterprises\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/nagios-plugins\"\u003ehttps://github.com/nagios-plugins\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"nagios安装配置\"\u003eNagios安装配置\u003c/h1\u003e\n\u003ch2 id=\"nagios发展\"\u003eNagios发展\u003c/h2\u003e\n\u003cp\u003eNagios core 1.0\u003c/p\u003e\n\u003cp\u003eNagios core 2.0\u003c/p\u003e\n\u003cp\u003eNagios core 3.0\u003c/p\u003e\n\u003cp\u003eNagios XI\u003c/p\u003e\n\u003cp\u003eNagios core 4.0\u003c/p\u003e\n\u003cp\u003e目前nagios有两大阵营：\u003c/p\u003e\n\u003cp\u003e开源解决方案： Nagios core\u003c/p\u003e\n\u003cp\u003e商业解决方案： Nagios XI\u003c/p\u003e\n\u003ch2 id=\"nagios安装配置-1\"\u003eNagios安装配置\u003c/h2\u003e\n\u003cp\u003e安装和配置nagios core,plugins,addons参考\u003c/p\u003e\n\u003cp\u003e官方文档:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html\"\u003ehttps://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e中文文档：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://nagios-cn.sourceforge.net/nagios-cn/index.html\"\u003ehttp://nagios-cn.sourceforge.net/nagios-cn/index.html\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"nagios开源解决方案\"\u003eNagios开源解决方案\u003c/h1\u003e\n\u003ch2 id=\"nagios-core\"\u003eNagios core:\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNagios Core is the monitoring and alerting engine that serves as the primary application around which hundreds of Nagios projects are built.\u003c/p\u003e",
    "content": "Nagios Nagios is the industry standard in IT infrastructure monitoring\nNagios offers complete monitoring and alerting for servers, switches, applications, and services.\nNagios官方宣称nagios是IT基础监控的工业标准。\nNagios提供对服务器，交换机，应用和服务的完整的监控和警报。\nNagios是无agent的，nagios的plugin通过协议远程获取信息。\nhttps://www.nagios.org/\nhttps://www.nagios.com/\nhttps://exchange.nagios.org/\nhttps://github.com/NagiosEnterprises\nhttps://github.com/nagios-plugins\nNagios安装配置 Nagios发展 Nagios core 1.0\nNagios core 2.0\nNagios core 3.0\nNagios XI\nNagios core 4.0\n目前nagios有两大阵营：\n开源解决方案： Nagios core\n商业解决方案： Nagios XI\nNagios安装配置 安装和配置nagios core,plugins,addons参考\n官方文档:\nhttps://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/toc.html\n中文文档：\nhttp://nagios-cn.sourceforge.net/nagios-cn/index.html\nNagios开源解决方案 Nagios core: Nagios Core is the monitoring and alerting engine that serves as the primary application around which hundreds of Nagios projects are built.\nNagios core是监控和警报的主引擎，围绕它建立了成千上万的项目。 技术栈是c，只能安装在linux/unix系统。 Nagios core只是一个监控套件，本身没有监控功能，需要插件来完成监控。\nhttps://www.nagios.org/projects/nagios-core/\nhttps://github.com/NagiosEnterprises/nagioscore\nNagios plugins: Efficient, standalone extensions that provide low-level intelligence for monitoring anything and everything with Nagios Core.\nNagios core的监控插件,也就是官方插件,主要是c、shell和perl。\nhttps://www.nagios.org/projects/nagios-plugins/\nhttps://github.com/nagios-plugins/nagios-plugins\nNagios frontends: Web interfaces, themes, Windows and Linux interfaces, and mobile apps for Nagios. Change the look and style of Nagios to suite your needs.\nNagios frontends包括了 主题,web接口,移动设备接口。\nhttps://www.nagios.org/downloads/nagios-core-frontends/\nNagios config tools(Nagios addons projects): Tools and GUIs for simplifying Nagios Core configuration.\nnagios core的组件。\n包括Lilac,NagiosQL,NConf,OneCMDB,ignoramus\nhttps://www.nagios.org/projects/nagios-config-tools/\nhttps://www.nagios.org/downloads/nagios-core-addons/\nhttps://github.com/NagiosEnterprises\nNagios exchange: Nagios® Exchange is the central place where you\u0026rsquo;ll find all types of Nagios projects - plugins, addons, documentation, extensions, and more. This site is designed for the Nagios Community to share its Nagios creations.\nNagios exchange是nagios的开源宝库。\n包括第三方plugins、addons和docs。\nhttps://exchange.nagios.org/https://exchange.nagios.org/\nNagios商业解决方案 Nagios XI: Our most powerful IT infrastructure monitoring and IT monitoring software alerting solution for today’s demanding organizational requirements.\nNagios XI 是现代化的商业监控解决套件。\nNagios XI 使用nagios core 4.0。\nNagios XI 架构：\nNagios network analyzer Nagios log server Nagios fusion Nagios incident manager Nagios命令 /usr/local/nagios/bin/nagios --help -v 验证配置文件 -d daemon mode -W worker mode. Nagios 集中监控 本地监控 使用nagios core + plugins只能监控本地的linux/unix机器。\n远程监控 使用nagios core + plugins + addons可以监控远程的linux/unix/windows机器。\nNRPE(for linux)/NRPE_NT(for windows)和check_nrpe, 运行远程机器上的插件, 支持windows/unix/linux:\nnagios core + check_nrpe \u0026lt;=\u0026gt; NRPE/NRPE_NT + plugins NSCP和check_nt, 只能使用固定的几个命令查基本属性, 支持windows/linux/unix：\nnagios core + check_nt -H \u0026lt;NSCP IP\u0026gt; [-v \u0026lt;command\u0026gt;] \u0026lt;=\u0026gt; NSCP(NSClient++) NSCP和check_nrpe，可以传自己的命令或插件, 支持windows/linux/unix：\nnagios core + check_nrpe -H \u0026lt;NSCP IP\u0026gt; [-c \u0026lt;command/plugins\u0026gt;] [-a \u0026lt;argument list\u0026gt;] \u0026lt;=\u0026gt; NSCP(NSClient++) + plugins NSCP和NSCA/NRDP,NSCP主动check,然后将结果发送给NSCA/NRDP:\nnagios core + NSCA \u0026lt;=\u0026gt; NSCP(NSClient++) NCPA是python写的跨平台代理, 支持linux/windows/unix：\nnagios core + check_ncpa.py \u0026lt;=\u0026gt; NCPA Nagios 分布式监控 NRDP/NSCA/NSCA-ng 官方推荐，NRDP是NSCA的升级版,提供被动检测,这种方式效率低，稳定性差。\nnagios core \u0026lt;- plugins \u0026lt;- NSCA \u0026lt;= send_nsca \u0026lt;- ocsp \u0026lt;- Nagios core \u0026lt;=\u0026gt; Hosts ^ || send_nsca \u0026lt;- ocsp \u0026lt;- Nagios core \u0026lt;=\u0026gt; Hosts Nagios的组件 https://www.nagios.org/downloads/nagios-core-addons/\nhttps://github.com/NagiosEnterprises\nNDOUtils(NDO)/IDOUtils(IDO) 从nagios导出当前和历史数据到mysql数据库,需要安装数据库。\n相似功能有mk livestatus。\nN * (Nagios core + NDO module) -\u0026gt; TCP/Socket -\u0026gt; NDO2DB daemon -\u0026gt; DB\nhttps://github.com/NagiosEnterprises/ndoutils\nNSTI Nagios SNMP Trap Interface.\nhttps://github.com/NagiosEnterprises/nsti\nBPI Nagios Business Process Intelligence.\nhttps://github.com/NagiosEnterprises/nagiosbpi\n其它组件介绍 NCONF nagios的基于web的配置工具。\nhttp://www.nconf.org/dokuwiki/doku.php\nhttps://github.com/nconf/nconf\nDNX 分布式组件。\nhttp://dnx.sourceforge.net/\nhttps://sourceforge.net/projects/dnx/\nNagiosgraph nagiosgraph parses output and performance data from Nagios plugins and stores the data in RRD files. nagiosgraph creates graphs and generates HTML pages with graphic reports from the data.\n基于RRD，绘制nagios的性能图。\nhttp://nagiosgraph.sourceforge.net/\nhttps://sourceforge.net/projects/nagiosgraph/\nconsol的分布式监控方案 一家德国的咨询和解决方案软件公司。\n可以通过 check_MK 的omd来安装。\nhttps://www.consol.de/\nhttps://labs.consol.de/index.html\nhttps://github.com/ConSol\n主要贡献组件：\nhttps://github.com/sni\n主要贡献插件：\nhttps://github.com/lausser\nMod gearman labs consol的分布式监控组件, gearman的worker。\nhttp://www.mod-gearman.org/\nhttps://github.com/sni/mod_gearman\nNDOUtils/livestatus Event broker.\nThruk 基于perl的web框架catalyst的dashbord。\nhttp://www.thruk.org/\nhttps://github.com/sni/Thruk\nOp5的分布式监控方案 一家瑞典的监控和解决方案公司。\nhttps://www.op5.com/\nhttps://kb.op5.com/dashboard.action\nhttps://github.com/op5\nmerlin 分布式组件。\nhttps://kb.op5.com/display/MERLIN/Distributed+%28Merlin%29+Home\nhttps://github.com/op5/merlin\nNDOUtils/MK livestatus Eevent broker\nNinja Dashboard.\nhttps://kb.op5.com/display/GUI/GUI+%28Ninja%29+Home\nhttps://github.com/op5/ninja\n介绍Addons.\nOMD OMD implements a completely new concept of how to install, maintain and update a monitoring system built on Nagios.\nhttp://omdistro.org/\nhttp://git.mathias-kettner.de/git/?p=omd.git;a=tree\nThe Open Monitoring Distribution\n用于快速部署基于nagios的分布式监控，包括：\nIcinga/Shinken/check_MK\nMonitoring-Plugins和其它插件\nmod-gearman/MK Livestatus/thruk/multisite\nnsca/check_nrpe。\nNagVis/Pnp4nagios/rrdtool/dokuwiki\nGearman Gearman provides a generic application framework to farm out work to other machines or processes that are better suited to do the work.\nGearman用来做任务分发的.\n一个C++实现的Gearman Job Server:\nhttp://gearman.org/\nhttps://github.com/gearman/gearmand\n一个C实现的Gearman worker:\nhttp://www.mod-gearman.org/\nhttps://github.com/sni/mod_gearman\nrrdtools RRDtool is a little program for easily maintaining a database of time-series data. It comes with a charting program for drawing pretty graphs based on the data stored.\n存储性能数据。\nhttp://oss.oetiker.ch/rrdtool/\nhttps://github.com/oetiker/rrdtool-1.x\npnp4nagios PNP is an addon to Nagios which analyzes performance data provided by plugins and stores them automatically into RRD-databases.\n基于RRD，绘制nagios的性能图。\nhttp://docs.pnp4nagios.org/\nhttps://github.com/lingej/pnp4nagios\n可以在nagios的service配置中添加“ostpl_enable-graph\u0026quot;启用图形。\ntemplates.dist是自带模板\ntemplates是用户自定义模板\nXXX.php需要和nagios的service的command_name同名，默认查找这个同名的模板.\n测试就是scp XXX.php nagios-server:/usr/share/pnp4nagios/html/templates/然后去nagios查看结果\npnp4nagios查找顺序：\ntemplates/check_XXX.php templates.dist/check_XXX.php templates/default.php templates.dist/default.php Nagvis NagVis is a program for visualizing the data the monitoring core of your choice, for example Nagios, Naemon, Icinga or Shinken, in a human friendly way.\n绘制监控地图。\nhttp://www.nagvis.org/\nhttps://github.com/NagVis/nagvis\ndokuwiki DokuWiki is a simple to use and highly versatile Open Source wiki software that doesn\u0026rsquo;t require a database.\n创建监控的procedure。\nhttps://www.dokuwiki.org/dokuwiki/\nhttps://github.com/splitbrain/dokuwiki\ngraphite https://github.com/graphite-project\nhttp://graphite.readthedocs.io/en/latest/index.html\nZabbix,Sensu,Ganglia,Nagios/Naemon/Icinga/Shinken都可以配合使用。\n绘制性能图。\ngraphite-web\nA highly scalable real-time graphing system\ncarbon\nCarbon is responsible for receiving metrics over the network, caching them in memory for \u0026ldquo;hot queries\u0026rdquo; from the Graphite-Web application, and persisting them to disk using the Whisper time-series library.\nwhisper/ceres\nceres会替代whisper。\nWhisper is a fixed-size database, similar in design and purpose to RRD (round-robin-database). It provides fast, reliable storage of numeric data over time. Whisper allows for higher resolution (seconds per point) of recent data to degrade into lower resolutions for long-term retention of historical data.\ngrafana Grafana is an open source, feature rich metrics dashboard and graph editor for Graphite, Elasticsearch, OpenTSDB, Prometheus and InfluxDB.\n为graphite提供更好的可视化图形。\nhttps://github.com/grafana/grafana\nhttp://grafana.org/\ngraphios A program to send nagios perf data to graphite(carbon)/statsd/librato/influxdb\n发送nagios性能数据到Graphite。\nhttps://github.com/shawn-sterling/graphios\nLedbetter A simple script for gathering Nagios problem statistics and submitting them to Graphite. It focuses on summary (overall, servicegroup and hostgroup) statistics and writes them to the nagios.problems metrics namespace within Graphite.\n发送nagios性能数据到Graphite。\nhttps://github.com/github/ledbetter\nNSCP NSClient is an agent designed originally to work with Nagios but has since evolved into a fully fledged monitoring agent which can be used with numerous monitoring tools (like Icinga, Naemon, OP5, NetEye Opsview etc).\n又叫NSClient++,现在同时支持windows和linux,主要用来安装到windows服务器,用于监控windows系统.\nhttps://nsclient.org/\nhttps://github.com/mickem/nscp\n介绍Plugins\nMonitoring Plugins Nagios/naemon/icinga/shinken/centreon/opsview/sensu\nOffice project:\nhttps://github.com/monitoring-plugins\nhttps://www.monitoring-plugins.org/\nMy plugin project:\nhttps://github.com/crazy-canux/pymonitoringplugins\nOpen source project:\nhttps://github.com/crazy-canux/awesome-monitoring\nmonitoring-plugins negate 设置相反状态\n-o 设置ok对应状态 -w -c -u check_http [-f \u0026lt;ok|warning|critcal|follow|sticky|stickyport\u0026gt;] # 跳转 -p PORT # http:80, https:443 -a \u0026quot;USERNAME\u0026quot;:\u0026quot;PASSWORD\u0026quot; -u PATH --ssl=1/-S # https需要ssl -s SEARCH -e SEARCH,SEARCH... -l # 用在-r或-R前面,表示可以在多行进行正则匹配 -r # 正则匹配 -R # 大小写不敏感的正则匹配 -C # 检查证书, 不检查URL -t # timeout. -w # warning response time -c # critical response time Windows monitoring check_wmi_plus.pl\nIgnoreMyOutDatedPerlModuleVersions -m checkfolderfileage -a 'C:' -o '/tmp' -inc _FileAge=@0:1000 -c 10 -m check_file_count -a 'F:' -o '/folder' check_snmp_win_services.pl\n查windows的service\n-n \u0026lt;name\u0026gt;[,\u0026lt;name2\u0026gt;]... # 指定service名字，默认大小写不敏感,正则匹配，逗号分隔多个service，用display name。 -N=\u0026lt;n\u0026gt; # 匹配到service数量大于n就报错 -r # 精确匹配 check_smb_shares.pl\nLinux/Unix monitoring check_hpasm.pl OS X monitoring OSX-Monitoring-Tools Vitual Machine monitoring check_wmware_api.pl\ncheck_vmware_esx.pl\nDB monitoring check_mysql_health.pl\ncheck_oracle_health.pl\ncheck_db2_health.pl\ncheck_mssql_health.pl\n--name database/sql Network monitoring check_nwc_health.pl Storage monitoring check_snmp_storage.pl\n返回用了多少空间。\ncheck_disk\n返回剩余多少空间。\nLog monitoring check_logfiles.pl\ncheck_events.pl\nProcess monitoring check_snmp_process.pl\n-n \u0026lt;name\u0026gt; # process名字，大小写敏感，正则匹配，windows需要用processname.exe -r # 精确匹配 -w minW, maxW -c minC, maxC # minC \u0026lt;= minW \u0026lt; maxW \u0026lt; maxC Application monitoring check_sap_health.pl\ncheck_mailbox_health.pl\nMonitoring插件开发 Nagios Plugin API:\nhttps://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/pluginapi.html\nDeveloping Plugins For Use With Embedded Perl:\nhttps://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/epnplugins.html\nNagios plugin development guidelines:\nhttps://nagios-plugins.org/doc/guidelines.html\nMonitoring Plugin Development Guidelines:\nhttps://www.monitoring-plugins.org/doc/guidelines.html\nNagios不是基于agent的，所以插件都是通过协议来获取监控信息。\nplugin需要遵守下面规则：\n至少输出一行文本到STDOUT 事件状态由插件的返回码决定 输出：\njust support 4kb data shortoutput - $SERVICEOUTPUT$ perfdata - $SERVICEPERFDATA$ longoutput - $LONGSERVICEOUTPUT$ 返回码：\n0： OK（绿色） 1： Warning（黄色） 2： Critical（红色） 3： Unknown（深黄色） 阀值：\n10 | 0:10 | \u0026lt;0 or \u0026gt;10 alert 10: | 10:æ | \u0026lt;10 alert ~:10 | -æ:10 | \u0026gt;10 alert 10:20 | | \u0026lt;10 or \u0026gt;20 alert @10:20 | | \u0026gt;=10 and \u0026lt;=20 alert ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Zabbix",
    "permalink": "https://canuxcheng.com/post/metrics_zabbix/",
    "date": "2016-03-25",
    "summary": "\u003ch1 id=\"zabbix\"\u003eZabbix\u003c/h1\u003e",
    "content": "Zabbix ",
    "categories": ["DevOps"],
    "tags": ["monitoring"]
  },
  {
    "title": "Hexo",
    "permalink": "https://canuxcheng.com/post/hexo/",
    "date": "2016-03-22",
    "summary": "\u003ch1 id=\"hexo\"\u003eHexo\u003c/h1\u003e\n\u003ch2 id=\"什么是hexo\"\u003e什么是hexo\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHexo是用nodejs开发的快速、简洁且高效的博客框架，\nHexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003ehexo有大量的插件和主题。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://hexo.io/plugins/\"\u003eplugins\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://hexo.io/themes/\"\u003ethemes\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装hexo\"\u003e安装hexo\u003c/h2\u003e\n\u003cp\u003e需要安装依赖nodejs(包括npm)和git。\u003c/p\u003e\n\u003cp\u003e安装hexo命令行插件hexo-cli：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$sudo npm install hexo-cli -g\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"next\"\u003eNext\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNext是一种文雅的Hexo主题。\n一个主题，三种外观，选您所好。\n通过主题中的主题（亦称Scheme），您可以方便地改变您博客的外观，同时几乎所有配置同样适用。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/iissnan/hexo-theme-next\"\u003e原生的Next\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/crazy-canux/hexo-theme-next\"\u003e作者的Next\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"快速使用\"\u003e快速使用\u003c/h1\u003e\n\u003ch2 id=\"初始化\"\u003e初始化\u003c/h2\u003e\n\u003cp\u003e初始化一个hexo的目录：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$hexo init \u0026lt;folder\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"安装依赖\"\u003e安装依赖\u003c/h2\u003e\n\u003cp\u003e进入hexo目录安装依赖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$cd \u0026lt;folder\u0026gt;\n$sudo npm install \u0026lt;package-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e默认安装下列依赖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehexo\nhexo-server\nhexo-generator-index\nhexo-generator-archive\nhexo-generator-category\nhexo-generator-tag\nhexo-renderer-ejs\nhexo-renderer-marked\nhexo-renderer-stylus\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"查看文件和目录\"\u003e查看文件和目录\u003c/h2\u003e\n\u003cp\u003e安装完成后有下列\u003c/p\u003e\n\u003cp\u003e文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e_config.yml\ndb.json\npackage.json\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e目录：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enode_modules\nscaffolds\nsource\nthemes\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"生成静态文件\"\u003e生成静态文件\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$hexo g\n$hexo generate\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"启动本地服务器\"\u003e启动本地服务器\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e$hexo s\n$hexo server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用浏览器打开链接即可本地查看默认博客。\u003c/p\u003e",
    "content": "Hexo 什么是hexo Hexo是用nodejs开发的快速、简洁且高效的博客框架， Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\nhexo有大量的插件和主题。\nplugins\nthemes\n安装hexo 需要安装依赖nodejs(包括npm)和git。\n安装hexo命令行插件hexo-cli：\n$sudo npm install hexo-cli -g Next Next是一种文雅的Hexo主题。 一个主题，三种外观，选您所好。 通过主题中的主题（亦称Scheme），您可以方便地改变您博客的外观，同时几乎所有配置同样适用。\n原生的Next\n作者的Next\n快速使用 初始化 初始化一个hexo的目录：\n$hexo init \u0026lt;folder\u0026gt; 安装依赖 进入hexo目录安装依赖：\n$cd \u0026lt;folder\u0026gt; $sudo npm install \u0026lt;package-name\u0026gt; 默认安装下列依赖：\nhexo hexo-server hexo-generator-index hexo-generator-archive hexo-generator-category hexo-generator-tag hexo-renderer-ejs hexo-renderer-marked hexo-renderer-stylus 查看文件和目录 安装完成后有下列\n文件：\n_config.yml db.json package.json 目录：\nnode_modules scaffolds source themes 生成静态文件 $hexo g $hexo generate 启动本地服务器 $hexo s $hexo server 用浏览器打开链接即可本地查看默认博客。\n写博文 $hexo new post \u0026lt;article-name\u0026gt; 编辑这篇文章。\n清理生成文件和缓存 $hexo clean 再次运行hexo g和hexo s查看。\n安装部署插件 $sudo npm install hexo-deployer-git --save 修改全局配置文件，参考插件的github 针对github需要新建一个名字为\u0026lt;your-github-name\u0026gt;.github.io的仓库。\n部署到github $hexo d $hexo deploy 在浏览器打开http://\u0026lt;your-github-name\u0026gt;.github.io/查看博客。\n配置 全局配置 全局配置文件是\u0026lt;folder\u0026gt;/_config.yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site\ntitle: subtitle: description: author: language: zh-Hans timezone: Asia/Shanghai # URL\n## If your site is put in a subdirectory, set url as \u0026lsquo;http://yoursite.com/child' and root as \u0026lsquo;/child/\u0026rsquo;\nurl: http://\u0026lt;your-github-name\u0026gt;.github.io/ root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory\nsource_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing\nnew_post_name: :title.md # File name of new posts default_layout: post # post | page | draft titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: true tab_replace: '' # Category \u0026amp; Tag\ndefault_category: uncategorized category_map: tag_map: # Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10 pagination_dir: page # Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-canux Plugins: - hexo-deployer-git # Extend plugins\n## deploy\ndeploy: type: git repo: github: https://github.com/crazy-canux/crazy-canux.github.io.git,master coding: https://git.coding.net/Canux/Canux.git,master 主题配置 hexo官方默认主题是\u0026lt;folder\u0026gt;/themes/landscape。\n主题配置文件是\u0026lt;folder\u0026gt;/themes/landscape/_config.yml\n现在将默认主题替换成自己喜欢的主题：\ncd \u0026lt;folder\u0026gt;/themes git clone \u0026lt;github-url-of-your-favourite-theme\u0026gt; 然后将全局配置的 theme: landscape 改为 theme: \u0026lt;your-favourite-theme-name\u0026gt;\n部署 部署到github和coding(gitcafe)：\n$hexo clean $hexo g $hexo d github访问http://.github.io即可。\ncoding访问http://.coding.me/\n绑定自己的域名：\n在域名供应商购买域名后添加解析，记录类型A或者CNAME，主机类型@或者www，记录值可以是http://.github.io或者通过ping获取的ip地址。 在/source/新建文件CNAME，添加你购买的域名.com。 正常部署到github。 访问http://.com即可。 安装hexo插件 plugins\n$sudo npm install \u0026lt;plugin-name\u0026gt; --save 配置hexo插件 全局配置文件是\u0026lt;folder\u0026gt;/_config.yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next Plugins: - hexo-deployer-git # Extend plugins\n## deploy\ndeploy: type: git repo: git@github.com:\u0026lt;your-github-name\u0026gt;/\u0026lt;your-github-name\u0026gt;.github.io.git branch: master message: 站点地图 $npm install hexo-generator-sitemap --save ## sitemap\nsitemap: path: sitemap.xml https://github.com/hexojs/hexo-generator-sitemap\nRSS $npm install hexo-generator-feed --save ## feed\nfeed: type: atom path: atom.xml limit: 20 hub: https://github.com/hexojs/hexo-generator-feed\nSEO优化 $npm install hexo-generator-seo-friendly-sitemap --save sitemap: path: sitemap.xml https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap\nNext 以hexo主题next为例\n中文文档：\nhttp://theme-next.iissnan.com/\n英文文档：\nhttps://github.com/iissnan/hexo-theme-next/blob/master/README.en.md\n主题配置文件 主题配置文件在：\n\u0026lt;folder\u0026gt;/themes/next/_config.yml\n主题配置 # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 站点信息设置\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 将制作好的favicon图标放到/source里面。\nfavicon: /favicon.ico # SEO优化的关键字。\nkeywords: \u0026quot;Canux, CHENG, blog\u0026quot; # 指定站点的起始日期。\nsince: 2013 # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 菜单设置\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 顶部菜单栏\nmenu: home: / about: /about categories: /categories tags: /tags archives: /archives #commonweal: /404.html # 菜单栏图标,使用fontawsome\nmenu_icons: enable: true home: home about: user categories: th tags: tags archives: archive #commonweal: heartbeat # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 主题方案设计: Must | Mist | Pisces\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nscheme: Muse # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 捐赠设置\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nreward_comment: 您的支持是我创作的动力! wechatpay: /images/myimages/wechatpay.jpg alipay: /images/myimages/alipay.jpg # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 侧边栏设置\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 社交信息\nsocial: GitHub: https://github.com/crazy-canux Stackoverflow: http://stackoverflow.com/ LinkedIn: http://www.linkedin.com/profile/preview?locale=zh_CN\u0026amp;trk=prof-0-sb-preview-primary-button E-mail: mailto:canuxcheng@gmail.com # 社交信息图标，使用fontawsome。\nsocial_icons: enable: true GitHub: github LinkedIn: linkedin Stackoverflow: stack-overflow E-mail: envelope # 友情链接\nlinks_title: Links links: CSDN: http://bbs.csdn.net/home 51CTO: http://bbs.51cto.com/ ChinaUnix: http://bbs.chinaunix.net/ ITPUB: http://www.itpub.net/forum.php # 侧边栏图像\navatar: /images/myimages/avatar.jpg # TOC(table of contents)设置\ntoc: enable: true number: true # 设置 4.0 International 许可证: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero\ncreative_commons: zero # 侧边栏位置: left | right\nsidebar: position: left # 侧边栏显示方式： post | always | hide | remove\ndisplay: post # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 其它设置\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 使用Custom Logo.\ncustom_logo: enabled: false image: # 代码高亮主题: normal | night | night eighties | night blue | night bright\nhighlight_theme: night eighties # 自动滚动页面\nscroll_to_more: true # 自动摘录\nauto_excerpt: enable: true length: 150 # 使用Lato font\nuse_font_lato: true # \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 第三方插件: 一般都需要去插件的官网注册使用。\n# \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# MathJax Support\nmathjax: true # Google Analytics - US\n#google_analytics: # Facebook sdk Analytics - US\nfacebook_sdk: enable: false app_id: #\u0026lt;app_id\u0026gt; fb_admin: #\u0026lt;user_id\u0026gt; like_button: #true webmaster: #true # CNZZ Analytics - CN\ncnzz_siteid: ****** # leancloud Analytics - CN\nleancloud_visitors: enable: false app_id: #\u0026lt;app_id\u0026gt; app_key: #\u0026lt;app_key\u0026gt; # Baidu Analytics\n#baidu_analytics: ****** # Tencent Analytics\n#tencent_analytics: ****** # Disqus - US\n#disqus_shortname: ****** # Duoshuo - CN\nduoshuo_shortname: ****** # Make duoshuo show UA\nduoshuo_info: ua_enable: true admin_enable: false user_id: #admin_nickname: ROOT # Make duoshuo show hot artical\nduoshuo_hotartical: true # AddThis - US\n#add_this_id: # JiaThis - CN\njiathis: true # Baidu Share\n#baidushare: true # Duoshuo Share\n#duoshuo_share: true # Swiftype - US\nswiftype_key: ****** # Tinysou - CN\n#tinysou_Key #! \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n#! 谨慎编辑的主题信息\n#! \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n# 侧边栏移动插件 Motion\nuse_motion: true # 图片弹出插件 Fancybox\nfancybox: true # Static files\nvendors: vendors css: css js: js images: images # Theme version\nversion: 0.5.0 ",
    "categories": ["Web"],
    "tags": ["hexo"]
  },
  {
    "title": "Hugo",
    "permalink": "https://canuxcheng.com/post/hugo/",
    "date": "2013-04-01",
    "summary": "\u003ch1 id=\"hugo\"\u003eHugo\u003c/h1\u003e\n\u003cp\u003ego开发的静态站点生成器.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gohugoio/hugo\"\u003ehttps://github.com/gohugoio/hugo\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gohugo.io/\"\u003ehttps://gohugo.io/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"搭建博客\"\u003e搭建博客\u003c/h1\u003e\n\u003cp\u003e创建环境:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# linux, ubuntu18.04默认是非extended, 19.04 默认extended。\n$ sudo apt-get install hugo\n\n# extended支持Sass/scss\n$ sudo snap install hugo --channel=extended\n\n# windows\nPATH:   C:\\Hugo\\bin\\hugo.exe\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e测试安装:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ hugo help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建hugo项目:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd /home/canux/sites\n\u0026gt; cd C:\\hugo\\sites\n$ hugo new site canuxcheng.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成下列文件和目录:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econfig.toml\narchetypes\ncontent    # md 文件\ndata\nlayouts\nstatic\nthemes\nbytes\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch1 id=\"theme\"\u003eTheme\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gohugoio/hugoThemes\"\u003ehttps://github.com/gohugoio/hugoThemes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e下载所有主题:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd blog\ngit clone --depth 1 --recursive https://github.com/gohugoio/hugoThemes.git themes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下载单个主题：\u003c/p\u003e",
    "content": "Hugo go开发的静态站点生成器.\nhttps://github.com/gohugoio/hugo\nhttps://gohugo.io/\n搭建博客 创建环境:\n# linux, ubuntu18.04默认是非extended, 19.04 默认extended。 $ sudo apt-get install hugo # extended支持Sass/scss $ sudo snap install hugo --channel=extended # windows PATH: C:\\Hugo\\bin\\hugo.exe 测试安装:\n$ hugo help 创建hugo项目:\n$ cd /home/canux/sites \u0026gt; cd C:\\hugo\\sites $ hugo new site canuxcheng.com 生成下列文件和目录:\nconfig.toml archetypes content # md 文件 data layouts static themes bytes Theme https://github.com/gohugoio/hugoThemes\n下载所有主题:\ncd blog git clone --depth 1 --recursive https://github.com/gohugoio/hugoThemes.git themes 下载单个主题：\ncd themes git clone url 在config.toml添加主题：\ntheme = 'name' themesDir = \u0026quot;/path/to/themes\u0026quot; 创建主题:\n$ hugo new theme [name] 添加自己的主题:\n$ git submodule add https://github.com/crazy-canux/hugo-theme-canux.git 克隆主题：\n$ git submodule init $ git submodule update 创建页面 ## content/about.md $ hugo new about.md 创建文章 ## content/post/page.md $ hugo new post/Shell.md 本地测试 $ hugo server --theme=hyde --buildDrafts $ firefox http://localhost:1313 部署到github 先在github创建repo.\n$ hugo --theme=\u0026lt;theme\u0026gt; --baseUrl=\u0026quot;https://\u0026lt;user\u0026gt;.github.io/\u0026quot; push到github:\n$ cd public $ git init $ git remote add origin https://github.com/\u0026lt;user\u0026gt;/\u0026lt;user\u0026gt;.github.io.git $ git add -A $ git commit -m \u0026quot;first push.\u0026quot; $ git push -u origin master ",
    "categories": ["Web"],
    "tags": ["hugo"]
  },
  {
    "title": "Pelican",
    "permalink": "https://canuxcheng.com/post/pelican/",
    "date": "2013-04-01",
    "summary": "\u003ch1 id=\"pelican\"\u003ePelican\u003c/h1\u003e\n\u003cp\u003epython开发的静态站点生成器.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://blog.getpelican.com/\"\u003ehttp://blog.getpelican.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/getpelican/pelican\"\u003ehttps://github.com/getpelican/pelican\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html\"\u003ehttp://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://pelican-zh.readthedocs.io/en/latest/zh-cn/\"\u003ehttp://pelican-zh.readthedocs.io/en/latest/zh-cn/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"搭建博客\"\u003e搭建博客\u003c/h1\u003e\n\u003cp\u003e创建环境:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$mkdir blog_pelican\n$cd blog_pelican\n$virtualenv .venv\n$source .venv/bin/activate\n$pip install pelican\n$pip install markdown\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建pelican项目:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$pelican-quickstart\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成下列文件和目录:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublishconf.py # 主配置文件\npelicanconf.py # 发布的配置文件\nfabfile.py # fabric配置文件\nMakefile   # make配置文件\ndevelop_server.sh # 用于开启测试服务器\ncontent # 用于存放所有文章\noutput # 静态生成文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"发布站点\"\u003e发布站点\u003c/h1\u003e\n\u003cp\u003epelican部署博客:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 将rst或md格式转换成html,默认导入到output.\n$pelican content\n$pelican content -s pelicanconf.py\n\n# 启动web服务器预览\n$cd output\n$python -m pelican.server\n$python2.7 -m SimpleHTTPServer\n$python3 -m http.server\n$firefox http://localhost:8000/\n\n# 部署站点\n# 一般publishconf.py导入pelicanconf.py即可，配置一样．\n$pelican content -s publishconf.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efabric部署博客:\u003c/p\u003e",
    "content": "Pelican python开发的静态站点生成器.\nhttp://blog.getpelican.com/\nhttps://github.com/getpelican/pelican\nhttp://pelican-docs-zh-cn.readthedocs.io/en/latest/getting_started.html\nhttp://pelican-zh.readthedocs.io/en/latest/zh-cn/\n搭建博客 创建环境:\n$mkdir blog_pelican $cd blog_pelican $virtualenv .venv $source .venv/bin/activate $pip install pelican $pip install markdown 创建pelican项目:\n$pelican-quickstart 生成下列文件和目录:\npublishconf.py # 主配置文件 pelicanconf.py # 发布的配置文件 fabfile.py # fabric配置文件 Makefile # make配置文件 develop_server.sh # 用于开启测试服务器 content # 用于存放所有文章 output # 静态生成文件 发布站点 pelican部署博客:\n# 将rst或md格式转换成html,默认导入到output. $pelican content $pelican content -s pelicanconf.py # 启动web服务器预览 $cd output $python -m pelican.server $python2.7 -m SimpleHTTPServer $python3 -m http.server $firefox http://localhost:8000/ # 部署站点 # 一般publishconf.py导入pelicanconf.py即可，配置一样． $pelican content -s publishconf.py fabric部署博客:\n$fab github # 一键部署到github/coding. make部署博客:\n$make github # 一键部署到github/coding. 配置 pelicanconf.py\npublishconf.py\n参考pelican和hexo的配置：\nhttps://github.com/crazy-canux/blog_hexo\nhttps://github.com/crazy-canux/blog_pelican\nTheme 添加主题\n$cd blog_pelican $git submodule add https://github.com/getpelican/pelican-themes.git themes 安装主题：\n$cd pelican-themes $pelican-themes -i bootstrap2 在pelicanconf.py添加主题：\nTHEME = 'bootstrap2' Plugin 添加插件：\n$cd blog_pelican $git submodule add https://github.com/getpelican/pelican-plugins.git plugins 部署到github 在makefile添加三个变量：\nGITHUB_BRANCH=master GITHUB_URL=https://github.com/crazy-canux/crazy-canux.github.io.git 修改makefile:\ngithub: publish cd $(OUTPUTDIR); git init; git remote add origin $(GITHUB_URL); git add -A; git commit -m \u0026quot;[$(shell date +%Y%m%d)]update\u0026quot;; git push -f -u origin $(GITHUB_BRANCH) 一键部署：\n$make github ",
    "categories": ["Web"],
    "tags": ["pelican"]
  },
  {
    "title": "About",
    "permalink": "https://canuxcheng.com/about/",
    "date": "2013-04-01",
    "summary": "\u003ch1 id=\"作者简介synopsis\"\u003e作者简介(Synopsis)\u003c/h1\u003e\n\u003cp\u003e程 伟\u003c/p\u003e\n\u003cp\u003eCanux CHENG\u003c/p\u003e\n\u003cp\u003eInterested in：DevSecOps, Cloud, AWS, GCP, Azure, Terraform, Kubernetes, Golang, Python, TS/JS/NodeJS\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"技术交流contact\"\u003e技术交流(Contact)\u003c/h1\u003e\n\u003cp\u003e了解项目情况，欢迎追踪我的Github\u003c/p\u003e\n\u003cp\u003eWelcome to follow my github, to see the project.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/crazy-canux\"\u003eFollow\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e查看简历，欢迎追踪我的LinkedIn\u003c/p\u003e\n\u003cp\u003eWelcome to follow my LinkedIn, to see my resume.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.linkedin.com/in/canux-cheng-4b5b23ab/\"\u003eFollow\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"个人邮箱e-mail\"\u003e个人邮箱(E-mail):\u003c/h1\u003e\n\u003cp\u003e技术邮箱(tech)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"mailto:canuxcheng@gmail.com\"\u003ecanuxcheng@gmail.com\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e职位邮箱(position)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"mailto:canuxcheng@163.com\"\u003ecanuxcheng@163.com\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e商务邮箱(business)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"mailto:canuxcheng@outlook.com\"\u003ecanuxcheng@outlook.com\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e",
    "content": "作者简介(Synopsis) 程 伟\nCanux CHENG\nInterested in：DevSecOps, Cloud, AWS, GCP, Azure, Terraform, Kubernetes, Golang, Python, TS/JS/NodeJS\n技术交流(Contact) 了解项目情况，欢迎追踪我的Github\nWelcome to follow my github, to see the project.\nFollow\n查看简历，欢迎追踪我的LinkedIn\nWelcome to follow my LinkedIn, to see my resume.\nFollow\n个人邮箱(E-mail): 技术邮箱(tech)\ncanuxcheng@gmail.com\n职位邮箱(position)\ncanuxcheng@163.com\n商务邮箱(business)\ncanuxcheng@outlook.com\n",
    "categories": null,
    "tags": null
  },
  {
    "title": "",
    "permalink": "https://canuxcheng.com/post/sec_security/",
    "date": "0001-01-01",
    "summary": "\u003ch2 id=\"date-2016-07-28-160854\"\u003eTitle: Security\nDate: 2016-07-28 16:08:54\u003c/h2\u003e\n\u003ch2 id=\"draft-false\"\u003etitle: \u0026ldquo;Csrf\u0026rdquo;\ndate: 2018-07-28T16:08:54\ncategories: [\u0026ldquo;Security\u0026rdquo;]\ntags: [\u0026ldquo;capture\u0026rdquo;]\nkeywords: []\nauthor: \u0026ldquo;Canux\u0026rdquo;\ndraft: false\u003c/h2\u003e\n\u003ch1 id=\"security\"\u003eSecurity\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://nvd.nist.gov/\"\u003ehttps://nvd.nist.gov/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://cve.scap.org.cn/\"\u003ehttp://cve.scap.org.cn/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"gfw\"\u003eGFW\u003c/h1\u003e\n\u003ch1 id=\"ngfw\"\u003eNGFW\u003c/h1\u003e\n\u003ch1 id=\"utm\"\u003eUTM\u003c/h1\u003e\n\u003cp\u003eUnified Threat Management, 安全网关\u003c/p\u003e\n\u003cp\u003eBUV: Block Until Verdict\u003c/p\u003e\n\u003ch1 id=\"waf\"\u003eWAF\u003c/h1\u003e\n\u003cp\u003eWeb Application Firewall, web应用防火墙\u003c/p\u003e\n\u003ch1 id=\"ips\"\u003eIPS\u003c/h1\u003e\n\u003cp\u003eIntrusion Prevention System, 入侵防御系统\u003c/p\u003e\n\u003ch1 id=\"ids\"\u003eIDS\u003c/h1\u003e\n\u003cp\u003eIntrusion Detection System, 入侵检测系统\u003c/p\u003e\n\u003ch1 id=\"nsm\"\u003eNSM\u003c/h1\u003e\n\u003cp\u003eNetwork Security Monitoring, 网络安全监控\u003c/p\u003e",
    "content": "Title: Security Date: 2016-07-28 16:08:54 title: \u0026ldquo;Csrf\u0026rdquo; date: 2018-07-28T16:08:54 categories: [\u0026ldquo;Security\u0026rdquo;] tags: [\u0026ldquo;capture\u0026rdquo;] keywords: [] author: \u0026ldquo;Canux\u0026rdquo; draft: false Security https://nvd.nist.gov/\nhttp://cve.scap.org.cn/\nGFW NGFW UTM Unified Threat Management, 安全网关\nBUV: Block Until Verdict\nWAF Web Application Firewall, web应用防火墙\nIPS Intrusion Prevention System, 入侵防御系统\nIDS Intrusion Detection System, 入侵检测系统\nNSM Network Security Monitoring, 网络安全监控\n",
    "categories": null,
    "tags": null
  },
  {
    "title": "🔍",
    "permalink": "https://canuxcheng.com/search/",
    "date": "0001-01-01",
    "summary": "",
    "content": "",
    "categories": null,
    "tags": null
  }
]
