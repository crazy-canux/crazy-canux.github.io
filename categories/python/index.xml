<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Morgoth</title>
    <link>https://canuxcheng.com/categories/python/</link>
    <description>Recent content in Python on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Aug 2016 11:16:29 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PSL_builtins</title>
      <link>https://canuxcheng.com/post/psl_builtins/</link>
      <pubDate>Mon, 15 Aug 2016 11:16:29 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_builtins/</guid>
      <description>&lt;h1 id=&#34;_builtins_&#34;&gt;_&lt;em&gt;builtins&lt;/em&gt;_&lt;/h1&gt;&#xA;&lt;p&gt;python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。&lt;/p&gt;&#xA;&lt;p&gt;包括内置类类型以及所属的内置方法，和内置函数.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;builtin&lt;/strong&gt; - 包括内置类类型以及所属的内置方法，和内置函数.解释器不会自动导入．&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;builtins&lt;/strong&gt; - 仅仅是__builtin__的一个引用．解释器自动导入的．&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;内置常量&lt;/p&gt;&#xA;&lt;p&gt;内置函数(BIF)&lt;/p&gt;&#xA;&lt;p&gt;内置类型(BIT)&lt;/p&gt;&#xA;&lt;p&gt;工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．&lt;/p&gt;&#xA;&lt;p&gt;内置类型的内置方法(BIM)&lt;/p&gt;&#xA;&lt;p&gt;内置异常&lt;/p&gt;&#xA;&lt;p&gt;该模块是通过C/C++实现的．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;内置函数&#34;&gt;内置函数&lt;/h1&gt;&#xA;&lt;p&gt;python2和python3共同的内置函数：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数&#xA;&#xA;compile(source, filename, mode[, flags[, dont_inherit]])&#xA;# 编译source返回一个code对象(代码对象)．&#xA;# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;&#xA;module = &amp;quot;for i in xrange(10): print(i)&amp;quot;&#xA;code = compile(module, &#39;&#39;, &#39;exec&#39;)&#xA;type(code) # code&#xA;exec code&#xA;# mode: single, 用于单行语句, 也是用exec执行;&#xA;code = compile(&amp;quot;print &#39;test&#39;&amp;quot;, &#39;&#39;, single)&#xA;type(code) # code&#xA;exec code&#xA;# mode: eval, 用于表达式 可以用eval()函数执行． eg:&#xA;expression = &amp;quot;3 * 4&amp;quot;&#xA;code = compile(expression, &#39;&#39;, &#39;eval&#39;)&#xA;type(code) # code&#xA;eval(code)&#xA;&#xA;eval(source[, globals[, locals]])&#xA;# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．&#xA;&#xA;format(value[, format_spec]) # 返回格式化后的字符串形式．&#xA;&#xA;## 环境变量相关&#xA;globals() # 返回当前作用域的全局名称空间的字典．&#xA;locals() # 返回当前作用域的局部名称空间的字典．&#xA;&#xA;## 数字类型的数学运算&#xA;abs(number) # 返回int/long的绝对值&#xA;divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组&#xA;pow(x, y[, z]) # 返回x**y或(x**y) % z&#xA;round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.&#xA;chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 &amp;lt;= i &amp;lt; 256.&#xA;ord(c) # 返回字符ASCII字符c对应的整数.&#xA;bin(number) # 返回int/long的二进制的字符串形式&#xA;oct(number) # 返回int/long的八进制的字符串形式．&#xA;hex(number) # 返回int/long的十六进制的字符串形式.&#xA;&#xA;## 对象相关的操作&#xA;id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.&#xA;repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.&#xA;callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()&#xA;hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.&#xA;len(object) # 返回序列（str, tuple, list)或映射（dict)的长度&#xA;dir([object]) # 查看对象的信息&#xA;getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．&#xA;hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.&#xA;setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value&#xA;delattr(object, name) # 删除对象object的属性name&#xA;isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.&#xA;issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．&#xA;vars([object]) # 没有参数等于locals()，有参数等于object.__dict__.&#xA;&#xA;## related to iterable&#xA;min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素&#xA;min(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素&#xA;max(iterable[, key=func]) # 和min相反&#xA;max(a, b, c, ...[, key=func]) # 和min相反&#xA;all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,&#39;&#39;则返回True,iterable为空也返回True,否则返回False&#xA;any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,&#39;&#39;则返回False,　否则返回True&#xA;sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．&#xA;&#xA;## related to iterator&#xA;iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.&#xA;iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．&#xA;next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．&#xA;&#xA;## related to input&#xA;input([prompt]) # 等于eval(raw_input(prompt))&#xA;# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.&#xA;&#xA;## related to file&#xA;open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;[New]python3新增的内置函数：&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Concurrency</title>
      <link>https://canuxcheng.com/post/psl_concurrency/</link>
      <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_concurrency/</guid>
      <description>&lt;h1 id=&#34;concurrent-execution&#34;&gt;Concurrent Execution&lt;/h1&gt;&#xA;&lt;p&gt;进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。&lt;/p&gt;&#xA;&lt;p&gt;线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。&lt;/p&gt;&#xA;&lt;p&gt;IPC: 进程/线程之间交换信息叫进程间通信．&lt;/p&gt;&#xA;&lt;p&gt;python的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.&lt;/p&gt;&#xA;&lt;p&gt;IO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.&lt;/p&gt;&#xA;&lt;p&gt;python的多进程可以并行,每个进程启动一个解释器进程.&lt;/p&gt;&#xA;&lt;p&gt;多进程开销大，消耗内存.&lt;/p&gt;&#xA;&lt;p&gt;计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.&lt;/p&gt;&#xA;&lt;h2 id=&#34;multiprocessing&#34;&gt;multiprocessing&lt;/h2&gt;&#xA;&lt;p&gt;多进程就是同时执行多个任务.&lt;/p&gt;&#xA;&lt;p&gt;python可以通过多进程取代多线程，从而绕过多线程的GIL.&lt;/p&gt;&#xA;&lt;p&gt;python是静态语言，&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import multiprocessing&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# multiprocessing.Process&#xA;proc = Process(group=None, target=None, name=None, args=(), kwargs={})&#xA;# methods:&#xA;run(self)&#xA;start(self) # 启动一个进程&#xA;join(self, timeout=None) # 父进程等待子进程结束&#xA;is_alive()&#xA;terminate(self)&#xA;# data descriptor:&#xA;authkey&#xA;daemon # proc.daemon = True 后台运行&#xA;exitcode&#xA;ident&#xA;name&#xA;pid&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 普通函数&#xA;active_children()&#xA;allow_connection_pickling()&#xA;cpu_count() # 获取cpu个数&#xA;current_process()&#xA;freeze_support()&#xA;get_logger()&#xA;log_to_stderr(level=None)&#xA;&#xA;Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)&#xA;pool = Pool()&#xA;# func只能是顶层函数，不能是方法和内部函数.&#xA;# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())&#xA;# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.&#xA;apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,&#xA;map_async(func, iterable, chunksize=None, callback=None) # 非阻塞&#xA;# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.&#xA;apply(func, args=(), kwargs={}) # 阻塞&#xA;map(func, itreable, chunksize=None) # 阻塞&#xA;terminate() # 终止所有任务&#xA;close() # 关闭pool,不接受新任务&#xA;join() # 等待pool中子进程结束，要在close/terminate之后调用.&#xA;&#xA;# IPC: 管道&#xA;Pipe(duplex=True) # duplex=True表示默认是双向pipe.&#xA;receiver, sender = Pipe()&#xA;sender.send(obj)&#xA;receiver.recv()&#xA;close()&#xA;&#xA;# IPC: 消息队列&#xA;# 来自于Queue.Queue, 具体方法参考Queue.Queue&#xA;Queue(maxsize=0) # return a queue object&#xA;q = Queue()&#xA;&#xA;# IPC: 共享内存&#xA;Manager()&#xA;list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array&#xA;&#xA;Array(typecode_or_type, size_or_initializer, **kwds)&#xA;&#xA;RawArray(typecode_or_type, size_or_initializer)&#xA;&#xA;Value(typecode_or_type, *args, **kwds)&#xA;&#xA;RawValue(typecode_or_type, *args)&#xA;&#xA;Event()&#xA;&#xA;# 同步：　条件变量&#xA;Condition(lock=None)&#xA;&#xA;# 同步：信号量&#xA;Semaphore(value=1)&#xA;&#xA;# 同步：有界信号量&#xA;BoundedSemaphore(value=1)&#xA;&#xA;# 同步： 锁&#xA;Lock()&#xA;&#xA;# 同步: 锁&#xA;RLock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Python</title>
      <link>https://canuxcheng.com/post/psl_python/</link>
      <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_python/</guid>
      <description>&lt;h1 id=&#34;python-runtime-services&#34;&gt;Python Runtime Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;_builtin_&#34;&gt;_&lt;em&gt;builtin&lt;/em&gt;_&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;builtin&lt;/strong&gt;/builtins - Built-in functions, exceptions, and other objects.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;python2叫__builtin__&lt;/p&gt;&#xA;&lt;p&gt;python3叫builtins&lt;/p&gt;&#xA;&lt;h2 id=&#34;_main_&#34;&gt;_&lt;em&gt;main&lt;/em&gt;_&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt; - Top-level script environment.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;当作为顶层脚本运行时(&lt;strong&gt;main&lt;/strong&gt;), 当作为一个模块运行时候就是模块名称．&lt;/p&gt;&#xA;&lt;h2 id=&#34;_future_&#34;&gt;_&lt;em&gt;future&lt;/em&gt;_&lt;/h2&gt;&#xA;&lt;p&gt;把下一个版本的新特性导入到当前版本。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;from __future__ import &amp;lt;feature_name&amp;gt;&#xA;&#xA;# feature name:&#xA;all_feature_names # 一次导入所有feature&#xA;absolute_import # 绝对导入&#xA;division&#xA;generators&#xA;nested_scopes&#xA;print_function&#xA;unicode_literals # python2中u&#39;string&#39;才表示unicode, &#39;string&#39;表示str，python3中所有字符串都是unicode。&#xA;with_statement&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;all_feature_names&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sys&#34;&gt;sys&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import sys&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Dynamic objects:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 动态对象&#xA;sys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc&#xA;sys.path # 搜索的路径．import导入模块的搜索路径．&#xA;sys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来．&#xA;sys.stdin # 标准输入，用于input()&#xA;sys.stdout # 标准输出，用于print&#xA;sys.stderr # 标准出错&#xA;displayhook -- called to show results in an interactive session&#xA;excepthook --&#xA;last_type -- type of last uncaught exception&#xA;last_value -- value of last uncaught exception&#xA;last_traceback --&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Static objects:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_System</title>
      <link>https://canuxcheng.com/post/psl_system/</link>
      <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_system/</guid>
      <description>&lt;h1 id=&#34;generic-operating-system-services&#34;&gt;Generic Operating System Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;os&#34;&gt;os&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import os&#xA;&#xA;os.path # 参考PSL_File&#xA;os.name&#xA;os.curdir&#xA;os.pardir # 表示上一级路径.., 需要用abspath解析&#xA;# os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))&#xA;os.sep&#xA;os.extsep&#xA;os.altsep&#xA;os.pathsep&#xA;os.linesep&#xA;os.defpath&#xA;os.devnull&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;WCOREDUMP(...)&#xA;...&#xA;&#xA;abort(...)&#xA;fork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程．&#xA;exec*&#xA;wait() # 等待子进程结束，返回(pid, status).&#xA;waitpid(pid, options) # 等待指定子进程结束.&#xA;listdir(path) # 列出目录下的文件和目录&#xA;makedirs(path [, mode=0o777], exist_ok=False)&#xA;mkdir(path [, mode=0777])&#xA;walk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器&#xA;remove(path) # 删除文件&#xA;rmdir(path) # 删除目录&#xA;removedirs(path)&#xA;symlink(src, dst)&#xA;chown(path, uid, gid)&#xA;chmod(path, mode=0o777)&#xA;...&#xA;&#xA;# 使用subprocess模块代替下列函数：&#xA;system(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果．&#xA;spawn*&#xA;popen*(command [, mode=&#39;r&#39; [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_GUI</title>
      <link>https://canuxcheng.com/post/psl_gui/</link>
      <pubDate>Mon, 15 Aug 2016 10:28:54 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_gui/</guid>
      <description>&lt;h1 id=&#34;gui&#34;&gt;GUI&lt;/h1&gt;&#xA;&lt;h2 id=&#34;tkinter&#34;&gt;Tkinter&lt;/h2&gt;&#xA;&lt;h2 id=&#34;ttk&#34;&gt;ttk&lt;/h2&gt;&#xA;&lt;h2 id=&#34;tix&#34;&gt;Tix&lt;/h2&gt;&#xA;&lt;h2 id=&#34;scrolledtext&#34;&gt;ScrolledText&lt;/h2&gt;&#xA;&lt;h2 id=&#34;turtle&#34;&gt;turtle&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;p&gt;相关的第三方库&lt;/p&gt;&#xA;&lt;h2 id=&#34;wxwidgets&#34;&gt;wxWidgets&lt;/h2&gt;&#xA;&lt;p&gt;python2的库叫wxPython.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.wxpython.org/&#34;&gt;https://www.wxpython.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Windows下载安装包安装即可．&#xA;$ sudo apt-get install python-wxgtk2.8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;python３启用新的项目phoneix.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wxWidgets/Phoenix&#34;&gt;https://github.com/wxWidgets/Phoenix&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;gtk&#34;&gt;gtk&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;PyGTK&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;qt&#34;&gt;qt&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;PyQt&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>PSL_Misc</title>
      <link>https://canuxcheng.com/post/psl_misc/</link>
      <pubDate>Mon, 15 Aug 2016 10:28:46 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_misc/</guid>
      <description>&lt;h1 id=&#34;psl&#34;&gt;PSL&lt;/h1&gt;&#xA;&lt;p&gt;Python Standard Library: Python标准库&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;internationalization&#34;&gt;Internationalization&lt;/h1&gt;&#xA;&lt;h2 id=&#34;gettext&#34;&gt;gettext&lt;/h2&gt;&#xA;&lt;h2 id=&#34;locale&#34;&gt;locale&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;program-frameworks&#34;&gt;Program Frameworks&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cmd&#34;&gt;cmd&lt;/h2&gt;&#xA;&lt;h2 id=&#34;shlex&#34;&gt;shlex&lt;/h2&gt;&#xA;&lt;p&gt;类shell的词法分析．&lt;/p&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;shlex&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;split(s, comments=False, posix=True)&#xA;# split(&amp;quot;command **kwargs&amp;quot;) -&amp;gt; [&#39;command&#39;, &#39;arg1&#39;, ...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;custom-python-interpreters&#34;&gt;Custom Python Interpreters&lt;/h1&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;code&lt;/h2&gt;&#xA;&lt;h2 id=&#34;codeop&#34;&gt;codeop&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;python-language-services&#34;&gt;Python Language Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;keyword&#34;&gt;keyword&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import keyword&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;keyword.iskeyword(keyword) # x.__contains__(y) &amp;lt;==&amp;gt; y in x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;keyword.kwlist # 返回所有关键字的列表&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;parser&#34;&gt;parser&lt;/h2&gt;&#xA;&lt;h2 id=&#34;ast&#34;&gt;ast&lt;/h2&gt;&#xA;&lt;h2 id=&#34;symtable&#34;&gt;symtable&lt;/h2&gt;&#xA;&lt;h2 id=&#34;symbol&#34;&gt;symbol&lt;/h2&gt;&#xA;&lt;h2 id=&#34;token&#34;&gt;token&lt;/h2&gt;&#xA;&lt;h2 id=&#34;tokenize&#34;&gt;tokenize&lt;/h2&gt;&#xA;&lt;h2 id=&#34;tabnanny&#34;&gt;tabnanny&lt;/h2&gt;&#xA;&lt;h2 id=&#34;pyclbr&#34;&gt;pyclbr&lt;/h2&gt;&#xA;&lt;h2 id=&#34;py_compile&#34;&gt;py_compile&lt;/h2&gt;&#xA;&lt;h2 id=&#34;compileall&#34;&gt;compileall&lt;/h2&gt;&#xA;&lt;h2 id=&#34;dis&#34;&gt;dis&lt;/h2&gt;&#xA;&lt;h2 id=&#34;pickletools&#34;&gt;pickletools&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;importing-modules&#34;&gt;Importing Modules&lt;/h1&gt;&#xA;&lt;h2 id=&#34;imp&#34;&gt;imp&lt;/h2&gt;&#xA;&lt;h2 id=&#34;importlib&#34;&gt;importlib&lt;/h2&gt;&#xA;&lt;h2 id=&#34;zipimport&#34;&gt;zipimport&lt;/h2&gt;&#xA;&lt;h2 id=&#34;pkgutil&#34;&gt;pkgutil&lt;/h2&gt;&#xA;&lt;h2 id=&#34;modulefinder&#34;&gt;modulefinder&lt;/h2&gt;&#xA;&lt;h2 id=&#34;runpy&#34;&gt;runpy&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;miscellaneous-services&#34;&gt;Miscellaneous Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;formatter&#34;&gt;formatter&lt;/h2&gt;&#xA;&lt;h2 id=&#34;ihooks&#34;&gt;ihooks&lt;/h2&gt;</description>
    </item>
    <item>
      <title>PSL_Cryptographic</title>
      <link>https://canuxcheng.com/post/psl_cryptographic/</link>
      <pubDate>Sun, 14 Aug 2016 21:15:14 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_cryptographic/</guid>
      <description>&lt;h1 id=&#34;cryptographic-services&#34;&gt;Cryptographic Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;hashlib&#34;&gt;hashlib&lt;/h2&gt;&#xA;&lt;p&gt;哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．&lt;/p&gt;&#xA;&lt;p&gt;MD5: Message Digest Algorithm 5.&lt;/p&gt;&#xA;&lt;p&gt;SHA1: Secure Hash Algorithm.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import hashlib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# methods:&#xA;# 哈希对象有下列方法：&#xA;update(arg) # 更新字符串&#xA;md5.update(&#39;string or read from a file&#39;) # 放入需要转换的内容&#xA;&#xA;digest() # 字符串&#xA;hexdigest() # 十六进制字符串&#xA;md5.hexdigest() # 获取md5十六进制字符串&#xA;&#xA;copy() # 复制哈希对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 下类函数都返回哈希对象&#xA;new(name, string=&#39;&#39;)&#xA;md5()&#xA;md5 = hashlib.md5() # 创建一个md5的hash对象&#xA;sha1()&#xA;sha224()&#xA;sha256()&#xA;sha384()&#xA;sha512()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hmac&#34;&gt;hmac&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;p&gt;相关的第三方库&lt;/p&gt;&#xA;&lt;h2 id=&#34;pycrypto&#34;&gt;pycrypto&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dlitz/pycrypto&#34;&gt;https://github.com/dlitz/pycrypto&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;windows需要MS Visual C++ compiler for python2.7.&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Data</title>
      <link>https://canuxcheng.com/post/psl_data/</link>
      <pubDate>Sun, 14 Aug 2016 20:57:36 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_data/</guid>
      <description>&lt;h1 id=&#34;data-types&#34;&gt;Data Types&lt;/h1&gt;&#xA;&lt;h2 id=&#34;datetime&#34;&gt;datetime&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import datetime&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# datetime.date&#xA;date(year, month, day)&#xA;# methods:&#xA;ctime(...)&#xA;...&#xA;# data descriptors:&#xA;day&#xA;month&#xA;year&#xA;&#xA;# datetime.datetime(datetime.date)&#xA;datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])&#xA;# methods:&#xA;datetime.datetime.strptime(string, format)&#xA;format_datetime = datetime.datetime.strptime(&#39;20160824161431&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)&#xA;format_datetime = datetime.datetime.strptime(&#39;24 August 2016 16:14:31&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)&#xA;&#xA;datetime.datetime.strftime(format[, tuple])&#xA;string_datetime = format_datetime.strftime(&amp;quot;%d %B %Y %H:%M:%S&amp;quot;) # return: &#39;24 August 2016 16:14:31&#39;&#xA;datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # return: &#39;2017-02-07 23:07:32&#39;&#xA;&#xA;str(datetime.datetime.now())&#xA;datetime.datetime.now().strftime(&#39;%Y%m%d%H%M%S&#39;) # 当前时间戳&#xA;&#xA;# datetime.time&#xA;&#xA;# datetime.timedelta&#xA;&#xA;# datetime.tzinfo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_File</title>
      <link>https://canuxcheng.com/post/psl_file/</link>
      <pubDate>Sun, 14 Aug 2016 20:51:28 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_file/</guid>
      <description>&lt;h1 id=&#34;file-and-directory-access&#34;&gt;File and Directory Access&lt;/h1&gt;&#xA;&lt;h2 id=&#34;ospath&#34;&gt;os.path&lt;/h2&gt;&#xA;&lt;p&gt;windows的路径要写成：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;C:\\test\\sub\\&#xA;&#xA;import os&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;os.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(&amp;quot;~/src&amp;quot;) -&amp;gt; /home/user/src&#xA;os.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原．&#xA;os.path.dirname(filename) # 返回filename的路径 dirname(&amp;quot;/home/user/file.py&amp;quot;) -&amp;gt; /home/user&#xA;os.path.join(a, *p) # 拼结一个完整的路径　&#xA;os.path.join(a, os.pardir) # 返回上级目录的路径&#xA;os.path.realpath(filename) # 返回filename的真实路径+文件名 realpath(&#39;__file__&#39;)&#xA;os.path.abspath(path) # 返回绝对路径, os.path.abspath(&#39;__file__&#39;)&#xA;os.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -&amp;gt; (&amp;quot;/home/user/test&amp;quot;, &amp;quot;.py&amp;quot;)&#xA;os.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -&amp;gt; test.py&#xA;os.path.getsize(filename) # 返回文件大小&#xA;os.path.exists(path) # 判断path(文件或目录)是否存在&#xA;os.path.isfile(path) # 判断path是否是常规文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pathlib&#34;&gt;pathlib&lt;/h2&gt;&#xA;&lt;p&gt;new in python3.4&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Math</title>
      <link>https://canuxcheng.com/post/psl_math/</link>
      <pubDate>Fri, 12 Aug 2016 16:56:45 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_math/</guid>
      <description>&lt;h1 id=&#34;numeric-and-mathematical-modules&#34;&gt;Numeric and Mathematical Modules&lt;/h1&gt;&#xA;&lt;h2 id=&#34;random&#34;&gt;random&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import random&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# random.Random&#xA;Random()&#xA;# methods:&#xA;seed([self,], a=None)&#xA;randint(a, b) # 随机一个[a,b]中的整数．&#xA;choice(self, seq) # 从seq中随机选择一个元素&#xA;uniform(self, a, b)&#xA;sample(self, population, k)&#xA;randint(self, a, b)&#xA;randrange(self, start, stop=None, step=1, _int=&amp;lt;type &#39;int&#39;&amp;gt;, _maxwidth=9007199254740992L)&#xA;&#xA;# random.SystemRandom(Random)&#xA;SystemRandom(Random)&#xA;&#xA;# random.WichmannHill(Random)&#xA;WichmannHill(Random)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;getrandbits(k)&#xA;random(self) # 随机一个小于１的数．&#xA;# 所有Random类的methods也可以直接使用．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fractions&#34;&gt;fractions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functools&#34;&gt;functools&lt;/h2&gt;&#xA;&lt;p&gt;函数式编程相关的模块&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import functools&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# functools.partial&#xA;partial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型.&#xA;RED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED)&#xA;RED(&amp;quot;show me red&amp;quot;) == lambda content, color: Fore.RED + str(&amp;quot;show me red&amp;quot;) + Fore.RESET&#xA;# 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_String</title>
      <link>https://canuxcheng.com/post/psl_string/</link>
      <pubDate>Fri, 12 Aug 2016 16:49:07 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_string/</guid>
      <description>&lt;h1 id=&#34;text-processing-services&#34;&gt;Text Processing Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ascii_letters&#xA;ascii_lowercase&#xA;ascii_uppercase&#xA;digits&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;re&#34;&gt;re&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import re&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;compile(pattern, flags=0)&#xA;escape(pattern)&#xA;findall(pattern, string, flags=0)&#xA;finditer(pattern, string, flags=0)&#xA;match(pattern, string, flags=0) # if not match, return None, else return object.&#xA;search(pattern, string, flags=0)&#xA;purge()&#xA;split(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表．&#xA;sub(pattern, repl, string, count=0, flags=0)&#xA;subn(pattern, repl, string, count=0, flags=0)&#xA;template(pattern, flags=0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;data:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# flags:&#xA;IGNORECASE # 大小写不敏感&#xA;LOCALE&#xA;MULTILINE&#xA;DOTALL&#xA;VERBOSE&#xA;UNICODE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;modules:&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Multimedia</title>
      <link>https://canuxcheng.com/post/psl_multimedia/</link>
      <pubDate>Fri, 12 Aug 2016 15:51:56 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_multimedia/</guid>
      <description>&lt;h1 id=&#34;multimedia-services&#34;&gt;Multimedia Services&lt;/h1&gt;&#xA;&lt;h2 id=&#34;audioop&#34;&gt;audioop&lt;/h2&gt;&#xA;&lt;h2 id=&#34;aifc&#34;&gt;aifc&lt;/h2&gt;&#xA;&lt;h2 id=&#34;sunau&#34;&gt;sunau&lt;/h2&gt;&#xA;&lt;h2 id=&#34;wave&#34;&gt;wave&lt;/h2&gt;&#xA;&lt;h2 id=&#34;chunk&#34;&gt;chunk&lt;/h2&gt;&#xA;&lt;h2 id=&#34;colorsys&#34;&gt;colorsys&lt;/h2&gt;&#xA;&lt;h2 id=&#34;imghdr&#34;&gt;imghdr&lt;/h2&gt;&#xA;&lt;h2 id=&#34;sndhdr&#34;&gt;sndhdr&lt;/h2&gt;&#xA;&lt;h2 id=&#34;ossaudiodev&#34;&gt;ossaudiodev&lt;/h2&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>PSL_Network</title>
      <link>https://canuxcheng.com/post/psl_network/</link>
      <pubDate>Fri, 12 Aug 2016 14:21:36 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_network/</guid>
      <description>&lt;h1 id=&#34;internet-protocols-and-support&#34;&gt;Internet Protocols and Support&lt;/h1&gt;&#xA;&lt;p&gt;socketserver/http/ftp参考&lt;a href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;&gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;pop,imap/smtp参考&lt;a href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;&gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;urllib&#34;&gt;urllib&lt;/h2&gt;&#xA;&lt;p&gt;urllib.request&lt;/p&gt;&#xA;&lt;p&gt;urllib.respponse&lt;/p&gt;&#xA;&lt;p&gt;urllib.parse&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;from urllib.parse import urlparse&#xA;from urllib.parse import urljoin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;urllib.error&lt;/p&gt;&#xA;&lt;p&gt;urllib.robotparser&lt;/p&gt;&#xA;&lt;h2 id=&#34;ipaddress&#34;&gt;ipaddress&lt;/h2&gt;&#xA;&lt;h2 id=&#34;webbrowser&#34;&gt;webbrowser&lt;/h2&gt;&#xA;&lt;h2 id=&#34;cgi&#34;&gt;cgi&lt;/h2&gt;&#xA;&lt;h2 id=&#34;cgitb&#34;&gt;cgitb&lt;/h2&gt;&#xA;&lt;h2 id=&#34;wsgiref&#34;&gt;wsgiref&lt;/h2&gt;&#xA;&lt;h2 id=&#34;xmlrpc&#34;&gt;xmlrpc&lt;/h2&gt;&#xA;&lt;h2 id=&#34;socketserver&#34;&gt;socketserver&lt;/h2&gt;&#xA;&lt;h2 id=&#34;nntplib&#34;&gt;nntplib&lt;/h2&gt;&#xA;&lt;p&gt;network news transfer protocol&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import nntplib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;telnet&#34;&gt;telnet&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import telnetlib&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;structured-markup-processing-tools&#34;&gt;Structured Markup Processing Tools&lt;/h1&gt;&#xA;&lt;h2 id=&#34;html&#34;&gt;html&lt;/h2&gt;&#xA;&lt;h2 id=&#34;xml&#34;&gt;xml&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;internet-data-handling&#34;&gt;Internet Data Handling&lt;/h1&gt;&#xA;&lt;h2 id=&#34;json&#34;&gt;json&lt;/h2&gt;&#xA;&lt;p&gt;http api(restful)一般使用json格式的数据．&lt;/p&gt;&#xA;&lt;p&gt;python和json数据类型对应关系参考WEB/JSON.&lt;/p&gt;&#xA;&lt;p&gt;complex和class/def不能被编码.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import json&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 将转换后的json格式写入文件&#xA;dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)&#xA;with open(file, &#39;w&#39;) as f:&#xA;    json.dump(dict_data, f)&#xA;&#xA;# 将dict类型转换成json格式&#xA;dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)&#xA;json_data = json.dumps(dict_data)&#xA;&#xA;indent=4 # 写入自动缩进４个空格&#xA;&#xA;# 将读出的文件(json格式)转换成dict&#xA;load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&#xA;with open(file, &#39;r&#39;) as f:&#xA;    dict_data = json.load(f)&#xA;&#xA;# json类型变成dict类型&#xA;loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&#xA;response_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;base64&#34;&gt;base64&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mailcap&#34;&gt;mailcap&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mailbox&#34;&gt;mailbox&lt;/h2&gt;&#xA;&lt;h2 id=&#34;minetypes&#34;&gt;minetypes&lt;/h2&gt;&#xA;&lt;h2 id=&#34;binhex&#34;&gt;binhex&lt;/h2&gt;&#xA;&lt;h2 id=&#34;binascii&#34;&gt;binascii&lt;/h2&gt;&#xA;&lt;h2 id=&#34;quopri&#34;&gt;quopri&lt;/h2&gt;&#xA;&lt;h2 id=&#34;uu&#34;&gt;uu&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Debug</title>
      <link>https://canuxcheng.com/post/python_debug/</link>
      <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_debug/</guid>
      <description>&lt;h1 id=&#34;ide&#34;&gt;IDE&lt;/h1&gt;&#xA;&lt;p&gt;pycharm可以通过breakpoint和step调试.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;&#xA;&lt;h2 id=&#34;bdb&#34;&gt;bdb&lt;/h2&gt;&#xA;&lt;h2 id=&#34;pdb&#34;&gt;pdb&lt;/h2&gt;&#xA;&lt;h2 id=&#34;hotshot&#34;&gt;hotshot&lt;/h2&gt;&#xA;&lt;h2 id=&#34;timeit&#34;&gt;timeit&lt;/h2&gt;&#xA;&lt;h2 id=&#34;trace&#34;&gt;trace&lt;/h2&gt;&#xA;&lt;h2 id=&#34;cprofile&#34;&gt;cProfile&lt;/h2&gt;&#xA;&lt;h2 id=&#34;profile&#34;&gt;profile&lt;/h2&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>PEP</title>
      <link>https://canuxcheng.com/post/python_pep/</link>
      <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_pep/</guid>
      <description>&lt;h1 id=&#34;pep-8--style-guide-for-python-code&#34;&gt;PEP 8 &amp;ndash; Style Guide for Python Code&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;&gt;https://www.python.org/dev/peps/pep-0008/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;pep-257--docstring-conventions&#34;&gt;PEP 257 &amp;ndash; Docstring Conventions&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0257/&#34;&gt;https://www.python.org/dev/peps/pep-0257/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;pep-20pep-20--the-zen-of-python&#34;&gt;PEP-20PEP 20 &amp;ndash; The Zen of Python&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0020/&#34;&gt;https://www.python.org/dev/peps/pep-0020/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 查看pep20&#xA;&amp;gt;import this&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Document</title>
      <link>https://canuxcheng.com/post/python_document/</link>
      <pubDate>Wed, 03 Aug 2016 21:57:26 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_document/</guid>
      <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;&#xA;&lt;p&gt;python项目文档相关的工具．&lt;/p&gt;&#xA;&lt;h1 id=&#34;pydoc&#34;&gt;pydoc&lt;/h1&gt;&#xA;&lt;p&gt;python自带的文档命令行接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ pydoc --help&#xA;$ pydoc -p &amp;lt;port&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;h2 id=&#34;sphinx&#34;&gt;Sphinx&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sphinx-doc/sphinx&#34;&gt;https://github.com/sphinx-doc/sphinx&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&#34;&gt;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Sphinx就是python处理reStructuredText格式的工具。&lt;/p&gt;&#xA;&lt;p&gt;安装：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$pip install -U Sphinx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;使用sphinx：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$cd your-project/docs&#xA;&#xA;$sphinx-quickstart&#xA;# 以下选项需要手动设定，其它都可以用默认值：&#xA;&amp;gt; Project name: pydeveloper&#xA;&amp;gt; Author name(s): Canux CHENG&#xA;&amp;gt; Project version: 1.0.0.0&#xA;&amp;gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y&#xA;&amp;gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;配置文件conf.py包含刚才的所有配置，可以在这里手动修改。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&#34;&gt;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;添加包的版本：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sys.path.insert(0, os.path.abspath(&amp;quot;..&amp;quot;))&#xA;from &amp;lt;project&amp;gt; import __version__&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;修改自己的配置：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Package</title>
      <link>https://canuxcheng.com/post/python_package/</link>
      <pubDate>Wed, 22 Jun 2016 05:17:19 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_package/</guid>
      <description>&lt;h1 id=&#34;package&#34;&gt;Package&lt;/h1&gt;&#xA;&lt;p&gt;PEP426是python最新的打包标准，定义了wheel为最新的python包。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0426/&#34;&gt;https://www.python.org/dev/peps/pep-0426/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;ensurepip&#34;&gt;ensurepip&lt;/h2&gt;&#xA;&lt;p&gt;内置模块.提供使用pip从pypi安装模块。&lt;/p&gt;&#xA;&lt;h2 id=&#34;distutils&#34;&gt;distutils&lt;/h2&gt;&#xA;&lt;p&gt;内置的模块.处理简单的包安装,一般使用setuptools代替该模块。&lt;/p&gt;&#xA;&lt;h2 id=&#34;venv&#34;&gt;venv&lt;/h2&gt;&#xA;&lt;p&gt;python3新增了虚拟环境的包．python2中使用virtualenv.&lt;/p&gt;&#xA;&lt;h2 id=&#34;zipapp&#34;&gt;zipapp&lt;/h2&gt;&#xA;&lt;p&gt;python3新增管理可执行的python的zip包．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;p&gt;相关的第三方库&lt;/p&gt;&#xA;&lt;h2 id=&#34;virtualenv&#34;&gt;virtualenv&lt;/h2&gt;&#xA;&lt;p&gt;python3.5开始并入了虚拟化标准库venv.&lt;/p&gt;&#xA;&lt;p&gt;分离的虚拟的python环境,自动安装setuptools和pip和wheel&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pypa/virtualenv&#34;&gt;https://github.com/pypa/virtualenv&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$cd project&#xA;&#xA;# 默认python2.7&#xA;$virtualenv .env&#xA;# 指定python3, 会安装pip/setuptools/wheel到当前环境.&#xA;$$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env&#xA;&#xA;# 激活虚拟环境&#xA;$source .env/bin/activate&#xA;&#xA;# 先升级pip和setuptools&#xA;$pip install pip&#xA;$pip install setuptools&#xA;$pip install wheel&#xA;&#xA;# 导出项目用的所有依赖库．&#xA;$pip freeze &amp;gt; requirements.txt&#xA;# 在其它环境需要安装依赖：&#xA;$pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;virtualenvwrapper&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&#34;&gt;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;封装了virtualenv的工具:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ pip install virtualenvwrapper&#xA;&#xA;# 创建主目录&#xA;$ mkdir -p $WORKON_HOME&#xA;&#xA;# 最好写入到.bashrc/.zshrc:&#xA;$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python&#xA;$ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv&#xA;$ export WORKON_HOME=~/.virtualenvs&#xA;$ source /usr/local/bin/virtualenvwrapper.sh&#xA;&#xA;# 为每个项目创建独立python环境：&#xA;$ mkvirtualenv -r requirementx.txt [project-name]&#xA;# 不安装setuotools/wheel/pip&#xA;$ mkvirtualenv --no-setuptools --no-wheel --no-pip [name]&#xA;# 指定查找pip/setuptools的路径&#xA;--extra-search-dir=/usr/local/lib/python2.7/dist-packages&#xA;--extra-search-dir=/usr/lib/python2.7/dist-packages&#xA;$ workon [project-name] # 切换到针对该项目的virtualenv&#xA;(pro)$ /path/to/pip install [package] # 安装第三方包&#xA;(pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装&#xA;(pro)$ lssitepackages # 查看安装的第三方包&#xA;$ deactivate # 退出virtualenv&#xA;$ rmvirtualenv [project-name] # 删除环境&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;pipenv&lt;/p&gt;</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://canuxcheng.com/post/python_summary/</link>
      <pubDate>Tue, 21 Jun 2016 21:18:20 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_summary/</guid>
      <description>&lt;h1 id=&#34;python难点总结&#34;&gt;python难点总结&lt;/h1&gt;&#xA;&lt;h1 id=&#34;多线程&#34;&gt;多线程&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;GIL&lt;/p&gt;&#xA;&lt;p&gt;GIL: Global Interpretror Lock. 全局解释器锁．&lt;/p&gt;&#xA;&lt;p&gt;python不建议使用多线程，用多进程代替．&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;协程&#34;&gt;协程&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;coroutine&lt;/p&gt;&#xA;&lt;p&gt;协程就是同时开启两个任务，但一次只顺序执行一个．&#xA;如果执行的任务阻塞，就切换到下一个继续执行．节省时间．&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>OOP</title>
      <link>https://canuxcheng.com/post/python_oop/</link>
      <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_oop/</guid>
      <description>&lt;h1 id=&#34;面向对象oop&#34;&gt;面向对象/OOP&lt;/h1&gt;&#xA;&lt;p&gt;OOD: Object Oriented Design.&lt;/p&gt;&#xA;&lt;p&gt;面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．&lt;/p&gt;&#xA;&lt;p&gt;OOP: Object Oriented Programming.&lt;/p&gt;&#xA;&lt;p&gt;python内置OOP的结构，但是不必一定要使用类和OOP.&lt;/p&gt;&#xA;&lt;p&gt;面向对象的两个主题就是类和类实例．&lt;/p&gt;&#xA;&lt;p&gt;创建实例的过程叫实例化．&lt;/p&gt;&#xA;&lt;p&gt;属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;类class&#34;&gt;类/Class&lt;/h1&gt;&#xA;&lt;p&gt;类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．&lt;/p&gt;&#xA;&lt;p&gt;类是一种数据结构的定义，实例是申明了一个这种类型的变量．&lt;/p&gt;&#xA;&lt;p&gt;类的定义：&lt;/p&gt;&#xA;&lt;p&gt;Python 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class ClassName(object):&#xA;    &amp;quot;&amp;quot;&amp;quot;Doc string.&amp;quot;&amp;quot;&amp;quot;&#xA;    class_suite&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;类的初始化方法init(相当于构造器):&lt;/p&gt;&#xA;&lt;p&gt;如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。&lt;/p&gt;&#xA;&lt;p&gt;init方法的第一个参数必须是实例self，而且不能有return语句。&lt;/p&gt;&#xA;&lt;p&gt;init方法一般用来设置实例属性(也就是数据属性)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class ClassName(object):&#xA;    def __init__(self, *args, **kwargs):&#xA;        pass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;特殊方法new:&lt;/p&gt;&#xA;&lt;p&gt;如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。&lt;/p&gt;&#xA;&lt;p&gt;new方法的第一个参数必须是类cls。并且需要返回一个实例。&lt;/p&gt;&#xA;&lt;p&gt;new方法在object中被定义为staticmethod。&lt;/p&gt;&#xA;&lt;p&gt;相当于析构器的特殊方法del:&lt;/p&gt;&#xA;&lt;p&gt;__del__特殊方法要在实例对象的所有引用都被清除后才会执行。&lt;/p&gt;&#xA;&lt;p&gt;不要在del中做与实例没有关系的事情，一般不建议实现该方法。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class ClassName(object):&#xA;&#xA;    def __new__(cls, *args, **kwargs):&#xA;        ...&#xA;        return ...&#xA;&#xA;    def __del__(self):&#xA;        ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类属性&#34;&gt;类属性&lt;/h2&gt;&#xA;&lt;p&gt;类属性分为数据属性和方法属性。&lt;/p&gt;&#xA;&lt;p&gt;类的数据属性仅仅是定义的类的变量。&lt;/p&gt;&#xA;&lt;p&gt;数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>https://canuxcheng.com/post/python/</link>
      <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python/</guid>
      <description>&lt;h1 id=&#34;python概述&#34;&gt;&lt;strong&gt;Python概述&lt;/strong&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/2.7/index.html&#34;&gt;https://docs.python.org/2.7/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://python.usyiyi.cn/translate/python_278/index.html&#34;&gt;http://python.usyiyi.cn/translate/python_278/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3.5/index.html&#34;&gt;https://docs.python.org/3.5/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://python.usyiyi.cn/translate/python_352/index.html&#34;&gt;http://python.usyiyi.cn/translate/python_352/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;python是一门优雅而健壮的语言.&lt;/p&gt;&#xA;&lt;p&gt;继承了编译语言(静态语言)的强大性和通用性.&lt;/p&gt;&#xA;&lt;p&gt;同时也借鉴了脚本语言(动态语言)的易用性．&lt;/p&gt;&#xA;&lt;p&gt;python特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高级&lt;/li&gt;&#xA;&lt;li&gt;面向对象&lt;/li&gt;&#xA;&lt;li&gt;可升级&lt;/li&gt;&#xA;&lt;li&gt;可扩展&lt;/li&gt;&#xA;&lt;li&gt;可移植性&lt;/li&gt;&#xA;&lt;li&gt;易学&lt;/li&gt;&#xA;&lt;li&gt;易读&lt;/li&gt;&#xA;&lt;li&gt;易维护&lt;/li&gt;&#xA;&lt;li&gt;健壮性&lt;/li&gt;&#xA;&lt;li&gt;高效的快速原型开发工具&lt;/li&gt;&#xA;&lt;li&gt;内存管理器&lt;/li&gt;&#xA;&lt;li&gt;解释性和编译性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;python基本语法&#34;&gt;&lt;strong&gt;python基本语法&lt;/strong&gt;&lt;/h1&gt;&#xA;&lt;p&gt;python源程序叫xxx.py&lt;/p&gt;&#xA;&lt;p&gt;python中一切皆对象．&lt;/p&gt;&#xA;&lt;p&gt;python大小写敏感．&lt;/p&gt;&#xA;&lt;p&gt;python通过缩进和冒号:区分语法块，而不是大括号{}.&lt;/p&gt;&#xA;&lt;p&gt;python中的表达式(条件/循环表达式等)不需要用小括号()括起来．&lt;/p&gt;&#xA;&lt;p&gt;python标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．&lt;/p&gt;&#xA;&lt;p&gt;python不支持方法或函数重载．&lt;/p&gt;&#xA;&lt;p&gt;python不支持char和type类型．&lt;/p&gt;&#xA;&lt;p&gt;python没有switch语句．&lt;/p&gt;&#xA;&lt;p&gt;python支持多继承．&lt;/p&gt;&#xA;&lt;p&gt;python不支持++/&amp;ndash;自增和自减运算符．&lt;/p&gt;&#xA;&lt;p&gt;python支持连续比较，a&amp;lt;b&amp;lt;c.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lexical-analysis&#34;&gt;lexical analysis&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/2/reference/lexical_analysis.html&#34;&gt;https://docs.python.org/2/reference/lexical_analysis.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Logical lines and physical lines：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python通过行尾的令牌NEWLINE表示逻辑行&#xA;expression&#xA;# 以操作系统的换行符表示物理行．&#xA;\n&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;encoding declarations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python脚本中的第一行或第二行的&#xA;coding[=:]\s*([-\w.]+)&#xA;# 注释与正则表达式匹配将被作为编码申明处理．&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;[Deprecated] explicit line joining:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 多个物理行通过反斜线backslash续行进行显示换行&#xA;# 推荐用隐式换行．&#xA;if a == b \&#xA;       and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释.&#xA;    print(&#39;more than one physical line.&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;implicit line joining：&lt;/p&gt;</description>
    </item>
    <item>
      <title>PSL_Test</title>
      <link>https://canuxcheng.com/post/psl_test/</link>
      <pubDate>Mon, 11 Apr 2016 22:58:13 +0000</pubDate>
      <guid>https://canuxcheng.com/post/psl_test/</guid>
      <description>&lt;h1 id=&#34;development-tools&#34;&gt;Development Tools&lt;/h1&gt;&#xA;&lt;h2 id=&#34;typing&#34;&gt;typing&lt;/h2&gt;&#xA;&lt;h2 id=&#34;2to3&#34;&gt;2to3&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;$2to3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pydoc&#34;&gt;pydoc&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import pydoc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;import test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;doctest&#34;&gt;doctest&lt;/h2&gt;&#xA;&lt;p&gt;python内置的文档测试库．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import doctest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;unittest&#34;&gt;unittest&lt;/h2&gt;&#xA;&lt;p&gt;python内置的单元测试库．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import unittest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;&#xA;&lt;p&gt;相关的第三方库&lt;/p&gt;&#xA;&lt;h2 id=&#34;unittest2&#34;&gt;unittest2&lt;/h2&gt;&#xA;&lt;p&gt;unittest2是unittest的升级版．&lt;/p&gt;&#xA;&lt;p&gt;python3集成了unittest2到unittest,像使用unittest一样使用即可．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python2.7&#xA;$pip install unittest2&#xA;import unittest2&#xA;&#xA;# python3&#xA;import unittest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．&lt;/p&gt;&#xA;&lt;p&gt;测试结果：&lt;/p&gt;&#xA;&lt;p&gt;OK 表示测试通过&lt;/p&gt;&#xA;&lt;p&gt;FAIL 表示测试没有通过，并引发一个AssertionError异常．&lt;/p&gt;&#xA;&lt;p&gt;ERROR 表示测试过程引发一个不是AssertionError的异常．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是标准库的unittest.&#xA;import unittest&#xA;import MyClass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;classes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;unittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．&#xA;unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.&#xA;unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.&#xA;unittest.TestResult: 用来保存测试的结果．&#xA;&#xA;unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．&#xA;fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．&#xA;&#xA;unittest.TextTestRunner: 用来执行测试用例．&#xA;unittest.TextTestResult: 用来打印格式化的测试结果．&#xA;&#xA;# unittest.TestCase&#xA;# methods:&#xA;assertXXX　系列方法．&#xA;failXXX 系列方法&#xA;fail(self, msg=None) # test立即失败&#xA;addCleanup(self, function, *args, **kwargs)&#xA;addTypeEqualityFunc(self, typeobj, function)&#xA;countTestCases(self)&#xA;debug(self)&#xA;defaultTestResult() # return unittest.TestResult()&#xA;doCleanups(self)&#xA;id(self)&#xA;run(self, result=None) # 可以在子类覆盖该方法．&#xA;shortDescription(self)&#xA;skipTest(self, reason)&#xA;setUp(self) # 重写之后，每个case运行之前都会调用一次．&#xA;tearDown(self) # 同上&#xA;&#xA;# classmethods:&#xA;setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．&#xA;tearDownClass(cls) # 同上&#xA;&#xA;# data:&#xA;failureException = AssertionError&#xA;longMessage = False&#xA;maxDiff = 640&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>DevOps</title>
      <link>https://canuxcheng.com/post/python_devops/</link>
      <pubDate>Sun, 03 Apr 2016 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/python_devops/</guid>
      <description>&lt;h1 id=&#34;python&#34;&gt;Python&lt;/h1&gt;&#xA;&lt;p&gt;python2的最后一个版本是python2.7, 2020年停止更新.&lt;/p&gt;&#xA;&lt;p&gt;Windows安装：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Python2.7.9之后的版本直接下载msi安装即可．&#xA;选择自动设置PATH，默认安装pip和setuptools.&#xA;可以使用IDLE或python命令行或cmd执行python命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Linux安装：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$sudo apt-get install python&#xA;$sudo yum install python&#xA;&#xA;$sudo apt-get install python-dev&#xA;$sudo apt-get install python3-dev&#xA;$sudo yum install python-devel&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;标准库的路径：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;C:\Python*\Lib&#xA;/usr/lib/python*/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;python的IDE：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Windows: IDLE&lt;/li&gt;&#xA;&lt;li&gt;Linux: Vim&lt;/li&gt;&#xA;&lt;li&gt;Pycharm/VS&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;python命令&#34;&gt;python命令&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ python/ipython     # 进入python解释器&#xA;&amp;gt;&amp;gt;&amp;gt;exit()/Ctrl+d     # 退出python解释器&#xA;&amp;gt;&amp;gt;&amp;gt;help()            # 进入help工具&#xA;help&amp;gt;quit            # 退出help工具&#xA;$ pydoc --help        # 文档工具&#xA;&#xA;# -c　cmd, __name__ != &#39;__main__&#39;&#xA;$ python -c &#39;import module/package; expressions&#39;&#xA;# -m mod, __name__ == &#39;__main__&#39;&#xA;$ python -m &#39;module/package&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;python的可用接口&#34;&gt;python的可用接口&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;python内置常量，函数，类和异常．&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
