<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Python on Morgoth</title>
        <link>https://canuxcheng.com/categories/python/</link>
        <description>Recent content in Python on Morgoth</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 15 Aug 2016 11:16:29 +0000</lastBuildDate><atom:link href="https://canuxcheng.com/categories/python/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>PSL_builtins</title>
        <link>https://canuxcheng.com/post/psl_builtins/</link>
        <pubDate>Mon, 15 Aug 2016 11:16:29 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_builtins/</guid>
        <description>&lt;h1 id=&#34;builtins&#34;&gt;builtins&lt;/h1&gt;
&lt;p&gt;python的内置模块，所有python的内置功能都在这个模块中，不需要import导入就可以使用。&lt;/p&gt;
&lt;p&gt;包括内置类类型以及所属的内置方法，和内置函数.&lt;/p&gt;
&lt;p&gt;内置常量&lt;/p&gt;
&lt;p&gt;内置函数(BIF)&lt;/p&gt;
&lt;p&gt;内置类型(BIT)&lt;/p&gt;
&lt;p&gt;工厂函数：python内置的类型都有对应的类的实现，同名的类的方法就是工厂函数．&lt;/p&gt;
&lt;p&gt;内置类型的内置方法(BIM)&lt;/p&gt;
&lt;p&gt;内置异常&lt;/p&gt;
&lt;p&gt;该模块是通过C/C++实现的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import builtins # can be ignored
dir(builtins)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置特殊常量&#34;&gt;内置特殊常量&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;False # 内置类型bool的实例
True # 内置类型bool的实例
None # python的Null对象或types.NoneType,只有一个值None.布尔值始终为False.
NotImplemented # types.NotImplementedType
Ellipsis # types.EllipsisType, 省略对象，布尔值始终为True.
__debug__ # True/False
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置函数&#34;&gt;内置函数&lt;/h1&gt;
&lt;p&gt;不需要import可以直接使用的函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__import__(name, globals={}, locals={}, fromlist=[], level=-1) # import关键字实际调用该函数

print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False) # python3新增

compile(source, filename, mode[, flags[, dont_inherit]])
# 编译source返回一个code对象(代码对象)．
# mode: exec, 用于模块 python2可以用exec关键字执行,python3改成exec()函数;
module = &amp;quot;for i in xrange(10): print(i)&amp;quot;
code = compile(module, &#39;&#39;, &#39;exec&#39;)
type(code) # code
exec code
# mode: single, 用于单行语句, 也是用exec执行;
code = compile(&amp;quot;print &#39;test&#39;&amp;quot;, &#39;&#39;, single)
type(code) # code
exec code
# mode: eval, 用于表达式 可以用eval()函数执行． eg:
expression = &amp;quot;3 * 4&amp;quot;
code = compile(expression, &#39;&#39;, &#39;eval&#39;)
type(code) # code
eval(code)

eval(source[, globals[, locals]])
# 返回python表达式的结果，source可以是compile()返回的代码对象，也可以是一个表达式．

exec(object[, globals[, locals]]) # python3 新增
# object可以是一个文件对象，也可以是一个语句或代码块．

format(value[, format_spec]) # 返回格式化后的字符串形式．

## 环境变量相关
globals() # 返回当前作用域的全局名称空间的字典．
locals() # 返回当前作用域的局部名称空间的字典．

## 数字类型的数学运算
abs(number) # 返回int/long的绝对值
divmod(x, y) # 返回x/y 的　(商，余数) 组成的元组
pow(x, y[, z]) # 返回x**y或(x**y) % z
round(number[, ndigits]) # 返回number四舍五入后的结果，ndigits表示小数点后的位数，默认是0.
chr(i) # 返回整数ｉ对应的ASCII字符的字符串形式，0 &amp;lt;= i &amp;lt; 256.
ord(c) # 返回字符ASCII字符c对应的整数.
bin(number) # 返回int/long的二进制的字符串形式
oct(number) # 返回int/long的八进制的字符串形式．
hex(number) # 返回int/long的十六进制的字符串形式.

## 对象相关的操作
id(object) # 返回一个对象的ID, 用内存地址作为ID来表示唯一性. 也就是对象的身份．等价is关键字.
repr(object) # 返回object的标准字符串形式，可以通过eval()重新得到该对象．eval(repr(object)) == object.
ascii(object) # 和repr()函数等效．
callable(object) # 如果object是可调用的返回True, 需要实现魔法方法__call__()
hash(object) # 返回一个对象的散列/哈希(hash)值，有相同值的对象hash值相同.可用做字典的键.
len(object) # 返回序列（str, tuple, list)或映射（dict)的长度
dir([object]) # 查看对象的信息
getattr(object, name[, default]) # 如果object.name存在,返回name的值，否则如果default存在，返回default,否则抛出异常AttributeError, 和super的查找顺序一样．
hasattr(object, name) # 和getattr一样，但是捕获了异常，object.name存在返回True,否则返回False.
setattr(object, name, value) # 给对象的属性赋值，相当于object.name = value
delattr(object, name) # 删除对象object的属性name
isinstance(object, class-or-type-or-tuple) # 如果object是class-or-type中指定的类或类型的实例或子类的实例，返回True,否则返回False.
issubclass(C, B-or-(B,A)) # 如果C是B或(B,A,...)中的类的子类，返回True,否则返回False. 不严格子类也允许，例如一个类可以看作是自身的子类．
vars([object]) # 没有参数等于locals()，有参数等于object.__dict__.

## related to iterable
min(iterable[, key=func]) # 返回可迭代对象iterable中的最小元素
min(a, b, c, ...[, key=func])  # 返回a,b,c...中的最小元素
max(iterable[, key=func]) # 和min相反
max(a, b, c, ...[, key=func]) # 和min相反
all(iterable) # 如果可迭代的参数iterable中所有的元素都不是0,False,&#39;&#39;则返回True,iterable为空也返回True,否则返回False
any(iterable) # 如果可迭代的参数iterable中所有的元素都是0,False,&#39;&#39;则返回False,　否则返回True
sum(sequence[, start]) # 返回数字序列sequence的所有元素加上start的和，start默认是０．

## related to iterator
iter(collection) # 将可迭代对象（str, tuple, list, dict的键,集合,文件的行等）转换成迭代器,返回迭代器对象.
iter(callable, sentinel) # 第一个参数需要是callable的，每次迭代到sentinel停止．
next(iterator[, default]) # 返回迭代器iterator中的下一个元素，如果没有元素了，default指定内容返回该内容，否则抛出StopIteration异常．

## related to input
input([prompt]) # python3
# 根据prompt提示输入内容，返回输入的内容,如果是表达式会先求值再返回.

## related to file
open(name[, mode[, buffering]]) # 打开一个文件，返回一个file类类型的对象．

// python3 refactor
sorted(iterable, key=None, reverse=False)
// 多维数据排序
dict = {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 1}
sorted(dict.items(), key=lambda x:x[1], reverse=False)
json = [{&amp;quot;time&amp;quot;: 1, &amp;quot;data&amp;quot;: &amp;quot;message&amp;quot;}, {&amp;quot;time&amp;quot;: 2, &amp;quot;data&amp;quot;: &amp;quot;message&amp;quot;}]
sorted(json, key=lambda k:k[&amp;quot;time&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内置异常类&#34;&gt;内置异常类&lt;/h1&gt;
&lt;p&gt;BaseException(object) # 所有异常的基类, 继承自object.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# BaseException的四个子类
SystemExit # python解释器请求退出
KeyboardInterrupt # 用户输入ctrl-c中断执行
GeneratorExit # 生成器发出异常来通知退出
Exception # 常规错误的基类
    StopIteration # 迭代器结束抛出的异常
    StandardError # 所有内置标准error的基类
        BufferError
        ArithmeticError # 数值计算错误的基类
            FloatingPointError
            OverflowError
            ZeroDivisionError # 除法分母为０错误
        AsseertionError # 断言语句失败
        AttributeError # 访问未知的对象属性
        EnvironmentError
            IOError # 打开不存在的磁盘文件导致的输入/输出错误
            OSError
                WindowError
                VMSError
        EOFError
        ImportError
        LookupError
            IndexError # 序列的索引错误
            KeyError # 字典的键错误
        MemoryError
        NameError # 未申明或初始化的对象
            UnboundLocalError
        ReferenceError
        RuntimeError # 一般的运行错误
            NotImplementedError # 尚未实现的方法
        SyntaxError # 语法错误， 唯一不在运行时发生的异常
            IndentationError # 缩进错误
                TabError # 跳格和空格混用
        SystemError # 一般的解释器系统错误
        TypeError # 对类型无效的操作
        ValueError # 传入无效的参数
            UnicodeError
                UnicodeDecodeError
                UnicodeEncodeError
                UnicodeTranslateError
    Warning # 所有warning的基类
       DeprecationWarning # 被弃用特征的警告
       RuntimeWarning # 可疑的运行时行为警告
       SyntaxWarning # 可疑的语法行为警告
       UserWarning # 用户代码生成的警告
       FutureWarning # 使用新的语法特征的警告
       ImportWarning # 导入包警告
       UnicodeWarning
       ByteWarning
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;built-in-typesclass&#34;&gt;built-in Types/Class&lt;/h1&gt;
&lt;p&gt;下面是数据类型：&lt;/p&gt;
&lt;h2 id=&#34;int&#34;&gt;int&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int(x=0)
int(x, base=10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bit_length() # 一个int类型的二进制形式的位数．
conjugate()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;denominator
numerator
imag
real
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;boolint&#34;&gt;bool(int)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bool(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置类类型int的内置方法和数据描述符都是继承自基类int.&lt;/p&gt;
&lt;h2 id=&#34;float&#34;&gt;float&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;float(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;as_integer_ratio() # 返回一个整数对，相除的结果是该浮点数
conjugate()
fromhex(string) # 将十六进制的字符转换成浮点型
# float.fromhex(&#39;-0x1p-1074&#39;)
hex() # 将浮点数转换成十六进制形式
is_integer() # 如果浮点数是整数，返回true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imag
real
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;complex&#34;&gt;complex&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;complex(real[, imag])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conjugate() # 返回一个复数的工軛复数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imag 复数的虚部
real 复数的实部
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;str&#34;&gt;str&lt;/h2&gt;
&lt;p&gt;字符串是不可变类型, 是标量，是序列．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str(object=&#39;&#39;) # 把一个对象转换成字符串．或者返回一个对象的可读性好的字符串表示，无法用语eval()求值．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;capitalize() # 字符串首字母大写, 返回新的字符串
title() # 所有单词首字母大写，返回新的字符串
lower() # 所有字符小写，返回新的字符串
upper() # 所有字符大写，返回新的字符串
swapcase() # 大写字符转换成小写，小写转化成大写
translate(table [,deletechars]) #
join(iterable) # 用字符串分割iterable,返回新的字符串
replace(old, new[, count]) # 用new替换字符串中的前count个old, 返回替换后的字符串
expandtabs([tabsize]) # 把字符串中的tab键替换为tabsize指定的宽度的新tab，默认是8,然后返回新的字符串
format(*args, **kwargs) # 返回格式化后的字符串

lstrip([chars]) # 如果字符串以chars开头,就删除开头chars，然后返回新的字符串, chars默认是空格．
strip([chars]) # 删除开头和结尾的chars,如果有的话，然后返回新的字符串，chars默认是空格．
rstrip([chars]) # 如果字符串以chars结尾，就删除结尾的chars,然后返回新的字符串，chars默认是空格．

center(width[, fillchar]) # 以字符串为中心填充字符串，默认用空格填充,返回填充后的字符串
zfill(width) # 用0填充字符串的左边，直到width长度，返回新的字符串
ljust(width[, fillchar]) # 字符串左对齐，右边填充fillchar,默认空格，直到长度为width,返回新的字符串
rjust(width[, fillchar]) # 字符串右对齐，左边填充fillchar，默认空格，直到长度为width,返回新的字符串

count(sub[, start[, end]]) # 返回sub字符串在str[start:end]中出现的次数

# 参考codecs模块的decode/encode.
decode([encoding[,errors]]) # 解码
encode([encoding[,errors]]) # 编码

startswith(prefix[, start[, end]]) # 如果str[start:end]以prefix开头，返回true.
endswith(suffix[, start[, end]]) # 如果str[start:end]以suffix结尾，返回true.
isalnum() # 如果非空字符串，且元素都是字符或数字，返回True,否则返回False
isalpha() # 如果非空字符串，且元素都是字符，返回True,否则返回False
isdigit() # 如果非空字符串，且元素都是数字，返回True,否则返回False
isspace() # 如果非空字符串，且所有元素都是空格，返回True,否则返回False
istitle() # 如果非空字符串，且所有单词的首字母大写，返回True,否则返回False
islower() # 如果非空字符串，且所有元素都是小写，返回True,否则返回False
isupper() # 如果非空字符串，且所有单词都是大写，返回True,否则返回False

splitlines(keepends=False) # 根据\n,\r,\r\n来拆分字符串，返回拆分后的列表，True表示保留换行符，默认是False．
split([sep [,maxsplit]]) # 将字符串以从左到右的maxsplit个seq分割，返回分割后的列表，默认seq是空格，maxsplit是所有seq．
rsplit([sep [,maxsplit]]) # 和split相反,从右到左的maxsplit个seq分割．

partition(sep) # 字符串根据从左往右根据第一个找到的seq分割，返回一个(head, seq, tail), 如果没有找到seq, 返回(str, &#39;&#39;, &#39;&#39;).
rpartition(sep) # 字符串根据最后一个找到的seq分割，返回(head, seq, tail),如果没有找到seq,返回(&#39;&#39;, &#39;&#39;, str)

find(sub [,start [,end]]) # 在str[start:end]中从左往右查找sub,返回找到的第一个字符所在的下标,没找到返回-1
rfind(sub [,start [,end]]) # 在str[start:end]中查找sub,返回最后一个sub的第一个元素的索引,没有找到返回-1

index(sub [,start [,end]]) # 和find一样，但是没找到抛出异常ValueError．
rindex(sub [,start [,end]]) # 和rfind一样，但是没找到抛出ValueError异常．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytes&#34;&gt;bytes&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bytes(iterable_of_ints) -&amp;gt; bytes
bytes(string, encoding[, errors]) -&amp;gt; bytes
bytes(bytes_or_buffer) -&amp;gt; immutable copy of bytes_or_buffer
bytes(int) -&amp;gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&amp;gt; empty bytes object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;capitalize()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytearray&#34;&gt;bytearray&lt;/h2&gt;
&lt;p&gt;bytearray表示可变字节数组类型, bytearray是可变类型，是序列（可迭代）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bytearray(iterable_of_ints) -&amp;gt; bytearray
bytearray(string, encoding[, errors]) -&amp;gt; bytearray
bytearray(bytes_or_buffer) -&amp;gt; mutable copy of bytes_or_buffer
bytearray(int) -&amp;gt; bytes array of size given by the parameter initialized with null bytes
bytearray() -&amp;gt; empty bytes array
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;append(int)
capitalize()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tuple&#34;&gt;tuple&lt;/h2&gt;
&lt;p&gt;元组是不可变类型, 是容器，是序列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tuple()
tuple(iterable) # 把可迭代对象转换成元组.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(value) # 返回值为value的元素在元组中出现的次数
index(value, [start, [stop]]) # 返回值为value的元素在元组tuple[start:stop]中的第一次出现的索引，没有该元素返回ValueError.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;list&#34;&gt;list&lt;/h2&gt;
&lt;p&gt;列表是可变类型,　是容器，是序列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list()
list(iterable) # 把可迭代的对象转换成列表．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(value) # 返回value在列表中出现的次数
index(value, [start, [stop]]) # 从左往右在list[start:stop]中寻找value,返回第一个找到的元素的索引，否则返回ValueError异常．

# 下列改变列表的值的方法都没有返回值，直接改变原列表的值．
append(object) # 在列表结尾追加对象
extend(iterable) # 将可迭代对象iterable的元素依次追加到列表,相当于序列的+运算．
insert(index, object) # 在list[index]前面插入object.
pop([index]) # 删除list[index],默认是最后一个元素，如果列表为空或索引越界，抛出IndexError异常．
remove(value) # 删除第一个出现的value．
reverse() # 翻转列表
sort(cmp=None, key=None, reverse=False) # 默认对列表中的元素从小到大排序，reverse=True,则从大到小．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dict&#34;&gt;dict&lt;/h2&gt;
&lt;p&gt;字典是可变类型, 是容器，是映射类型（mapping), 字典可以迭代键．字典是无序的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dict()
dict(mapping) # dict(one=1, two=2)
dict(iterable) # dict([(1, &#39;one&#39;), (2, &#39;two&#39;)]), dict([[1,1], [2,2]]), dict(([1,1], [2, 2])), dict(((1,1), (2,2))),
dict(**kwargs) # dict({1:&amp;quot;one&amp;quot;, 2:&amp;quot;two&amp;quot;})

in, not in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy() # 返回字典的一个浅拷贝
clear() # 清空字典所有元素
fromkeys(S[,v]) # 返回以S的元素为键，v为值的新字典，v默认为None.
get(k[,d]) # 如果键k在字典里面，返回dict[k], 否则返回d, d默认为None.
pop(k[,d]) # 从字典中删除键k的键值对，返回dict[k], 如果不存在返回d,如果没有指定d,抛出KeyError异常．
popitem() # 从字典中删除随机的键值对，返回该键值对组成的元组，如果字典为空，抛出KeyError异常．
setdefault(k[,d]) # 如果键k在字典中存在，等效于get(k[,d]), 否则就插入D[k]=d键值对．
update([E, ]**F) # 向字典插入指定的项目(字典或可迭代对象).
keys() # 返回字典的键组成的列表．
values() # 返回字典的值组成的列表．
items() # 返回一个列表，每个元素是字典的键和值组成的元组．
iteritems() # 返回字典的键值对组成的迭代器，next()每次返回一个一对键值组成的元组．
iterkeys() # 返回字典的键组成的迭代器．
itervalues() # 返回字典的值组成的迭代器．
viewitems() # 返回键和值组成的可迭代对象
viewkeys()　# 返回键组成的可迭代对象
viewvalues() # 返回值组成的可迭代对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;frozenset&#34;&gt;frozenset&lt;/h2&gt;
&lt;p&gt;不可变集合frozenset是不可变类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;frozenset()
frozenset(iterable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不可变集合和可变集合共同的内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy() # 返回集合的一个浅拷贝
isdisjoint() # 两个集合交集为空，返回为True.
a.issubset(b) # a是b的非严格子集，　a &amp;lt;= b, 返回True
a.issuperset(b) # a是b的非严格超集, a &amp;gt;= b, 返回True
union() # 联合/并集，OR操作，等效于|运算符
intersection([others, ...]) # 交集，　AND操作，　等效于&amp;amp;运算符
difference([others, ...]) # 差补或相对补充集，等效于-运算符
symmetric_difference() # 对称差分或异或，等效于^运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;p&gt;可变集合set是可变类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set()
set(iterable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;set除了有frozenset的所有方法还有自己特有的内置方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear() # 清空集合所有元素
pop() # 删除并返回任意一个集合元素，集合为空抛出KeyError.
add(obj) # 往集合中添加一个不存在的元素
remove(obj) # 删除集合中的存在的指定的数字元素, 非数字抛出KeyError.
s.discard(obj) # 如果obj是集合s中的元素，从s中删除obj.

update() # 等效于|=运算符
intersection_update() # 等效于&amp;amp;=运算符
difference_update() # 等效于-=运算法
symmetric_difference_update() # 等效于^=运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;slice(stop)
slice(start, stop[, step])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indices(len) -&amp;gt; (start, stop, stride)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;range&#34;&gt;range&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;range(stop) # 返回[0, 1, stop-1]的列表
range(start, stop[, step]) # 返回[start, start+n*step... ], n&amp;gt;=1,start+n*step&amp;lt;stop.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count(self, object, /)
index(self, object, /)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;memoryview&#34;&gt;memoryview&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;memoryview(object)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cast(self, /, format, shape=&amp;lt;unrepresentable&amp;gt;)
hex(self, /, sep=&amp;lt;unrepresentable&amp;gt;, bytes_per_sep=1)
release(self, /)
tobytes(self, /, order=&#39;C&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内置数据描述符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;format
itemsize
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;迭代器/生成器类&lt;/p&gt;
&lt;h2 id=&#34;enumerate&#34;&gt;enumerate&lt;/h2&gt;
&lt;h2 id=&#34;reversed&#34;&gt;reversed&lt;/h2&gt;
&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;
&lt;h2 id=&#34;filter&#34;&gt;filter&lt;/h2&gt;
&lt;h2 id=&#34;zip&#34;&gt;zip&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;classmethod&#34;&gt;classmethod&lt;/h2&gt;
&lt;h2 id=&#34;staticmethod&#34;&gt;staticmethod&lt;/h2&gt;
&lt;h2 id=&#34;property&#34;&gt;property&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;
&lt;p&gt;object类是所有类的基类&lt;/p&gt;
&lt;h2 id=&#34;type&#34;&gt;type&lt;/h2&gt;
&lt;p&gt;所有类的类型或元类&lt;/p&gt;
&lt;p&gt;type是用来创建类的类，可以动态创建类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class type(object)
    type(object) -&amp;gt; the object&#39;s type
    type(name, bases, dict, **kwds) -&amp;gt; a new type
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Concurrency</title>
        <link>https://canuxcheng.com/post/psl_concurrency/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_concurrency/</guid>
        <description>&lt;h1 id=&#34;concurrent-execution&#34;&gt;Concurrent Execution&lt;/h1&gt;
&lt;p&gt;进程：每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据，进程间不共享全局变量。&lt;/p&gt;
&lt;p&gt;线程：线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境，同一个进程的线程之间共享全局变量。&lt;/p&gt;
&lt;p&gt;IPC: 进程/线程之间交换信息叫进程间通信．&lt;/p&gt;
&lt;p&gt;python的多线程由于GIL只有并发没有并行，无论有多少cpu,一次只能有一个python解释器(线程)执行.一次只能执行一个线程.一次只能用到一个逻辑cpu.&lt;/p&gt;
&lt;p&gt;IO密集型任务消耗IO,但是不消耗CPU,cpu切换消耗少,适合用多线程.&lt;/p&gt;
&lt;p&gt;python的多进程可以并行,每个进程启动一个解释器进程.&lt;/p&gt;
&lt;p&gt;多进程开销大，消耗内存.&lt;/p&gt;
&lt;p&gt;计算密集型消耗cpu,任务个数不超过cpu个数．适合用多进程，把每个cpu跑满.&lt;/p&gt;
&lt;p&gt;io密集 =》 用异步asyncio或者多线程
计算密集 =》 用多进程&lt;/p&gt;
&lt;h2 id=&#34;multiprocessing&#34;&gt;multiprocessing&lt;/h2&gt;
&lt;p&gt;多进程就是同时执行多个任务.&lt;/p&gt;
&lt;p&gt;python可以通过多进程取代多线程，从而绕过多线程的GIL.&lt;/p&gt;
&lt;p&gt;python是静态语言，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import multiprocessing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# multiprocessing.Process
proc = Process(group=None, target=None, name=None, args=(), kwargs={})
# methods:
run(self)
start(self) # 启动一个进程
join(self, timeout=None) # 父进程等待子进程结束
is_alive()
terminate(self)
# data descriptor:
authkey
daemon # proc.daemon = True 后台运行
exitcode
ident
name
pid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 普通函数
active_children()
allow_connection_pickling()
cpu_count() # 获取cpu个数
current_process()
freeze_support()
get_logger()
log_to_stderr(level=None)

Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)
pool = Pool()
# func只能是顶层函数，不能是方法和内部函数.
# 进程池，可以控制进程数量,processes 默认是cpu个数(cpu_count())
# 非阻塞，维持进程总数，当一个进程结束会添加新的进程到pool,主进程不阻塞，同步运行，pool中的进程并发执行.
apply_async(func, args=(), kwargs={}, callback=None) # 非阻塞,
map_async(func, iterable, chunksize=None, callback=None) # 非阻塞
# 阻塞，维持进程总数，当一个进程结束会添加新的进程到pool，主进程阻塞，pool中的进程一个一个执行.
apply(func, args=(), kwargs={}) # 阻塞
map(func, itreable, chunksize=None) # 阻塞
terminate() # 终止所有任务
close() # 关闭pool,不接受新任务
join() # 等待pool中子进程结束，要在close/terminate之后调用.

# IPC: 管道
Pipe(duplex=True) # duplex=True表示默认是双向pipe.
receiver, sender = Pipe()
sender.send(obj)
receiver.recv()
close()

# IPC: 消息队列
# 来自于Queue.Queue, 具体方法参考Queue.Queue
Queue(maxsize=0) # return a queue object
q = Queue()

# IPC: 共享内存
Manager()
list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array

Array(typecode_or_type, size_or_initializer, **kwds)

RawArray(typecode_or_type, size_or_initializer)

Value(typecode_or_type, *args, **kwds)

RawValue(typecode_or_type, *args)

Event()

# 同步：　条件变量
Condition(lock=None)

# 同步：信号量
Semaphore(value=1)

# 同步：有界信号量
BoundedSemaphore(value=1)

# 同步： 锁
Lock()

# 同步: 锁
RLock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SUBDEBUG = 5
SUBWARNING = 25
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;threading&#34;&gt;threading&lt;/h2&gt;
&lt;p&gt;多线程就是把单个任务分成不同部分运行.&lt;/p&gt;
&lt;p&gt;threading支持守护线程(通过join方法实现)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import threading
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# threading.Thread
t = Thread(group=None, target=None, name=None, args=(), kwargs=None, verbose=None)
threads.append(t)
# methods:
run(self) # 子类重写用来定义线程的功能的函数, 通常通过这种方式来创建线程
start(self) # 开始执行线程
join(self, timeout=None) # 主程序挂起，直到线程结束,再继续运行主程序
is_alive(self) # 表示线程是否还在运行的boolean
getName(self) # 返回线程名字
setName(self, name) # 设置线程名字
isDaemon(self) # 返回线程的daemon标志
setDaemon(self, daemonic) # daemonic=True 使线程在后台运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;active_count() # 当前活动的线程对象的数量
current_thread() # 返回当前线程对象
enumerate() # 返回当前活动线程列表
settrace(func) # 为所有的线程设置一个跟踪函数
setprofile(func) # 为所有线程设置一个profile函数
stack_size()

Timer(*args, **kwargs)
t = Timer(30.0, f, args=[], kwargs={})
t.start() # 在一个子线程等待，timeout就执行f(*args, **kwaargs).
t.cancel() # 如果还在等待就取消．

Event(*args, **kwargs)

# 同步：　条件变量
Condition(*args, **kwargs)

# 同步：　信号量
Semaphore(value=1, *args, **kwargs)
# 信号量，默认value=1, 内部计数器不能小于0,当计数器==0时，调用acquire会阻塞.

# 同步：　有界信号量
BoundedSemaphore(value=1, *args, **kwargs)
# 有界信号量，默认value=1，内部计数器不能小于0，并且不能大于value。
# 当计数器==0，调用acquire会阻塞，当&amp;gt;value抛出VAlueError异常
# 可用来控制并发运行的线程数量
bs = BoundSemaphore(number) # bs是全局的.
def thread_function(*args, **kwargs):
    ...
    bs.release() # 使计数器+1
for t in threads:
    bs.acquire() # 使计数器-1
    thread.start()
for t in threads:
    t.join()

# 同步：　锁
Lock()
# 使同一变量在多个线程间同步
lock = Lock()
variable = value
def thread_function(*args, **kwargs):
    global lock
    global variable
    lock.acquire() # 加锁，使线程进入同步阻塞状态
    variable = new_value
    lock.release() # 释放锁

# 同步：　锁
RLock(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;subprocess&#34;&gt;subprocess&lt;/h2&gt;
&lt;p&gt;开启一个子进程来执行外部命令.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import subprocess
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Popen(args,
bufsize=0, executable=None, stdin=None, stdout=None, stderr=None,
preexec_fn=None, close_fds=False, shell=False,cwd=None,
env=None, universal_newlines=False,startupinfo=None, creationflags=0)
# p = Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
# 如果命令和参数是字符串形式，需要参数shell=True
# p = Popen(command_string, shell=True, ...)

# 非交互执行sudo命令, 或者使用sh/pexpect等第三方库
Popen([&#39;sudo&#39;, &#39;-S&#39;] + shlex.split(command), stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, ...)
stdout, stderr = child.communicate(password+&#39;\n&#39;)

# methods:
poll() # 检查子进程是否结束，返回returncode.
wait() # 等待子进程结束，返回returncode.
communicate(input=None) # 返回(stdout, stderr).
kill() # 发送SIGKILL信号
pipe_cloexec()
send_signal(sig)
terminate()

# Data:
stdin
stdout
stderr
pid
returncode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call(*popenargs, **kwargs)
# retcode = call([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;])

check_call(*popenargs, **kwargs)
# check_call([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;]) -&amp;gt; 如果返回码为０就返回，否则抛出CalledProcessError.

check_output(*popenargs, **kwargs) # 返回一个字符串
# output = check_output([&amp;quot;ls&amp;quot;, &amp;quot;-l&amp;quot;, &amp;quot;/dev/null&amp;quot;]) -&amp;gt; 如果返回码为０返回命令结果，否则抛出CalledProcessError.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PIPE = -1
STDOUT = -2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sched&#34;&gt;sched&lt;/h2&gt;
&lt;h2 id=&#34;queue&#34;&gt;queue&lt;/h2&gt;
&lt;h2 id=&#34;dummy_threading&#34;&gt;dummy_threading&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;interprocess-communication-and-networking&#34;&gt;Interprocess Communication and Networking&lt;/h1&gt;
&lt;h2 id=&#34;socket&#34;&gt;socket&lt;/h2&gt;
&lt;p&gt;socket协议的标准库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import socket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# socket = class _socketobject(__builtin__.object)
# socket.socket([family[, type[, proto]]])
close() # 关闭socket
shutdown(flag) # 0 关闭读，１关闭写，２全部关闭
# eg: socket.socket(AF_INET, SOCK_STREAM, 0) ipv4+tcp
# eg: socket.socket(AF_INET, SOCK_DGRAM, 0) ipv4+udp

# methods:
bind(address) # 服务器绑定(host, port)到socket
listen(backlog) # 服务器开始监听tcp
accept() # 服务器阻塞等待客户的tcp连接, 返回(socket object, address info)

connect(address) # 客户端主动初始化tcp连接,连接失败抛出异常
connect_ex(address) # 同上，连接失败返回errno

send(data[, flags]) # 发送tcp数据
sendall(data[, flags]) # 发送完整tcp数据
recv(buflen[, flags]) # 接收tcp数据
recv_into(buffer[, nbytes[, flags]])

sendto(data[, flags], addr) # 发送udp数据
recvfrom(buflen[, flags]) # 接收udp数据
recvfrom_into(buffer[, nbytes, [, flags])])

getpeername() # 获取当前socket的远端地址
getsockname() # 获取当前socket的地址
getsockopt(level, option[, buffersize]) # 获取socket参数
setsockopt(level, option, value) # 设置socket参数

setblocking(flag)
gettimeout()
settimeout(timeout)

makefile([mode[, bufsize]])
fileno()

dup()

# data descriptor:
family/type/proto　参考man 2 socket
recv
recv_into
recvfrom
recvfrom_into
send
sendto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class SocketIO:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SocketIO(io.RawIOBase)
sio = SocketIO(sock, mode)

methods:
close()
readinto(b)
write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create_connection(address, timeout=&amp;lt;object object&amp;gt;, source_address=None)
fromfd(fd, family, type[, proto]) # 用一个已经打开的文件描述符创建一个socket对象
getaddrinfo(host, port [, family, socktype, proto, flags])
getdefaulttimeout()
getfqdn(name=&#39;&#39;) # FQDN, 获取完整域的信息
gethostbyaddr(host) -&amp;gt; (name, aliaslist, addresslist)
gethostbyname(host)
gethostbyname_ex(host) -&amp;gt; (name, aliaslist, addresslist)
gethostname()
getnameinfo(sockaddr, flags) --&amp;gt; (host, port)
getprotobyname(name)
getservbyname(servicename[, protocolname])
getservbyport(port[, protocolname])
htonl(integer)
htons(integer)
inet_aton(string)
inet_ntoa(packed_ip)
inet_ntop(af, packed_ip)
inet_pton(af, ip)
ntohl(integer)
ntohs(integer)
setdefaulttimeout(timeout)
socketpair([family[, type[, proto]]]) -&amp;gt; (socket object, socket object)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ssl&#34;&gt;ssl&lt;/h2&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;h2 id=&#34;selectors&#34;&gt;selectors&lt;/h2&gt;
&lt;h2 id=&#34;asyncio&#34;&gt;asyncio&lt;/h2&gt;
&lt;h2 id=&#34;asyncore&#34;&gt;asyncore&lt;/h2&gt;
&lt;h2 id=&#34;asynchat&#34;&gt;asynchat&lt;/h2&gt;
&lt;h2 id=&#34;signal&#34;&gt;signal&lt;/h2&gt;
&lt;h2 id=&#34;mmap&#34;&gt;mmap&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>PSL_Python</title>
        <link>https://canuxcheng.com/post/psl_python/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_python/</guid>
        <description>&lt;h1 id=&#34;python-runtime-services&#34;&gt;Python Runtime Services&lt;/h1&gt;
&lt;h2 id=&#34;_builtin_&#34;&gt;_&lt;em&gt;builtin&lt;/em&gt;_&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;builtin&lt;/strong&gt;/builtins - Built-in functions, exceptions, and other objects.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;python2叫__builtin__&lt;/p&gt;
&lt;p&gt;python3叫builtins&lt;/p&gt;
&lt;h2 id=&#34;_main_&#34;&gt;_&lt;em&gt;main&lt;/em&gt;_&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt; - Top-level script environment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当作为顶层脚本运行时(&lt;strong&gt;main&lt;/strong&gt;), 当作为一个模块运行时候就是模块名称．&lt;/p&gt;
&lt;h2 id=&#34;_future_&#34;&gt;_&lt;em&gt;future&lt;/em&gt;_&lt;/h2&gt;
&lt;p&gt;把下一个版本的新特性导入到当前版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import &amp;lt;feature_name&amp;gt;

# feature name:
all_feature_names # 一次导入所有feature
absolute_import # 绝对导入
division
generators
nested_scopes
print_function
unicode_literals # python2中u&#39;string&#39;才表示unicode, &#39;string&#39;表示str，python3中所有字符串都是unicode。
with_statement
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;all_feature_names
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sys&#34;&gt;sys&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import sys
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dynamic objects:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 动态对象
sys.argv # 命令行参数的列表，sys.argv[0]是程序名称, len(sys.argv)就是C语言中的argc
sys.path # 搜索的路径．import导入模块的搜索路径．
sys.modules # 字典格式的加载的模块.已经导入并加载的模块会加进来．
sys.stdin # 标准输入，用于input()
sys.stdout # 标准输出，用于print
sys.stderr # 标准出错
displayhook -- called to show results in an interactive session
excepthook --
last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback --
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Static objects:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 静态对象
float_info -- a dict with information about the float inplementation.
long_info -- a struct sequence with information about the long implementation.
maxint -- the largest supported integer (the smallest is -maxint-1).
maxsize -- the largest supported length of containers.
maxunicode -- the largest supported character
builtin_module_names -- tuple of module names built into this interpreter
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
hexversion -- version information encoded as a single integer
copyright -- copyright notice pertaining to this interpreter
platform -- platform identifier # 可以判断操作系统类型
sys.platform # &#39;win32&#39;, &#39;linux2&#39;, &#39;darwin&#39;
executable -- absolute path of the executable binary of the Python interpreter
prefix -- prefix used to find the Python library
exec_prefix -- prefix used to find the machine-specific Python library
float_repr_style -- string indicating the style of repr() output for floats
__stdin__ -- the original stdin; don&#39;t touch!
__stdout__ -- the original stdout; don&#39;t touch!
__stderr__ -- the original stderr; don&#39;t touch!
__displayhook__ -- the original displayhook; don&#39;t touch!
__excepthook__ -- the original excepthook; don&#39;t touch!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;displayhook() -- print an object to the screen, and save it in __builtin__._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- 返回当前异常的线程安全的三个信息．type, value, traceback.
exc_clear() -- 清空当前线程的异常状态
exit() -- 抛出 SystemExit 异常退出解释器
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flags # 命令行的状态，-d debug, -v verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysconfig&#34;&gt;sysconfig&lt;/h2&gt;
&lt;h2 id=&#34;future_builtins&#34;&gt;future_builtins&lt;/h2&gt;
&lt;h2 id=&#34;warnings&#34;&gt;warnings&lt;/h2&gt;
&lt;p&gt;python的警告模块，只警告，不中断程序运行．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import warnings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warn(message[, category[, stacklevel]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;contextlib&#34;&gt;contextlib&lt;/h2&gt;
&lt;p&gt;编写上下文管理器的模块．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import contextlib
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;abc&#34;&gt;abc&lt;/h2&gt;
&lt;p&gt;实现抽象方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# abc.ABCMeta
ABCMeta

# abc.abstractproperty
abstractproperty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstractmethod(funcobj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;atexit&#34;&gt;atexit&lt;/h2&gt;
&lt;h2 id=&#34;traceback&#34;&gt;traceback&lt;/h2&gt;
&lt;p&gt;For python stack traces. 追踪python的堆栈信息．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import traceback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extract_stack(f=None, limit=None)
extract_tb(tb, limit=None)
format_stack(f=None, limit=None)
format_tb(tb, limit=None) # 格式化后返回字符串
print_stack(f=None, limit=None, file=None)
print_tb(tb, limit=None, file=None) # 直接打印stacktrace信息
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gc&#34;&gt;gc&lt;/h2&gt;
&lt;p&gt;garbage collector：python的垃圾回收模块．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import gc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;inspect&#34;&gt;inspect&lt;/h2&gt;
&lt;p&gt;从运行的python对象获取有用的信息．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import inspect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classify_class_attrs(cls)
stack(context=1)
isgenerator()
isgeneratorfunction() # 检查一个函数是否是生成器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;site&#34;&gt;site&lt;/h2&gt;
&lt;h2 id=&#34;user&#34;&gt;user&lt;/h2&gt;
&lt;h2 id=&#34;fpectl&#34;&gt;fpectl&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_System</title>
        <link>https://canuxcheng.com/post/psl_system/</link>
        <pubDate>Mon, 15 Aug 2016 11:04:12 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_system/</guid>
        <description>&lt;h1 id=&#34;generic-operating-system-services&#34;&gt;Generic Operating System Services&lt;/h1&gt;
&lt;h2 id=&#34;os&#34;&gt;os&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import os

os.path # 参考PSL_File
os.name
os.curdir
os.pardir # 表示上一级路径.., 需要用abspath解析
# os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))
os.sep
os.extsep
os.altsep
os.pathsep
os.linesep
os.defpath
os.devnull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WCOREDUMP(...)
...

abort(...)
fork() # 创建一个子进程，返回0给子进程，返回子进程pid给父进程．
exec*
wait() # 等待子进程结束，返回(pid, status).
waitpid(pid, options) # 等待指定子进程结束.
listdir(path) # 列出目录下的文件和目录
makedirs(path [, mode=0o777], exist_ok=False)
mkdir(path [, mode=0777])
walk(top, topdown=True, onerror=None, followlinks=False) # 返回 (dirpath, dirnames, filenames) 类型的迭代器
remove(path) # 删除文件
rmdir(path) # 删除目录
removedirs(path)
symlink(src, dst)
chown(path, uid, gid)
chmod(path, mode=0o777)
...

# 使用subprocess模块代替下列函数：
system(command) # 在subshell执行命令，返回退出码(windows系统始终为0),而非命令执行结果．
spawn*
popen*(command [, mode=&#39;r&#39; [, bufsize]]) # 执行命令，返回命令执行结果的文件句柄(file对象)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EX_CANTCREAT = 73
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;time&#34;&gt;time&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clock()
sleep(seconds) # 延迟
tzset()

# 获取时间戳(Epoch seconds)
time() # 获取当前时间戳
mktime(tuple) # mktime((2017,8,23,11,7,10,12)) , 参数是时间元组

# 获取时间元组 (tm_year,tm_mon,tm_mday,tm_hour,tm_min, tm_sec,tm_wday,tm_yday,tm_isdst)
localtime([seconds]) # 参数是时间戳
gmtime([seconds]) # 参数是时间戳
strptime(string, format) # 参数是时间字符串

# 获取时间字符串
asctime([tuple]) # 参数是时间元组
strftime(format[, tuple]) # 参数是时间元组
ctime(seconds) # 参数是时间戳
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;logging&#34;&gt;logging&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import logging
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Logger(Filterer)
# methods:
setLevel(self, level) # 只会输出指定level以上的log, 默认是WARNING
critical(self, msg, *args, **kwargs) # 50
error(self, msg, *args, **kwargs) # 40
warning(self, msg, *args, **kwargs) # 30
info(self, msg, *args, **kwargs) # 20
debug(self, msg, *args, **kwargs) # 10
exception(self, msg, *args, **kwargs) #
log(self, level, msg, *args, **kwargs) #
addHandler(self, hdlr) # 添加handler到logger

Formatter
# %(asctime)s:%(levelname)s:%(name)s:%(message)s&#39;
Formatter(fmt=None, datefmt=None)

Handler(Filterer)
# methods:
setFormatter(self, fmt)
setLevel(self, level)

StreamHandler(Handler) # 默认打印到sys.stderr
StreamHandler(stream=None)

FileHandler(StreamHandler) # 打印到文件
FileHandler(filename, mode=&#39;a&#39;, encoding=None, delay=0)

# from logging.handlers import *
WatchedFileHandler
RotatingFileHandler
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;basicConfig(**kwargs) # 设置log的格式
# filename/filemode/format/datefmt/level/stream
# format默认是BASIC_FORMAT.
# level默认是warning/warn.
# stream默认是sys.stderr,当filename和stream同时指定，stream被忽略．
# datafmt
# filename 日志文件名
# filemode w每次覆盖写入，a每次追加写入

getLogger(name=None) # 返回Logger类型对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BASIC_FORMAT = &#39;%(levelname)s:%(name)s:%(message)s&#39;
CRITICAL = 50
FATAL = 50
ERROR = 40
WARN = 30
WARNING = 30
INFO = 20
DEBUG = 10
NOTSET = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getopt&#34;&gt;getopt&lt;/h2&gt;
&lt;p&gt;C风格的参数处理.&lt;/p&gt;
&lt;h2 id=&#34;argparse&#34;&gt;argparse&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import argparse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# argparse.ArgumentParser(_AttributeHolder, _ActionsContainer)
parser = argparse.ArgumentParser()
    prog -- The name of the program (default: sys.argv[0])
    usage -- A usage message (default: auto-generated from arguments)
    description -- A description of what the program does
    epilog -- Text following the argument descriptions
    parents -- Parsers whose arguments should be copied into this one
    formatter_class -- HelpFormatter class for printing help messages
    prefix_chars -- Characters that prefix optional arguments
    fromfile_prefix_chars -- Characters that prefix files  containing additional arguments
    argument_default -- The default value for all arguments
    conflict_handler -- String indicating how to handle conflicts
    add_help -- Add a -h/-help option
# methods:
add_argument_group(self, *args, **kwargs) # -&amp;gt; argparse._ArgumentGroup
add_argument(self, *args, **kwargs)
    name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.
    action - The basic type of action to be taken when this argument is encountered at the command line.
    nargs - The number of command-line arguments that should be consumed.
    const - A constant value required by some action and nargs selections.
    default - The value produced if the argument is absent from the command line.
    type - The type to which the command-line argument should be converted.
    choices - A container of the allowable values for the argument.
    required - Whether or not the command-line option may be omitted (optionals only).
    help - A brief description of what the argument does. # 用来打印默认值：%(default)s
    metavar - A name for the argument in usage messages.
    dest - The name of the attribute to be added to the object returned by.
add_subparsers(self, **kwargs) # -&amp;gt; argparse._SubParsersAction
add_mutually_exclusive_group(self, **kwargs)
set_defaults(self, **kwargs)
parse_args(self, args=None, namespace=None) # -&amp;gt; argparse.Namespace
parse_known_args(self, args=None, namespace=None) # -&amp;gt; argparse.Namespace
convert_arg_line_to_args(self, arg_line)
error(self, message)
exit(self, status=0, message=None)
format_help(self)
format_usage(self)
format_version(self)
print_help(self, file=None)
print_usage(self, file=None)
print_version(self, file=None)
get_default(self, dest)
register(self, registry_name, value, object)

# argparse._ArgumentGroup
# methods:
add_argument(self, *args, **kwargs)
add_argument_group(self, *args, **kwargs)
add_mutually_exclusive_group(self, **kwargs)
get_default(self, dest)
register(self, registry_name, value, object)
set_defaults(self, **kwargs)

# argparse._SubParsersAction
# methods:
add_parser(self, name, **kwargs) # -&amp;gt; argparse.ArgumentParser

# HelpFormatter

# Action
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;io&#34;&gt;io&lt;/h2&gt;
&lt;h2 id=&#34;errno&#34;&gt;errno&lt;/h2&gt;
&lt;h2 id=&#34;getpass&#34;&gt;getpass&lt;/h2&gt;
&lt;h2 id=&#34;curses&#34;&gt;curses&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/psl/mycurses.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/psl/mycurses.py&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import curses
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;platform&#34;&gt;platform&lt;/h2&gt;
&lt;h2 id=&#34;ctypes&#34;&gt;ctypes&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import ctypes
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unixlinux-sytem&#34;&gt;Unix/Linux sytem&lt;/h1&gt;
&lt;h2 id=&#34;pwd&#34;&gt;pwd&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据用户名获取uid和gid
pw = getpwnam(user)  
pw.pw_uid
pw.pw_gid

getpwuid(uid)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;grp&#34;&gt;grp&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import grp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;group = group.getgrnam(&amp;lt;group_name&amp;gt;)
group.gr_name // 返回组名
group.gr_mem // 返回该组的所有用户
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_GUI</title>
        <link>https://canuxcheng.com/post/psl_gui/</link>
        <pubDate>Mon, 15 Aug 2016 10:28:54 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_gui/</guid>
        <description>&lt;h1 id=&#34;gui&#34;&gt;GUI&lt;/h1&gt;
&lt;h2 id=&#34;tkinter&#34;&gt;Tkinter&lt;/h2&gt;
&lt;h2 id=&#34;ttk&#34;&gt;ttk&lt;/h2&gt;
&lt;h2 id=&#34;tix&#34;&gt;Tix&lt;/h2&gt;
&lt;h2 id=&#34;scrolledtext&#34;&gt;ScrolledText&lt;/h2&gt;
&lt;h2 id=&#34;turtle&#34;&gt;turtle&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;wxwidgets&#34;&gt;wxWidgets&lt;/h2&gt;
&lt;p&gt;python2的库叫wxPython.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wxpython.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wxpython.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Windows下载安装包安装即可．
$ sudo apt-get install python-wxgtk2.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python３启用新的项目phoneix.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/wxWidgets/Phoenix&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wxWidgets/Phoenix&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;gtk&#34;&gt;gtk&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;PyGTK
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;qt&#34;&gt;qt&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;PyQt
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_Misc</title>
        <link>https://canuxcheng.com/post/psl_misc/</link>
        <pubDate>Mon, 15 Aug 2016 10:28:46 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_misc/</guid>
        <description>&lt;h1 id=&#34;psl&#34;&gt;PSL&lt;/h1&gt;
&lt;p&gt;Python Standard Library: Python标准库&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;internationalization&#34;&gt;Internationalization&lt;/h1&gt;
&lt;h2 id=&#34;gettext&#34;&gt;gettext&lt;/h2&gt;
&lt;h2 id=&#34;locale&#34;&gt;locale&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;program-frameworks&#34;&gt;Program Frameworks&lt;/h1&gt;
&lt;h2 id=&#34;cmd&#34;&gt;cmd&lt;/h2&gt;
&lt;h2 id=&#34;shlex&#34;&gt;shlex&lt;/h2&gt;
&lt;p&gt;类shell的词法分析．&lt;/p&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shlex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;split(s, comments=False, posix=True)
# split(&amp;quot;command **kwargs&amp;quot;) -&amp;gt; [&#39;command&#39;, &#39;arg1&#39;, ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;custom-python-interpreters&#34;&gt;Custom Python Interpreters&lt;/h1&gt;
&lt;h2 id=&#34;code&#34;&gt;code&lt;/h2&gt;
&lt;h2 id=&#34;codeop&#34;&gt;codeop&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python-language-services&#34;&gt;Python Language Services&lt;/h1&gt;
&lt;h2 id=&#34;keyword&#34;&gt;keyword&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import keyword
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keyword.iskeyword(keyword) # x.__contains__(y) &amp;lt;==&amp;gt; y in x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keyword.kwlist # 返回所有关键字的列表
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;parser&#34;&gt;parser&lt;/h2&gt;
&lt;h2 id=&#34;ast&#34;&gt;ast&lt;/h2&gt;
&lt;h2 id=&#34;symtable&#34;&gt;symtable&lt;/h2&gt;
&lt;h2 id=&#34;symbol&#34;&gt;symbol&lt;/h2&gt;
&lt;h2 id=&#34;token&#34;&gt;token&lt;/h2&gt;
&lt;h2 id=&#34;tokenize&#34;&gt;tokenize&lt;/h2&gt;
&lt;h2 id=&#34;tabnanny&#34;&gt;tabnanny&lt;/h2&gt;
&lt;h2 id=&#34;pyclbr&#34;&gt;pyclbr&lt;/h2&gt;
&lt;h2 id=&#34;py_compile&#34;&gt;py_compile&lt;/h2&gt;
&lt;h2 id=&#34;compileall&#34;&gt;compileall&lt;/h2&gt;
&lt;h2 id=&#34;dis&#34;&gt;dis&lt;/h2&gt;
&lt;h2 id=&#34;pickletools&#34;&gt;pickletools&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;importing-modules&#34;&gt;Importing Modules&lt;/h1&gt;
&lt;h2 id=&#34;imp&#34;&gt;imp&lt;/h2&gt;
&lt;h2 id=&#34;importlib&#34;&gt;importlib&lt;/h2&gt;
&lt;h2 id=&#34;zipimport&#34;&gt;zipimport&lt;/h2&gt;
&lt;h2 id=&#34;pkgutil&#34;&gt;pkgutil&lt;/h2&gt;
&lt;h2 id=&#34;modulefinder&#34;&gt;modulefinder&lt;/h2&gt;
&lt;h2 id=&#34;runpy&#34;&gt;runpy&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;miscellaneous-services&#34;&gt;Miscellaneous Services&lt;/h1&gt;
&lt;h2 id=&#34;formatter&#34;&gt;formatter&lt;/h2&gt;
&lt;h2 id=&#34;ihooks&#34;&gt;ihooks&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>PSL_Cryptographic</title>
        <link>https://canuxcheng.com/post/psl_cryptographic/</link>
        <pubDate>Sun, 14 Aug 2016 21:15:14 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_cryptographic/</guid>
        <description>&lt;h1 id=&#34;cryptographic-services&#34;&gt;Cryptographic Services&lt;/h1&gt;
&lt;h2 id=&#34;hashlib&#34;&gt;hashlib&lt;/h2&gt;
&lt;p&gt;哈希算法和摘要算法标准库，就是把任意长度的数据转换为一个长度固定的数据串．&lt;/p&gt;
&lt;p&gt;MD5: Message Digest Algorithm 5.&lt;/p&gt;
&lt;p&gt;SHA1: Secure Hash Algorithm.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import hashlib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# methods:
# 哈希对象有下列方法：
update(arg) # 更新字符串
md5.update(&#39;string or read from a file&#39;) # 放入需要转换的内容

digest() # 字符串
hexdigest() # 十六进制字符串
md5.hexdigest() # 获取md5十六进制字符串

copy() # 复制哈希对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 下类函数都返回哈希对象
new(name, string=&#39;&#39;)
md5()
md5 = hashlib.md5() # 创建一个md5的hash对象
sha1()
sha224()
sha256()
sha384()
sha512()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hmac&#34;&gt;hmac&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;pycrypto&#34;&gt;pycrypto&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dlitz/pycrypto&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dlitz/pycrypto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows需要MS Visual C++ compiler for python2.7.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install pycrypto
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ecdsa&#34;&gt;ecdsa&lt;/h2&gt;
&lt;p&gt;pure-python ECDSA signature/verification&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/warner/python-ecdsa&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/warner/python-ecdsa&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install ecdsa
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pygpgme&#34;&gt;pygpgme&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi/pygpgme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi/pygpgme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A Python wrapper for the GPGME library.&lt;/p&gt;
&lt;p&gt;Windows安装失败？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 需要先安装gpgme的开发库
$ sudo apt-get install libgpgme11-dev
$ pip install pygpgme
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>PSL_Data</title>
        <link>https://canuxcheng.com/post/psl_data/</link>
        <pubDate>Sun, 14 Aug 2016 20:57:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_data/</guid>
        <description>&lt;h1 id=&#34;data-types&#34;&gt;Data Types&lt;/h1&gt;
&lt;h2 id=&#34;datetime&#34;&gt;datetime&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import datetime
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# datetime.date
date(year, month, day)
# methods:
ctime(...)
...
# data descriptors:
day
month
year

# datetime.datetime(datetime.date)
datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])
# methods:
datetime.datetime.strptime(string, format)
format_datetime = datetime.datetime.strptime(&#39;20160824161431&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)
format_datetime = datetime.datetime.strptime(&#39;24 August 2016 16:14:31&#39;, &#39;%Y%m%d%H%M%S&#39;) # return: datetime.datetime(2016, 8, 24, 16, 14, 31)

datetime.datetime.strftime(format[, tuple])
string_datetime = format_datetime.strftime(&amp;quot;%d %B %Y %H:%M:%S&amp;quot;) # return: &#39;24 August 2016 16:14:31&#39;
datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) # return: &#39;2017-02-07 23:07:32&#39;

str(datetime.datetime.now())
datetime.datetime.now().strftime(&#39;%Y%m%d%H%M%S&#39;) # 当前时间戳

# datetime.time

# datetime.timedelta

# datetime.tzinfo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MAXYEAR = 9999
MINYEAR = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;calendar&#34;&gt;calendar&lt;/h2&gt;
&lt;h2 id=&#34;collections&#34;&gt;collections&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import collections
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# collections.Callable

# collections.Container

# collections.Counter

# collections.Hashable

# collections.ItemsView

# collections.Iterable

# collections.Iterator

# collections.deque
# 返回一个deque类型的实例，也就是双端队列
deque([iterable[, maxlen]])

# collections.defaultdict
# 返回一个defaultdict类型的实例，类似于dict.setdefault()
defaultdict(default_factory[, ...])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;namedtuple(typename, field_names, verbose=False, rename=False)
# 返回一个tuple的子类, 将只能通过index访问的tuple变为可以通过name来访问．
NewTuple = namedtuple(&#39;NewTuple&#39;, [&#39;elm1&#39;, &#39;elm2&#39;, &#39;elm3&#39;])
nt = NewTuple(1, 2, 3)
nt.elm1 # 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;heapq&#34;&gt;heapq&lt;/h2&gt;
&lt;h2 id=&#34;bisect&#34;&gt;bisect&lt;/h2&gt;
&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;
&lt;h2 id=&#34;sched&#34;&gt;sched&lt;/h2&gt;
&lt;h2 id=&#34;queue&#34;&gt;Queue&lt;/h2&gt;
&lt;p&gt;队列数据结构．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Queue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Queue.Queue
Queue(maxsize=0) # 创建一个大小为maxsize的queue对象
# methods:
empty(self) # 如果queue为空返回True
full(self) # 如果queue达到maxsize返回True
get(self, block=True, timeout=None) # 从队列中取出一个元素并返回,如果block=True,会一直阻塞,直到队列中有元素．
get_nowait(self)
join(self)
put(self, item, block=True, timeout=None) # 把item放到队列中,如果block=true,会一直阻塞,直到队列有空间存放item.
put_nowait(self, item)
qsize(self) # 返回queue大小，近似值
task_done(self)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;weakref&#34;&gt;weakref&lt;/h2&gt;
&lt;h2 id=&#34;userdict&#34;&gt;UserDict&lt;/h2&gt;
&lt;h2 id=&#34;userlist&#34;&gt;UserList&lt;/h2&gt;
&lt;h2 id=&#34;userstring&#34;&gt;UserString&lt;/h2&gt;
&lt;h2 id=&#34;types&#34;&gt;types&lt;/h2&gt;
&lt;h2 id=&#34;copy&#34;&gt;copy&lt;/h2&gt;
&lt;p&gt;copy和deepcopy都只拷贝对象的类型和数值，不拷贝对象的ID.也就是==运算为True, is(id())运算为False.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import copy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy.copy(x) # 浅复制, 只拷贝父对象，不拷贝内部的子对象.
copy.deepcopy(x, memo=None, _nil=[]) # 深复制, 拷贝父对象和内部的子对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pprint&#34;&gt;pprint&lt;/h2&gt;
&lt;h2 id=&#34;repr&#34;&gt;repr&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-persistence&#34;&gt;Data Persistence&lt;/h1&gt;
&lt;p&gt;pickle/cPickle/marshal提供对象的序列化操作．&lt;/p&gt;
&lt;p&gt;gdb相关的模块anydbm/whichdb/dbm/gdbm/dumbdbm提供类似字典和文件的对象．&lt;/p&gt;
&lt;p&gt;shelve集合了以上两者的功能．&lt;/p&gt;
&lt;h2 id=&#34;pickle&#34;&gt;pickle&lt;/h2&gt;
&lt;p&gt;pickle不支持unicode,只支持ascii.&lt;/p&gt;
&lt;h2 id=&#34;cpickle&#34;&gt;cPickle&lt;/h2&gt;
&lt;p&gt;python3将cPickle和pickle统一合并为pickle.&lt;/p&gt;
&lt;p&gt;cPickle是c开发的，速度比pickle快，但是不支持被继承．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import cPickle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pickler(file, protocol=0)
Unpickler(file)
dump(obj, file, protocol=0) # 写入到一个文件
dumps(obj, protocol=0) # 写入到一个字符串
load(file) # 从文件读取
loads(string) # 从字符串读取
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HIGHEST_PROTOCOL = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;marshal&#34;&gt;marshal&lt;/h2&gt;
&lt;h2 id=&#34;shelve&#34;&gt;shelve&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import shelve

with shelve.open(f, flag=&#39;n&#39;, writeback=True) as f:
r/w: 不存在报错
c: read-write to new/existing，不存在创建
n: read-write to new. 总是创建新的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;anydbm&#34;&gt;anydbm&lt;/h2&gt;
&lt;h2 id=&#34;whichdb&#34;&gt;whichdb&lt;/h2&gt;
&lt;h2 id=&#34;dbm&#34;&gt;dbm&lt;/h2&gt;
&lt;h2 id=&#34;gdbm&#34;&gt;gdbm&lt;/h2&gt;
&lt;h2 id=&#34;dumbdbm&#34;&gt;dumbdbm&lt;/h2&gt;
&lt;h2 id=&#34;cope_reg&#34;&gt;cope_reg&lt;/h2&gt;
&lt;h2 id=&#34;pickletools&#34;&gt;pickletools&lt;/h2&gt;
&lt;h2 id=&#34;sqlite&#34;&gt;sqlite&lt;/h2&gt;
&lt;p&gt;python访问数据库两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ORM&lt;/li&gt;
&lt;li&gt;DB-API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ORM是对象-关系管理器，相关模块有SQLAlchemy, SQLObject.&lt;/p&gt;
&lt;p&gt;DB-API参考PEP248/249定义了Database的API。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0249/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0249/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sqlite3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sqlite3.Connection
# methods:
close(...)
commit(...)
cursor(...)
execute(...)
...

# sqlite3.Cursor
# methods:
close(...)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adapt(obj, protocol, alternate)
connect(database[, timeout, isolation_level, detect_types, factory])
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;data-compression-and-archiving&#34;&gt;Data Compression and Archiving&lt;/h1&gt;
&lt;h2 id=&#34;gzip&#34;&gt;gzip&lt;/h2&gt;
&lt;h2 id=&#34;bz2&#34;&gt;bz2&lt;/h2&gt;
&lt;h2 id=&#34;zlib&#34;&gt;zlib&lt;/h2&gt;
&lt;h2 id=&#34;zipfile&#34;&gt;zipfile&lt;/h2&gt;
&lt;h2 id=&#34;tarfile&#34;&gt;tarfile&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_File</title>
        <link>https://canuxcheng.com/post/psl_file/</link>
        <pubDate>Sun, 14 Aug 2016 20:51:28 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_file/</guid>
        <description>&lt;h1 id=&#34;file-and-directory-access&#34;&gt;File and Directory Access&lt;/h1&gt;
&lt;h2 id=&#34;ospath&#34;&gt;os.path&lt;/h2&gt;
&lt;p&gt;windows的路径要写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\\test\\sub\\

import os
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os.path.expanduser(path) # 把path中~或~user扩展成绝对路径 expanduser(&amp;quot;~/src&amp;quot;) -&amp;gt; /home/user/src
os.path.expandvars(path) # 把path中的shell变量$var 或 ${var} 还原．
os.path.dirname(filename) # 返回filename的路径 dirname(&amp;quot;/home/user/file.py&amp;quot;) -&amp;gt; /home/user
os.path.join(a, *p) # 拼结一个完整的路径　
os.path.join(a, os.pardir) # 返回上级目录的路径
os.path.realpath(filename) # 返回filename的真实路径+文件名 realpath(&#39;__file__&#39;)
os.path.abspath(path) # 返回绝对路径, os.path.abspath(&#39;__file__&#39;)
os.path.splitext(p) # 分解路径和扩展名返回组成的元组，/home/user/test.py -&amp;gt; (&amp;quot;/home/user/test&amp;quot;, &amp;quot;.py&amp;quot;)
os.path.basename(p) # 返回最后一个组件名，也就是文件名 /home/user/test.py -&amp;gt; test.py
os.path.getsize(filename) # 返回文件大小
os.path.exists(path) # 判断path(文件或目录)是否存在
os.path.isfile(path) # 判断path是否是常规文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pathlib&#34;&gt;pathlib&lt;/h2&gt;
&lt;p&gt;new in python3.4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pathlib import Path
from pathlib import PurePosixPath
from pathlib import PureWindowsPath
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stat&#34;&gt;stat&lt;/h2&gt;
&lt;h2 id=&#34;fileinput&#34;&gt;fileinput&lt;/h2&gt;
&lt;h2 id=&#34;filecmp&#34;&gt;filecmp&lt;/h2&gt;
&lt;h2 id=&#34;fnmatch&#34;&gt;fnmatch&lt;/h2&gt;
&lt;h2 id=&#34;linecache&#34;&gt;linecache&lt;/h2&gt;
&lt;h2 id=&#34;glob&#34;&gt;glob&lt;/h2&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glob(pathname) # 返回匹配pathname路径下正则表达式的所有文件组成的列表
iglob(pathname) # 同上，返回generator.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shutil&#34;&gt;shutil&lt;/h2&gt;
&lt;p&gt;Utility functions for copying and archiving files and directory trees.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import shutil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copy(src, dst)
copy2(src, dst)
...
rmtree(path, ignore_errors=False, onerror=None) # 删除指定的目录,path不能是文件．
unregister_archive_format(name)
move(src, dst)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tempfile&#34;&gt;tempfile&lt;/h2&gt;
&lt;h2 id=&#34;macpath&#34;&gt;macpath&lt;/h2&gt;
&lt;h2 id=&#34;configparser&#34;&gt;ConfigParser&lt;/h2&gt;
&lt;p&gt;一般用来处理*.ini文件，格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[section]
option-key = option-value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import ConfigParser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ConfigParser.ConfigParser(defaults=None)
# methods:
read(filenames) # 读取ini文件
sections() # 获取所有section
options(section) # 获取section的所有option
get(section, option, raw=False, vars=None) # 返回字符串
getint(section, options)
getfloat(section, options)
getboolean(section, options) # 大小写都可以:0/1, false/true, no/yes, off/on
set(section, option, value)
has_section(section)
has_option(section, option)
remove_section(section)
remove_option(section, option)
write(fp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;issue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;默认是全部小写写入.
config = ConfigParser.ConfigParser(allow_no_value=True)
config.optionxform =str # 原样写入

from configparser import ConfigParser, ExtendedInterpolation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 默认interpolation只支持section之间变量
[section1]
1var1 = /opt
1var2 = %(1var1)s/test

// 扩展interpolation支持section变量引用
config = ConfigParser(interpolation=ExtendedInterpolation())

[section1]
1var1 = /opt
[section2]
2var1 = ${section1:1var1}/test
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;file-formats&#34;&gt;File Formats&lt;/h1&gt;
&lt;h2 id=&#34;csv&#34;&gt;csv&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# csv.DictReader
DictReader(self, f, fieldnames=None, restkey=None, restval=None, dialect=&#39;excel&#39;, *args, **kwds)
# methods
next()

# csv.DictWriter
DictWriter(self, f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, *args, **kwargs)
# mthods
writeheader()
writerow(rowdict)
writerows(rowdicts)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回DictReader对象
reader(iterable, dialect=&#39;excel&#39;, **kwargs)

// 返回DictWriter对象
writer(fileobj, dialect=&#39;excel&#39;, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;robotparser&#34;&gt;robotparser&lt;/h2&gt;
&lt;h2 id=&#34;netrc&#34;&gt;netrc&lt;/h2&gt;
&lt;h2 id=&#34;xdrlib&#34;&gt;xdrlib&lt;/h2&gt;
&lt;h2 id=&#34;plistlib&#34;&gt;plistlib&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Math</title>
        <link>https://canuxcheng.com/post/psl_math/</link>
        <pubDate>Fri, 12 Aug 2016 16:56:45 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_math/</guid>
        <description>&lt;h1 id=&#34;numeric-and-mathematical-modules&#34;&gt;Numeric and Mathematical Modules&lt;/h1&gt;
&lt;h2 id=&#34;random&#34;&gt;random&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import random
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# random.Random
Random()
# methods:
seed([self,], a=None)
randint(a, b) # 随机一个[a,b]中的整数．
choice(self, seq) # 从seq中随机选择一个元素
uniform(self, a, b)
sample(self, population, k)
randint(self, a, b)
randrange(self, start, stop=None, step=1, _int=&amp;lt;type &#39;int&#39;&amp;gt;, _maxwidth=9007199254740992L)

# random.SystemRandom(Random)
SystemRandom(Random)

# random.WichmannHill(Random)
WichmannHill(Random)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getrandbits(k)
random(self) # 随机一个小于１的数．
# 所有Random类的methods也可以直接使用．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fractions&#34;&gt;fractions&lt;/h2&gt;
&lt;h2 id=&#34;functools&#34;&gt;functools&lt;/h2&gt;
&lt;p&gt;函数式编程相关的模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import functools
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# functools.partial
partial(func, *args, **keywords) # 返回functools.partial类型的对象, partial是functools内置的偏函数类类型.
RED = partial(lambda content, color: color + str(content) + Fore.RESET, color=Fore.RED)
RED(&amp;quot;show me red&amp;quot;) == lambda content, color: Fore.RED + str(&amp;quot;show me red&amp;quot;) + Fore.RESET
# 相当于通过partial传一个参数给func，然后剩下的参数通过返回的偏函数传入．这样可以固化一部分参数．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reduce(function, sequence[, initial]) # 如果initial存在，就把initial作为function的第一个参数，如果function有两个参数，就再从sequence取第一个元素作为function的第二个参数，然后调用function，返回的结果作为function的第一个参数，再继续从sequence获取元素作为参数，继续调用function, 直到sequence为空．
reduce(lambda x,y: x+y, range(5))

cmp_to_key(mycmp)
total_ordering(cls)
update_wrapper(wrapper, wrapped, assigned=(&#39;__module__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;), updated=(&#39;__dict__&#39;,))

wraps(wrapped, assigned=(&#39;__module__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;), updated=(&#39;__dict__&#39;,))
# example:
def deco(func):
    @wraps(func):
    def wrapper(*args, **kwargs):
        &amp;quot;&amp;quot;&amp;quot;Docs for wrapper.&amp;quot;&amp;quot;&amp;quot;
        pass

@deco
def foo()
    &amp;quot;&amp;quot;&amp;quot;Docs for new function.&amp;quot;&amp;quot;&amp;quot;
    pass

# 不用wraps被装饰的函数foo的属性其实是原来函数的属性，也就是wrapper的属性
# 用了wraps被装饰的函数foo的属性就是foo自己的属性．
print foo.__name__
print foo.__doc__
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;operator&#34;&gt;operator&lt;/h2&gt;
&lt;p&gt;操作符相关的模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import operator
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decimal&#34;&gt;decimal&lt;/h2&gt;
&lt;h2 id=&#34;itertools&#34;&gt;itertools&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import itertools
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmath&#34;&gt;cmath&lt;/h2&gt;
&lt;h2 id=&#34;math&#34;&gt;math&lt;/h2&gt;
&lt;h2 id=&#34;numbers&#34;&gt;numbers&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_String</title>
        <link>https://canuxcheng.com/post/psl_string/</link>
        <pubDate>Fri, 12 Aug 2016 16:49:07 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_string/</guid>
        <description>&lt;h1 id=&#34;text-processing-services&#34;&gt;Text Processing Services&lt;/h1&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ascii_letters
ascii_lowercase
ascii_uppercase
digits
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;re&#34;&gt;re&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import re
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile(pattern, flags=0)
escape(pattern)
findall(pattern, string, flags=0)
finditer(pattern, string, flags=0)
match(pattern, string, flags=0) # if not match, return None, else return object.
search(pattern, string, flags=0)
purge()
split(pattern, string, maxsplit=0, flags=0) # 根据pattern分割string,返回分割后的列表．
sub(pattern, repl, string, count=0, flags=0)
subn(pattern, repl, string, count=0, flags=0)
template(pattern, flags=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# flags:
IGNORECASE # 大小写不敏感
LOCALE
MULTILINE
DOTALL
VERBOSE
UNICODE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;modules:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sre_parse module
# functions:
sre_parse.parse(str, flags=0, pattern=None)
sre_parse.expand_template(template, match)
sre_parse.parse_template(source, pattern)

# sre_compile module
# functions:
sre_compile.compile(p, flags=0)
sre_compile.isstring(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cstringio&#34;&gt;cStringIO&lt;/h2&gt;
&lt;h2 id=&#34;stringio&#34;&gt;StringIO&lt;/h2&gt;
&lt;h2 id=&#34;codecs&#34;&gt;codecs&lt;/h2&gt;
&lt;p&gt;python的编码解码器coder/decoder。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import codecs

# 使用注册名为encoding的编码器编码obj，encoding默认为ascii。
# encode将unicode编码的obj编码成encoding编码对应的字节序列．
codecs.encode(obj, [encoding[,errors]])
codecs.encode(u&#39;hello world&#39;, &#39;utf-8&#39;) # 编码成utf-8字节序．

# 使用注册名为encoding的解码器解码obj，encoding默认是ascii。
# decode将原来按照encoding编码的obj解码成unicode字符串.
codecs.decode(obj, [encoding[,errors]])
codecs.decode(obj, &#39;utf-8&#39;) # 将utf-8编码的obj解码成unicode.

# encoding取下面值:
# ascii是默认值,gb2312, gbk, gb18030, utf-8, utf-16
# ascii利用一个字节把字符转换成数字．
# unicode利用多字节转换，支持多种编码方式，utf-8, uft-16.

# errors取下面值：
# strict, 默认值，抛出UnicodeError异常。
# ignore
# replace
# xmlcharrefreplace
# backslashreplace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open(filename, mode=&#39;rb&#39;, encoding=None, errors=&#39;strict&#39;, buffering=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data:&lt;/p&gt;
&lt;h2 id=&#34;struct&#34;&gt;struct&lt;/h2&gt;
&lt;h2 id=&#34;difflib&#34;&gt;difflib&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import difflib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get_close_matches(word, possibilities, n=3, cutoff=0.6)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;textwrap&#34;&gt;textwrap&lt;/h2&gt;
&lt;h2 id=&#34;unicodedata&#34;&gt;unicodedata&lt;/h2&gt;
&lt;h2 id=&#34;stringprep&#34;&gt;stringprep&lt;/h2&gt;
&lt;h2 id=&#34;readline&#34;&gt;readline&lt;/h2&gt;
&lt;h2 id=&#34;rlcompleter&#34;&gt;rlcompleter&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Multimedia</title>
        <link>https://canuxcheng.com/post/psl_multimedia/</link>
        <pubDate>Fri, 12 Aug 2016 15:51:56 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_multimedia/</guid>
        <description>&lt;h1 id=&#34;multimedia-services&#34;&gt;Multimedia Services&lt;/h1&gt;
&lt;h2 id=&#34;audioop&#34;&gt;audioop&lt;/h2&gt;
&lt;h2 id=&#34;aifc&#34;&gt;aifc&lt;/h2&gt;
&lt;h2 id=&#34;sunau&#34;&gt;sunau&lt;/h2&gt;
&lt;h2 id=&#34;wave&#34;&gt;wave&lt;/h2&gt;
&lt;h2 id=&#34;chunk&#34;&gt;chunk&lt;/h2&gt;
&lt;h2 id=&#34;colorsys&#34;&gt;colorsys&lt;/h2&gt;
&lt;h2 id=&#34;imghdr&#34;&gt;imghdr&lt;/h2&gt;
&lt;h2 id=&#34;sndhdr&#34;&gt;sndhdr&lt;/h2&gt;
&lt;h2 id=&#34;ossaudiodev&#34;&gt;ossaudiodev&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Network</title>
        <link>https://canuxcheng.com/post/psl_network/</link>
        <pubDate>Fri, 12 Aug 2016 14:21:36 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_network/</guid>
        <description>&lt;h1 id=&#34;internet-protocols-and-support&#34;&gt;Internet Protocols and Support&lt;/h1&gt;
&lt;p&gt;socketserver/http/ftp参考&lt;a class=&#34;link&#34; href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;pop,imap/smtp参考&lt;a class=&#34;link&#34; href=&#34;https://super-devops.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://super-devops.readthedocs.io/en/latest/&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;urllib&#34;&gt;urllib&lt;/h2&gt;
&lt;p&gt;urllib.request&lt;/p&gt;
&lt;p&gt;urllib.respponse&lt;/p&gt;
&lt;p&gt;urllib.parse&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from urllib.parse import urlparse
from urllib.parse import urljoin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;urllib.error&lt;/p&gt;
&lt;p&gt;urllib.robotparser&lt;/p&gt;
&lt;h2 id=&#34;ipaddress&#34;&gt;ipaddress&lt;/h2&gt;
&lt;h2 id=&#34;webbrowser&#34;&gt;webbrowser&lt;/h2&gt;
&lt;h2 id=&#34;cgi&#34;&gt;cgi&lt;/h2&gt;
&lt;h2 id=&#34;cgitb&#34;&gt;cgitb&lt;/h2&gt;
&lt;h2 id=&#34;wsgiref&#34;&gt;wsgiref&lt;/h2&gt;
&lt;h2 id=&#34;xmlrpc&#34;&gt;xmlrpc&lt;/h2&gt;
&lt;h2 id=&#34;socketserver&#34;&gt;socketserver&lt;/h2&gt;
&lt;h2 id=&#34;nntplib&#34;&gt;nntplib&lt;/h2&gt;
&lt;p&gt;network news transfer protocol&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import nntplib
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;telnet&#34;&gt;telnet&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import telnetlib
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;structured-markup-processing-tools&#34;&gt;Structured Markup Processing Tools&lt;/h1&gt;
&lt;h2 id=&#34;html&#34;&gt;html&lt;/h2&gt;
&lt;h2 id=&#34;xml&#34;&gt;xml&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;internet-data-handling&#34;&gt;Internet Data Handling&lt;/h1&gt;
&lt;h2 id=&#34;json&#34;&gt;json&lt;/h2&gt;
&lt;p&gt;http api(restful)一般使用json格式的数据．&lt;/p&gt;
&lt;p&gt;python和json数据类型对应关系参考WEB/JSON.&lt;/p&gt;
&lt;p&gt;complex和class/def不能被编码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将转换后的json格式写入文件
dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)
with open(file, &#39;w&#39;) as f:
    json.dump(dict_data, f)

# 将dict类型转换成json格式
dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&#39;utf-8&#39;, default=None, sort_keys=False, **kw)
json_data = json.dumps(dict_data)

indent=4 # 写入自动缩进４个空格

# 将读出的文件(json格式)转换成dict
load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
with open(file, &#39;r&#39;) as f:
    dict_data = json.load(f)

# json类型变成dict类型
loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
response_dict = json.loads(response.content) # 使用requests获取的json数据,转化为dict类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;base64&#34;&gt;base64&lt;/h2&gt;
&lt;h2 id=&#34;mailcap&#34;&gt;mailcap&lt;/h2&gt;
&lt;h2 id=&#34;mailbox&#34;&gt;mailbox&lt;/h2&gt;
&lt;h2 id=&#34;minetypes&#34;&gt;minetypes&lt;/h2&gt;
&lt;h2 id=&#34;binhex&#34;&gt;binhex&lt;/h2&gt;
&lt;h2 id=&#34;binascii&#34;&gt;binascii&lt;/h2&gt;
&lt;h2 id=&#34;quopri&#34;&gt;quopri&lt;/h2&gt;
&lt;h2 id=&#34;uu&#34;&gt;uu&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Debug</title>
        <link>https://canuxcheng.com/post/python_debug/</link>
        <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_debug/</guid>
        <description>&lt;h1 id=&#34;ide&#34;&gt;IDE&lt;/h1&gt;
&lt;p&gt;pycharm可以通过breakpoint和step调试.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;
&lt;h2 id=&#34;bdb&#34;&gt;bdb&lt;/h2&gt;
&lt;h2 id=&#34;pdb&#34;&gt;pdb&lt;/h2&gt;
&lt;h2 id=&#34;hotshot&#34;&gt;hotshot&lt;/h2&gt;
&lt;h2 id=&#34;timeit&#34;&gt;timeit&lt;/h2&gt;
&lt;h2 id=&#34;trace&#34;&gt;trace&lt;/h2&gt;
&lt;h2 id=&#34;cprofile&#34;&gt;cProfile&lt;/h2&gt;
&lt;h2 id=&#34;profile&#34;&gt;profile&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PEP</title>
        <link>https://canuxcheng.com/post/python_pep/</link>
        <pubDate>Sat, 06 Aug 2016 16:54:08 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_pep/</guid>
        <description>&lt;h1 id=&#34;pep-8--style-guide-for-python-code&#34;&gt;PEP 8 &amp;ndash; Style Guide for Python Code&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0008/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;pep-257--docstring-conventions&#34;&gt;PEP 257 &amp;ndash; Docstring Conventions&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0257/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0257/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;pep-20pep-20--the-zen-of-python&#34;&gt;PEP-20PEP 20 &amp;ndash; The Zen of Python&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0020/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0020/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 查看pep20
&amp;gt;import this
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Document</title>
        <link>https://canuxcheng.com/post/python_document/</link>
        <pubDate>Wed, 03 Aug 2016 21:57:26 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_document/</guid>
        <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;p&gt;python项目文档相关的工具．&lt;/p&gt;
&lt;h1 id=&#34;pydoc&#34;&gt;pydoc&lt;/h1&gt;
&lt;p&gt;python自带的文档命令行接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pydoc --help
$ pydoc -p &amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;h2 id=&#34;sphinx&#34;&gt;Sphinx&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sphinx-doc/sphinx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sphinx-doc/sphinx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh-sphinx-doc.readthedocs.io/en/latest/contents.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sphinx就是python处理reStructuredText格式的工具。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install -U Sphinx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用sphinx：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd your-project/docs

$sphinx-quickstart
# 以下选项需要手动设定，其它都可以用默认值：
&amp;gt; Project name: pydeveloper
&amp;gt; Author name(s): Canux CHENG
&amp;gt; Project version: 1.0.0.0
&amp;gt; autodoc: automatically insert docstrings from modules (y/n) [n]: y
&amp;gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件conf.py包含刚才的所有配置，可以在这里手动修改。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.sphinx-doc.org/en/1.4.8/config.html#confval-locale_dirs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加包的版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys.path.insert(0, os.path.abspath(&amp;quot;..&amp;quot;))
from &amp;lt;project&amp;gt; import __version__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改自己的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;copyright = u&#39;2016, &amp;lt;a href=&amp;quot;http://canuxcheng.com&amp;quot;&amp;gt;Canux CHENG&amp;lt;/a&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sphinx-docs&#34;&gt;sphinx-docs&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh-sphinx-doc.readthedocs.io/en/latest/markup/index.html#sphinxmarkup&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh-sphinx-doc.readthedocs.io/en/latest/markup/index.html#sphinxmarkup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sphinx的标记把reST格式的文档关联起来。&lt;/p&gt;
&lt;p&gt;index.rst这是文档的首页。&lt;/p&gt;
&lt;h3 id=&#34;sphinx-build&#34;&gt;sphinx-build&lt;/h3&gt;
&lt;p&gt;生成web可读的文档。&lt;/p&gt;
&lt;p&gt;简单方法生成文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 生成html格式的文档
$make html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sphinx-apidoc&#34;&gt;sphinx-apidoc&lt;/h3&gt;
&lt;p&gt;自动生成API文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sphinx-apidoc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;debug&#34;&gt;Debug&lt;/h3&gt;
&lt;p&gt;浏览器打开docs/_build/html/index.html即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$firefox _build/html/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;readthedocs&#34;&gt;ReadTheDocs&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://readthedocs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://readthedocs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://readthedocs.readthedocs.io/zh_CN/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://readthedocs.readthedocs.io/zh_CN/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将项目文档部署到readthedocs站点。&lt;/p&gt;
&lt;p&gt;直接注册帐号，同步github项目，然后导入你的项目即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;alabaster&#34;&gt;alabaster&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bitprophet/alabaster/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bitprophet/alabaster/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个主题是sphinx的默认主题，基于requests和flask的文档的主题而来。&lt;/p&gt;
&lt;p&gt;主题设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html_theme_options = {
    &#39;github_user&#39;: &#39;crazy-canux&#39;,
    &#39;github_repo&#39;: &#39;&amp;lt;your-project&amp;gt;&#39;,
    &#39;github_banner&#39;: True,
    &#39;show_powered_by&#39;: False,
    &#39;show_related&#39;: True,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pypandoc&#34;&gt;pypandoc&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bebraw/pypandoc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bebraw/pypandoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档转换工具pandoc的python包。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install pandoc
$ pip install pypandoc
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/python_package/</link>
        <pubDate>Wed, 22 Jun 2016 05:17:19 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_package/</guid>
        <description>&lt;h1 id=&#34;package&#34;&gt;Package&lt;/h1&gt;
&lt;p&gt;PEP426是python最新的打包标准，定义了wheel为最新的python包。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.python.org/dev/peps/pep-0426/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.python.org/dev/peps/pep-0426/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ensurepip&#34;&gt;ensurepip&lt;/h2&gt;
&lt;p&gt;内置模块.提供使用pip从pypi安装模块。&lt;/p&gt;
&lt;h2 id=&#34;distutils&#34;&gt;distutils&lt;/h2&gt;
&lt;p&gt;内置的模块.处理简单的包安装,一般使用setuptools代替该模块。&lt;/p&gt;
&lt;h2 id=&#34;venv&#34;&gt;venv&lt;/h2&gt;
&lt;p&gt;python3新增了虚拟环境的包．python2中使用virtualenv.&lt;/p&gt;
&lt;h2 id=&#34;zipapp&#34;&gt;zipapp&lt;/h2&gt;
&lt;p&gt;python3新增管理可执行的python的zip包．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;virtualenv&#34;&gt;virtualenv&lt;/h2&gt;
&lt;p&gt;python3.5开始并入了虚拟化标准库venv.&lt;/p&gt;
&lt;p&gt;分离的虚拟的python环境,自动安装setuptools和pip和wheel&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/virtualenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/virtualenv&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cd project

# 默认python2.7
$virtualenv .env
# 指定python3, 会安装pip/setuptools/wheel到当前环境.
$$virtualenv -p `which python3.6` --pip 21.0.1 --setuptools 51.1.2 --wheel 0.36.2 .env

# 激活虚拟环境
$source .env/bin/activate

# 先升级pip和setuptools
$pip install pip
$pip install setuptools
$pip install wheel

# 导出项目用的所有依赖库．
$pip freeze &amp;gt; requirements.txt
# 在其它环境需要安装依赖：
$pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;virtualenvwrapper&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/virtualenvwrapper/virtualenvwrapper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;封装了virtualenv的工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install virtualenvwrapper

# 创建主目录
$ mkdir -p $WORKON_HOME

# 最好写入到.bashrc/.zshrc:
$ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
$ export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv
$ export WORKON_HOME=~/.virtualenvs
$ source /usr/local/bin/virtualenvwrapper.sh

# 为每个项目创建独立python环境：
$ mkvirtualenv -r requirementx.txt [project-name]
# 不安装setuotools/wheel/pip
$ mkvirtualenv --no-setuptools --no-wheel --no-pip [name]
# 指定查找pip/setuptools的路径
--extra-search-dir=/usr/local/lib/python2.7/dist-packages
--extra-search-dir=/usr/lib/python2.7/dist-packages
$ workon [project-name] # 切换到针对该项目的virtualenv
(pro)$ /path/to/pip install [package] # 安装第三方包
(pro)$ ~/.virtualenvs/[project-name]/bin/python setupt.py install # 源码安装
(pro)$ lssitepackages # 查看安装的第三方包
$ deactivate # 退出virtualenv
$ rmvirtualenv [project-name] # 删除环境
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pipenv&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/pipenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/pipenv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;封装了virtualenv的工具，用于取代virtualenvwrapper.&lt;/p&gt;
&lt;h2 id=&#34;setuptools&#34;&gt;setuptools&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/setuptools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/setuptools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pypa/wheel&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pypa/wheel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python2.7.9和python3.4以及virtualenv自带setuptools．&lt;/p&gt;
&lt;p&gt;支持sdist打包成tar.gz包,和wheel打包成whl包．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install -U pip
$pip install -U setuotools
$pip install -U wheel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建setup.py文件：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi?%3Aaction=list_classifiers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi?%3Aaction=list_classifiers&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os

from setuptools import setup, find_packages

import project

def read(readme):
    extend = os.path.splitext(readme)[1]
    # pypi只识别reST格式
    if (extend == &amp;quot;.rst&amp;quot;):
        import codecs
        return codecs.open(readme, &#39;r&#39;, &#39;utf-8&#39;).read()
    # pypandoc可以将markdown格式转换成reST格式
    elif (extend == &amp;quot;.md&amp;quot;):
        import pypandoc
        return pypandoc.convert(readme, &#39;rst&#39;)

setup(
    # metadata:
    name=project,
    version=project.__version__,
    url=&#39;&#39;,
    download_url=&#39;&#39;,
    author=&#39;&#39;,
    author_email=&#39;&#39;,
    maintainer=&#39;&#39;,
    maintainer_email=&#39;&#39;,
    description=&#39;&#39;
    long_description=read(&#39;README.XXX&#39;),
    license=&#39;&#39;,
    platforms=&#39;any&#39;,
    keywords=&#39;&#39;,
    classifiers=[
        &#39;Development Status :: 5 - Production/Stable&#39;,
        ...
    ],

    # options

    # 指定源码的位置
    packages=find_packages(),
    package_dir={},

    # 需要和源码一起安装的非代码文件,写入MANIFEST.in
    # 比如文档和测试文件
    package_data={}, # 将指定的文件放入安装路径
    include_package_data=None, # True表示
    exclude_package_data=None,

    # 不需要和源码一起安装的非代码文件.
    # 比如配置文件
    data_files=[(dest, source),()],

    # 通过pip安装requirement
    install_requires=[&#39;a==1.0.0&#39;, &#39;b&amp;gt;=1.0.0&#39;],
    # python版本的要求
    python_requires=&#39;&amp;gt;=3&#39;,
    setup_requires=[],
    extras_require=None,
    test_require=[]

    zip_safe=True,

    # 安装一个命令
    scripts=[],    # 会被添加到环境变量用于命令.

    entry_points={}

    # preinst/postinst
    cmdclass={
        &amp;quot;develop&amp;quot;: PostInstDevelop,
        &amp;quot;install&amp;quot;: PostInstInstall
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;怎样实现postinst功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from setuptools.command.develop import develop
from setuptools.command.install import install

class InstDevelop(develop):
    def run(self):
        # your preinst code here for develop.
        develop.run(self)
        # your postinst code here for develop.

class InstInstall(install):
    def run(self):
        # your preinst code here for install.
        install.run(self)
        # your postinst code here for install.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建setup.cfg文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[wheel]
universal = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建README.rst文件：&lt;/p&gt;
&lt;p&gt;可以是rst格式也可是是md格式。&lt;/p&gt;
&lt;p&gt;如果是md格式不要使用类似于***的分割线。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参考rst和md的文档
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建MAINFEST.in文件：&lt;/p&gt;
&lt;p&gt;默认只有python模块和包会被打包，如果需要其它文件需要添加到这个文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include LICENSE README.rst AUTHORS.rst CONTRIBUTING.rst
recursive-include docs *
graft examples
graft tests
global-exclude *.py[co]
prune docs/_build
prune docs/_themes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建__init__.py文件：&lt;/p&gt;
&lt;p&gt;位于project/project/__init__.py，安装后用import导入，help(project)看到的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME: 自动获取的项目名字 - 该文件注释的总结部分
FILE: /install_path/project/project/__init__.py
DESCRIPTION: 该文件的注释，除总结部分
PACKAGE CONTENTS: 在project/project/自动获取的py文件名
DATA: __开头和结尾的变量
VERSION: __version__变量的值
AUTHOR: __author__变量的值

#!/usr/bin/env python
# -*- coding: utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
SUMMARY

Descriptions
&amp;quot;&amp;quot;&amp;quot;

__version__ = &#39;&#39;
__author__ = &#39;&#39;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发布到pypi主服务器pypi：&lt;/p&gt;
&lt;p&gt;去pypi注册帐号&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建~/.pypirc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[distutils]
index-servers = pypi

[pypi]
username = &amp;lt;username&amp;gt;
password = &amp;lt;password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在索引中注册项目(不再支持，直接upload)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Deprecated] $ python setup.py register -r pypi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先打包, 在dist目录生成包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python setup.py sdist # 生成tarball
$ python setup.py bdist_wheel # 安装wheel后，可以用setuptools生成wheel包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再上传到pypi(推荐):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install twine
$ twine upload dist/*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包并上传到pypi：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$python setup.py sdist upload -r pypi
$python setup.py bdist_wheel upload -r pypi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cython&#34;&gt;cython&lt;/h2&gt;
&lt;p&gt;编译成.so文件&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo pip install cython
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在setup.py中引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from Cython.Build import cythonize
from Cython.Distutils import build_ext

def add_extensions(modules):
    extensions = []
    for module in modules:
        level = module
        for depth in range(10):
            source_dir = level + &amp;quot;.py&amp;quot;
            if glob.glob(source_dir):
                extensions.append(Extension(module, [source_dir], include_dirs=[&amp;quot;.&amp;quot;], extra_compile_args=[&#39;-O3&#39;]),)
            level = os.path.join(level, &amp;quot;*&amp;quot;)
    print(extensions)
    return extensions

INCLUDE_PACKAGES = []
EXCLUDE_PACKAGES = []    

setup(
    ext_modules=cythonize(
        add_extensions(INCLUDE_PACKAGES),
        build_dir=&amp;quot;build&amp;quot;,
        # 指定 .py =&amp;gt; .c 使用8个线程编译.
        nthreads=8,
        compiler_directives=dict(
            always_allow_keywords=True,
            language_level=3),
        exclude=EXCLUDE_PACKAGES),
    cmdclass={
        &amp;quot;install&amp;quot;: InstInstall,
        &amp;quot;build_ext&amp;quot;: build_ext
    },
)

// -j 8 指定.c =&amp;gt; .so 使用8个线程编译.
$ python3 setup.py build_ext --inplace -j 8 
// 删除符号信息
$ find sandbox/ -name &amp;quot;*.so&amp;quot; -exec strip {} \; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pbr&#34;&gt;pbr&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/openstack-dev/pbr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/openstack-dev/pbr&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;扩展点entry-points&#34;&gt;扩展点（Entry Points）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pkg_resources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;entry_point_inspector&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dhellmann/entry_point_inspector&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/dhellmann/entry_point_inspector&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stevedore&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://docs.openstack.org/developer/stevedore/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://docs.openstack.org/developer/stevedore/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Summary</title>
        <link>https://canuxcheng.com/post/python_summary/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:20 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_summary/</guid>
        <description>&lt;h1 id=&#34;python难点总结&#34;&gt;python难点总结&lt;/h1&gt;
&lt;h1 id=&#34;多线程&#34;&gt;多线程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GIL&lt;/p&gt;
&lt;p&gt;GIL: Global Interpretror Lock. 全局解释器锁．&lt;/p&gt;
&lt;p&gt;python不建议使用多线程，用多进程代替．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;协程&#34;&gt;协程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;coroutine&lt;/p&gt;
&lt;p&gt;协程就是同时开启两个任务，但一次只顺序执行一个．
如果执行的任务阻塞，就切换到下一个继续执行．节省时间．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>OOP</title>
        <link>https://canuxcheng.com/post/python_oop/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_oop/</guid>
        <description>&lt;h1 id=&#34;面向对象oop&#34;&gt;面向对象/OOP&lt;/h1&gt;
&lt;p&gt;OOD: Object Oriented Design.&lt;/p&gt;
&lt;p&gt;面向过程的设计支持任何语言，但是如果语言本身内置面向过程的结构，就会更容易编程．&lt;/p&gt;
&lt;p&gt;OOP: Object Oriented Programming.&lt;/p&gt;
&lt;p&gt;python内置OOP的结构，但是不必一定要使用类和OOP.&lt;/p&gt;
&lt;p&gt;面向对象的两个主题就是类和类实例．&lt;/p&gt;
&lt;p&gt;创建实例的过程叫实例化．&lt;/p&gt;
&lt;p&gt;属性就是属于另一个对象的数据或函数元素．属性分为数据属性和函数属性．&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;类class&#34;&gt;类/Class&lt;/h1&gt;
&lt;p&gt;类是现实世界的抽象的实体以编程的形式出现，实例是这些对象的具体化．&lt;/p&gt;
&lt;p&gt;类是一种数据结构的定义，实例是申明了一个这种类型的变量．&lt;/p&gt;
&lt;p&gt;类的定义：&lt;/p&gt;
&lt;p&gt;Python 3 所有类默认继承自 object，即使不写 (object) 也是新式类。建议保留 (object) 以兼容性和可读性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    &amp;quot;&amp;quot;&amp;quot;Doc string.&amp;quot;&amp;quot;&amp;quot;
    class_suite
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的初始化方法init(相当于构造器):&lt;/p&gt;
&lt;p&gt;如果定义了__init__方法在实例化的时候会首先调用该方法，进行一些初始化的工作。&lt;/p&gt;
&lt;p&gt;init方法的第一个参数必须是实例self，而且不能有return语句。&lt;/p&gt;
&lt;p&gt;init方法一般用来设置实例属性(也就是数据属性)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    def __init__(self, *args, **kwargs):
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊方法new:&lt;/p&gt;
&lt;p&gt;如果定义了__new__方法，会在init方法之前运行，并且返回一个实例，也就是__init__的self。&lt;/p&gt;
&lt;p&gt;new方法的第一个参数必须是类cls。并且需要返回一个实例。&lt;/p&gt;
&lt;p&gt;new方法在object中被定义为staticmethod。&lt;/p&gt;
&lt;p&gt;相当于析构器的特殊方法del:&lt;/p&gt;
&lt;p&gt;__del__特殊方法要在实例对象的所有引用都被清除后才会执行。&lt;/p&gt;
&lt;p&gt;不要在del中做与实例没有关系的事情，一般不建议实现该方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):

    def __new__(cls, *args, **kwargs):
        ...
        return ...

    def __del__(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类属性&#34;&gt;类属性&lt;/h2&gt;
&lt;p&gt;类属性分为数据属性和方法属性。&lt;/p&gt;
&lt;p&gt;类的数据属性仅仅是定义的类的变量。&lt;/p&gt;
&lt;p&gt;数据属性通常是静态变量, 也就是和类对象绑定, 与类的实例无关。&lt;/p&gt;
&lt;p&gt;直接通过类名来访问类的数据属性。不建议通过实例来访问类的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    CONST_VARIABLE = &#39;value&#39;

    def __init__(self, *args, **kwargs):
        ClassName.CONST_VARIABLE = &#39;new&#39;

ClassName.CONST_VARIABLE = &#39;new value&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的方法属性仅仅是一个作为类定义的一部分定义的函数, 与类的实例无关。&lt;/p&gt;
&lt;p&gt;类中定义的方法的第一个参数是一个实例self。&lt;/p&gt;
&lt;p&gt;方法属性必须绑定到一个实例才能被直接调用, 非绑定方法没有给出实例对象一般不能直接调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    def func(self, *args, **kwargs):
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python 3 中，直接调用 ClassName.func() 会报错：TypeError: func() missing 1 required positional argument: &amp;lsquo;self&lt;/p&gt;
&lt;p&gt;调用非绑定方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassName.func(ClassName()) # 除非传入实例作为第一个参数self的值
# 常用场景： 调用父类中的非绑定方法
class ClassName(BaseClass):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用绑定方法： 自动把实例作为self传入，不用显式传入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ClassName().func()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看类的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dir(class) # 内建函数
class.__dict__ # 类的特殊属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__name__ # class namkkk
class.__qualname__
class.__module__
class.__doc__ # 文档的特殊属性, 不会被继承.
class.__annotations

class.__bases__ # 类的父类构成的元组
class.__orig_bases__
# 新式类新增的三个特殊属性:
class.__mro__ # 返回方法解析顺序的元组, mro()
class.__subclasses__() # 返回子类的列表

class.__dict__ # 以字典的形式存储对象的属性
class.__weakref__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法和函数的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;__doc__&#39;,
&#39;__annotations__&#39;
&#39;__qualname__&#39;
&#39;__name__&#39;,
&#39;__module__&#39;,
&#39;__self__&#39;,
&#39;__func__&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;实例instances&#34;&gt;实例/Instances&lt;/h1&gt;
&lt;p&gt;实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ins = ClassName()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例属性&#34;&gt;实例属性&lt;/h2&gt;
&lt;p&gt;实例属性：&lt;/p&gt;
&lt;p&gt;实例严格来说只有数据属性(方法属性应该属于类属性)，数据属性就是和某个实例相关联的数据值，这些值独立于其它实例或类，当一个实例被释放，相应的数据属性也被释放。通常通过init方法来设置实例的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    DATA = &amp;quot;in class&amp;quot; # 类的数据属性

    def __init__(self, default=&amp;quot;default&amp;quot;, *args, **kwargs):
        self.default = default # 当前实例的数据属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别类的数据属性和实例的数据属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj1 = ClassName()
print(obj1.DATA) # &amp;quot;in class&amp;quot;, 当实例没有同名的数据属性，会访问类的数据属性。
obj1.DATA = &amp;quot;in obj1&amp;quot; # 相当于给实例新建了一个数据属性，会覆盖类的数据属性。
print(obj1.DATA) # &amp;quot;in obj1&amp;quot; 访问的是实例的数据属性，覆盖了类的数据属性。
print(ClassName.DATA) # &amp;quot;in class&amp;quot; 访问类的数据属性。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看实例属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance.__dict__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance.__dict__ # 以字典的形式存储对象的属性
instance.__class__ # 实例对应的类
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;封装encapsulation&#34;&gt;&lt;strong&gt;封装/Encapsulation&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;封装描述了对数据／信息进行隐藏的观念，对数据属性提供接口和访问函数．&lt;/p&gt;
&lt;p&gt;默认情况下，数据属性和类属性都是public的．类所在的模块和导入了类的其它模块都可以使用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var # public
def method_name(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个下划线开头的属性是protected,能在类本身和子类使用，类的实例可以直接访问，不可以用from module import *导入．&lt;/p&gt;
&lt;p&gt;用于把属性限制在一个模块中．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_xxx # protected
def _xxx(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双下划线开头的属性是private, 只能类本身使用，类的实例不能直接访问，子类和其它类都不能使用,子类也不能覆盖．&lt;/p&gt;
&lt;p&gt;用于把属性限制在一个类中.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__xxx # private
def __xxx(self):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;系统已经定义的特殊方法，也称魔法方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __xxx__(self): # 系统定义的名字
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;composition&#34;&gt;Composition&lt;/h2&gt;
&lt;p&gt;类之间的关系只有两种继承和包含.&lt;/p&gt;
&lt;p&gt;创建复合对象时可以通过composition组合来增加功能和代码的重用性．&lt;/p&gt;
&lt;p&gt;当类之间有显著不同，并且较小的类是较大的类所需的组件时一般使用组合．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .company import Company
from .home import Home
class Emp(object):
    def __init__(self, *args, **kwargs):
        self.comp = Company(args)
        self.home = Home(kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;继承inheritance&#34;&gt;&lt;strong&gt;继承/Inheritance&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;利用类的两种方式就是包装和继承．&lt;/p&gt;
&lt;h2 id=&#34;子类和派生&#34;&gt;子类和派生&lt;/h2&gt;
&lt;p&gt;对于相同的类但是有不同的功能，可以通过derivation派生来实现．&lt;/p&gt;
&lt;p&gt;通过使用一个已经定义好的类，扩展它或者修改，而不会影响系统中使用现存类的其它代码片段．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father(object):
    def woman(self):
        ...

class Mother(object);
    def man(self):
        ...

class Child(Father, Mother):
    def child(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;继承描述了基类的属性如何遗传给派生类．&lt;/p&gt;
&lt;p&gt;派生类（子类）继承自基类（父类）&lt;/p&gt;
&lt;p&gt;python中的类需要继承一个或多个父类．&lt;/p&gt;
&lt;p&gt;object类是所有类的父类．&lt;/p&gt;
&lt;p&gt;子类继承了基类的属性和方法．&lt;/p&gt;
&lt;p&gt;文档字符串__doc__是唯一的，不能继承．&lt;/p&gt;
&lt;p&gt;一个类的__bases__属性可以查看它的父类组成的元组．不包括父类的父类．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__bases__ # 类的父类构成的元组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例调用方法时，默认调用的该对象的类的本身的方法，如果该类没有实现该方法才会调用父类的方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent(object):
    def foo(self):
        print(&amp;quot;in parent.&amp;quot;)

class Child(Parent):
    def foo(self):
        print(&amp;quot;in child.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;从内置类继承&#34;&gt;从内置类继承&lt;/h2&gt;
&lt;p&gt;可以从内置类型继承子类，修改一些属性．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class RoundFloat(float):
    def __new__(cls, val):
       return super(RoundFloat, cls).__new__(cls, round(val, 2))

class SortedKeyDict(dict):
    def keys(self):
        return sorted(super(SortedKeyDict, self).keys())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;multiple-inheritance多重继承&#34;&gt;Multiple inheritance多重继承&lt;/h2&gt;
&lt;p&gt;由于类，类型，内建类型的子类都重新架构，新的类采用MRO算法来查找子类中使用的属性．&lt;/p&gt;
&lt;p&gt;MRO: Method Resolution Order, 方法解释顺序．采用广度优先，从左至右边，来获取在子类中的属性．&lt;/p&gt;
&lt;p&gt;可以通过新式类的特殊属性查看子类的属性的查找顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class.__mro__ # 返回方法解析顺序的元组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多继承，mro和super的用法：&lt;/p&gt;
&lt;p&gt;super每次只调用MRO中的第一个父类，和getattr的顺序一样．并且相同的父类只调用一次．&lt;/p&gt;
&lt;p&gt;数据属性，普通方法属性，特殊方法属性都是按照MRO顺序来查找．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/multiple_inheritance&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;多态polymorphism&#34;&gt;&lt;strong&gt;多态/Polymorphism&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python不支持方法重载，但是可以通过对参数的判断，对不同的参数进行不同的处理。以此来实现重载的功能。&lt;/p&gt;
&lt;p&gt;python可以重载魔法方法。&lt;/p&gt;
&lt;h2 id=&#34;magicmethod&#34;&gt;magicmethod&lt;/h2&gt;
&lt;p&gt;python类有一些可自定义的特殊方法集，它们中的一些有预定义的默认行为，一些没有，留到需要的时候去实现。&lt;/p&gt;
&lt;p&gt;这些特殊方法是python中用来扩充类的方法。可以用来模拟标准类型或者重载操作符。&lt;/p&gt;
&lt;p&gt;这些特殊方法都是用双下划线开头和结尾的，也被称为魔法方法。&lt;/p&gt;
&lt;p&gt;对象创建和销毁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__init__(self, *args, **kwargs) # 构造器，带一些可选的参数
__new__(cls, *args, **kwargs) # 构造器，带一些可选的参数，通常用来设置不可变数据类型的子类。
__del__(self) # 解构器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串表示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__str__(self) # str(), print() 
obj = ClassName()
print(obj) # 没有定义__str__ 会调用__repr__

__repr__(self)  # repr()
obj = ClassName()
obj # 默认的打印对象的运行时的字符串，&amp;lt;test.RoundFloat at 0x7fb715253e90&amp;gt;
# 可以通过重写__repr__()改变打印的内容

__bool__(self) # 用于bool判断真假
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可调用对象的特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__call__(self, *args) # 表示可调用的实例, callable(object) 会返回true.

class TestClass(object):
    def __call__(self, *args):
        print(&amp;quot;Instance is callable after implement call method in class.&amp;quot;)
        print(&amp;quot;Args come from instance invoke is: {}&amp;quot;.format(args))

tc = TestClass()
callable(tc) # True
tc()
tc(&#39;arg1&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例和类的检查相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__instancecheck__(self, instance) # isinstance(instance, class)
__subclasscheck__(self, subclass) # issubclass(subclass, class)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__getattr__(self, name) # getattr(), 仅当属性没有在实例／类／父类的__dict__中找到才会调用．
__getattribute__(self, name)
__setattr__(self, name, value)
__delattr__(self, name)
__dir__(self) # dir()

# 描述符相关
__get__(self, instance, owner)
__set__(self, instance, value)
__delete__(self, instance)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with上下文管理特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__enter__(self) # return self, 需要返回self
__exit__(self, exc_type, exc_value, traceback)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象比较特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__cmp__(self, other) # cmp()
__lt__(self, other)
__le__(self, other)
__eq__(self, other)
__ne__(self, other)
__gt__(self, other)
__ge__(self, other)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容器类型相关特殊方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__len__(self) #　len()
__getitem__(self, key) #
__setitem__(self, key, value) #
__delitem__(self, key) # del
__reversed__(self) # reversed()
__iter__(self) # iter()
__contains__(self, item)
__missing__(self, key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/magicmethod/container.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数值类型相关特殊方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__add__(self, other)
__sub__(self, other)
__mul__(self, other)
__div__(self, other)
__truediv__(self, other)
__floordiv__(self, other)
__mod__(self, other)
__divmod__(self, other)
__pow__(self, other[, module])
__lshift__(self, other)
__rshift__(self, other)
__and__(self, other)
__xor__(self, other)
__or__(self, other)

__rxxx__(self, other)

# 原位运算必须返回self.
__ixxx__(self, other) # self += other -&amp;gt; self = self + other

__neg__(self)
__pos__(self)
__abs__(self)
__invert__(self)

__complex__(self)
__int__(self)
__long__(self)
__float__(self)

__oct__(self)
__hex__(self)

__index__(self)
__coerce__(self, other)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;delegation--wrapping&#34;&gt;Delegation &amp;amp; Wrapping&lt;/h2&gt;
&lt;p&gt;Wrapping包装就是对一个已经存在的对象增加，删除或修改已经存在的功能．&lt;/p&gt;
&lt;p&gt;Delegation授权(代理)是Wrapping包装的一个特性,用于简化处理相关命令性功能，最大化重用代码．&lt;/p&gt;
&lt;p&gt;实现delegation的关键在于覆盖__getattr__()特殊方法．通过调用内置函数getattr()得到一个对象的默认行为．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Wrapper(object):
    def __init__(self, obj):
        self.__data = obj

    def __getattr__(self, attr):
        return getattr(self.__data, attr)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;metaclass元类&#34;&gt;metaclass元类&lt;/h1&gt;
&lt;p&gt;metaclass 是&amp;quot;创建类的类&amp;quot;。正如实例是类的实例化，类也是元类的实例化。在 Python 中，类本身也是对象，而元类就是用来创建这些类对象的。&lt;/p&gt;
&lt;p&gt;元类用来定义某些类是如何被创建的。改变类的默认行为和创建方式。&lt;/p&gt;
&lt;p&gt;大多数情况下不需要创建元类，一般使用系统的元类的默认方式。&lt;/p&gt;
&lt;p&gt;在执行类定义的时候，解释器必须知道这个类的元类；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(metaclass=MetaClassName):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行类定义时候检查元类，元类传递三个参数到构造器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类名
从基类继承数据的元组, __bases__
类的属性字典, __dict__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元类相关的可定制属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__metaclass__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个元类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MetaClassName(type):
    def __new__(cls, name, bases, dicts):
        super().__new__(cls, name, bases, dicts)
        # 在这里做一些你希望使用该元类的类在定义时做的操作
    def __call__(cls, *args, **kwargs):
       if cls not in cls._instances:
          cls._instances[cls] = super().__call__(*args, **kwargs)
      return cls._instances[cls]

class ClassName(metaclass=MetaClassName):
    def __init__(self, value):
        self.value = value
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/metaclass&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/metaclass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;自动注册类&lt;/li&gt;
&lt;li&gt;属性验证和转&lt;/li&gt;
&lt;li&gt;ORM模型创建&lt;/li&gt;
&lt;li&gt;抽象基类和接口检查&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;abstractmethod&#34;&gt;abstractmethod&lt;/h2&gt;
&lt;p&gt;抽象方法，类似于java的interface.&lt;/p&gt;
&lt;p&gt;最简单的抽象方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 如果子类没有实现同名的该方法，就会抛出异常．
def base_method(self):
    raise NotImplementedError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用abc标准库来实现：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/psl/myabc.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;descriptors描述符&#34;&gt;descriptors描述符&lt;/h1&gt;
&lt;p&gt;普通对象访问(set/get/delete)属性的优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.__dict__[&#39;attr&#39;] # 先访问实例对象
obj.__class__.__dict__[&#39;attr&#39;] # 再访问类对象
obj.__class__.__base__.__dict__[&#39;attr&#39;] # 接着访问基类的对象,不包括metaclass.
__getattr__ # 如果实现了的话，优先级最低
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是一个对象，它定义了当另一个对象的属性被访问时应该如何处理。任何定义了 &lt;strong&gt;get&lt;/strong&gt;()、&lt;strong&gt;set&lt;/strong&gt;() 或 &lt;strong&gt;delete&lt;/strong&gt;() 方法的类都是描述符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__get__(self, obj, type=None) # 返回一个属性的值
__set__(self, obj, value) # 设置一个属性的值，返回None
__delete__(self, obj) # 属性的引用递减，返回None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是数据property，class，staticmethod，classmethod, 以及super的机制．&lt;/p&gt;
&lt;p&gt;data descriptor:定义了__get__和__set__的对象是数据描述符, 主要用于数据属性．&lt;/p&gt;
&lt;p&gt;non data descriptor:仅仅定义了__get__的对象是非数据描述符，主要用于方法属性．&lt;/p&gt;
&lt;p&gt;如果实例的字典(obj.&lt;strong&gt;dict&lt;/strong&gt;)具有与数据描述符相同名称的条目，则数据描述符优先。&lt;/p&gt;
&lt;p&gt;如果实例的字典(obj.&lt;strong&gt;dict&lt;/strong&gt;)具有与非数据描述符相同名称的条目，则字典条目优先。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class DescriptorName(object):
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, typ):
        print(&#39;__get__&#39;, instance, typ)
        return self.name

    def __set__(self, instance, value):
        print(&#39;__set__&#39;, instance, value)
        self.name = value

class TestClass(object):
    name = DescriptorName(&#39;canux&#39;)

tc = TestClass()
print(tc.name) # __get__(tc, type(tc))被调用
print(TestClass.name) # __get__(None, TestClass)被调用
tc.__dict__[&#39;name&#39;] = &#39;test&#39; # 无效
tc.name = &#39;test&#39; # __set__被调用
TestClass.name = &#39;test&#39; # 仅仅是重新定义类的属性，覆盖了描述符
# 此时tc.__dict__有同名属性，如果定义了__set__
print(tc.name) # __get__被调用，属性已经修改
print(TestClass.name) # __get__被调用,属性已经修改
# 如果没有定义__set__，就是调用的tc.__dict__里面的．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符访问属性的优先级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数据描述符(__set__, __get__)
# 对于访问实例属性obj.__getattribute__调用方式：type(obj).__dict__[&#39;attr&#39;].__get__(obj, type(obj))
# 对于访问类属性class.__getattribute__调用方式：ClassName.__dict__[&#39;attr&#39;].__get__(None, ClassName)
instance.__dict__
非数据描述符(__get__)
__getattr__ # 如果实现了的话，在描述符中优先级最低
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符是由__getattribute__特殊方法调用，覆盖该方法可以防止描述符自动调用.&lt;/p&gt;
&lt;p&gt;obj.__getattribute__和class.__getattribute__的调用方式不同．&lt;/p&gt;
&lt;p&gt;描述符的三个特殊方法一般是通过属性访问自动调用．&lt;/p&gt;
&lt;p&gt;函数和方法的描述符：&lt;/p&gt;
&lt;p&gt;在属性访问期间函数包括了__get__方法用于绑定方法．因此函数和方法是非数据描述符．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TClass(object):
    def __get__(self, obj, typ=None):
        return types.MethodType(self, obj, typ)


    def tmethod(self, args):
        return args

class Foo(object):
    @Tclass
    def bar(self):
        print(&#39;in bar&#39;)

obj = TClass()
TClass.__dict__[&#39;tmethod&#39;] # __tion __main__.f
TClass.tmethod # unbound method TClass.tmethod
obj.tmethod # bound method TClass.tmethod of &amp;lt;__main__.TClass object at 0x7f8a4f084c10&amp;gt;

obj.function(*args) -&amp;gt; function(obj, *args)
Class.function(*args) -&amp;gt; function(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;property&#34;&gt;property&lt;/h2&gt;
&lt;p&gt;property属性是一种有用的特殊类型的描述符． 也是descriptor的主要用途．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;property(fget=None, fset=None, fdel=None, doc=None) # 返回一个property类型的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的descriptor的普通方式实现纯pytho写的property:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Property(object):
    def __init__(self, fget, fset, fdelete):
        self.fget = fget
        self.fset = fset
        self.fdelete = fdelete

    def __get__(self, obj, typ=None):
        return self.fget(obj)

    def __set__(self, obj, val):
        self.fset(obj, val)

    def __delete__(self, obj):
        self.fdelete(obj)

class Foo(object):
    def fget(self):
        print &#39;fget called&#39;

    def fset(self, val):
        print &#39;fset called&#39;

    def fdelete(self):
        print &#39;fdelete called&#39;

    bar = Property(fget, fset, fdelete)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过装饰器@property来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person(object):
    def __init__(self):
        self._email = None

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        m = re.match(&#39;\W+@\W+\.\W+&#39;, value)
        if not m:
            raise Exception(&#39;email not valid&#39;)
        self._email = value

    @email.deleter
    def email(self):
        del self._email
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/tree/master/python/descriptor&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/tree/master/python/descriptor&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;super&#34;&gt;super&lt;/h1&gt;
&lt;p&gt;因为同名的方法子类会覆盖父类，在子类中调用父类的同名方法可以通过super内置函数。&lt;/p&gt;
&lt;p&gt;super()方法实际是一个构造器。自动找到基类方法，同时传入self参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super().__init__() # 不需要传递参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于单继承, super用来调用父类同名方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Child(Parent):
    def foo(self):
        Parent.foo(self) # 可以手动调用父类同名的方法，调用非绑定方法，传入self参数。

class Child(Parent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs) 
        ...

    def foo(self, *args, **kwargs):
        super().foo(*args, **kwargs) 
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于多继承，super用法参考上面的多继承．&lt;/p&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用父类构造函数&lt;/li&gt;
&lt;li&gt;扩展父类方法&lt;/li&gt;
&lt;li&gt;多重继承场景&lt;/li&gt;
&lt;li&gt;属性设置场景&lt;/li&gt;
&lt;li&gt;合作式继承&lt;/li&gt;
&lt;li&gt;类方法中使用&lt;/li&gt;
&lt;li&gt;静态方法中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;super()返回的对象有一个用于调用Descriptor的定制__getattribute__()方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super(B, obj).method() -&amp;gt;
obj.__class__.__mro__ -&amp;gt;
A.__dict__[&#39;method&#39;].__get__(obj, B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考面向对象编程．&lt;/p&gt;
&lt;h1 id=&#34;classmethod&#34;&gt;classmethod&lt;/h1&gt;
&lt;p&gt;classmethod 是一个内置装饰器，用于将方法转换为类方法。类方法的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是类本身 cls，而不是实例 self&lt;/li&gt;
&lt;li&gt;可以通过类或实例调用&lt;/li&gt;
&lt;li&gt;可以访问类属性，但不能直接访问实例属性&lt;/li&gt;
&lt;li&gt;常用于创建备选构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类方法通常用于替代类构造函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    @classmethod
    def demo_cm(cls, *args, **kwargs):
        ...

# 可以通过类来调用, 也就是可以直接调用非绑定方法．自动传入类作为第一个参数．
ClassName.demo_cm(args, kwargs)
# 也可以通过实例来调用, 自动传入类作为第一个参数
ClassName().demo_cm(args, kwargs) // not recommend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符相关：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.function(*args) -&amp;gt; function(type(obj), *args)
Class.function(*args) -&amp;gt; function(Class, *args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备选构造函数&lt;/li&gt;
&lt;li&gt;工厂方法模式&lt;/li&gt;
&lt;li&gt;访问和修改类属性&lt;/li&gt;
&lt;li&gt;配置和设置相关方o&lt;/li&gt;
&lt;li&gt;继承中的类方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;staticmethod&#34;&gt;staticmethod&lt;/h1&gt;
&lt;p&gt;staticmethod 是一个内置装饰器，用于将方法转换为静态方法。静态方法的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不接收隐式的第一个参数（不需要 self 或 cls）&lt;/li&gt;
&lt;li&gt;可以通过类或实例调……&lt;/li&gt;
&lt;li&gt;不能访问类或实例的属性&lt;/li&gt;
&lt;li&gt;行为类似普通函数，只是在类的命名空间中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ClassName(object):
    @staticmethod
    def demo_sm():
        ...

ClassName.demo_sm()
ClassName().demo_sm()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;描述符相关：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.function(*args) -&amp;gt; function(*args)
Class.function(*args) -&amp;gt; function(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具函数&lt;/li&gt;
&lt;li&gt;验证和转换函数&lt;/li&gt;
&lt;li&gt;常量和配置相关&lt;/li&gt;
&lt;li&gt;工厂方法辅助函数&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;class-decorators&#34;&gt;Class Decorators&lt;/h1&gt;
&lt;p&gt;类装饰器比函数装饰器更灵活，高内聚，封装性等优点．&lt;/p&gt;
&lt;p&gt;类装饰器用于装饰一个类.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(cls):
    class WrapperName(cls, ...):
        def __init__(self, *args, **kwargs):
            cls.__init__()
            ....__init__()
            ...
    return WrapperName

@deco_name
class ClassName(object):
    def __init__(self, *args, **kwargs):
        ...
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/decorator/class_decorator.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Python</title>
        <link>https://canuxcheng.com/post/python/</link>
        <pubDate>Tue, 21 Jun 2016 21:18:09 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python/</guid>
        <description>&lt;h1 id=&#34;python概述&#34;&gt;&lt;strong&gt;Python概述&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/2.7/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/2.7/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/python_278/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/python_278/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/3.5/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/3.5/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://python.usyiyi.cn/translate/python_352/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://python.usyiyi.cn/translate/python_352/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python是一门优雅而健壮的语言.&lt;/p&gt;
&lt;p&gt;继承了编译语言(静态语言)的强大性和通用性.&lt;/p&gt;
&lt;p&gt;同时也借鉴了脚本语言(动态语言)的易用性．&lt;/p&gt;
&lt;p&gt;python特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高级&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;可升级&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;易学&lt;/li&gt;
&lt;li&gt;易读&lt;/li&gt;
&lt;li&gt;易维护&lt;/li&gt;
&lt;li&gt;健壮性&lt;/li&gt;
&lt;li&gt;高效的快速原型开发工具&lt;/li&gt;
&lt;li&gt;内存管理器&lt;/li&gt;
&lt;li&gt;解释性和编译性&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python基本语法&#34;&gt;&lt;strong&gt;python基本语法&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python源程序叫xxx.py&lt;/p&gt;
&lt;p&gt;python中一切皆对象．&lt;/p&gt;
&lt;p&gt;python大小写敏感．&lt;/p&gt;
&lt;p&gt;python通过缩进和冒号:区分语法块，而不是大括号{}.&lt;/p&gt;
&lt;p&gt;python中的表达式(条件/循环表达式等)不需要用小括号()括起来．&lt;/p&gt;
&lt;p&gt;python标识符(变量，函数，参数，类等)由字母和下划线开头，还可以包含数字．不能是关键字．&lt;/p&gt;
&lt;p&gt;python不支持方法或函数重载．&lt;/p&gt;
&lt;p&gt;python不支持char和type类型．&lt;/p&gt;
&lt;p&gt;python没有switch语句．&lt;/p&gt;
&lt;p&gt;python支持多继承．&lt;/p&gt;
&lt;p&gt;python不支持++/&amp;ndash;自增和自减运算符．&lt;/p&gt;
&lt;p&gt;python支持连续比较，a&amp;lt;b&amp;lt;c.&lt;/p&gt;
&lt;p&gt;命名规则&lt;/p&gt;
&lt;p&gt;variable: snake_case, case
function:  get_user_info(), get()
class: User, UserInfo
module: snake_case.py
package: myapp, utils&lt;/p&gt;
&lt;h2 id=&#34;lexical-analysis&#34;&gt;lexical analysis&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/2/reference/lexical_analysis.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.python.org/2/reference/lexical_analysis.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Logical lines and physical lines：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python通过行尾的令牌NEWLINE表示逻辑行
expression
# 以操作系统的换行符表示物理行．
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;encoding declarations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python脚本中的第一行或第二行的
coding[=:]\s*([-\w.]+)
# 注释与正则表达式匹配将被作为编码申明处理．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[Deprecated] explicit line joining:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 多个物理行通过反斜线backslash续行进行显示换行
# 推荐用隐式换行．
if a == b \
       and c ==d: # 只有续行的最后一行可以有注释．反斜线的行不能注释.
    print(&#39;more than one physical line.&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;implicit line joining：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在括号(parentheses),方括号(square brackets)，大括号(curly braces)中的表达式可以分割多个物理行而不需要显示换行．
test_list = [
    &#39;a&#39;, # 每一行都可以注释
    &#39;b&#39;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;indentation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 逻辑行的开头的空格和跳格用于缩进，python根据行的缩进级别区分语法块．
# 缩进级别用于生成INDENT和DEDENT两个令牌
pep8建议用四个空格表示一个缩进级别．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python2.7源代码格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行python代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python mycode.py
# OR
$ chmod u+x mycode.py
$ ./mycode.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;f-string&#34;&gt;f-string&lt;/h3&gt;
&lt;p&gt;格式字符串字面值则是可在运行时求值的表达式。&lt;/p&gt;
&lt;p&gt;!s call str()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f&amp;quot;his name is {name!r}&amp;quot;
f&amp;quot;his name is {repr(name)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;!r call repr()
!a call ascii()&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python注释&#34;&gt;&lt;strong&gt;python注释&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
comment1

comment2
comment3
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python3键字&#34;&gt;&lt;strong&gt;python3键字&lt;/strong&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;def lambda class import from
if elif else while for continue break try except finally return pass
global raise assert del yield with as
and or not is in nonlocal
False None True 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python运算符和优先级&#34;&gt;&lt;strong&gt;python运算符和优先级&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;优先级从高到底：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 函数调用
f(x)

# 序列的切片
seq[ind1:ind2:step]

# 序列下标索引
seq[index]

# 属性运算.
object.attribute

# 算术运算符
**   幂运算，乘方运算符, 等效内置函数pow(), 优先级高于单目运算符

# 位运算(只能用于整数)
~    按位取反
# 单目运算符．
+expr    # 结果符号不变
-expr    # 对结果符号取负

# 算术运算符, 优先级一样
*
/    python2两个操作数都是整数时，结果是商舍去小数后的整数,也就是地板除; 只要有一个以上的浮点操作数,结果就是浮点数，也就是真正的除法．
/    python3会自动转化成两个浮点数出发，结果永远是浮点数，永远是真正的除法．
//   地板除，结果总是舍去小数部分．
%

# 算术运算符, 优先级一样
+
-

# 位运算(只能用于整数), 优先级一样．
&amp;lt;&amp;lt;   左移位运算
&amp;gt;&amp;gt;   右移位运算

# 位运算(只能用于整数)
&amp;amp;    按位与

# 位运算(只能用于整数), 优先级一样
^    按位异或
|    按位或

# 关系运算, 优先级一样
&amp;lt;
&amp;gt;
&amp;lt;=
&amp;gt;=

# 关系运算, 优先级一样
==
!=
# Python2的&amp;lt;&amp;gt;不再支持，使用!=

# 赋值运算符和增量赋值
=
+=
-=
*=
/=
%=
**=
&amp;lt;&amp;lt;=
&amp;gt;&amp;gt;=
&amp;amp;=
|=
^=

# [New] 对象运算符, 优先级一样
is
is not

# [New] 序列的元素/字典的键/集合的元素 成员运算符, 优先级一样
in
not in

# boolean逻辑运算符
not    逻辑非

# boolean逻辑运算符, 优先级一样
and    逻辑与
or     逻辑或
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python数据类型&#34;&gt;&lt;strong&gt;python数据类型&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python中一切皆对象，每个对象都有身份(id()), 类型(type()) 和 值三个属性．&lt;/p&gt;
&lt;p&gt;python中对象的类型和内存占用都是在运行时确定的．&lt;/p&gt;
&lt;p&gt;is和is not可以判断两个变量是否指向同一个对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a is b # 等价于 id(a) == id(b), 表示a和b是同一个对象
a is not b # 等价于 id(a) != id(b), 表示a和b不是同一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is和is not可以判断变量的类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import types
type(a) is types.IntType
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;垃圾回收&#34;&gt;&lt;em&gt;垃圾回收&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Garbage Collector垃圾回收机制是引用计数为主，标记清除和分代收集为辅．&lt;/p&gt;
&lt;p&gt;当对象被引用，包括对象在被创建，对象被作为参数传递给函数，对象成为容器对象的一个元素时，引用值增加．&lt;/p&gt;
&lt;p&gt;当对象的引用被销毁，包括一个本地引用离开其作用域，对象的别名被del显示销毁，对象的别名被赋值给其它对象，对象被从一个窗口对象中移除，窗口对象本身被del显示销毁，引用值减少．&lt;/p&gt;
&lt;p&gt;del语句会删除对象的一个引用．&lt;/p&gt;
&lt;h2 id=&#34;变量和常量&#34;&gt;&lt;em&gt;变量和常量&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python是动态类型语言，变量不需要先申明，变量的类型和值在赋值的时候被初始化．&lt;/p&gt;
&lt;p&gt;用全部小写表示变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;counter = 0
miles = 100.03
name = &amp;quot;canux&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用全部大写表示常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PIE = 3.14
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型总结&#34;&gt;&lt;em&gt;类型总结&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;更新模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可变类型:immutable不可变类型就是变量的值是固定的，再次赋值就是重新创建了新的对象: 数字类型，字符串str，元组tuple，不可变集合frozenset.&lt;/li&gt;
&lt;li&gt;可变类型:mutable可变类型就是变量的值是可以改变的: 列表list，字典dict，可变集合set.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scalar标量/原子类型:只能容纳单个对象：数字类型，字符串str&lt;/li&gt;
&lt;li&gt;container容器类型:可以容纳多个对象：元组tuple，列表list，字典dict,集合set/frozenset.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接存取:数字类型&lt;/li&gt;
&lt;li&gt;索引访问:sequence序列是顺序访问：字符串str，元组tuple，列表list.&lt;/li&gt;
&lt;li&gt;映射访问:mapping映射类型是映射访问,元素无序存放，通过唯一的key来访问：字典dict.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据拷贝&#34;&gt;数据拷贝&lt;/h2&gt;
&lt;p&gt;浅拷贝:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只拷贝顶层数据.

对不可变对象不开辟新空间,相当于赋值操作;修改原数据,相当于定义了一个新的数据.拷贝的数据不变.
a=10
b=copy.copy(a)
old_id  = id(a) == id(b)
a=5 # 修改a相当于定义了新变量
id(a) != old_id
id(b) == old_id # id(b) 不变
id(b) == 10

对可变对象会在内存开辟新空间保存拷贝的数据;只拷贝第一层中的引用,原数据被修改,拷贝的对象也被修改.
a=[1,2,3]
b=copy.copy(a)
id(a) != id(b)
a[0]=5 # 改变a的数据
b == a # b的数据也改变

copy.copy()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;深拷贝:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;逐层拷贝数据,直到拷贝的所有引用都是不可变引用.

深拷贝,一份数据改变,不影响另一份数据.

copy.deepcopy()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sequences序列类型&#34;&gt;&lt;em&gt;Sequences序列类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;sequence序列是指成员有序排列，可以通过下标偏移量访问，同时可以进行切片操作．序列是可迭代的．&lt;/p&gt;
&lt;p&gt;sequence索引操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq[ind] # 获取下标为ind的元素，下标从0开始．
seq[-1] # 取最后一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence切片操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq[ind1:ind2] # 获取下标从ind1到ind2间的元素的集合．不包括ind2.
seq[:ind2] # ind1缺省默认为０.
seq[ind1:] # ind2缺省表示从ind1到最后一个元素

seq[ind1:ind2:step] # 以步长为step来切片
seq[:ind2:step]
seq[::step] # ind1缺省为０，ind2缺省为整个序列长度．
seq[::-1]  # 翻转序列
seq[::-step]  # 以步长为step翻转序列．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence算术运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq * number # 序列重复number次
sql1 + seq2 # 两个序列连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sequence成员运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj in seq # obj在包含在序列中,返回True
obj not in seq # obj不包含在序列中返回True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数字类型&#34;&gt;&lt;em&gt;数字类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;数字类型是不可变类型(immutable),是标量(scalar),是直接存储的．&lt;/p&gt;
&lt;p&gt;0b开头表示二进制&lt;/p&gt;
&lt;p&gt;0开头表示八进制&lt;/p&gt;
&lt;p&gt;0x开头表示十六进制&lt;/p&gt;
&lt;p&gt;数字类型转换的关系是整数转换成浮点数，非复数转换成复数．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int&lt;/p&gt;
&lt;p&gt;Python3的int类型整合了short、int、long三种长度，统一为int类型，且没有长度限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bool(int)&lt;/p&gt;
&lt;p&gt;bool类继承自int.&lt;/p&gt;
&lt;p&gt;bool类型只有True和False两个值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  bool类型取反: 
  a = True
  b = bool(1-a) # b=False
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;float&lt;/p&gt;
&lt;p&gt;python中的float其实就包括了单精度和双精度，相当于float和double都可以用．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complex&lt;/p&gt;
&lt;p&gt;python中有复数类型．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;str&#34;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python2中str和unicode继承自basestring, basestring继承自object.&lt;/p&gt;
&lt;p&gt;python3中unicode和basestring在python3中被废弃．str直接继承自object.&lt;/p&gt;
&lt;p&gt;python3中不再需要u/U来表示unicode字符串．&lt;/p&gt;
&lt;p&gt;str类型是不可变类型(immutable),是标量(scalar),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;字符串表示方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;This is a string&#39;
&amp;quot;This is a string&amp;quot;
&amp;quot;&amp;quot;&amp;quot;This is a string&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串的续行：&lt;/p&gt;
&lt;p&gt;下面都表示一个只有一行的字符串．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一个引号的情况,需要在引号内部空格表示和下一行有空格，续行符前的空格可有可无．
a = &#39;This is a &#39; \
&#39;string&#39;

b = &#39;This is a \
string&#39;

c = &amp;quot;This is a &amp;quot; \
&amp;quot;string&amp;quot;

d = &amp;quot;This is a \
string&amp;quot;

# 三引号续行符前的空格就表示和下一行有空格．
c = &amp;quot;&amp;quot;&amp;quot;This is a \
string&amp;quot;&amp;quot;&amp;quot;
&amp;gt; This is a string

c = &amp;quot;&amp;quot;&amp;quot;line1
line2&amp;quot;&amp;quot;&amp;quot;
&amp;gt; line1\nline2   没有续行符会在行尾加换行符号.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译时字符串连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo = &amp;quot;hello&amp;quot; &#39;world&#39;
urllib.urlopen(&#39;http://&#39; # protocol
&#39;localhost&#39; # hostname
&#39;:8000&#39; # port
&#39;/&#39;) # path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原始字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 正常情况下在字符串中的特殊字符串(\加一个字符)表示特殊含义．是不可打印的．
print(&#39;\n&#39;)
# 如果需要表示正常含义需要转译(\用来转意)．
print(&#39;\\n&#39;) # 需要转译．
# 也可以使用原始字符串来表示正常含义．r&#39;&#39;和R&#39;&#39;都可以．
print(r&#39;\n&#39;)
open(r&#39;C:\windows\test.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串编码解码:&lt;/p&gt;
&lt;p&gt;Unicode: Universal Multiple-Octet Coded Character Set. 使用十六进制表示．加上前缀U+&lt;/p&gt;
&lt;p&gt;ASCII: American Standard Code for Information&lt;/p&gt;
&lt;p&gt;UFT-8: Unicode Transformation Format&lt;/p&gt;
&lt;p&gt;python2因为比unicode出现要早，所以python2默认使用的是ASCII编码．&lt;/p&gt;
&lt;p&gt;python3 默认使用utf-8编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 获取默认编码
import sys
print(sys.getdefaultencoding())

// python2
a = u&#39;测试&#39;
type(a) # unicode
a # u&#39;\u6d4b\u8bd5&#39;,　十六进制表示

// python2
# str类型
b = &#39;测试&#39;
type(b) # str
b # \xe6\xb5\x8b\xe8\xaf\x95

// python2
# encode将unicode类型编码成str类型用于数据传输．
encode([encoding[,errors]]) # 编码
c = a.encode(&#39;uft-8&#39;)
type(c) # str
c # \xe6\xb5\x8b\xe8\xaf\x95

// python2
# decode将str类型根据原来的编码类型解码成unicode类型进行阅读．
decode([encoding[,errors]]) # 解码
d = c.decode(&#39;utf-8&#39;) # 参数必须是原来的编码的类型
type(d) # unicode
d # u&#39;\u6d4b\u8bd5&#39;

// python2
# python2默认ascii编码，所以encode和decode默认都是ascii. 不能处理中文
u&#39;测试&#39;.encode() # UnicodeEncodeError

// python2
# str+unicode, str会隐式的转换成unicode.
&#39;测&#39; + u&#39;试&#39; -&amp;gt; &#39;测&#39;.decode() + u&#39;试&#39; # 因为decode默认是ascii不能解码中文,UnicodeDecodeError．
&#39;测&#39;.decode(&#39;uft-8&#39;) + u&#39;试&#39;

// python2
# 对非unicode进行encode编码，会先隐式解码成unicode再编码
&#39;测试&#39;.encode(&#39;utf-8&#39;) # UnicodeDecodeError, 因为&#39;测试&#39;.decode()默认用ascii解码
&#39;测试&#39;.decode(&#39;utf-8&#39;).decode(&#39;utf-8&#39;)

# python2程序中出现字符串一定加前缀u.表示成unicode格式
u&#39;hello world&#39;
# 不要用str(), 用unicode().
# 只在写入文件／数据库／网络时才调用编码函数encode().
# 只在读回数据时才调用解码函数decode().
# 始终使用utf-8编码．否则容易出现乱码．

// python3 默认类型非str，而是bytes。
str.encode()  # str类型通过encode编码成types类型
bytes.decode() # bytes类型通过decode解码成str类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可迭代对象转换成字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39;.join((&#39;a&#39;, &#39;b&#39;)) # 可迭代对象的元素需要是str类型.
&#39;&#39;.join([&#39;a&#39;, &#39;b&#39;]) # 可迭代对象的元素需要是str类型.
&#39;&#39;.join({&#39;a&#39;: &#39;b&#39;}) # 字典迭代键，可迭代对象的元素需要是str类型.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tuple&#34;&gt;&lt;em&gt;tuple&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;tuple类型是不可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;元组是不可变类型，不能对元组的元素进行增删操作．&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;list类型是可变类型(immutable),是容器(container),是序列(sequence)通过索引访问．&lt;/p&gt;
&lt;p&gt;列表元素增删修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 除了使用内置方法还可以使用序列的索引．
lst[index] = value
del lst[index]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;list-comprehensions列表解析&#34;&gt;&lt;em&gt;list comprehensions列表解析&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;List Comprehensions列表解析,来自函数式编程语言Haskell.&lt;/p&gt;
&lt;p&gt;列表解析使用中括号，列表解析返回一个列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lst = [expression for item in iterable]
# 嵌套if
lst = [expression for item in iterable if condition]
# 嵌套for
lst = [expression for item in iterable for item1 in iterable1]

[x ** 2 for x in range(10)]
等效于,python2的内置函数map(), filter()都是函数式编程的应用．
map(lambda x: x**2, range(10))

[(x+1, y+1) for x in range(10) for y in range(10)]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;range&#34;&gt;&lt;em&gt;range&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;用于生成整数序列的内建类型，返回对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;range(stop)
range(start, stop)
range(start, stop, step)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bytes&#34;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&#34;bytearray&#34;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&#34;memoryview&#34;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dict&#34;&gt;&lt;em&gt;dict&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;dict类型是可变类型(immutable),是容器(container),是映射(mapping)类型,是无序的,通过映射访问．&lt;/p&gt;
&lt;p&gt;字典迭代键，字典的键必须是可哈希的，字典的键必须是不可变类型．列表/字典/可变集合等不可哈希对象不能用作字典的键．&lt;/p&gt;
&lt;p&gt;所有不可变类型都是可哈希的，都可以作为字典的键．&lt;/p&gt;
&lt;p&gt;可用内置函数hash()获取或判断是否能用作字典的键．&lt;/p&gt;
&lt;p&gt;字典的键必须是唯一的，不能一个键对应多个值．有这种情况取最后一个赋值．&lt;/p&gt;
&lt;p&gt;字典的键操作符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 字典通过键操作符来读取元素的值
dic[&#39;key&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;键成员操作符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 取代has_key()和keys()内置方法
&#39;key&#39; in dic # 推荐用 &#39;key&#39; in dic 判断键是否存在
&#39;key&#39; not in dic
# Python3中dict.keys()、dict.values()、dict.items()返回的是视图对象（可迭代），如需列表可用list(dict.keys())等。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字典元素增删修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dic[&#39;key&#39;] = &#39;value&#39;
del dic[&#39;key&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sets集合&#34;&gt;&lt;em&gt;Sets集合&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;集合是一组无序排列的值，不能进行索引和切片操作，也不能进行键操作，只能通过for循环迭代集合元素．&lt;/p&gt;
&lt;p&gt;集合分为可变集合和不可变集合.&lt;/p&gt;
&lt;p&gt;集合运算符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;element&#39; in st 是成员
&#39;element&#39; not in st 不是成员
== 等于
!= 不等于
&amp;lt;  严格子集
&amp;lt;= 非严格子集, 等效于issubset()
&amp;gt; 严格超集
&amp;gt;= 非严格超集, 等效于issuperset()
| 联合, OR操作，等效于union()内置方法
&amp;amp; 交集, AND操作，等效于intersection()内置方法
- 差补或相对补集, 等效于difference()内置方法
^ 对称差分或异或, XOR操作，等效于symmetric_difference()内置方法

仅用于可变集合的运算符：
|= 等效于update()内置方法
&amp;amp;= 等效于intersection_update()内置方法
-= 等效于difference_update()内置方法
^= 等效于symmetric_difference_update()内置方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;集合运算返回结果的类型与左操作数的类型相同，左边是可变集合，结果就是可变集合，否则是不可变集合．&lt;/p&gt;
&lt;h3 id=&#34;frozenset&#34;&gt;frozenset&lt;/h3&gt;
&lt;p&gt;frozenset类型是不可变类型(immutable),是容器(container).&lt;/p&gt;
&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;
&lt;p&gt;set类型是可变类型(mutable)，是容器(container).&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python控制流&#34;&gt;&lt;strong&gt;python控制流&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;continue语句:表示立即终止本次循环，启动循环的下一次迭代．&lt;/p&gt;
&lt;p&gt;break语句：表示结束当前循环块，跳转到后面的语句．&lt;/p&gt;
&lt;p&gt;pass语句： 表示不做任何事情，NOP.&lt;/p&gt;
&lt;h2 id=&#34;if条件语句&#34;&gt;&lt;em&gt;if条件语句&lt;/em&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;if condition:
    expression
elif condition:
    expression
else:
    expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python中的三目运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X if C else Y
等效于
if C:
    X
else:
    Y

# 三目运算符高于赋值运算符．
a = b if c else d
# 等效于
a = (b if c else d)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python没有switch，可以用if实现:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if var == &amp;quot;a&amp;quot;:
    return &amp;quot;A&amp;quot;
elif var == &amp;quot;b&amp;quot;:
    return &amp;quot;B&amp;quot;
else:
    return &amp;quot;unknown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.10+引入match-case。&lt;/p&gt;
&lt;h2 id=&#34;while循环语句&#34;&gt;&lt;em&gt;while循环语句&lt;/em&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;while condition:
    expression

# while执行完会执行else(包括while不执行)，break会跳过else．
while condition:
    expression
else:
    expression
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;for循环语句&#34;&gt;&lt;em&gt;for循环语句&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;for循环可以用于遍历序列，字典的键 和 文件的行，集合，列表解析，生成器表达式.&lt;/p&gt;
&lt;p&gt;for循环会自动调用迭代器的next()方法，捕获StopIteration异常结束循环．&lt;/p&gt;
&lt;p&gt;用for迭代可变对象的时候，不应该改变可变对象的元素的值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for condition:
    expression

# for执行完成会执行else, break会跳过else.
for condition:
    expression
else:
    expression

# 字典有两种写法
for loop in dic.keys()
等效于
for loop in dic

# 文件有两种写法
for loop in open(&#39;file&#39;, &#39;r&#39;).readlines():
等效于
for loop in open(&#39;file&#39;,&#39;r&#39;):
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;iterator迭代器-类型&#34;&gt;&lt;em&gt;iterator迭代器 类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Iterable可迭代对象: 能直接用于for循环的对象为可迭代对象Iterable. 只需要实现__iter__()方法即可。&lt;/p&gt;
&lt;p&gt;Iterator迭代器: 能被next(g)内置函数调用并不断返回下一个值的对象为迭代器Iterator,迭代完成后抛出StopIteration异常, 也能用for循环，要同时实现__iter__()和__next__()&lt;/p&gt;
&lt;p&gt;enumerate和reversed内置类类型的工厂函数返回的都是迭代器类型．&lt;/p&gt;
&lt;p&gt;创建迭代器的3种方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过内建函数iter()
iter()

# 通过工厂函数
enumerate() # 迭代时同时获取元素值和索引

reversed() # 反转序列对象

# 自定义类，需要实现 __iter__() 和__next__() 两个方法(python3)
class TestIterator(object):
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        for item in self.data
            yield item

    def __next__(self):
        if condition:
            ...
        else:
            raise StopIteration()

i = TestIterator()
type(i) 
&amp;gt; iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;generator生成器类型&#34;&gt;&lt;em&gt;generator生成器类型&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;生成器就是一个迭代器对象，在每次调用next()方法时返回一个值．直到抛出StopIteration异常, 生成器通常用于迭代一个巨大的数据集．&lt;/p&gt;
&lt;p&gt;generator类类型,是一个迭代器，可以用for循环迭代:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;generator.close() # 在生成器内部抛出GeneratorExit异常要求生成器退出．
generator.send(arg) # 将值回送给生成器．
generator.throw(typ[,val[,tb]]) # 在生成器抛出异常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建生成器的两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用列表解析的变种&lt;/p&gt;
&lt;p&gt;g = (expression for item1 in iterable1 if condition1)
type(g)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;generator&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;next(g)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用yield关键字&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有yield的函数返回的就是一个生成器．&lt;/p&gt;
&lt;p&gt;yield函数能记住上一次返回时在函数体中的位置，迭代生成器会跳转至该函数中间，而且上次调用的所有局部变量保持不变．&lt;/p&gt;
&lt;p&gt;yield函数和普通函数执行顺序不一样，普通函数顺序执行，遇到return或最后一行语句返回．yield函数遇到yield语句返回，下次执行从上次返回的yield语句开始继续执行．遇到return语句抛出StopIteration异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def gena():
    yield &#39;first&#39;
    yield &#39;second&#39;

g = gena()
type(g) 
&amp;gt; generator

next(g) # first
next(g) # second
next(g) # StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;generator-expressions生成器表达式&#34;&gt;&lt;em&gt;generator expressions生成器表达式&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Generator Expressions生成器表达式, 是列表解析的一个扩展．&lt;/p&gt;
&lt;p&gt;列表解析的缺点就是要迭代整个对象用来创建列表，对大的对象来说性能差.&lt;/p&gt;
&lt;p&gt;生成器表达式就是结合生成器和列表解析解决这个问题．&lt;/p&gt;
&lt;p&gt;生成器表达式不必创建完整的列表，而是一边循环一边计算，返回一个生成器对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g = (expression for item1 in iterable1 if condition1)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python文件和输入输出&#34;&gt;&lt;strong&gt;python文件和输入输出&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;python2使用open()内置函数打开文件，返回file类类型的对象，出错返回IOError异常.&lt;/p&gt;
&lt;p&gt;file类类型对象是迭代器，同时也是上下文管理器．&lt;/p&gt;
&lt;p&gt;python3废弃了file类类型，open()内置函数返回IO流．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2
open(name[, mode=&#39;r&#39;[, buffering=-1]])

mode
r: 读，文件必须存在
w: 写，文件不存在则创建，否则先清空文件再写入．
a: 追加，文件存在就追加到文件结尾,否则就创建．
t: text模式，这个是默认模式．不用指定．
rb/wb/ab: 二进制读写．
r+/w+/a+: 以读写模式打开文本文件．
rb+/wb+/ab+: 以读写模式打开二进制文件．
U: 提供通用换行符支持，文件必须存在

buffering
0: 不缓冲
1: 只缓冲一行数据
&amp;lt;0: 使用系统默认缓冲机制
&amp;gt;1: 使用给定值作为缓冲区大小
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通用换行符UNS:&lt;/p&gt;
&lt;p&gt;Universal Newline Support.&lt;/p&gt;
&lt;p&gt;如果是二进制文件读写rb/wb/ab，不会有换行符的问题，如果是文本文件建议用rU/wU/aU来读写.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# UNS会把
\r\n
\r
\n
# 都被替换为
\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件可以使用with上下文管理器，并且迭代文件的行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with open(&#39;file&#39;, &#39;rU&#39;) as f:
    for line in f:
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准文件:&lt;/p&gt;
&lt;p&gt;系统默认的三个标准文件: sys.stdin, sys.stdout, sys.stderr.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2的关键字print会把语句打印到sys.stdout,并默认在语句结尾加换行符.
print(expression)
print(expression, end=&#39;&#39;) # 可以避免默认加换行符

# 内置函数input()会从sys.stdin接受输入
a = input()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python错误和异常&#34;&gt;&lt;strong&gt;python错误和异常&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;参考内置的错误和异常.&lt;/p&gt;
&lt;p&gt;BaseException是所有异常的基类． Exception是常规错误的基类.&lt;/p&gt;
&lt;p&gt;错误和异常的检测和处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    try_suite
except Exception0[ as reason]: # reason可以用于在except_suite中打印具体的异常信息，reason是一个Exception0类型的实例．
    except_suite
except Exception1[ as reason]: # 可以有多个except用来捕获不同的异常，但是只有一个except会被执行.
    except_suite
except (Exception2, Exception3)[ as reason]: # 也可以在一个except中同时检测多个异常．放入一个tuple中. reason是一个实例的元组．
    except_suite
except Exception[, reason]: # 可以用Exception来捕获所有异常，而不用区分具体的异常．不推荐用逗号，应该用as代替．
    except_suite
[Deprecated] except:    # 不推荐此用法，和上面一个等效
    except_suite
...
else:    # 可选， 没有异常触发except时运行else,　except和else只能运行一个．
    expression
finally:    # 可选，无论是否捕捉到异常都会执行的．
    expression

# 也可以不对异常处理
try:
    try_suite
finally:
    finally_suite

# 异常的参数
reason.__clas__.__name__  # 就是异常类的名字
print(reason) # 打印异常参数．
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;raise触发异常&#34;&gt;&lt;em&gt;raise触发异常&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;除了上面捕获解释器触发的异常，用户还可以用raise自己触发异常:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise [SomeException [, args [, traceback]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SomeException可以是字符串，内置异常，第三方库异常类，自定义异常类, 或实例.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise ExceptionClass[, args[, traceback]] # 类
raise ExceptionClass(arguments)[, args[, traceback]] # 实例
raise ExceptionClass, instance # [TODO]
raise instance # 触发实例异常, raise reason 就是跑出一个ExceptionClass类型的instance.
raise string # 触发字符串异常
raise # 重新触发前一个异常，如果之前没有异常触发TypeError.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义异常和错误&#34;&gt;&lt;em&gt;自定义异常和错误&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;自定义异常需要继承一个标准异常或者第三方库的异常来实现一个类．&lt;/p&gt;
&lt;p&gt;通过raise来触发自定义的异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyError(Exception/StandardError/Warning):
    def __init__(self, msg):
        super(...).__init__(self, ...)
        ...
    ...

raise MyError, args
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;assert断言&#34;&gt;&lt;em&gt;assert断言&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;断言语句等效assert表达式, 如果断言成功不采取任何措施，否则触发AssertionError异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert expression[, arguments]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以提供一个异常参数和捕获AssertionError异常:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try:
    assert expression, &amp;quot;If raise AssertionError, print this message.&amp;quot;
except AssertionError as e:
    print(&#39;%s: %s&#39; % (e.__class__.__name__, e))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;with上下文管理&#34;&gt;&lt;em&gt;with上下文管理&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;CMP: context management protocol.&lt;/p&gt;
&lt;p&gt;with上下文管理仅用于支持上下文管理协议(CMP)的对象．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with context_expr [as var]:
    with_suite
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with语句执行时就执行上下文符号（with和as之间的内容）来获得一个上下文管理器．&lt;/p&gt;
&lt;p&gt;上下文管理器调用__context__()方法来返回一个上下文对象．&lt;/p&gt;
&lt;p&gt;上下文对象会调用__enter_()方法完成with语句块执行前的准备工作．返回值赋给as后面的var变量．&lt;/p&gt;
&lt;p&gt;with语句块执行完毕后调用__exit__()方法，&lt;strong&gt;exit&lt;/strong&gt;()有三个参数，如果没有异常都是None,否则是sys.exc_info()的三个返回值．&lt;/p&gt;
&lt;p&gt;自定义上下文管理器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class CMPTest(object):
    def __init__(self):
        pass

    def __enter__(self):
        ...
        return self

    def __exit__(self, type, value, traceback):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类实现了上下文管理协议，子类可以直接使用with.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;函数function&#34;&gt;&lt;strong&gt;函数function&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义/申明一个函数:&lt;/p&gt;
&lt;p&gt;python对函数的申明和定义是一起的．&lt;/p&gt;
&lt;p&gt;函数必须先定义/申明才能引用/调用.&lt;/p&gt;
&lt;p&gt;通过关键字def来定义一个函数.&lt;/p&gt;
&lt;p&gt;def function_name(arguments)
expression&lt;/p&gt;
&lt;p&gt;函数引用：&lt;/p&gt;
&lt;p&gt;引用一个函数名并不会执行函数内容．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_copy = function_name

# 可以将函数作为参数传给另外一个函数，然后在另外一个函数调用该函数
def fun_name(arg):
    print(arg(10))
fun_name(str)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数调用:&lt;/p&gt;
&lt;p&gt;调用一个函数才会执行函数内容.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_name(arguments)
# 可以通过引用的副本来调用函数
function_copy(args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的返回值：&lt;/p&gt;
&lt;p&gt;省略return表示返回None. 单个return表示返回None.其它表示返回一个对象．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return
return return_value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的实参：&lt;/p&gt;
&lt;p&gt;位置参数，调用的时候通过先后顺序传递的参数,函数定义时需要放在前面．&lt;/p&gt;
&lt;p&gt;默认参数，在函数定义时就已经初始化的参数，调用时可以不再赋值．&lt;/p&gt;
&lt;p&gt;默认参数在函数定义时需要放在位置参数的后面．否则抛出SytaxError.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def function_test(position_args, keyword_args, *args, **kwargs):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的形参：&lt;/p&gt;
&lt;p&gt;位置参数，在函数调用时根据定义的参数的顺序来传递．&lt;/p&gt;
&lt;p&gt;默认参数，在函数调用时如果没有传值则使用定义的默认值．&lt;/p&gt;
&lt;p&gt;关键字参数，在函数调用时，根据定义时的参数名称来传值.&lt;/p&gt;
&lt;p&gt;非关键字参数的传值不能在关键字参数后面．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func_test(arg1, arg2, arg3=&amp;quot;val1&amp;quot;, arg4=&amp;quot;val2&amp;quot;):
    pass
func_test(1, 2, 3, 4) # 位置参数
func_test(1, 2) # 使用默认参数
func_test(arg2=2, arg1=1) # 关键字传参
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变长度参数:&lt;/p&gt;
&lt;p&gt;当函数参数不确定时，可以使用可变长度参数．&lt;/p&gt;
&lt;p&gt;一个星号表示一个非关键字参数组成的元组(可以是其它序列，会自动转换成元组)．&lt;/p&gt;
&lt;p&gt;两个星号表示一个关键字参数组成的字典．&lt;/p&gt;
&lt;p&gt;函数定义时可变长度参数必须在位置参数和默认参数后面．而且关键字变长参数应该在最后.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func_test(position, default=&#39;value&#39;, *args, **kwargs):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用可变长度参数时，可以把非关键字变长参数放到一个元组，把关键字变长参数放到一个字典．&lt;/p&gt;
&lt;p&gt;也可以在元组和字典中放部分参数，另外一部分直接传递, 非关键字参数的传值不能在关键字参数后面．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 注意，函数定义的时候星号是必须的，函数调用的时候也需要星号．
args = (&#39;val1&#39;, &#39;val2&#39;)
kwargs = {key1: &#39;val1&#39;, key2: &#39;val2&#39;}
func_test(&#39;position&#39;, &#39;default&#39;, *args, **kwargs)
# 部分传递，多出来的非关键字参数属于变长非关键字参数，多出来的关键字参数属于变长关键字参数．
func_test(&#39;position&#39;, &#39;default&#39;, &#39;non-keyword&#39;, key=&#39;keyword&#39;, *(1,2), **{3: &#39;three&#39;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的属性：&lt;/p&gt;
&lt;p&gt;通过小数点来调用函数的属性．&lt;/p&gt;
&lt;p&gt;内置函数的特殊属性(BIF)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function_test.__doc__
function_test.__name__
function_test.__module__ # __builtin__
function_test.__self__ # None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义函数的属性(UDF)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dir(function_test)
&#39;__doc__&#39;,
&#39;__name__&#39;,
&#39;func_closure&#39;,
&#39;func_code&#39;,
&#39;func_defaults&#39;,
&#39;func_dict&#39;,
&#39;func_doc&#39;,
&#39;func_globals&#39;,
&#39;func_name&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;偏函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from functools import partial
partial(func, *args, **keywords) # 一个偏函数的类
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量作用域:&lt;/p&gt;
&lt;p&gt;python搜索一个标识符先从局部作用域开始搜索，如果没有找到就在全局作用域找，否则抛出NameError异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 当在函数外部和内部都定义了同一个变量，局部变量会覆盖全局变量
var = &#39;global&#39;
def func_test(*args, **kwargs):
    var = &#39;local&#39;
    print(var)
func_test() # local

# 如果在函数内部使用一个不在函数内部定义的变量，就会在函数外部查找．
var = &#39;global&#39;
def func_test(*args, **kwargs):
    print(var)
func_test() # global

# 在函数内部不能修改外部变量,只能引用.
var = &#39;global&#39;
def func_test(*args, **kwargs):
    var += &#39;local&#39;
    print(var)
func_test() # UnboundLocalError: local variable &#39;var&#39; referenced before assignment

# 如果需要在局部引用全局变量需要使用global关键字
var = &#39;global&#39;
def func(*args, **kwargs):
    global var
    var = &#39;local&#39;
    print(var)
func() # local
print(var) # local # 全局变量在局部被修改．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func1(arg1: int, arg2: str) -&amp;gt; bool:
    ......

// with default value
def func2(arg1: str = &amp;quot;hello&amp;quot;) -&amp;gt; str
    ......

def func3(arg1: Optional[str]) -&amp;gt; int
    ......

def func4() -&amp;gt; Tuple[int, int]:
    ......
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lambda匿名函数&#34;&gt;&lt;em&gt;lambda匿名函数&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;lambda匿名函数就是一个只有一行表达式，不需要通过def来命名的函数.&lt;/p&gt;
&lt;p&gt;lambda匿名函数返回一个可调用的函数对象．&lt;/p&gt;
&lt;p&gt;lambda匿名函数支持通过def定义的函数的所有功能．&lt;/p&gt;
&lt;p&gt;lambda匿名函数中不能有return语句, expression的结果就是函数返回值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lambda [arg1[, arg2, ...argN]]: expression
lambda *args, **kwargs: expression
lambda : expression
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functional-programming函数式编程&#34;&gt;&lt;em&gt;Functional Programming函数式编程&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;python涉及到函数式编程主要有几个内置类类型的工厂函数和lambda匿名函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zip(*iterables, strict=False)

filter(function, iterable, /)
result = filter(lambda x: x%2==0, [1,2,3,4,5])
&amp;gt; x=1, 1%2==0 False
&amp;gt; x=2, 2%2==0, True
&amp;gt; x=3, 3%2==0, False
print(list(result))
&amp;gt; [2]

map(function, iterable, /, *iterables)
result = map(lambda x: x**2, [1,2,3])
&amp;gt; x=1, x**2 =1
&amp;gt; x=2, 2**2=4
&amp;gt; x=3, 3**2=9
print(list(result))
&amp;gt; [1,4,9]

from functools import reduce
reduce(func, iterable[, initializer]) 
reduce(lambda x,y: x*y, [1,2,3,4]
&amp;gt; x=1,y=2, x*y=2
&amp;gt; x=2, y=3, x*y=6
&amp;gt; x=6, y=4, x*y=24
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;内嵌函数&#34;&gt;&lt;em&gt;内嵌函数&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;可以在函数内部定义函数，内部函数不能在外部函数以外的地方调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def outer(*args, **kwargs):
    expression
    def inner(arg): # 内嵌函数的参数不能是外部函数的参数．内部函数必须完全独立．
        expression
    inner(args)

def outer(*args, **kwargs):
    filter(lambda arg: expression, sequence)
    map(lambda arg: expression, sequence)
    functools.reduce(lambda arg: expression, sequence)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在函数内部内嵌匿名函数，匿名函数可以使用外部函数的参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x, y):
    bar = lambda :x + y
    print(bar())
foo(4,3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在函数中调用函数本身是一种递归方法
def fib(n):
    if n in[0, 1]:
        val = 1
    else:
        val = fib(n-1) + fib(n-2)
    return val
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;closure闭包&#34;&gt;&lt;em&gt;closure闭包&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;在一个内部函数里对在外部作用域的变量进行引用，内部函数被认为是closure.&lt;/p&gt;
&lt;p&gt;定义在外部函数内的但由内部函数引用的变量称为自由变量．&lt;/p&gt;
&lt;p&gt;当自由变量是一个函数时，闭包就是一个装饰器，decorator是closure最常见的应用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def outer(free):
    def clos(*args, **kwargs):
        print(free)
        print(args, kwargs)
    return clos

# 调用外部函数，返回一个内部函数的引用,　传入外部函数的就是自由变量,返回的内部函数就是闭包.
first_clos = outer(1)

# 调用closure
first_clos(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decorator装饰器&#34;&gt;&lt;em&gt;decorator装饰器&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;装饰器分为函数(方法)装饰器和类装器．函数中再定义函数是函数装饰器，函数中再定义类是类装饰器．&lt;/p&gt;
&lt;p&gt;函数装饰器修饰函数和类中的方法，类装饰器修饰类．类装饰器参考OOP．&lt;/p&gt;
&lt;p&gt;装饰器本质是一个函数，可以让其它函数在不做修改的情况下增加额外的功能．&lt;/p&gt;
&lt;p&gt;常用于插入日志，性能测试，事务处理，缓存，权限校验等场景．&lt;/p&gt;
&lt;p&gt;装饰器是用来装饰函数的包装，返回一个修改后的函数对象．将其重新赋值给原来的标识符，并永久失去对原始函数对象的访问．&lt;/p&gt;
&lt;p&gt;符号@是装饰器的语法糖.&lt;/p&gt;
&lt;p&gt;不带参数的装饰器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(func):
    def wrapper_name(*args, **kwargs): # 抽象出相同的部分进行包装
        &amp;quot;&amp;quot;&amp;quot;Docs for wrapper_name.&amp;quot;&amp;quot;&amp;quot;
        print(func.__name__) # 抽象出来的部分在这里实现
        print(args, kwargs) # 可以引用func传入的参数
        return func(*args, **kwargs) # 最后调用新增加的功能
    return wrapper_name # 返回包装函数的引用.

# 增加新功能,装饰后返回包装函数的一个引用,赋值给原来的foo．此时包装函数wrapper_name并不会执行
@deco_name
def foo(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Docs for foo.&amp;quot;&amp;quot;&amp;quot;
    print(&#39;call foo&#39;)
# 等效于
foo = deco_name(foo)

# 调用装饰后的函数,　调用的是装饰后的新的函数．
foo(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带参数的装饰器:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def deco_name(arg):
    def deco_inner(func):
        def wrapper_name(*args, **kwargs):
            &amp;quot;&amp;quot;&amp;quot;Docs for wrapper_name.&amp;quot;&amp;quot;&amp;quot;
            print(arg) # 通过装饰器的参数arg来做一些判断
            print(func.__name__)
            print(func.__doc__)
            print(args, kwargs)
            return func(*args, **kwargs)
        return wrapper_name
    return deco_inner

# deco_name(arg)(foo) -&amp;gt; deco_inner(foo) -&amp;gt; wrapper_name
@deco_name(arg=&amp;quot;value&amp;quot;)
def foo(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Docs for foo.&amp;quot;&amp;quot;&amp;quot;
    pass

# wrapper_name(*args, **kwargs)
foo(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;装饰器的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo.__name__ #  wrapper_name, 并非foo
foo.__doc__ # &amp;quot;Docs for wrapper_name.&amp;quot;, 并非foo的doc.
# 可以通过import functools.wraps来修饰wrapper_name改变这一属性．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/psl/myfunctools.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/psl/myfunctools.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多层装饰器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@foo
@bar
def func(*args, **kwargs):
    ...

func = foo(bar(func))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/crazy-canux/python/blob/master/python/decorator/function_decorator.py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/crazy-canux/python/blob/master/python/decorator/function_decorator.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python模块和包&#34;&gt;&lt;strong&gt;python模块和包&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;名称空间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部名称空间&lt;/li&gt;
&lt;li&gt;全局名称空间&lt;/li&gt;
&lt;li&gt;内建名称空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;python解释器模块加载顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中已经加载的模块，也就是缓存(sys.modules)&lt;/li&gt;
&lt;li&gt;最先加载内建名称空间，也就是内置模块．&lt;/li&gt;
&lt;li&gt;sys.path路径中的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后加载执行模块的全局名称空间，在模块执行时是活动名称空间．&lt;/p&gt;
&lt;p&gt;最后加载局部名称空间，在执行期间是不断变化的．&lt;/p&gt;
&lt;p&gt;名称空间和变量的作用域是有区别的．&lt;/p&gt;
&lt;p&gt;变量／函数／方法先从局部名称空间开始查找，在找全局名称空间，最后查找内建名称空间．&lt;/p&gt;
&lt;p&gt;如果都没找到就抛出NameError异常．&lt;/p&gt;
&lt;p&gt;无限制名称空间，可以通过属性运算小数点来指定名称空间．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.var
module.function()
module.method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜索路径:&lt;/p&gt;
&lt;p&gt;搜索路径在不同的操作一同一般不同.&lt;/p&gt;
&lt;p&gt;搜索路径通过两个变量来设置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;shell的环境变量PYTHONPATH．&lt;/li&gt;
&lt;li&gt;python解释器的变量sys.path列表里.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在代码里修改搜索路径sys.path&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys.path.append(os.path.abspath(..))&lt;/li&gt;
&lt;li&gt;sys.path.insert(0, os.path.abspath(..)) # 插入到最前面，也就是在sys.path的第一个&amp;rsquo;&amp;rsquo;(当前路径)的前面．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有导入并加载的模块会存放在sys.modules中，导入模块时的搜索顺序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先搜索当前目录.(会覆盖同名的标准库), 其实是在运行过程中动态添加到sys.path中第一个&amp;rsquo;&amp;lsquo;的位置．&lt;/li&gt;
&lt;li&gt;没有的话再搜索sys.path,按照这个列表的顺序搜索找到第一个，然后加载该模块.&lt;/li&gt;
&lt;li&gt;没搜到抛出ImportError异常．&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;module模块&#34;&gt;&lt;em&gt;module模块&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;模块就是一个python程序的源文件．模块是用来组织python代码的方法．&lt;/p&gt;
&lt;p&gt;把其他模块中属性附加到你的模块中的操作叫做导入(import).&lt;/p&gt;
&lt;p&gt;那些自我包含并且有组织的代码片断就是模块( module ).&lt;/p&gt;
&lt;p&gt;查看所有模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;help(&#39;modules&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;package&#34;&gt;&lt;em&gt;package&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;包就是把多个模块放在一个目录中，然后必须加上__init__.py文件．包是用来组织模块的．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 包支持模糊导入.
[Deprecated] from package.module import * # 会导入包里面所有的变量，函数，类．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在__init__.py导入属性，导入时可以省略模块名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;robot/__init__.py
from robot.run import run, run_cli

test.py
from robot import run, run_cli # 可以省略属性所在的模块名
run()
run_cli()

等效:
test.py
from robot.run import run, run_cli # 通过包名和模块名直接导入．
run()
run_cli()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在__init__.py定义__all__变量来决定导入哪些属性．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from robot.run import run, run_cli
__all__ = [run, run_cli]

from robot import * # 仅仅导入__all__指定的属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;import导入模块和包&#34;&gt;&lt;em&gt;import导入模块和包&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;如果模块第一次被导入，就会被加载并执行．也就是说模块被加载时顶层的代码会被执行，一般包括全局变量，类和函数的申明．&lt;/p&gt;
&lt;p&gt;一个模块无论被导入(import)多少次，只在第一次导入时被加载一次．除非用reload()函数．&lt;/p&gt;
&lt;p&gt;写代码时候import导入顺序(中间空一格)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准库模块&lt;/li&gt;
&lt;li&gt;第三方库模块&lt;/li&gt;
&lt;li&gt;自定义模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;import关键字导入模块/包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import module
import package
# 包可以多层嵌套
import package.subpackage
import package.subpackage.module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from-import关键字导入模块中的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from module import function/method/variable
from package.module import function/method/variable
from package.subpackage.module import function/method/variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;from-import关键字导入包中的的包/模块到当前的名称空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from package import subpackage
from package...subpackage import sub-subpackage
from package import module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as关键字可以给模块/包/属性取别名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import module/package/package.subpackage as alias
from module/package.module/package.subpackage.module import function/method/variable as alias
from package/package.subpackage import module/subpackage/sub-subpackage alias
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关的内置函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;locals()
global()
[Deprecated] reload() # 推荐用from imp import reload(), 重新导入一个已经导入的模块．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块的特殊属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__name__ # 模块的特殊属性
# 如果模块直接运行，也就是作为top-level脚本运行．值为__main__.
# 如果作为module,也就是(import/python -m)，值为模块名称.
# 一般用来做单元测试.
if __name__ == &amp;quot;__main__&amp;quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pep0328&#34;&gt;&lt;em&gt;PEP0328&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;多行导入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 通过续行符
from module import a, b, c, \
    d, e, f

# 通过分成两行导入
from module import a, b, c
from module import d, e, f

# PEP328建议使用分组导入
from module import (a, b, c,
    d, e, f)

# 不推荐使用模糊导入．
[Deprecated] from module import *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绝对导入：&lt;/p&gt;
&lt;p&gt;默认采用绝对导入，也就是通过完整的包路径来导入，避免和标准库模块冲突．&lt;/p&gt;
&lt;p&gt;默认的包路径就是sys.path或PYTHONPATH.&lt;/p&gt;
&lt;p&gt;只有import没有from的一定是绝对导入．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import package/module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对导入： [TODO]&lt;/p&gt;
&lt;p&gt;小数点开头表示相对导入，一个小数点表示当前的包，两个小数点表示上一层的包，以此类推．&lt;/p&gt;
&lt;p&gt;相对导入一定是import-from结构．&lt;/p&gt;
&lt;p&gt;相对导入的优先级低于绝对导入，也就是先去sys.path中查找，然后根据当前模块的相对位置查找．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from . import package/module
from .foo import bar
from ..foo import bar
from ...foo import bar
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python文档&#34;&gt;&lt;strong&gt;python文档&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;文档注释:&lt;/p&gt;
&lt;p&gt;python的文档注释采用reST风格的注释.&lt;/p&gt;
&lt;p&gt;包/模块文档:&lt;/p&gt;
&lt;p&gt;包括作者,版权,模块的信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
File Summary

Copyright

License

:author:
:version:
:since:

Description
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类/函数/方法文档:&lt;/p&gt;
&lt;p&gt;包括作用,初始化方法参数和类型,函数和方法的参数和类型,返回类型和抛出异常,以及用法用例.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;Summary

:param param1: param1 used for what
:type param1: param1 type
:param param2: param2 used for what
:type param2: param2 type
...
:returns param: return what
:rtype param: return type
...
:raise exceptionname: raise what exception

Usage/Description
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档的特殊属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__doc__ # 函数/类/方法的特殊属性，用来表示文档的属性
# 文档字符串不能被子类继承．
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PSL_Test</title>
        <link>https://canuxcheng.com/post/psl_test/</link>
        <pubDate>Mon, 11 Apr 2016 22:58:13 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/psl_test/</guid>
        <description>&lt;h1 id=&#34;development-tools&#34;&gt;Development Tools&lt;/h1&gt;
&lt;h2 id=&#34;typing&#34;&gt;typing&lt;/h2&gt;
&lt;h2 id=&#34;2to3&#34;&gt;2to3&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$2to3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pydoc&#34;&gt;pydoc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import pydoc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;doctest&#34;&gt;doctest&lt;/h2&gt;
&lt;p&gt;python内置的文档测试库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import doctest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unittest&#34;&gt;unittest&lt;/h2&gt;
&lt;p&gt;python内置的单元测试库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import unittest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tpl&#34;&gt;TPL&lt;/h1&gt;
&lt;p&gt;相关的第三方库&lt;/p&gt;
&lt;h2 id=&#34;unittest2&#34;&gt;unittest2&lt;/h2&gt;
&lt;p&gt;unittest2是unittest的升级版．&lt;/p&gt;
&lt;p&gt;python3集成了unittest2到unittest,像使用unittest一样使用即可．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# python2.7
$pip install unittest2
import unittest2

# python3
import unittest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unittest也叫pyunit，类似于Junit(java)都是基于Kent Beck和Erich Gamma的XUnit框架．&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;OK 表示测试通过&lt;/p&gt;
&lt;p&gt;FAIL 表示测试没有通过，并引发一个AssertionError异常．&lt;/p&gt;
&lt;p&gt;ERROR 表示测试过程引发一个不是AssertionError的异常．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是标准库的unittest.
import unittest
import MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;classes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unittest.TestCase: 每个实例就是一个test case. 使用TestCase.assert* 系列方法进行测试．
unittest.TestSuite: 每个实例就是一个test suite. 多个test case放在一起就是一个test suite.
unittest.TestLoader/unittest.defaultTestLoader: 用来加载TestCase到TestSuite.
unittest.TestResult: 用来保存测试的结果．

unittest.TestProgram/unittest.main(): 搜索该模块下所有test开头的测试用例方法并执行．
fixtures对一个测试用例的环境的搭建和销毁，通过重载TestCase的setUp()和teaeDown()方法．

unittest.TextTestRunner: 用来执行测试用例．
unittest.TextTestResult: 用来打印格式化的测试结果．

# unittest.TestCase
# methods:
assertXXX　系列方法．
failXXX 系列方法
fail(self, msg=None) # test立即失败
addCleanup(self, function, *args, **kwargs)
addTypeEqualityFunc(self, typeobj, function)
countTestCases(self)
debug(self)
defaultTestResult() # return unittest.TestResult()
doCleanups(self)
id(self)
run(self, result=None) # 可以在子类覆盖该方法．
shortDescription(self)
skipTest(self, reason)
setUp(self) # 重写之后，每个case运行之前都会调用一次．
tearDown(self) # 同上

# classmethods:
setUpClass(cls) # 通过@classmethod重写，这样所有的case运行之前只调用一次，而不是每个case运行之前都调用．
tearDownClass(cls) # 同上

# data:
failureException = AssertionError
longMessage = False
maxDiff = 640
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;findTestCases(module, prefix=&#39;test&#39;, sortUsing=&amp;lt;built-in function cmp&amp;gt;, suiteClass=&amp;lt;class &#39;unittest.suite.TestSuite&#39;&amp;gt;)
getTestCaseNames(testCaseClass, prefix, sortUsing=&amp;lt;built-in function cmp&amp;gt;)
installHandler()
makeSuite(testCaseClass, prefix=&#39;test&#39;, sortUsing=&amp;lt;built-in function cmp&amp;gt;, suiteClass=&amp;lt;class &#39;unittest.suite.TestSuite&#39;&amp;gt;)
registerResult(result)
removeHandler(method=None)
removeResult(result)

# unittest.case实现了几个函数用来增强unittest.TestCase的方法, 一般当装饰器用．
expectedFailure(func) # 如果这个case失败了，不计入失败的数目．
# @unittest.expectedFailure
skip(reason) # 无条件跳过一个test case.
skipIf(condition, reason) # condition为true就跳过一个test case.
skipUnless(condition, reason) # 和上面相反
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyClassTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print &#39;Just execute before the first test case start.&#39;

    @classmethod
    def tearDownClass(cls):
        print &#39;Just execute after all test case end.&#39;

    def setUp(self):
        &amp;quot;&amp;quot;&amp;quot;重载setUp进行测试之前的初始化工作.运行每个test_func之前都会运行该方法&amp;quot;&amp;quot;&amp;quot;
        print &amp;quot;start&amp;quot;

    def tearDown(self):
        &amp;quot;&amp;quot;&amp;quot;重载tearDown进行测试结束后的清理工作.结束运行每个test_func之后都会运行该方法&amp;quot;&amp;quot;&amp;quot;
        print &amp;quot;end&amp;quot;

    def test_func(self):
        &amp;quot;&amp;quot;&amp;quot;具体的测试用例，需要用test开头,多个test_func会根据func名字中的数字或字母的顺序来执行，和位置无关.
        不是用test开头的方法默认不会被执行&amp;quot;&amp;quot;&amp;quot;
        self.assertEqual(MyClass.method(args), value, &amp;quot;message&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    unittest.main()

# 自动发现和批量执行testcase/testsuite:
def discover_test_case():
    test_cases = []
    _module = ...
    tests.append(unittest.defaultTestLoader.loadTestsFromModule(_module))
    unittest.defaultTestLoader.discover()
    return tests

def get_test_suite():
    &amp;quot;&amp;quot;&amp;quot;打包一个testsuite.&amp;quot;&amp;quot;&amp;quot;
    return unittest.TestSuite(discover_test_case())

unittest.TextTestRunner
if __name__ == &amp;quot;__main__&amp;quot;:
    runner = unittest.TextTestRunner()
    result = runner.run(get_test_suite())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mock&#34;&gt;mock&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/testing-cabal/mock&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/testing-cabal/mock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python3集成了mock到unittest模块，导入unittest.mock即可．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7
$pip install mock
import mock

# Python3
import unittest.mock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mock就是在测试中对于不容易构造或获取的对象，用一个虚拟的对象来代替以便测试的方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Python2.7 此处用的是第三方库mock
from mock import Mock, patch, PropertyMock, MagicMock
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nose2&#34;&gt;nose2&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nose-devs/nose2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nose-devs/nose2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nose是unittest/unittest2的升级版．&lt;/p&gt;
&lt;p&gt;nose2是nose的升级版．&lt;/p&gt;
&lt;p&gt;nose2用于单元测试．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install nose

import nose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pytest&#34;&gt;pytest&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pytest-dev/pytest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pytest-dev/pytest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pytest用于单元测试．推荐使用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install -U pytest

import pytest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;coverage&#34;&gt;coverage&lt;/h2&gt;
&lt;p&gt;分析单元测试的代码覆盖率&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nedbat/coveragepy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nedbat/coveragepy&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install coverage

# 通过命令进行测试，可以集成到其它工具．
$ coverage run --source=&amp;lt;package-name&amp;gt; setup.py test
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tox&#34;&gt;tox&lt;/h2&gt;
&lt;p&gt;virtualenv management and test command line tool.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tox-dev/tox&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tox-dev/tox&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install tox

# 通过命令进行测试，可以集成unittest, nose2, pytest等工具．
$ tox
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>DevOps</title>
        <link>https://canuxcheng.com/post/python_devops/</link>
        <pubDate>Sun, 03 Apr 2016 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/python_devops/</guid>
        <description>&lt;h1 id=&#34;python&#34;&gt;Python&lt;/h1&gt;
&lt;p&gt;python2的最后一个版本是python2.7, 2020年停止更新.&lt;/p&gt;
&lt;p&gt;Windows安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Python2.7.9之后的版本直接下载msi安装即可．
选择自动设置PATH，默认安装pip和setuptools.
可以使用IDLE或python命令行或cmd执行python命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install python
$sudo yum install python

$sudo apt-get install python-dev
$sudo apt-get install python3-dev
$sudo yum install python-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准库的路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Python*\Lib
/usr/lib/python*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python的IDE：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows: IDLE&lt;/li&gt;
&lt;li&gt;Linux: Vim&lt;/li&gt;
&lt;li&gt;Pycharm/VS&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python命令&#34;&gt;python命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ python/ipython     # 进入python解释器
&amp;gt;&amp;gt;&amp;gt;exit()/Ctrl+d     # 退出python解释器
&amp;gt;&amp;gt;&amp;gt;help()            # 进入help工具
help&amp;gt;quit            # 退出help工具
$ pydoc --help        # 文档工具

# -c　cmd, __name__ != &#39;__main__&#39;
$ python -c &#39;import module/package; expressions&#39;
# -m mod, __name__ == &#39;__main__&#39;
$ python -m &#39;module/package&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的可用接口&#34;&gt;python的可用接口&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;python内置常量，函数，类和异常．&lt;/p&gt;
&lt;p&gt;C/C++实现的，不需要导入就可以使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python标准库&lt;/p&gt;
&lt;p&gt;python实现的，需要导入才能使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python外部库&lt;/p&gt;
&lt;p&gt;需要安装和导入才能使用的。外部库是对python代码的补充。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python框架&lt;/p&gt;
&lt;p&gt;需要安装和导入才能使用的。python代码是对外部库的补充。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python的其它解释器&#34;&gt;python的其它解释器&lt;/h1&gt;
&lt;h2 id=&#34;cpython&#34;&gt;cpython&lt;/h2&gt;
&lt;p&gt;python的默认解释器，安装python即可获得。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/python/cpython&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/python/cpython&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;stackless&#34;&gt;stackless&lt;/h2&gt;
&lt;p&gt;cpython的增强版，支持多线程。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/stackless-dev/stackless&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/stackless-dev/stackless&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pypy&#34;&gt;pypy&lt;/h2&gt;
&lt;p&gt;用python写的python解释器。&lt;/p&gt;
&lt;p&gt;比cpython更快的python。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bitbucket.org/pypy/pypy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bitbucket.org/pypy/pypy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;jpython&#34;&gt;jpython&lt;/h2&gt;
&lt;p&gt;java开发的可以运行在JVM平台的python解释器。&lt;/p&gt;
&lt;h2 id=&#34;ironpython&#34;&gt;ironpython&lt;/h2&gt;
&lt;p&gt;C#开发的可以运行在.net/mono平台的python解释器。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python开发相关的工具&#34;&gt;python开发相关的工具&lt;/h1&gt;
&lt;h2 id=&#34;ipython&#34;&gt;ipython&lt;/h2&gt;
&lt;p&gt;python写的交互式解释器。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ipython/ipython&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ipython/ipython&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip install ipython
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pyenv&#34;&gt;pyenv&lt;/h2&gt;
&lt;p&gt;python的版本管理工具,　用于管理多个pyton版本.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/yyuu/pyenv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/yyuu/pyenv&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;安装第三方库&#34;&gt;安装第三方库&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pypi.python.org/pypi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pypi.python.org/pypi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三方库路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Python*\Lib\site-packages
~/.local/lib/python*/site-packages
/usr/local/lib/python*/dist-packages
/usr/local/lib/python*/site-packages
/usr/lib/python*/dist-packages
/usr/lib/python*/site-packages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$sudo apt-get install python-&amp;lt;packagename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码安装第三方库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd package
$ python setup.py install

# 安装到　~/.local/lib/python*/site-packages
$ python setup.py install --user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;easy_install(setuptools)安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;https://github.com/pypa/setuptools&amp;gt;
easy_install安装egg包,不推荐使用．
setuptools带的工具,从pypi的egg归档格式中安装。
python2.7.9, python3.4, virtualenv自带setuptools.
缺点是不支持卸载。

$sudo apt-get install python-setuptools
$sudo yum install python-setuptools

$ sudo apt-get install python3-setuptools

$ pip install -U setuptools

$sudo -E easy_install packagename[=version] # 安装
$sudo -E easy_install -U packagename[=version] # 升级
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;https://github.com/pypa/pip&amp;gt;
直接从pypi安装wheel格式和sdist格式(也就是tarball)。

$sudo apt-get install python-pip
$sudo apt-get install python-wheel
$sudo yum install python-pip
$sudo yum install python-wheel

$ sudo apt-get install python3-pip
$ sudo apt-get install python3-wheel

$pip install -U pip
$pip install -U wheel
$pip install -U setuptools

$ pip install packagename[==version] # 安装
$ pip install -U packagename[==version] # 升级
$ pip uninstall packagename # 卸载
$ pip install XXX.whl # 安装wheel包

$ pip3 install/uninstall &amp;lt;packagename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pip list
$pip search packagename
$pip freeze &amp;gt; requirements.txt
$pip install -r requirements.txt

$ pip install [options] &amp;lt;requirement specifier&amp;gt; [package-index-options]

$ pip install --target &amp;lt;dir&amp;gt; # 通过target指定安装的具体site-packages路径,不包括scripts/data
$ pip install --prefix &amp;lt;dir&amp;gt; # 通过prefix指定安装的bin, lib等路径，会安装scripts/data等
$ pip install --root &amp;lt;dir&amp;gt; # 会自动创建&amp;lt;dir&amp;gt;/usr/local/bin,&amp;lt;dir&amp;gt;/usr/local/lib来安装
$ pip install --user # 安装到/home/$USER/.local/lib

# 下面是通过源码安装，不能通过whl等二进制安装
$ pip install --install-option=&amp;quot;--&amp;lt;options&amp;gt;&amp;quot; # 通过源码安装，传递参数给python setup.py install
$ pip install --global-option=...

# 一般指定了其它安装路径都需要用-I, 因为如果系统路径已经安装，就不会再安装
$ pip install -I/--ignore-installed # 重新安装, 配合--prefix使用.

# General options:
--log &amp;lt;path&amp;gt;
--timeout &amp;lt;sec&amp;gt;
--trusted-host &amp;lt;hostname&amp;gt;
--cache-dir &amp;lt;dir&amp;gt;
--no-cache-dir
--disable-pip-version-check

# Package index options
-i, --index-url &amp;lt;url&amp;gt;
--extra-index-url &amp;lt;url&amp;gt;
--no-index
-f, --find-links &amp;lt;url&amp;gt;
--process-dependency-links

# 手动修改pip的源
$ sudo vim /etc/pip.conf

[global]
timeout=120
no-cache-dir = false
trusted-host = pypi.douban.com
index-url = http://pypi.douban.com/simple
# index-url = https://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@ip:port/simple

[freeze]
timeout = 10

[install]
ignore-installed = true
no-dependencies = yes
no-compile = no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip-tools&lt;/p&gt;
&lt;p&gt;根据项目中的import导出依赖。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jazzband/pip-tools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jazzband/pip-tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pipreqs&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/bndr/pipreqs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/bndr/pipreqs&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python代码检查&#34;&gt;python代码检查&lt;/h1&gt;
&lt;h2 id=&#34;flake8&#34;&gt;flake8&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/flake8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/flake8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Include: pyflakes, pep8/pycodestyle, McCabe&lt;/p&gt;
&lt;h2 id=&#34;pylama&#34;&gt;pylama&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/klen/pylama&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/klen/pylama&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Include: pyflakes, pylint, pep8/pycodestyle, pep257/pydocstyle, mccabe, radon, ghslint(for js)&lt;/p&gt;
&lt;h2 id=&#34;pep8pycodestyle&#34;&gt;pep8/pycodestyle&lt;/h2&gt;
&lt;p&gt;Simple Python style checker in one Python file.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pycodestyle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pycodestyle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pep257pydocstyle&#34;&gt;pep257/pydocstyle&lt;/h2&gt;
&lt;p&gt;docstring style checker&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pydocstyle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pydocstyle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;jedi&#34;&gt;jedi&lt;/h2&gt;
&lt;p&gt;Awesome autocompletion and static analysis library for python.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/davidhalter/jedi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/davidhalter/jedi&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mccabe&#34;&gt;mccabe&lt;/h2&gt;
&lt;p&gt;McCabe complexity checker for Python&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/mccabe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/mccabe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pyflakes&#34;&gt;pyflakes&lt;/h2&gt;
&lt;p&gt;A simple program which checks Python source files for errors.&lt;/p&gt;
&lt;p&gt;Faster than pylint.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pyflakes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pyflakes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pylint&#34;&gt;pylint&lt;/h2&gt;
&lt;p&gt;A Python source code analyzer which looks for programming errors, helps enforcing a coding standard and sniffs for some code smells&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PyCQA/pylint&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PyCQA/pylint&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$pylint --list-msgs
$pylint --help-msg=C6409
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rope&#34;&gt;rope&lt;/h2&gt;
&lt;p&gt;A python refactoring library&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/python-rope/rope&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/python-rope/rope&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;python项目结构&#34;&gt;python项目结构&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;.
|-- README.rst
|-- LICENSE
|-- AUTHORS.rst
|-- CONTRIBUTING.rst

|-- project    项目源代码目录
    |-- __init__.py 包文件
    |-- &amp;lt;module&amp;gt;.py // 模块名不要和已知的包重名
    ...
|-- docs       用来存放文档
    |-- conf.py
    |-- index.rst
    ...

|-- tests 用来存放测试相关的文件(不能有__init__.py)
|-- examples 用来存放使用本包相关的例子(不能有__init__.py)

|-- bin 用来存放将被setup.py安装的二进制脚本
|-- data 用来存放其它类型文件
|-- etc 用来存放配置文件
|-- tools 用来存放与工具相关shell脚本
|-- scripts 用来存放安装相关的脚本

|-- setup.py 标准安装脚本
|-- setup.cfg
|-- MANIFEST.in

|-- .gitignore
|-- .gitattributes
|-- requirements.txt 依赖的环境
|-- Makefile
|-- fabfile.py
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cicd&#34;&gt;CICD&lt;/h1&gt;
&lt;h2 id=&#34;buildbot&#34;&gt;buildbot&lt;/h2&gt;
&lt;p&gt;Python-based continuous integration testing framework&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/buildbot/buildbot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/buildbot/buildbot&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pybuilder&#34;&gt;pybuilder&lt;/h2&gt;
&lt;p&gt;Continuous build tool for Python.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/pybuilder/pybuilder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pybuilder/pybuilder&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pypi&#34;&gt;pypi&lt;/h1&gt;
&lt;p&gt;创建私有的pypi服务器&lt;/p&gt;
&lt;h2 id=&#34;pypiserver&#34;&gt;pypiserver&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
