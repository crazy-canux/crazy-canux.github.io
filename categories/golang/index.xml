<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Golang on Morgoth</title>
        <link>https://canuxcheng.com/categories/golang/</link>
        <description>Recent content in Golang on Morgoth</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 23 Apr 2019 21:42:07 +0800</lastBuildDate><atom:link href="https://canuxcheng.com/categories/golang/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Package</title>
        <link>https://canuxcheng.com/post/go_package/</link>
        <pubDate>Tue, 23 Apr 2019 21:42:07 +0800</pubDate>
        
        <guid>https://canuxcheng.com/post/go_package/</guid>
        <description></description>
        </item>
        <item>
        <title>Contribution</title>
        <link>https://canuxcheng.com/post/go_oss/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_oss/</guid>
        <description>&lt;h1 id=&#34;golang-contribution&#34;&gt;Golang Contribution&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.dev/doc/contribute&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.dev/doc/contribute&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建google账号&#34;&gt;创建google账号&lt;/h2&gt;
&lt;p&gt;推荐申请一个google邮箱。&lt;/p&gt;
&lt;p&gt;在开发机配置git&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.email name@example.com   
$ git config user.email name@example.com            
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;签cla&#34;&gt;签CLA&lt;/h2&gt;
&lt;p&gt;个人开发者需要签署CLA。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cla.developers.google.com/about/google-individual&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cla.developers.google.com/about/google-individual&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置git认证&#34;&gt;配置git认证&lt;/h2&gt;
&lt;p&gt;点击“Generate Password”， 用google邮箱登陆，根据提示配置git。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.googlesource.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.googlesource.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建gerrit账号&#34;&gt;创建gerrit账号&lt;/h2&gt;
&lt;p&gt;用google邮箱登陆即可。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go-review.googlesource.com/dashboard/self&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装git-codereview&#34;&gt;安装git-codereview&lt;/h2&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/review/git-codereview@latest
$ git --exec-path

&amp;gt; copy git-codereview.exe from GOBIN to Git\mingw64\libexec\git-core

$ git codereview help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux/mac:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/review/git-codereview@latest
$ git codereview help
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选取修改的cl&#34;&gt;选取修改的CL&lt;/h2&gt;
&lt;p&gt;从github选取一个还没有人提交CL(change log/list)的Issue进行修改。&lt;/p&gt;
&lt;p&gt;issue三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NeedsInvestigation&lt;/li&gt;
&lt;li&gt;NeedsDecision&lt;/li&gt;
&lt;li&gt;NeedsFix    选这个里面还没有CL的做&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/issues?q=is%3Aissue&amp;#43;is%3Aopen&amp;#43;label%3ANeedsFix&amp;#43;NOT&amp;#43;%22golang.org%2Fcl%22&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;提交patch&#34;&gt;提交patch&lt;/h2&gt;
&lt;p&gt;支持github或者gerrit提交patch。&lt;/p&gt;
&lt;p&gt;github用户直接fork到自己账号，clone下来即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/golang/go.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gerrit用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://go.googlesource.com/go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建开发分支并修改代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b canux_dev
...
git add -A
git codereview change
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地测试修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./all.bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交修改，github用户直接去github页面提交PR。&lt;/p&gt;
&lt;p&gt;gerrit用户通过命令行提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git codereview mail     # send changes to Gerrit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;commit message格式有严格要求。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/doc/contribute#commit_messages&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://golang.org/doc/contribute#commit_messages&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;code-review&#34;&gt;code review&lt;/h2&gt;
&lt;p&gt;提交之后trybots会自动构建，可以通过build dashboard查看各个平台build结果:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://build.golang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://build.golang.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看自己的patch的review情况：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go-review.googlesource.com/dashboard/self&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Debug</title>
        <link>https://canuxcheng.com/post/go_debug/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_debug/</guid>
        <description>&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;go vet
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;gdb&#34;&gt;gdb&lt;/h1&gt;
&lt;h1 id=&#34;delve&#34;&gt;delve&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/derekparker/delve&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/derekparker/delve&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Devops</title>
        <link>https://canuxcheng.com/post/go_devops/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_devops/</guid>
        <description>&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;
&lt;p&gt;go有三种安装方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码安装&lt;/li&gt;
&lt;li&gt;标准包安装&lt;/li&gt;
&lt;li&gt;第三方工具安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GOROOT:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOROOT 就是go的安装目录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows标准包安装go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msi指定安装路径，自动添加%GOROOT%/bin到环境变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linux标准包安装go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;下载.tar.gz包解压到/usr/local/go
GOROOT=/usr/local/go
export PATH=$PATH:/usr/local/go/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go --help
$ go version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三方工具gvm安装go:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://github.com/moovweb/gvm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gvm install go1.9.2
$ gvm use go1.9.2
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gopath&#34;&gt;GOPATH&lt;/h1&gt;
&lt;p&gt;gopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．&lt;/p&gt;
&lt;p&gt;GOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOPATH=$USERPROFILE%go
GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gopath结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src    存放源码
pkg    编译后的库文件
bin    编译后生成的可执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gopath有多个值时用冒号分开即可.&lt;/p&gt;
&lt;h1 id=&#34;gobin&#34;&gt;GOBIN&lt;/h1&gt;
&lt;p&gt;推荐设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOBIN=$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go get 和 go install 安装的二进制到GOBIN。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go命令&#34;&gt;go命令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ go help [command]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get&lt;/p&gt;
&lt;p&gt;下载并安装包和依赖, 也就是安装第三方的库．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get [...] [packages]

&amp;gt; go get安装第三方包如果出现依赖无法安装，可以通过github下载．
$ cd golang.org/x
$ git clone https://github.com/golang/crypto.git crypto
$ go install golang.org/x/crypto/ssh

go get -u (without any arguments) now only upgrades the direct and indirect dependencies of your current package, and no longer examines your entire module.

go get -u ./... from your module root upgrades all the direct and indirect dependencies of your module, and now excludes test dependencies.

go get -u -t ./... is similar, but also upgrades test dependencies.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;build&lt;/p&gt;
&lt;p&gt;编译包和依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go build [-o output] [-i] [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;install&lt;/p&gt;
&lt;p&gt;编译并安装包和依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go install [build flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run&lt;/p&gt;
&lt;p&gt;编译并运行程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run [...] gofiles... [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fmt&lt;/p&gt;
&lt;p&gt;格式化代码和文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go fmt [...] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vet&lt;/p&gt;
&lt;p&gt;检测代码常见错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go vet [-n] [-x] [build flags] [vet flags] [packages]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test&lt;/p&gt;
&lt;p&gt;测试包:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test [...] [packages] [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;doc&lt;/p&gt;
&lt;p&gt;查看文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go doc [package/symbol]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tool&lt;/p&gt;
&lt;p&gt;运行工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go tool [-n] command [args...]

addr2line

asm

buildid

cgo

// 查看汇编代码
compile
go tool compile -S pkg.go

cover
dist
doc
fix
link
nm
objdump
pack
pprof
test2json
trace
vet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go mod init &amp;lt;name&amp;gt;
go mod tidy // 添加缺少的，删除多余的.
go mod download // 下载包
go mod verify 
go mod edit
go mod graph
go mod why
go mod vendor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过env 设置golang的变量，取代系统环境变量
go env
go env -w GOROOT=&amp;quot;/usr/local/go&amp;quot;
go env -w GOPATH=&amp;quot;$HOME/go&amp;quot;
go env -w GOBIN=&amp;quot;$HOME/go/bin&amp;quot;
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;clean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go clean -cache
go clean -modcache
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;安装第三方包&#34;&gt;安装第三方包&lt;/h1&gt;
&lt;p&gt;go get的功能很有限．&lt;/p&gt;
&lt;p&gt;godep和golide都会被官方的dep取代．&lt;/p&gt;
&lt;h2 id=&#34;depdeprecated&#34;&gt;dep(deprecated)&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/dep&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/dep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无法解决GFW的问题.&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get -u github.com/golang/dep/cmd/dep
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go官方包管理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 初始化一个使用dep管理包的项目，
# 创建Gopkg.toml, Gopkg.lock, vendor/
$ dep init

$ dep status

$ dep prune

$ dep ensure
$ dep ensure -update
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;module&#34;&gt;module&lt;/h2&gt;
&lt;p&gt;vgo已经集成到go1.11&lt;/p&gt;
&lt;p&gt;通过go mod init初始化两个文件.&lt;/p&gt;
&lt;p&gt;go.mod:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module
go
require
exclude
replace

// 使用本地module,或使用指定repo里面的module
replace github.com/crazy-canux/go-devops =&amp;gt; /path/to/local/github.com/crazy-canux/go-devops
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go.sum:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go env -w GOSUMDB=off
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置相关环境变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GO111MODULE:
// auto/on/off
go env -w GO111MODULE=on

GOPROXY:
go env -w GOPROXY=https://goproxy.cn,direct
https://proxy.golang.org //默认值
https://goproxy.cn
https://goproxy.io
https://mirrors.aliyun.com/goproxy/

GOSUMDB:

GOPRIVATE

GONOPROXY

GONOSUMDB
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;项目结构&#34;&gt;项目结构&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cmd: 可执行文件入口
pkg: 核心代码库
api: api的spec, openapi/swagger/json/protocol/grpc
hack: 构建/测试相关脚本
plugin: 插件
staging: wip
third_party: 第三方工具/代码
vendor: 项目依赖
build
test
docs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有子目录包结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go-devops
    |- README.md
    |- doc.go
    |- grafana.go
    |- grafana_test.go
    ...

import &amp;quot;go-devops&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有子目录的包结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go-devops
    |- README.md
    |- doc.go // package go_devops
    |- grafana
       |- doc.go // package grafana
       |- grafana.go
       |- grafana_test.go

import &amp;quot;go-devops/grafana&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;proxy&#34;&gt;proxy&lt;/h1&gt;
&lt;p&gt;goproxy.io&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/goproxyio/goproxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goproxyio/goproxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;goproxy.cn&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/goproxy/goproxy.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/goproxy/goproxy.cn&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Document</title>
        <link>https://canuxcheng.com/post/go_document/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_document/</guid>
        <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;
&lt;p&gt;go文档相关&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://godoc.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godoc.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go文档的两种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go doc&lt;/li&gt;
&lt;li&gt;godoc&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;go-doc&#34;&gt;go doc&lt;/h1&gt;
&lt;p&gt;直接在命令行查看文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go doc [package/symbol]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;godoc&#34;&gt;godoc&lt;/h1&gt;
&lt;p&gt;go自带的文档命令行接口,在浏览器查看文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;godoc package [name ...]
godoc -http=:6060
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过github的项目文档在:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://godoc.org
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;godev&#34;&gt;go.dev&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pkg.go.dev&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go</title>
        <link>https://canuxcheng.com/post/go/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go/</guid>
        <description>&lt;h1 id=&#34;go概述&#34;&gt;Go概述&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://golang.org/ref/spec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go语言表达能力强，简洁，清晰，高效．&lt;/p&gt;
&lt;p&gt;go是一个快速的，静态的，强类型的，编译型语言．&lt;/p&gt;
&lt;p&gt;go具有高并发和垃圾回收功能.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go基本语法&#34;&gt;Go基本语法&lt;/h1&gt;
&lt;p&gt;go源程序叫*.go&lt;/p&gt;
&lt;p&gt;go大小写敏感&lt;/p&gt;
&lt;p&gt;go程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．&lt;/p&gt;
&lt;p&gt;go中只有首字母大写的名称才能从包中导出．&lt;/p&gt;
&lt;p&gt;go的类型在变量名后面．&lt;/p&gt;
&lt;p&gt;go函数外的每个语句都必须以关键字开始.&lt;/p&gt;
&lt;p&gt;go标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.&lt;/p&gt;
&lt;p&gt;go使用大括号{}表示一个代码块.&lt;/p&gt;
&lt;p&gt;go使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．&lt;/p&gt;
&lt;p&gt;go的包名一般是小写的单个单词(文件所在的最后一层目录名).&lt;/p&gt;
&lt;p&gt;go一般使用驼峰命名法.&lt;/p&gt;
&lt;p&gt;go没有逗号操作符.&lt;/p&gt;
&lt;p&gt;go中++/&amp;ndash;是语句不是表达式．&lt;/p&gt;
&lt;p&gt;go中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go注释&#34;&gt;Go注释&lt;/h1&gt;
&lt;p&gt;单行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// comment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行注释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* comment */
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go关键字&#34;&gt;Go关键字&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var const 
break continue for if else switch case default goto fallthrough
func return defer
package import
range type struct map
interface
select go chan
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go运算符和优先级&#34;&gt;Go运算符和优先级&lt;/h1&gt;
&lt;p&gt;go中的运算都是从左到右结合．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^    #
!    # 逻辑非

*
/    # 结果取整数
%
&amp;lt;&amp;lt;   # 位运算，左移
&amp;gt;&amp;gt;   # 位运算，右移
&amp;amp;    # 位运算，　按位与
&amp;amp;^   #

+
-
|    # 位运算,按位或
^    # 位运算,按位异或

==
!=
&amp;lt;
&amp;lt;=
&amp;gt;
&amp;gt;=

&amp;lt;- # chan运算符

&amp;amp;&amp;amp;   # 逻辑与
||   # 逻辑或
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go数据类型&#34;&gt;Go数据类型&lt;/h1&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;p&gt;定义/申明变量:&lt;/p&gt;
&lt;p&gt;通过关键字var在包或函数中申明/定义变量&lt;/p&gt;
&lt;p&gt;在函数或块中定义的变量作用域就是当前函数或当前块。&lt;/p&gt;
&lt;p&gt;在函数外部定义的全局变量作用域是整个包.&lt;/p&gt;
&lt;p&gt;大写字母开头的全局变量能被其它包引用。&lt;/p&gt;
&lt;p&gt;全局变量必须使用var关键字．&lt;/p&gt;
&lt;p&gt;没有初始化的变量在申明的时候赋予零值.&lt;/p&gt;
&lt;p&gt;已经申明但没有使用的变量在编译时会报错．&lt;/p&gt;
&lt;p&gt;通过等号给变量赋值就是定义变量.&lt;/p&gt;
&lt;p&gt;大写字母开头的变量是public, 小写字母开头的是private变量.&lt;/p&gt;
&lt;p&gt;申明变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一个变量一种类型
var varname Type

# 多个变量一种类型
var varname varname1 ... Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义(初始化)变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 定义的时候初始化
var i, j int = 1, 2
# 初始化使用表达式可以省略类型，从值中获取类型
var i, j = true, &amp;quot;str&amp;quot;

# 多个变量多种类型
var (
    var1 Type1 = val1
    var2 Type2 = val2
    # 给类型取别名
    variable alias Type = value
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特殊变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_  # 下划线是个特殊变量名，用于忽略一个值.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;
&lt;p&gt;定义常量：&lt;/p&gt;
&lt;p&gt;通过关键字const在包或函数中定义常量．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 常量可以是bool, string, 数值
const Pi float = 3.14
const World = &amp;quot;China&amp;quot;
const Truth = true
# 定义多个常量
const (
    Pi = 3.14
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;枚举:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# iota内置常量用来统计枚举中的行数
const (
    con = val
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量不能用:=语法来申明。&lt;/p&gt;
&lt;h2 id=&#34;bool&#34;&gt;bool&lt;/h2&gt;
&lt;p&gt;bool类型变量的零值是false.&lt;/p&gt;
&lt;p&gt;bool类型是值传递．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;true
false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数值类型&#34;&gt;数值类型&lt;/h2&gt;
&lt;p&gt;数值类型变量的零值是0.&lt;/p&gt;
&lt;p&gt;数值类型是值传递.&lt;/p&gt;
&lt;p&gt;有符号类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int int8 int16 int32(rune) int64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无符号类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uint uint8(byte) uint16 uint32 uint64 uintptr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;int, uint, uintptr 在32位系统是32bit, 在64位系统是64bit&lt;/p&gt;
&lt;p&gt;浮点类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float32
float64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;complex64
complex128
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;p&gt;string类型变量的零值是&amp;quot;&amp;quot;.&lt;/p&gt;
&lt;p&gt;string类型是值传递.&lt;/p&gt;
&lt;p&gt;go中的字符串都采用utf-8编码.&lt;/p&gt;
&lt;p&gt;go中的字符串用双引号  或者　反引号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 单行字符串
var str string = &amp;quot;hello&amp;quot;
# 多行字符串(原样输出)
var str string = `hello
                 world`

var str = &amp;quot;hello&amp;quot; // 类型可以通过值确定
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go中的字符串是不可变的, 修改字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用类型转换
var str string = &amp;quot;hello&amp;quot;
c := []byte(str) # str转换成 []byte 类型
c[index] = value # 重新赋值
newString := string(c) # []byte 转换成 string

# 使用索引运算
s := &amp;quot;hello&amp;quot;
s = &amp;quot;str&amp;quot; + s[1:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s1 := &amp;quot;hello&amp;quot;
s2 := &amp;quot;world&amp;quot;
s3 := s1 + s2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for index, value := range s {...}
for index := range s {...}
for _, value := range s {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结构体struct&#34;&gt;结构体/struct&lt;/h2&gt;
&lt;p&gt;结构体就是字段的集合．结构体字段通过点操作符来访问．&lt;/p&gt;
&lt;p&gt;结构体是值传递.&lt;/p&gt;
&lt;p&gt;申明一个结构体类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type StructName struct {
    var Type
    var1 Type1
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明多个结构体类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type (
    StructB struct {
        ...
    }

    StructB struct {
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明一个结构体类型的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s StructName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义结构体变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 列出全部字段
var s = StructName{val, ...}
s := StructName{val, ...}

# 使用val: 可以仅列出部分字段, 未列出的字段使用默认值
var s = StructName{
    var: val,
    ...
}
s := StructName{
    var: val,
    ...
}

# 给字段赋值
s.var1 = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构体指针:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type StructName struct {
    var Type
    var1 Type1
}

var s = &amp;amp;StructName{}
s := &amp;amp;StructName{}

(*s).Var1 = val1
s.Var1 = val1 // go允许隐士间接引用

s := StructName{val, val1}
p := &amp;amp;s
# 原本应该通过(*p).var来访问，go允许隐式间接引用．
p.var = p.var1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;指针pointer&#34;&gt;指针/pointer&lt;/h2&gt;
&lt;p&gt;指针的零值为nil.&lt;/p&gt;
&lt;p&gt;go的指针保存了值的内存地址, go没有指针运算．&lt;/p&gt;
&lt;p&gt;通过指针实现引用传递.&lt;/p&gt;
&lt;p&gt;申明一个指针变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var point *int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;amp;操作符会生成一个指向其操作数的指针(保存变量的地址)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;point = &amp;amp;variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*操作符表示指针指向的数值(读写该地址保存的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*point = value
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数组array&#34;&gt;数组/array&lt;/h2&gt;
&lt;p&gt;数组通过下标来访问．数组不能改变大小（长度）&lt;/p&gt;
&lt;p&gt;数组是值传递．&lt;/p&gt;
&lt;p&gt;数组的属性有类型和长度,只有长度和类型都相同的才是同类型数组,才能相互赋值.&lt;/p&gt;
&lt;p&gt;数组长度和容量相同．&lt;/p&gt;
&lt;p&gt;申明数组:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ArrayName [number]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ArrayName = [number]Type{}

ArrayName := [number]Type{val, val1, ...}
ArrayName := [number]Type{index: value, ...} // 给指定索引赋值,其余为零值
ArrayName := []Type{val, ...} // 容量也可以由初始化的元素个数决定.

ArrayName := [number]*Type{0: new(int), 1: new(string), ...} // 指针数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组元素赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayName[0] = val

*ArrayName[0] = val // 指针数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组赋值（值传递）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 只有类型和长度相同的数组才能赋值
# 非指针数组赋值，会另外开辟地址空间.
 # 修改newArray的值，不会改变ArrayName的值
 newArray = ArrayName

# 指针类型的数组赋值，指向的是相同的地址.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多维数组(嵌套数组):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6 7, 8}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for index, value := range a {
    fmt.Println(&#39;%d, %d\n&#39;, index, value)
}

# 只要索引, 去掉,value即可
for index := range a {...}
# 只要值，用_忽略索引
for _, value := range a {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切片slice&#34;&gt;切片/slice&lt;/h2&gt;
&lt;p&gt;切片的零值是nil, nil切片的长度和容量都是０，且没有底层数组．&lt;/p&gt;
&lt;p&gt;切片传递的是地址(引用传递),修改切片的元素值其实就是修改底层数组的对应的元素的值,共享该元素的其它切片的值也相应改变．&lt;/p&gt;
&lt;p&gt;切片的属性包括指向底层数组的指针，切片的长度，切片的容量.&lt;/p&gt;
&lt;p&gt;切片不存储数据，只是描述数组的一段,因此切片不指定大小（长度）.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 表示切片类型
[]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申明切片:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var SliceName []Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 通过字面量定义
var SliceName = []Type{}
SliceName := []Type{val, val1, ...}

SliceName := []Type{index: value}   // 索引就表示长度和容量

// 通过make函数创建切片
var SliceName = make([]type, len, cap)
SliceName := make([]Type, len, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过切片定义新切片:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;切片的操作返回新的切片。
NewS := SName[i:j]
cap(SName) = k
NewS 长度和容量：
len = j-i
cap = k-i
NewS 无法访问指向的底层数组第一个元素之前的元素。
也不能访问超出长度之后的索引,但是可以通过append增加切片长度之后访问.
NewS[index] //当index &amp;gt;= j编译器报错 ，超出了NewS 的长度，无法访问。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三索引操作:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NewS := SName[i:j:k]
三索引表示容量， i:j 表示长度， i:k 表示容量.
容量不能超过可用容量(也就是SName的容量).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切片操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 半开区间，不包括最后一个下标
s[low:high]
s[:high] // low=0, default
s[low:] // high=max, default
s[:] // s[0:max], default

s[:0] // 把切片的长度变为０（清空切片)
s[:4] // 扩展为４
s[2:] // 扩展为 arrayname[2:4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二维切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[][]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 切片遍历和数组相同
for index, value := range s {
    ...
}
for index := range s {...}
for _, value := range s {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;slice作为函数参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;切片作为函数参数，传递的其实是值,函数会使用和切片相同的底层数组创建一个新的切片来操作.
所以函数内部修改了切片的值,作为参数的切片的值也被修改了.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;映射map&#34;&gt;映射/map&lt;/h2&gt;
&lt;p&gt;映射的零值是nil, 既没有键，也不能添加键．&lt;/p&gt;
&lt;p&gt;map是引用传递．是存储键值对的无序集合.&lt;/p&gt;
&lt;p&gt;map是无序的，只能通过key索引，没有下标操作.&lt;/p&gt;
&lt;p&gt;map的key需要支持==或!= 运算，不能是函数，映射，切片&lt;/p&gt;
&lt;p&gt;申明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 申明值为nil的空映射，不能用于存储键值对.
var MapName map[keyType]ValueType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var MapName = map[keyType]ValueType{}
var MapName = map[keyType]ValueType{
    key: value,
    ...
}

MapName := map[keyType]valueType{}
MapName := map[KeyType]ValueType{
    &amp;quot;key&amp;quot;: value,
    ...
}

# 通过make定义map
var MapName = make(map[keyType]ValueType, cap)
MapName := make(map[keyType]ValueType, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m[key] = value

value = m[key]
# 若key在m中ok为true, 否则为false, 且value是对应类型的零值
value, ok := m[key]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历映射：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for key, value := range m {...}
for key := range m {...}
for _, value := range m {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map作为函数参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不会创建该映射的副本，该函数对映射的修改就是对原始参数指向的映射的修改.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;go中兼容的类型才能转换，而且必须显示转换．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ValueA [:]= TypeA(ValueB)

floatA := float64(uint64Var)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;值传递pass by value：bool, number, string, struct, array, interface&lt;/p&gt;
&lt;p&gt;引用传递pass by reference： slice, map, function, channel&lt;/p&gt;
&lt;p&gt;zero value:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struct, array 取决于元素类型&lt;/li&gt;
&lt;li&gt;pointer, slice, map, channel, function, interface: nil&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;amp;:  address of operator,  used to get memory address. 地址操作。
*:  dereference or pointer type. 解引用 或 指针类型。&lt;/p&gt;
&lt;p&gt;explicit(显式) is better than implicit（隐式）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go控制流&#34;&gt;Go控制流&lt;/h1&gt;
&lt;p&gt;go控制流的左大括号不能另起一行．&lt;/p&gt;
&lt;p&gt;golang没有内置的while循环。&lt;/p&gt;
&lt;h2 id=&#34;for循环&#34;&gt;for循环&lt;/h2&gt;
&lt;p&gt;go只有for可以循环．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; 10; i++ {
    sum += i
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环有三种模式：&lt;/p&gt;
&lt;p&gt;for循环后面没有小括号，代码块必须要大括号．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for init; condition; statement {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for循环的初始化语句init和后置语句statement可以省略,相当于while．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for condition {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无限循环, 相当于for(;;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;if条件语句&#34;&gt;if条件语句&lt;/h2&gt;
&lt;p&gt;if后面的小括号不要，但是代码块需要大括号．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition {
    ...
} else if condition {
    ...
} else {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;switch条件语句&#34;&gt;switch条件语句&lt;/h2&gt;
&lt;p&gt;go中的switch-case的variable无需为常量，且取值可以不是整数．&lt;/p&gt;
&lt;p&gt;go中的只执行匹配的case，相当于默认在每个case后面加了break语句．&lt;/p&gt;
&lt;p&gt;case匹配到的语句如果只有一行可以和case语句写在同一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
case value1:
    ...
case value2: expression
default:
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个条件可以放到一个case:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
    case value1, value2, ...: expression
    case valuen: fallthrough
    defalut:
        ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有条件的switch-case&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch {
case condition:
    ...
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不需要默认的break,需要添加fallthrough:&lt;/p&gt;
&lt;p&gt;fallthrough不会判断后面的case的condition,而是直接执行后面所有的case.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch variable {
case val1:
    ...
    fallthrough
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;label&#34;&gt;label&lt;/h2&gt;
&lt;p&gt;golang的label不需要缩进:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LabelName:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;break&#34;&gt;break&lt;/h2&gt;
&lt;p&gt;break用于跳出for/switch/select循环.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;break也支持label:&lt;/p&gt;
&lt;p&gt;break的label可以跳出外层循环.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break [tag]

label:
for i := 0; i &amp;lt; 1000; i++ {
    for j :=0; j &amp;lt; 1000; j++ {
        if j &amp;lt; i {
            break label // 跳出最外层循环.
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;continue&#34;&gt;continue&lt;/h2&gt;
&lt;p&gt;continue语句只能在for循环中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;continue也支持label:&lt;/p&gt;
&lt;p&gt;continue的label可以从外层循环继续执行.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;continue [tag]

next:
for outer := 2; outer &amp;lt; 3000; outer++ {
    for inner :=2; inner &amp;lt; outer; inner++ {
        if outer%inner == 0 {
            continue next // 并非继续内存循环，而是从外层循环继续执行.
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;goto&#34;&gt;goto&lt;/h2&gt;
&lt;p&gt;goto跳转语句，跳转到指定标签运行．&lt;/p&gt;
&lt;p&gt;标签区分大小写.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Label:
    expression

...
goto Label
continue LABEL
break LABEL
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go函数&#34;&gt;Go函数&lt;/h1&gt;
&lt;p&gt;函数的零值是nil.&lt;/p&gt;
&lt;p&gt;函数是引用类型.&lt;/p&gt;
&lt;p&gt;大写字母开头的函数是public, 小写字母开头的是private.&lt;/p&gt;
&lt;p&gt;创建函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var Type, var1 Type1) rType {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多值返回：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var Type) (rType, rType1, ...) {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命名返回值(必须用括号)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 一般return后面不带返回值，否则需要返回定义的所有变量
func FuncName(var Type) (rvar rType, rvar1 rType) {
    ...
    rvar = ...
    rvar1 = ...
    return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个变量类型相同时保留最后一个的类型即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(var, var1 Type) (rvar, rvar1 rType) {
    ...
    return ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量作用域：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数内部定义的变量是局部变量
函数外定义的变量是全局变量．
局部变量优先使用．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;形式参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;形式参数的作用域范围和函数体中的局部变量一致．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数返回值的作用域范围和函数体中的局部变量一致．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实际参数可以是值传递，也可以是引用传递．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 实参必须是指针才能调用该函数
func FuncName(v *Type) rType {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数中短变量申明(局部变量):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在函数内部，明确值的类型的情况下可以用 := 代替var关键字定义变量
func FuncName() {
    variable := value
    var1, var2, ... := val1, val2, ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重复申明短变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本次申明与已申明的变量在同一作用域．
在初始化中与已申明的变量类型相同才能赋值．
本次申明中至少另有一个变量是新申明的．
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;defer关键字：&lt;/p&gt;
&lt;p&gt;defer会将函数推迟到外层函数返回之后执行.&lt;/p&gt;
&lt;p&gt;推迟调用的函数其参数会立即求值，然后压入defer栈中,外层函数返回后按照后进先出的顺序调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncOut() {
    ...
    defer FuncName()
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数也是值，也可以传递，可以用作函数的参数或返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(variable func(Type, ...) rType) rType {
    ...
}

FuncName := func(variable Type, ...) rType {
    ..
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匿名函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func(&amp;lt;arguments&amp;gt;) (returns) {}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(vars ...Type) rType {}
FuncName(vars..)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;closures/闭包:&lt;/p&gt;
&lt;p&gt;init函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 每个包中可以有任意个init函数.
# 这些init函数会在main函数执行之前调用.
# init函数不能有参数和返回值
# main中的init最后调用.
func init() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go文件和输入输出&#34;&gt;Go文件和输入输出&lt;/h1&gt;
&lt;p&gt;go的标准库fmt实现了类似于C语言的printf和scanf格式化I/O函数.&lt;/p&gt;
&lt;p&gt;还有io和bufio标准库可用&lt;/p&gt;
&lt;h2 id=&#34;输入&#34;&gt;输入&lt;/h2&gt;
&lt;p&gt;输入的本质就是从Stdin读取&lt;/p&gt;
&lt;p&gt;fmt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var input string
fmt.Scan*(&amp;amp;input)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Reader:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inputReader := bufio.NewReader(os.Stdin)
inputReader.Read*()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输出&#34;&gt;输出&lt;/h2&gt;
&lt;p&gt;输出的本质就是往os.Stdout写&lt;/p&gt;
&lt;p&gt;fmt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Print*()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;os.File:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os.Stdout.Write*(&amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bufio.Writer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;outputWriter := bufio.NewWriter(os.Stdout)
outputWriter.Writer*()
outputWriter.Flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;p&gt;标准库os.File结构的指针用来表示文件句柄&lt;/p&gt;
&lt;p&gt;标准库bufio提供了带缓冲的操作&lt;/p&gt;
&lt;p&gt;读文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;readFile, err := os.Open(&amp;quot;filename&amp;quot;)
readFile.Read*()

inputReader := bufio.NewReader(readFile)
inputReader.Read*(&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writeFile, err := os.Create(&amp;quot;filename&amp;quot;)
writeFile.Write*()

outputWriter := bufio.NewWriter(outputFile)
outputWriter.Write*(&amp;quot;string&amp;quot;)
outputWriter.Flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go包&#34;&gt;Go包&lt;/h1&gt;
&lt;p&gt;创建包：&lt;/p&gt;
&lt;p&gt;包名一般和所在路径的最后一层目录一致．一般是小写的单个单词.&lt;/p&gt;
&lt;p&gt;同一个目录中的代码文件使用同一个包名．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package pkg1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单个导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;pkg1&amp;quot;
import &amp;quot;pkg2&amp;quot;
# 导入时创建别名
import alias &amp;quot;pkg&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组合导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    &amp;quot;pkg1&amp;quot;
    &amp;quot;pkg2&amp;quot;
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包内的函数名首字母大些才能被其它包导入，否则就是私有的．&lt;/p&gt;
&lt;p&gt;命名导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    alias &amp;quot;pkg&amp;quot; # 给包取别名
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入副作用：&lt;/p&gt;
&lt;p&gt;只执行导入包中的init函数并初始化全局变量，不导入其它内容．&lt;/p&gt;
&lt;p&gt;编译时不检查该导入是否使用.也不能通过包名调用其中的导出函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import _ &amp;quot;path/pkg&amp;quot;

import (
    _ &amp;quot;path/pkg&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go包查找顺序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$GOROOT/src/... # 安装golang的路径里面的标准库
$GOPATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发时候推荐的书写顺序:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;第三方包&lt;/li&gt;
&lt;li&gt;本地包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go包的编译器导入顺序：按照依赖关系拓扑排序topological sort.&lt;/p&gt;
&lt;p&gt;编译器导入规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先加载被依赖的包&lt;/li&gt;
&lt;li&gt;避免重复加载&lt;/li&gt;
&lt;li&gt;包之间有依赖关系的，根据依赖图顺序加载&lt;/li&gt;
&lt;li&gt;所有包在init()调用前完成初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go文档&#34;&gt;Go文档&lt;/h1&gt;
&lt;p&gt;通过注释编写文档，godoc会自动识别．对包，函数，类型，全局变量都可以.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// this is documents
func Fucntion() {}

/*
    This is documents
*/
type St struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以给包写一段文字较多的文档，通过在包内创建doc.go.&lt;/p&gt;
&lt;p&gt;这段文档会显示在所有其它文档之前．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim doc.go
/*
    This docs for package
    ...
*/
package pkg # 使用和包一样的名字.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go-runtime&#34;&gt;Go runtime&lt;/h1&gt;
&lt;h2 id=&#34;调度器&#34;&gt;调度器&lt;/h2&gt;
&lt;p&gt;GMP模型&lt;/p&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;p&gt;mcache: 每个p的本地缓存
mcentral：全局中心缓存
mheap：操作系内存管理&lt;/p&gt;
&lt;h2 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;GOGC
GOMEMLIMIT&lt;/p&gt;
&lt;p&gt;三色标记清除算法进行垃圾收集Tricolor Mark-and-Sweep&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色: 未访问，可能是垃圾&lt;/li&gt;
&lt;li&gt;灰色：已被访问，但子对象没有扫描&lt;/li&gt;
&lt;li&gt;黑色：已被访问，子对象处理完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GC四个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;STW（stop the world）起始阶段：暂停所有goroutine，做初始标记。&lt;/li&gt;
&lt;li&gt;concurrent mark并发标记：并发追踪所有可达对象。&lt;/li&gt;
&lt;li&gt;concurrent sweep并发清除：并发释放不可达对象的内存。&lt;/li&gt;
&lt;li&gt;STW终止阶段：做最后同步和收尾工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;网络轮询器netpoller&#34;&gt;网络轮询器netpoller&lt;/h2&gt;
&lt;h2 id=&#34;系统监控sysmon&#34;&gt;系统监控Sysmon&lt;/h2&gt;
&lt;h2 id=&#34;栈管理&#34;&gt;栈管理&lt;/h2&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;go的标准库errors实现了用于错误处理的函数.&lt;/p&gt;
&lt;p&gt;内置函数panic是断言函数，会触发一个异常，用于终止当前的线程(会在defer执行完之后终止线程)&lt;/p&gt;
&lt;p&gt;内置接口定义了error接口类型, error类型都有一个Error方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var errName error = errors.New(&amp;quot;error message.&amp;quot;)

err := errors.New(&amp;quot;error message.&amp;quot;)

err := fmt.Errorf(format string, a ...interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;panic:&lt;/p&gt;
&lt;p&gt;相当于抛出一个异常，在运行完defer之后,返回到调用者继续运行defer，直到最外层的defer执行完毕，终止程序.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;panic(v interface{})
panic(&amp;quot;ERROR: command not found&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;recover:&lt;/p&gt;
&lt;p&gt;只能用于defer修饰的函数，用于接收panic调用中传递过来的错误值,没有panic返回nil.&lt;/p&gt;
&lt;p&gt;当前函数的后面不会被执行，recover捕获异常之后会返回到调用者继续执行.&lt;/p&gt;
&lt;p&gt;相当于catch一个异常.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;recover() interface{}
defer func() {
    if err := recover(); err != nil {
        fmt.Println(e)
        // &amp;quot;ERROR: command not found&amp;quot;
    }
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在包内部，总是应该从panic中recover．&lt;/li&gt;
&lt;li&gt;总是向包的调用者返回错误值，而不是panic.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反射与接口&#34;&gt;反射与接口&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Go_Concurrency</title>
        <link>https://canuxcheng.com/post/go_concurrency/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_concurrency/</guid>
        <description>&lt;h1 id=&#34;并发concurrency&#34;&gt;并发/concurrency&lt;/h1&gt;
&lt;p&gt;传统并发基于线程，golang基于CSP&lt;/p&gt;
&lt;p&gt;CSP: communicating sequential processes, 通信顺序进程。&lt;/p&gt;
&lt;p&gt;go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.&lt;/p&gt;
&lt;p&gt;concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。&lt;/p&gt;
&lt;p&gt;所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.&lt;/p&gt;
&lt;p&gt;parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。&lt;/p&gt;
&lt;p&gt;process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。&lt;/p&gt;
&lt;p&gt;thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。&lt;/p&gt;
&lt;p&gt;co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。&lt;/p&gt;
&lt;p&gt;goroutine: go语言的协程，是并行的，通过channel来通信.&lt;/p&gt;
&lt;p&gt;GMP: goroutine的实现模型。&lt;/p&gt;
&lt;p&gt;G: goroutine, 初始栈2kb，够过go关键字创建，包含grunable, grunning, gwaiting三种状态。&lt;/p&gt;
&lt;p&gt;M: machine，对应OS线程，与cpu绑定，golang默认10000个，SetMaxThreads可以设置，需要绑定P才能执行G，否则休眠。&lt;/p&gt;
&lt;p&gt;P: processor, 逻辑处理器，管理G的本地队列和调度上下文。由GOMAXPROCS确定个数(默认cpu核个数)。用来 解决GM的锁竞争问题。&lt;/p&gt;
&lt;p&gt;不要通过共享内存通信，通过通信来共享内存。&lt;/p&gt;
&lt;h2 id=&#34;goroutines&#34;&gt;goroutines&lt;/h2&gt;
&lt;p&gt;go关键字会启动一个新的goroutine并执行.&lt;/p&gt;
&lt;p&gt;每个goroutine会绑定到一个逻辑处理器P上运行，每个逻辑处理器会绑定到单个操作系统线程。&lt;/p&gt;
&lt;p&gt;当goroutine阻塞，就会把goroutine和machine从逻辑处理器P上分离，然后创建一个新的machine绑定到该逻辑处理器P，并继续运行队列中的其它goroutine.&lt;/p&gt;
&lt;p&gt;当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的machine也会保存下来.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go FuncName(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主进程main结束了，goroutine也结束．&lt;/p&gt;
&lt;h2 id=&#34;竟态&#34;&gt;竟态&lt;/h2&gt;
&lt;p&gt;race condition: 竞争状态，多个goroutine同时操作同一资源.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 检测竞争状态
$ go build -race
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以要解决goroutine间的通信和同步的问题.&lt;/p&gt;
&lt;p&gt;通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。&lt;/p&gt;
&lt;p&gt;channel还是mutex,选择的依据是他们的能力/特性.&lt;/p&gt;
&lt;p&gt;channel的能力是让数据流动起来，擅长的是数据流动的场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递数据的所有权，即把某个数据发送给其他协程&lt;/li&gt;
&lt;li&gt;分发任务，每个任务都是一个数据&lt;/li&gt;
&lt;li&gt;交流异步结果，结果是一个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;状态&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;p&gt;goroutine通过channel来通信和同步。&lt;/p&gt;
&lt;p&gt;channels是引用类型,chan是线程安全的，并且不会有数据冲突。&lt;/p&gt;
&lt;p&gt;chan通过make来创建，通过close来关闭．chan是先进先出的FIFO.&lt;/p&gt;
&lt;p&gt;chan 支持的类型Type： 基本类型（number, string, bool），复合类型（pointer, struct, array, slice, map, function, interface），自定义类型.&lt;/p&gt;
&lt;p&gt;chan的Type不能是channel本身。&lt;/p&gt;
&lt;p&gt;申明一个变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ChanName chan Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个chan, 默认chan都是双向的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ch = make(chan Type, cap)
ch := make(chan Type, cap)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chan的方向：&lt;/p&gt;
&lt;p&gt;将make创建的双向转换为单向,也可以直接在函数参数申明单向。&lt;/p&gt;
&lt;p&gt;只接收的chan无法关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var recvOnly chan&amp;lt;- Type = ch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只发送的chan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var sendOnly &amp;lt;-chan Type = ch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;操作chan:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch &amp;lt;- v    # 发送值到ch
v := &amp;lt;-ch    # 从ch接收值, 并赋予Type类型变量v
v, ok = &amp;lt;-ch # 从ch接收值带状态, 如果ch关闭或没有数据，ok就为false.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无缓冲的chan(同步):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无缓冲的chan发送者会阻塞unbuffered，直到接收者接收数据, 也就是说是同步的synchronous.&lt;/p&gt;
&lt;p&gt;只有发送者或只有接受者的chan会导致死锁，产生panic.&lt;/p&gt;
&lt;p&gt;带缓冲的chan（异步）:&lt;/p&gt;
&lt;p&gt;带缓冲的chan，在缓冲区满之前，都不会阻塞buffered，是异步的asynchronous.&lt;/p&gt;
&lt;p&gt;只有通道中没有要接收的值，接收动作才会阻塞.&lt;/p&gt;
&lt;p&gt;只有在通道没有可用缓冲区容纳被发送的值，发送动作才会阻塞．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan Type, cap)

// 带缓冲的chan可以通过range遍历
for val := range ch {
    fmt.Println(val)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示关闭chan:&lt;/p&gt;
&lt;p&gt;通道关闭后，不能再向通道发送值，但是已经发送的值可以被接收.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 一般在生产者(发送动作)关闭chan
close(ch)

// 如果chan关闭ok=false, v为零值.
v, ok := &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;监听chan的数据流，类似于switch-case, 可用于处理多个chan的情况&lt;/p&gt;
&lt;p&gt;运行规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每次执行select都只会执行一个case或者执行default；当有case可以执行，default不会执行；没有case执行时才执行default。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当没有case或default可以执行，select阻塞等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有多个case可以执行，select随机选择一个执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;case后面必须是读或写chan的操作，否则编译出错。&lt;/p&gt;
&lt;p&gt;ctx, cancel := context.WithCancel(context.Background())
select {
case var := &amp;lt;-ch1:
do something
case ch2 &amp;lt;-value:
do something
case &amp;lt;-time.After(2 * time.Second):
fmt.Println(&amp;ldquo;timeout!&amp;rdquo;)
case &amp;lt;-ctx.Done():
fmt.Println(&amp;ldquo;cancelled:&amp;rdquo;, ctx.Err())
&amp;hellip;
default:    // default可以省略
do default thing.
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;退出goroutine&#34;&gt;退出goroutine&lt;/h2&gt;
&lt;h3 id=&#34;for-range&#34;&gt;for-range&lt;/h3&gt;
&lt;p&gt;range能感知channel关闭，当channel被发送数据的goroutine关闭时，range就会结束，然后退出for循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func(send &amp;lt;-chan int) {
    for val := range send {
        ...
    }
}(sendOnly)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;for-select&#34;&gt;for-select&lt;/h3&gt;
&lt;p&gt;select有多路复用能力，for-select 可以持续处理多路多个channel的能力。但select不能感知channel的关闭.&lt;/p&gt;
&lt;p&gt;context.Context退出goroutine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case &amp;lt;-ctx.Done():
            fmt.Println(&amp;quot;goroutine exiting:&amp;quot;, ctx.Err())
            return
        default:
            fmt.Println(&amp;quot;working...&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;某个通道关闭，不再处理该通道，但是继续处理其它channel,select不会在nil的通道上进行等待:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case x, ok := in1:
            if !ok {
                in1 = nil   把只读channel设置为nil,select不会在这里阻塞。
            }
        case y, ok :=&amp;lt;-in2:
            if !ok {
                in2 = nil
            }
        if in1 == nil &amp;amp;&amp;amp; in2 == nil {
            return
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用专门channel发送退出信号,只需要在main中关闭channel，所有goroutine都会接收到信号退出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go func() {
    for {
        select {
        case &amp;lt;- stopCh:
            ...
            return
        case &amp;lt;- t.C:
            ...
        }
    }
}()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_builtin</title>
        <link>https://canuxcheng.com/post/gsl_builtin/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_builtin/</guid>
        <description>&lt;h1 id=&#34;builtin&#34;&gt;builtin&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pkg.go.dev/builtin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pkg.go.dev/builtin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;go的builtin package.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;true
false
iota // Untyped int.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;p&gt;pointer, channel, func, interface, map, or slice type的zero value：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nil
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 分配并初始化各种类型的对象, 返回一个指针．
new(Type) *Type

# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.
make(t Type, size ...IntegerType) Type

# 返回容量，　Array/ArrayPointer/Slice/Channel
cap(v Type) int

# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel
len(v Type) int

print(args ...Type)

println(args ...Type)

func max[T cmp.Ordered](x T, y ...T) T
func min[T cmp.Ordered](x T, y ...T) T
func clear[T ~[]Type | ~map[Type]Type1](t T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;complex:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 把两个浮点数构造成一个复数
complex(r, i FloatType) ComplexType

# 返回复数c的实部
real(c ComplexType) FloatType

# 返回复数c的虚部
imag(c ComplexType) FloatType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;slice:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 向切片末尾追加元素，返回新的切片．切片长度增加.
# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．
# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.
append(slice []Type, elems ...Type) []Type

# 复制一个切片, 返回复制的元素的个数
copy(dst, src []Type) int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从映射删除一个键值对
delete(m map[Type]1, key Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;chan:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 由发送者关闭一个双向或只发送的信道
close(c chan&amp;lt;- Type)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 停止当前go程的正常执行(断言函数)
panic(v interface{})

# 管理panic过程中的go程
recover() interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;types&#34;&gt;types&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bool

uint
uintptr
uint8/byte (0 - 255)
uint16
uint32
uint64

int
int8 (-128 - 127)
int16
int32/rune
int64

float32
float64

complex64
complex128

string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文档类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Type
Type1
IntegerType
FloatType
ComplexType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误处理:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error

// go使用error值来表示错误状态，nil表示成功，非nil表示失败．
type error interface {
    ERROR() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;any:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type any = interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comparable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type comparable interface{ comparable }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_concurrency</title>
        <link>https://canuxcheng.com/post/gsl_concurrency/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_concurrency/</guid>
        <description>&lt;h1 id=&#34;sync&#34;&gt;sync&lt;/h1&gt;
&lt;p&gt;sync用于goroutine同步.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;locker&#34;&gt;Locker&lt;/h2&gt;
&lt;p&gt;一个可以加锁和解锁的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Locker interface {
    Lock()
    Unlock()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pool&#34;&gt;Pool&lt;/h2&gt;
&lt;p&gt;Pool是一个可以分别存取的临时对象的集合。&lt;/p&gt;
&lt;h2 id=&#34;once&#34;&gt;Once&lt;/h2&gt;
&lt;p&gt;只执行一次动作的对象(单例模式)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Once struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只有第一次调用才执行
func (o *Once) Do(f func())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;
&lt;p&gt;互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.&lt;/p&gt;
&lt;p&gt;Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。&lt;/p&gt;
&lt;p&gt;同一时刻只能有一个线程进入临界区.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Mutex struct {}

Mutex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 加锁，如果已经加锁，阻塞至m解锁．
func (m *Mutex) Lock()

// 解锁，如果没有加锁，导致panic
func (m *Mutex) Unlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rwmutex&#34;&gt;RWMutex&lt;/h2&gt;
&lt;p&gt;读写互斥锁,可以由不同的线程加锁和解锁.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type RWMutex struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。
func (rw *RWMutex) Lock()

// 解除写入锁定，如果没有加锁，导致panic
func (rw *RWMutex) Unlock()

// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。
func (rw *RWMutex) RLock()

// 解除读取锁，如果没有加锁，导致panic.
func (rw *RWMutex) RUnlock()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cond&#34;&gt;Cond&lt;/h2&gt;
&lt;p&gt;条件变量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cond struct {
    L Locker
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewCond(l Locker) *Cond
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (c *Cond) Broadcase()

func (c *Cond) Signal()

func (c *Cond) Wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;
&lt;p&gt;用于等待一组线程结束，父线程用Add方法来设定应等待的线程数量;
每个被等待的线程在结束时应调用Done方法;
同时，主线程应调用Wait方法阻塞至所有线程结束．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type WaitGroup sttruct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 增加计数
func (*WaitGroup) Add(delta int)

# 减少计数
func (*WaitGroup) Done()

# 阻塞直到计数器为0
func (*WaitGroup) Wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;syncatomic&#34;&gt;sync/atomic&lt;/h1&gt;
&lt;p&gt;提供底层的原子级内存操作，主要用于goroutine同步.&lt;/p&gt;
&lt;p&gt;int32, int64, uint32, uint64, uintptr, pointer.&lt;/p&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func AddInt64(addr *int64, delta int64) (new int64)
func AddUint64(addr *uint64, delta uint64) (new uint64)
func LoadInt64(addr *int64) (val int64)
func LoadUint64(addr *uint64) (val uint64)
func StoreInt64(addr *int64, val int64)
func StoreUint64(addr *uint64, val uint64)
func SwapInt64(addr *int64, new int64) (old int64)
func SwapUint64(addr *uint64, new uint64) (old uint64)
func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_cryptographic</title>
        <link>https://canuxcheng.com/post/gsl_cryptographic/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_cryptographic/</guid>
        <description>&lt;h1 id=&#34;crypto&#34;&gt;crypto&lt;/h1&gt;
&lt;p&gt;收集了常用的密码常量&lt;/p&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;RegisterHash(h Hash, f func() hash.Hash)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;publickey&#34;&gt;PublicKey&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PublicKey interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;privatekey&#34;&gt;PrivateKey&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PrivateKey interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Hash uint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (h Hash) Avaliable() bool
func (h Hash) Size() int
func (h Hash) New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptocipher&#34;&gt;crypto/cipher&lt;/h1&gt;
&lt;p&gt;用于包装底层块加密算法的实现.&lt;/p&gt;
&lt;h2 id=&#34;block&#34;&gt;Block&lt;/h2&gt;
&lt;p&gt;代表一个使用特定密钥的底层　加／解密器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;blockmode&#34;&gt;BlockMode&lt;/h2&gt;
&lt;p&gt;代表一个工作在块模式(CBC, ECB等)的加／解密器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type BlockMode interface {
    BlockSize() int
    CryptBlocks(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个BlockMode接口，底层用b加密，初始向量长度等于b的块尺寸.
func NewCBCEncrypter(b Block, iv []byte) BlockMode

// 返回一个BlockMode接口，底层用b解密，初始向量长度等于b的块尺寸.
func NewCBCDecrypter(b Block, iv []byte) BlockMode
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stream&#34;&gt;Stream&lt;/h2&gt;
&lt;p&gt;stream接口表示一个流模式的加／解密器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stream interface {
    XORKeyStream(dst, src []byte)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewCFBEncrypter(block Block, iv []byte) Stream

func NewCFBDecrypter(block Block, iv []byte) Stream

func NewOFB(b Block, iv []byte) Stream

func NewCTR(b Block, iv []byte) Stream
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptorand&#34;&gt;crypto/rand&lt;/h1&gt;
&lt;p&gt;用于加解密的更安全的随机数生成器.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptoaes&#34;&gt;crypto/aes&lt;/h1&gt;
&lt;p&gt;对称加密算法,aes加密算法用于取代des算法.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const BlockSize = 16
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个cipher.Block接口, key为密钥，长度只能是16(aes-128),24(aes-192),32(aes-256)字节.
func NewCipher(key []byte) (cipher.Block, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptodsa&#34;&gt;crypto/dsa&lt;/h1&gt;
&lt;p&gt;非对称，数字签名算法dsa.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptorsa&#34;&gt;crypto/rsa&lt;/h1&gt;
&lt;p&gt;非对称加密算法rsa.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptomd5&#34;&gt;crypto/md5&lt;/h1&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const BlockSize = 64
const Size = 16
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回data的ms5检验和
func Sum(data []byte) [Size]byte

func New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha1&#34;&gt;crypto/sha1&lt;/h1&gt;
&lt;h2 id=&#34;constants-2&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// SHA1块大小
const BlockSize = 64

// SHA1校验和的字节数
const Size = 20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回数据data的SHA1校验和
func Sum(data []byte) [Size]byte

// 返回一个使用新的SHA1校验的hash.Hash接口
func New() hash.Hash
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha256&#34;&gt;crypto/sha256&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cryptosha512&#34;&gt;crypto/sha512&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hash-1&#34;&gt;hash&lt;/h1&gt;
&lt;h2 id=&#34;hash-2&#34;&gt;Hash&lt;/h2&gt;
&lt;p&gt;被所有hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash interface {
    io.Writer
    Sum(b []byte) []byte
    Reset()
    Size() int
    BlockSize() int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash32&#34;&gt;Hash32&lt;/h2&gt;
&lt;p&gt;被所有32位hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash32 interface {
    Hash
    Sum32() uint32
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hash64&#34;&gt;Hash64&lt;/h2&gt;
&lt;p&gt;被所有64位hash函数实现的公共接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Hash64 interface {
    Hash
    Sum64() uint64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashadler32&#34;&gt;hash/adler32&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashcrc32&#34;&gt;hash/crc32&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashcrc64&#34;&gt;hash/crc64&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;hashfnv&#34;&gt;hash/fnv&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_data</title>
        <link>https://canuxcheng.com/post/gsl_data/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_data/</guid>
        <description>&lt;h1 id=&#34;time&#34;&gt;time&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;p&gt;const:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    ANSIC       = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;
    Unixdate    = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;
    RFC3339     = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 阻塞go程d代表的时间段
func Sleep(d Duration)

func After(d Duration) &amp;lt;- chan Time

func Tick(d Duration) &amp;lt;- chan Time
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;time-1&#34;&gt;Time&lt;/h2&gt;
&lt;p&gt;代表一个纳秒精度的时间点.&lt;/p&gt;
&lt;p&gt;零值是January 1, year 1, 00:00:00.000000000 UTC.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type  Time struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST
func date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time

// 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301
func Now() Time

func Parse(layout, value s tring) (Time, error)

func ParseInLocation(layout, value string, loc *Location) (Time, error)

func Unix(sec int64, nsec int64) Time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回T的地点和时区信息
func (t Time) Location() *Location

// 返回t的时区规范名和相对于UTC的偏移量
func (t Time) Zone() (name string, offset int)

func (t Time) IsZero() bool

func (t Time) Local() Time

func (t Time) UTC() Time

func (t Time) In(loc *Location) Time

func (t Time) Unix() int64

func (t Time) UnixNano() int64

// 比较两个时间
func (t Time) Equal(u Time) bool

// t &amp;gt; u 返回true
func (t Time) Before(u Time) bool

// t &amp;lt; u 返回true
func (t Time) After(u Time) bool

// 返回t的年月日.
func (t Time) date() (year int, month Month, day int)

// 返回t对应的时分秒
func (t Time) Clock() (hour, min, sec int)

// 返回t对应的年
func (t Time) Year() int

// 返回t对应的月
func (t Time) Month() Month

func (t Time) ISOWeek() (year, week int)

// 返回t对应的当年的第几天
func (t Time) YearDay() int

// 返回t对应的当月的第几天
func (t Time) Day() int

// 返回t对应的星期几
func (t Time) Weekday() Weekday

// 返回t对应的第几小时
func (t Time) Hour() int

// 返回t对应的分钟
func (t Time) Minute() int

// 返回t对应的秒
func (t Time) Second() int

// 返回t对应的纳秒偏移量
func (t Time) Nanosecond() int

func (t Time) Add(d Duration) Time

func (t Time) Adddate(years int, months int, days int) Time

func (t Time) Sub(u Time) Duration

func (t Time) Round(d duration) Time

func (t Time) Truncate(d Duration) Time

func (t Time) Format(layout string) string

func (t Time) String(layout string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;weekday&#34;&gt;Weekday&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回d对应的英文名
func (d Weekday) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;month&#34;&gt;Month&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Month int

const (
    January Month = 1 + iota
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回m对应的英文名
func (m Month) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;location&#34;&gt;Location&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Location struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回使用给定名字创建的Location
// name == &amp;quot;&amp;quot; 或　name == &amp;quot;UTC&amp;quot;, 返回UTC
// name == &amp;quot;Local&amp;quot;, fanhui1Local
// 其它时间数据库的值
func LoadLocation(name string) (*Location, error)

// 使用给定的名称和偏移量创建一个Location
func FixedZone(name string, offset int) *Location
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回对时区信息的描述
func (l *Location) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;duration&#34;&gt;Duration&lt;/h2&gt;
&lt;h2 id=&#34;timer&#34;&gt;Timer&lt;/h2&gt;
&lt;h2 id=&#34;ticker&#34;&gt;Ticker&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerheap&#34;&gt;container/heap&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerlist&#34;&gt;container/list&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;containerring&#34;&gt;container/ring&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressbzip2&#34;&gt;compress/bzip2&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressflate&#34;&gt;compress/flate&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compressgzip&#34;&gt;compress/gzip&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compresslzw&#34;&gt;compress/lzw&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;compresszlib&#34;&gt;compress/zlib&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;archive&#34;&gt;archive&lt;/h1&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_database</title>
        <link>https://canuxcheng.com/post/gsl_database/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_database/</guid>
        <description>&lt;h1 id=&#34;databasesql&#34;&gt;database/sql&lt;/h1&gt;
&lt;p&gt;使用该包，必须提供一个数据库驱动&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/golang/go/wiki/SQLDrivers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/golang/go/wiki/SQLDrivers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mssql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/denisenkom/go-mssqldb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/denisenkom/go-mssqldb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mysql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/go-sql-driver/mysql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/go-sql-driver/mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;postgresql driver:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/lib/pq&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lib/pq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jackc/pgx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jackc/pgx&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量
var ErrNoRows = errors.New(&amp;quot;sql: no rows in result set&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 注册并命名一个数据库，在Open中使用该命名启用该驱动
// 如果注册同一名称两次或者driver参数为nil, 会导致panic.
Register(name string, driver driver.Driver)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;db&#34;&gt;DB&lt;/h2&gt;
&lt;p&gt;DB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．&lt;/p&gt;
&lt;p&gt;可以安全的被多个go程同时使用．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type DB struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 验证数据库驱动和参数,并不创建和数据库的连接．
// driverName: mssql, mysql, postgres
// mssql dataSourceName: &amp;quot;server=%s;port=%d;database=%s;user id=%s;password=%s&amp;quot;
// mysql dataSourceName: &amp;quot;user:password@tcp(server:port)/database&amp;quot;
Open(driverName, dataSourceName string) (*DB, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回数据库下层驱动
func (db *DB) Driver() driver.Driver

// 创建和数据库的连接,检查连接是否有效
func (db *DB) Ping() error

// 关闭数据库，释放资源
func (db *DB) Close() error

// 设置与数据库建立连接的最大数目, 默认０表示无限制.
func (db *DB) SetMaxOpenConns(n int)

// 设置连接池中的最大闲置连接数
func (db *DB) SetMaxIdleConns(n int)

// 执行命令但是不返回执行结果,一般用于(insert/update/delete)
func (db *DB) Exec(query string, args ...interface{}) (Result, error)

// 执行命令返回多行结果（一般用于select)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)

// 执行命令最多返回一行结果
// 总是返回非nil值，直到返回值的Scan方法被调用，才会返回被延迟的错误.
func (db *DB) QueryRow(query string, args ...interface{}) *Row

// 创建一个准备好的状态用于之后的命令
func (db *DB) Prepare(query string) (*Stmt, error)

// 开始一个事务
func (db *DB) Begin() (*Tx, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stmt&#34;&gt;Stmt&lt;/h2&gt;
&lt;p&gt;stmt是准备好的状态，可以安全的被多个go程同时使用．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stmt struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *Stmt) Exec(args ...interface{}) (Result, error)

func (s *Stmt) Query(args ...interface{}) (*Rows, error)

func (s *Stmt) QueryRow(args ...interface{}) *Row

func (s *Stmt) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tx&#34;&gt;Tx&lt;/h2&gt;
&lt;p&gt;Tx表示一个进行中的数据库事务．&lt;/p&gt;
&lt;p&gt;一次事务必须以对Commit或Rollback的调用结束．&lt;/p&gt;
&lt;p&gt;事务结束后，所有的操作都会失败并返回ErrTxDone.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Tx struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)

func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)

func (tx *Tx) QueryRow(query string, args ...interface{}) *Row

func (tx *Tx) Prepare(query string) (*Stmt, error)

// 使用已存在的状态生成一个特定的状态．
func (tx *Tx) Stmt(stmt *Stmt) *Stmt

// 提交事务
func (tx *Tx) Commit() error

// 回滚事务
func (tx *Tx) Rollback() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner interface {
    Scan(src interface{}) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;result&#34;&gt;Result&lt;/h2&gt;
&lt;p&gt;Exec方法返回Result.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Result interface {
    LastInsertId() (int64, error)
    RowsAffected() (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;row&#34;&gt;Row&lt;/h2&gt;
&lt;p&gt;QueryRow方法返回Row, 表示单行查询结果．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Row struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将该行查询结果各列分别保存进dest参数指定的值中．
// 如果匹配多行，只取第一行，如果没有匹配行，返回ErrNoRows.
func (r *Row) Scan(dest ...interface{}) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rows&#34;&gt;Rows&lt;/h2&gt;
&lt;p&gt;Query方法返回Rows, 表示查询的结果集，它的游标指向第０行，使用Next方法遍历该结果集．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Rows struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回列名
func (rs *Rows) Columns() ([]string, error)

// 将当前行的各列结果填充进dest
func (rs *Rows) Scan(dest ...interface{}) error

// 准备用于Scan的下一行结果，每次调用Scan都要先调用Next
func (rs *Rows) Next() bool

func (rs *Rows) Close() error

func (rs *Rows) Err() error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;databasesqldriver&#34;&gt;database/sql/driver&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_file</title>
        <link>https://canuxcheng.com/post/gsl_file/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_file/</guid>
        <description>&lt;h1 id=&#34;path&#34;&gt;path&lt;/h1&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool
func Join(elem ...string) string
func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pathfilepath&#34;&gt;path/filepath&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;Constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    Separator = os.PathSeparator
    ListSeparator = os.PathListSeparator
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variable&#34;&gt;Variable&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrBadPattern = errors.New(&amp;quot;Syntax error in pattern&amp;quot;)

var SkipDir = errors.New(&amp;quot;skip this diractory&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool
func Abs(path string) (string, error)

// 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名.
func Rel(basepath, targpath string) (string, error)

func Split(path string) (dir, file string)
func Join(elem ...string) string
func Dir(path string) string
func Base(path string) string
func Ext(path string) string) // 包括小数点
func Walk(root string, walkFn WalkFunc) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;walkfunc&#34;&gt;WalkFunc&lt;/h2&gt;
&lt;p&gt;调用Walk时会对每个目录和文件调用该函数.&lt;/p&gt;
&lt;p&gt;如果该函数返回错误，Walk函数会中止.&lt;/p&gt;
&lt;p&gt;如果该函数返回SkipDir, Walk会掉过处理该目录，继续处理其它内容.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type WalkFunc func(path string, info os.FileInfo, err error) error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encoding&#34;&gt;encoding&lt;/h1&gt;
&lt;p&gt;定义了供其它包使用的在字节和文本之间转换数据的接口.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;encoding&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodingjson&#34;&gt;encoding/json&lt;/h1&gt;
&lt;p&gt;go和json数据类型对应关系，参考WEB/JSON.&lt;/p&gt;
&lt;p&gt;在线获取json的go数据结构:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mholt/json-to-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mholt/json-to-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mholt.github.io/json-to-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mholt.github.io/json-to-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;chan/complex/func类型不能编码为json.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;encoding/json&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 返回golang对象v的json编码(将go的对象转换为json对象), 可以打tag.
&amp;gt; &amp;quot;-&amp;quot; 该字段不会输出到json
&amp;gt; myName 在json中的名字
&amp;gt; omitempty 允许json中没有该字段
&amp;gt; Type 如果指定类型，会转换成指定的类型出现在json
json.Marshal(v interface{}) ([]byte, error)

# 具有缩进功能
json.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)

# 将json对象data转换成go对象，存入v
# 只有可导出字段才会在json中找到.
&amp;gt; Bool                   对应JSON布尔类型
&amp;gt; float64                对应JSON数字类型
&amp;gt; string                 对应JSON字符串类型
&amp;gt; []interface{}          对应JSON数组
&amp;gt; map[string]interface{} 对应JSON对象
&amp;gt; nil                    对应JSON的null
json.Unmarshal(data []byte, v interface{}) error

// 将json格式的src中的无用的空白字符剔除后写入dst.
func Compact(dst *bytes.Buffer, src []byte) error

// 格式化json，以便json编码能安全的嵌入html的&amp;lt;script&amp;gt;标签
func HTMLEscape(dst *bytes.Buffer, src []byte)

//
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;marshaler&#34;&gt;Marshaler&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Marshaler interface {
    MarshalJSON() ([]byte, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unmarshaler&#34;&gt;Unmarshaler&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Unmarshaler interface {
    UnmarshalJSON([] byte) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decoder&#34;&gt;Decoder&lt;/h2&gt;
&lt;p&gt;从输入流解码json对象&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Decoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewDecoder(r io.Reader) *Decoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 从dec读取下一个对象存入v.
func (dec *Decoder) Decode(v interface{}) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;encoder&#34;&gt;Encoder&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodingcsv&#34;&gt;encoding/csv&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;encodinggob&#34;&gt;encoding/gob&lt;/h1&gt;
&lt;p&gt;go binary, go的数据持久化包，用于编码器和解码器之间交换二进制数据.&lt;/p&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Register(value interface{})

func RegisterName(name string, value interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gobdecoder&#34;&gt;GobDecoder&lt;/h2&gt;
&lt;h2 id=&#34;gobencoder&#34;&gt;GobEncoder&lt;/h2&gt;
&lt;h2 id=&#34;decoder-1&#34;&gt;Decoder&lt;/h2&gt;
&lt;p&gt;管理从远端读取数据的类型和信息的解码操作.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Decoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个从r读取数据的Decoder
func NewDecoder(r io.Reader) *Decoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从dec读取下一个值并存入e
func (dec *Decoder) Decode(e interface{}) error

func (dec *Decoder) DecodeValue(v reflect.Value) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;encoder-1&#34;&gt;Encoder&lt;/h2&gt;
&lt;p&gt;管理数据类型和信息编码后发送到远端的操作.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Encoder struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个将编码后数据写入w的Encoder
func NewEncoder(w io.Writer) *Encoder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将e编码后发送到enc
func (enc *Encoder) Encode(e interface{}) error

func (enc *Encoder) EncodeValue(value reflect.Value) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;commontype&#34;&gt;CommonType&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type CommonType struct {
    Name string
    Id typeId
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttemplate&#34;&gt;text/template&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttemplateparse&#34;&gt;text/template/parse&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;textscanner&#34;&gt;text/scanner&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;texttabwriter&#34;&gt;text/tabwriter&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;html&#34;&gt;html&lt;/h1&gt;
&lt;p&gt;提供了用于转义和解转义html文本的函数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将　&amp;lt;, &amp;gt;, &amp;amp;, &#39;, &amp;quot; 转义为字符实体 &amp;amp;lt, &amp;amp;gt, &amp;amp;#39,
 func EscapeString(s string) string

 func UnescapeString(s string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;htmltemplate&#34;&gt;html/template&lt;/h1&gt;
&lt;p&gt;实现了数据驱动模板，用于生成可对抗代码注入的安全html输出．&lt;/p&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将b转义后写入w．
func HTMLEscape(w io.Writer, b []byte)

// 转义s之后,返回结果字符串.
func HTMLEscapeString(s string) string

// 转义多个字符串，返回结果字符串.
func HTMLEscaper(args ...interface{}) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;funcmap&#34;&gt;FuncMap&lt;/h2&gt;
&lt;p&gt;定义函数名字符串到函数的映射，每个函数必须要1到2个返回值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FuncMap map[string]interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;template&#34;&gt;Template&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Template struct {
    Tree *parse.Tree
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建名为name的模板
func New(name string) *Template

// 在err非nil时panic, 检测模板是否正确．
// 通过template.New().Parse() 返回值作为参数.
func Must(t *Template, err error) *Template

// 创建一个模板，并解析filenames作为模板内容
// 第一个文件名为模板名字(不包括扩展名)
func ParseFiles(filenames ...string) (*Template, error)

// 创建一个模板，并解析匹配pattern的文件．
// 匹配的第一个文件名为模板名字(不包括扩展名)
func ParseGlob(pattern string) (*Template, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将字符串str解析为模板
func (t *Template) Parse(str string) (*Template, error)

// 将文件解析为模板
func (t *Template) ParseFiles(filenames ...string) (*Template, error)

//
func (t *Template) ParseGlob(pattern string) (*Template, error)

// 将解析好的模板应用到data上，并将输出写入wr.
func (t *Template) Execute(wr io.Writer, data interface{}) (err error)

// 使用和t关联的名为name的模板
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error

// 注册函数到模板t, funcMap的key是模板中调用的函数名，value是实际的函数
func (t *Template) Funcs(funcMap FuncMap) *Template
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;yaml&#34;&gt;yaml&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/go-yaml/yaml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/go-yaml/yaml&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;toml&#34;&gt;toml&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/toml-lang/toml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/toml-lang/toml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/BurntSushi/toml&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/BurntSushi/toml&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GSL_golang</title>
        <link>https://canuxcheng.com/post/gsl_golang/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_golang/</guid>
        <description>&lt;h1 id=&#34;runtime&#34;&gt;runtime&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 指定编译器
const Compiler = &amp;quot;gc&amp;quot;/&amp;quot;gccgo&amp;quot;

// 处理器架构: 386/amd64/arm
const GOARCH string = theGoarch

// 操作系统: linux/freebsd/darwin/win
const GOOS string = theGoos
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var MemProfileRate int = 512 * 1024
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func GOROOT() string
func Version() string

// 返回本地机器的逻辑cpu个数
func NumCPU() int

//更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu.
func GOMAXPROCS(n int) int

// 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行.
// 当前goroutine放回队列等待继续执行.
func Gosched()

// 终止当前goroutine,终止前执行所有defer.
func Goexit()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimedebug&#34;&gt;runtime/debug&lt;/h1&gt;
&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 设置最大线程数，默认1000.
func SetMaxThreads(threads int) int
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimecgo&#34;&gt;runtime/cgo&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimepprof&#34;&gt;runtime/pprof&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimerace&#34;&gt;runtime/race&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;runtimetrace&#34;&gt;runtime/trace&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;expvar&#34;&gt;expvar&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;context&#34;&gt;context&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unsafe&#34;&gt;unsafe&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;errors&#34;&gt;errors&lt;/h1&gt;
&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 使用字符串创建一个错误, 返回一个error
func New(text string) error
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GSL_math</title>
        <link>https://canuxcheng.com/post/gsl_math/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_math/</guid>
        <description>&lt;h1 id=&#34;math&#34;&gt;math&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathbig&#34;&gt;math/big&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathcmplx&#34;&gt;math/cmplx&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mathrand&#34;&gt;math/rand&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sort&#34;&gt;sort&lt;/h1&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Ints(a []int)
func IntAreSorted(a []int) bool
func SearchInts(a []int, x int) int

func Float64s(a []float64)
func Float64sArerSorted(a []float64) bool
func SearchFloat64s(a []float64, x float64) int

func Strings(a []string)
func StringsAreSorted(a []string) bool
func SearchStrings(a []string, x string) int

func Sort(data Interface)
func Stable(data Interface)
func IsSorted(data Interface) bool
func Reverse(data Interface) Interface
// 二分查找
func Search(n int, f func(int) bool) int
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;interface&#34;&gt;Interface&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;initslice&#34;&gt;InitSlice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type InitSlice []int
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;float64slice&#34;&gt;Float64Slice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Float64Slice []float64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringslice&#34;&gt;StringSlice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type StringSlice []string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_multimedia</title>
        <link>https://canuxcheng.com/post/gsl_multimedia/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_multimedia/</guid>
        <description>&lt;h1 id=&#34;image&#34;&gt;image&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mime&#34;&gt;mime&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_network</title>
        <link>https://canuxcheng.com/post/gsl_network/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_network/</guid>
        <description>&lt;h1 id=&#34;net&#34;&gt;net&lt;/h1&gt;
&lt;p&gt;网络IO接口，包括TCP/IP, UDP, SOCKET, DNS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    IPv4len = 4
    IPv6len = 16
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;addr&#34;&gt;Addr&lt;/h2&gt;
&lt;p&gt;代表一个网络终端地址．&lt;/p&gt;
&lt;p&gt;TCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Addr interface {
    Network() string
    String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tcpaddr&#34;&gt;TCPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveTCPAddr(net, addr string) (*TCPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;udpaddr&#34;&gt;UDPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveUDPAddr(net, addr string) (*UDPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipaddr&#34;&gt;IPAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveIPAddr(net, addr string) (*IPAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unixaddr&#34;&gt;UnixAddr&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ResolveUnixAddr(net, addr string) (*UnixAddr, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conn&#34;&gt;Conn&lt;/h2&gt;
&lt;p&gt;该接口代表通用的面向流的网络连接．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Conn interface {
    Read()
    Write()
    Close()
    LocalAddr()
    RemoteAddr()
    SetDeadline()
    SetReadDeadline()
    setWriteDeadline()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// tcp: &amp;quot;tcp&amp;quot;、&amp;quot;tcp4&amp;quot;、&amp;quot;tcp6&amp;quot;、
// unix: &amp;quot;unix&amp;quot;, &amp;quot;unixpacket&amp;quot;
// unix: &amp;quot;unixgramh&amp;quot;
// udp: &amp;quot;udp&amp;quot;、&amp;quot;udp4&amp;quot;、&amp;quot;udp6&amp;quot;、
// ip: &amp;quot;ip&amp;quot;、&amp;quot;ip4&amp;quot;、&amp;quot;ip6&amp;quot;、
func Dail(network, address string) (Conn, error)

func DialTimeout(network, address string, timeout time.Duration) (Conn, error)

func Pipe() (Conn, Conn)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;packetconn&#34;&gt;PacketConn&lt;/h2&gt;
&lt;p&gt;该接口代表通用的面向数据包的网络连接．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type PacketConn interface {
    ReadDrom()
    WriteTo()
    Close()
    LocalAddr()
    SetDeadline()
    SetReadDeadline()
    SetWriteDeadline()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ip: &amp;quot;ip&amp;quot;、&amp;quot;ip4&amp;quot;、&amp;quot;ip6&amp;quot;、
// udp: &amp;quot;udp&amp;quot;、&amp;quot;udp4&amp;quot;、&amp;quot;udp6&amp;quot;、
// unix: &amp;quot;unixgram&amp;quot;
func ListenPacket(net, laddr string) (PacketConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;listener&#34;&gt;Listener&lt;/h2&gt;
&lt;p&gt;通用的面向流的网络协议的公用的网络监听接口．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Listener interface {
    Addr() addr
    Accept() (c Conn, err error)
    Close() error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// tcp: &amp;quot;tcp&amp;quot;、&amp;quot;tcp4&amp;quot;、&amp;quot;tcp6&amp;quot;、
// unix: &amp;quot;unix&amp;quot;, &amp;quot;unixpacket&amp;quot;
func Listen(net, laddr string) (Listener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipconn&#34;&gt;IPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口．&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DilIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)
func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;udpconn&#34;&gt;UDPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)
func ListenDUP(net string, laddr *UDPAddr) (*UDPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;tcpconn&#34;&gt;TCPConn&lt;/h2&gt;
&lt;p&gt;实现了Conn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;tcplistener&#34;&gt;TCPListener&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *TCPListener) Accept() (Conn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unixconn&#34;&gt;UnixConn&lt;/h2&gt;
&lt;p&gt;实现了Conn和PacketConn接口.&lt;/p&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)
func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;h2 id=&#34;unixlistener&#34;&gt;UnixListener&lt;/h2&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *UnixListener) Accept() (c Conn, err error)
func (l *UnixListener) AcceptUnix() (*UnixConn, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nethttp&#34;&gt;net/http&lt;/h1&gt;
&lt;p&gt;http协议客户端和服务器的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;net/http&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    MethodGet = &amp;quot;GET&amp;quot;
    MethodHead = &amp;quot;HEAD&amp;quot;
    MethodPost = &amp;quot;POST&amp;quot;
    MethodPut = &amp;quot;PUT&amp;quot;
    MethodPatch = &amp;quot;PATCH&amp;quot;
    MethodDelete = &amp;quot;DELETE&amp;quot;
    MethodConnect = &amp;quot;CONNECT&amp;quot;
    MethodOptions = &amp;quot;OPTIONS&amp;quot;
    MethodTrace = &amp;quot;TRACE&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 在w的header中添加Set-Cookie头．
func SetCookie(w ResponseWriter, cookie *Cookie)

func Handle(pattern string, handler Handler)

// 注册一个handler和对应的pattern 到DefaultServeMux.
func HandlerFunc(pattern string, handler func(ResponseWriter, *Request))

// 为监听器收到的每个连接创建一个新的goroutine．
// goroutine 会读取请求并调用handler回复该请求．
func Serve(l net.Listener, handler Handler) error

// 监听tcp地址addr, 使用handler参数调用Serve函数处理连接．
// handler = nil 相当于DefaultServeMux
func ListenAndServe(addr string, handler Handler) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type File interface {
    io.Closer
    io.Reader
    Readdir(count int) ([]os.FileInfo, error)
    Seek(offset int64, whence int) (int64, error)
    Stat() (os.FileInfo, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;filesystem&#34;&gt;FileSystem&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type FileSystem interface {
    Open(name string) (File, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dir&#34;&gt;Dir&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Dir string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (d Dir) Open(name string) (File, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;
&lt;p&gt;实现Handler接口的对象可以被注册为http的服务函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对每个请求回复&amp;quot;404 page not found&amp;quot;
func NotFoundHandler() Handler

// 对每个请求使用状态码code重定向到url.
func RedirectHandler(url string, code int) Handler

func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler

// 将请求的URL.Path中的前缀prefix去除后再给h.
func StripPrefix(prefix string, h Handler) Handler

func FileServer(root FileSystem) Handler
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;handlerfunc&#34;&gt;HandlerFunc&lt;/h2&gt;
&lt;p&gt;将普通函数转换成http的服务函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ServeHTTP会调用f(w, r)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;servemux&#34;&gt;ServeMux&lt;/h2&gt;
&lt;p&gt;ServeMux是http请求的多路转接器．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ServeMux struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建并返回一个新的*ServeMux
func NewServeMux() *ServeMux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//
func (mux *ServeMux) Handle(pattern string, handler Handler)

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))

func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)

func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;server&#34;&gt;Server&lt;/h2&gt;
&lt;p&gt;定义了运行http服务端的参数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Server struct {
    Addr string
    Handler Handler
    ReadTimeout time.Duration
    WriteTimeout time.Duration
    MaxHeaderBytes int
    TLSConfig *tls.Config
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
    ConnState func(net.Conn, ConnState)
    ErrorLog *log.Logger
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *Server) SetKeepAlivesEnabled(v bool)

func (s *Server) Serve(l net.Listener) error

func (s *Server) ListenAndServe() error

func (s *Server) ListenAndServeTLS(certFile, keyFile string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;client&#34;&gt;Client&lt;/h2&gt;
&lt;p&gt;代表一个http客户端.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Client struct {
    Transport RoundTripper
    CheckRedirect func(req *Request, via []*Request) error
    Jar CookieJar
    Timeout time.Duration
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;
&lt;p&gt;代表http的头部.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Header map[string][]string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (h Header) Get(key string) string
func (h Header) Set(key, value string)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;代表一个http回复的头部中SetCookie头的值，或http请求的头部里面的cookie值．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cookie struct {
    Name string
    Value string
    Path string
    Domain string
    Expires time.Time
    RawExpires string
    MaxAge int
    Secure bool
    HttpOnly bool
    Raw string
    Unparsed []string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回cookie序列化的结果
func (c *Cookie) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;request&#34;&gt;Request&lt;/h2&gt;
&lt;p&gt;代表一个服务端接收的或客户端发送的http请求.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Request struct {
    Method string
    URL *url.URL
    Proto string // &amp;quot;HTTP/1.0&amp;quot;
    ProtoMajor int // 1
    ProtoMinor int // 0
    Header Header
    Body io.ReadCloser
    ContentLength int64
    TransferEncoding []string
    Close bool
    Host string
    Form url.Values
    PostForm url.Values
    MultipartForm *multipart.Form
    Trailer Header
    RemoteAddr string
    RequestURI string
    TSL *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewRequest(method, urlStr string, body io.Reader) (*Request, error)

func ReadRequest(b *bufio.Reader) (req *Request, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 解析并返回该请求r的header设置的cookie
func (r *Request) Cookies() []*Cookie

// 返回请求r中命名为name的cookie,如果未找到返回nil, ErrNoCookie.
func (r *Request) Cookie(name string) (*cookie, error)

//解析r.URL中的查询字符串，并将解析结果更新到r.Form字段.
// post和put的body会同时更新到r.PostForm和r.Form.
func (r *Request) ParseForm() error

// 将请求的主体作为multipart/form-data解析.
func (r *Request) ParseMultipartForm(maxMemory int64) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;response&#34;&gt;Response&lt;/h2&gt;
&lt;p&gt;代表一个http请求的回复r&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Response struct {
    Status string
    StatusCode int
    Proto string
    ProtoMajor int
    ProtoMinor int
    Header Header
    Body io.ReadCloser
    ContentLength int64
    TransferEncoding []string
    Close bool
    Trailer Header
    Request *Request
    TLS *tls.ConnectionState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)

func Head(url string) (resp *Response, err error)
func Get(url string) (resp *Response, err error)
func Post(url string, bodyType string, boyd io.Reader) (resp *Response, err error)
func PostForm(url string, data url.Values) (resp *Response, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (r *Response) ProtoAtLeast(major, minor int) bool

// 获取相应中的Set-Cookie设置的cookie
func (r *Response) Cookies() []*Cookie
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;responsewriter&#34;&gt;ResponseWriter&lt;/h2&gt;
&lt;p&gt;用于构造http回复.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ResponseWriter interface {
    Header() Header
    WriteHeader(int)
    Write([]byte) (int, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netmail&#34;&gt;net/mail&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netsmtp&#34;&gt;net/smtp&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netrpc&#34;&gt;net/rpc&lt;/h1&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 在DefaultServer注册并公布rcvr方法.
func Register(rcvr interface{}) error

// 接收连接，将每个连接交给DefaultServer服务.会阻塞.
func Accept(lis net.Listener)

// 在单个连接执行DefaultServer,会阻塞.
func ServceConn(conn io.ReadWriteCloser)

func HandleHTTP()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;call&#34;&gt;Call&lt;/h2&gt;
&lt;p&gt;代表一个执行中或执行完毕的会话．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Call struct {
    ServiceMethod string
    Args interface{}
    Reply interface{}
    Error error
    Done chan *Call
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;client-1&#34;&gt;Client&lt;/h2&gt;
&lt;p&gt;rpc客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type client struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewClient(conn io.ReadWriteCloser) *Client

func Dial(network, address string) (*Client, error)

func DialHTTP(network, address string) (*Client, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 调用指定的方法，等待返回，将结果写入reply.
func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error

func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call

func (client *Client) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nettextproto&#34;&gt;net/textproto&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;neturl&#34;&gt;net/url&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;scheme://[userinfo@]host/path[?query][#fragment]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type URL struct {
    Scheme string
    Opaque string
    User *Userinfo
    Host string // host or host:port
    Path string
    RawQuery string
    Fragment string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Parse(rawurl string) (url *URL, err error)
func ParseRequestURI(rawurl string) (url *URL, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;h2 id=&#34;userinfo&#34;&gt;Userinfo&lt;/h2&gt;
&lt;h2 id=&#34;values&#34;&gt;VAlues&lt;/h2&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_oop</title>
        <link>https://canuxcheng.com/post/gsl_oop/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_oop/</guid>
        <description>&lt;h1 id=&#34;reflect&#34;&gt;reflect&lt;/h1&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;p&gt;const:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    SelectSend
    SelectRecv
    SelectDefault
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 将src拷贝到dst, 直到src被耗尽或dst被装满.
func Copy(dst, src Value) int

// 判断两个值是否深度一致
func DeepEqual(a1, a2 interface{}) bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;kind&#34;&gt;Kind&lt;/h2&gt;
&lt;p&gt;表示Type类型值表示的具体分类.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Kind uint

const (
    Invalid Kind = iota
    Bool
    Int
    ...
    Uint
    ...
    Float...
    Complex...
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (k Kind) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringheader&#34;&gt;StringHeader&lt;/h2&gt;
&lt;h2 id=&#34;sliceheader&#34;&gt;SliceHeader&lt;/h2&gt;
&lt;h2 id=&#34;structfield&#34;&gt;StructField&lt;/h2&gt;
&lt;h2 id=&#34;structtag&#34;&gt;StructTag&lt;/h2&gt;
&lt;h2 id=&#34;chandir&#34;&gt;ChanDir&lt;/h2&gt;
&lt;h2 id=&#34;selectdir&#34;&gt;SelectDir&lt;/h2&gt;
&lt;h2 id=&#34;selectcase&#34;&gt;SelectCase&lt;/h2&gt;
&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;
&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;
&lt;p&gt;用来表示一个go类型.&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Type interface {
    Kind() Kind
    Name() string
    PkgPath() string
    String() string
    Size() uintptr
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回接口中保存的值的类型
func TypeOf(i interface{}) Type

// 返回类型t的指针的类型
func PtrTo(t Type) Type

// 返回类型t的slice的类型
func SliceOf(t Type) Type

// 返回一个键类型为key, 值类型为elem的map类型
func MapOf(key, elem Type) Type

// 返回元素类型为t, 方向为dir的chan类型
func ChanOf(dir ChanDir, t Type) Type
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;
&lt;p&gt;为go值提供反射接口.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Value struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个接口i保存的具体值的Value
func ValueOf(i interface{}) Value

// 返回一个类型typ的零值的Value
func Zero(typ Type) Value

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 如果v是否持有值，如果v是Value零值，返回false.
func (v Value) IsValid() bool

func (v Value) IsNil() bool

// 返回v持有值的分类，如果v是Value零值，返回Invalid
func (v Value) Kind() Kind

// 返回v持有的值的类型Type.
func (v Value) Type() Type

...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>GSL_string</title>
        <link>https://canuxcheng.com/post/gsl_string/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_string/</guid>
        <description>&lt;h1 id=&#34;strings&#34;&gt;strings&lt;/h1&gt;
&lt;p&gt;实现了用于操作字符的函数.&lt;/p&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func EqualFold(s, t string) bool

func HasPrefix(s, prefix string) bool
func HasSuffix(s, suffix string) bool

func Count(s, sep string) int

func Contains(s, substr string) bool
...

func Index(s, sep string) int
...

func LastIndex(s, sep string) int
...

func title(s string) string

func ToLower(s string) string
...

// 返回count个string
func Repeat(s string, count int) string

func Replace(s, old, new string, n int) string

func Map(mapping func(rune) rune, s string) string

func Trim(s string, cutset string) string
...

// 返回将字符串按照空白分割的多个字符串
func Fields(s string) []string
// 按照f作为分隔符来分割字符串，返回切片
func FieldsFunc(s string, f func(rune) bool) []string

func Split(s, sep string) []string
...

// 将一系列字符串连接为一个字符串，之间用sep来分割.
func Join(a []string, sep string) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;
&lt;h2 id=&#34;replacer&#34;&gt;Replacer&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bytes&#34;&gt;bytes&lt;/h1&gt;
&lt;p&gt;实现了操作[]bytes的常用函数.&lt;/p&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;reader-1&#34;&gt;Reader&lt;/h2&gt;
&lt;h2 id=&#34;buffer&#34;&gt;Buffer&lt;/h2&gt;
&lt;p&gt;Buffer是一个实现了读写方法的可变大小的字节缓冲.&lt;/p&gt;
&lt;p&gt;零值是一个空的可用于读写的缓冲.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Buffer struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewBuffer(buf []byte) *Buffer
func NewBufferString(s string) *Buffer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Buffer) String() string

func (b *Buffer) Read(p []byte) (n int, err error)
func (b *Buffer) Write(p []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;strconv&#34;&gt;strconv&lt;/h1&gt;
&lt;p&gt;实现了基本数据类型和字符串的相互转换.&lt;/p&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const InitSize = intSize
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;Variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrRange = errors.New(&amp;quot;value out of range&amp;quot;)
var ErrSyntax = errors.New(&amp;quot;invalid syntax&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个字符是否是可打印的
func IsPrint(r rune) bool

// 返回字符串s是否可以不被修改的表示为一个反引号字符串
func CanBackquote(s string) bool

func Quote(s string) string
...

func Unquote(s string) (t string, err error)
...

func AppendInt(dst []byte, i int64, base int) []byte
...

// 字符串转换成其他类型
func ParseInt(s string, base int, bitSize int) (i int64, err error)
...

// 其他类型转换为字符串
func FormatInt(i int64, base int) string
...

// ParseInt(s, 10, 0)的简写, string -&amp;gt; int
func Atoi(s string) (i int, err error)
// FormatInt(i, 10)的简写, int -&amp;gt; string
func Itoa(i int) string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;numerror&#34;&gt;NumError&lt;/h2&gt;
&lt;p&gt;表示一次失败的转换&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type NumError struct {
    Func string
    Num string
    Err error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (e *NumError) Error() string
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;unicode&#34;&gt;unicode&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;regexp&#34;&gt;regexp&lt;/h1&gt;
&lt;p&gt;实现了正则表达式搜索&lt;/p&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;regexp-1&#34;&gt;Regexp&lt;/h2&gt;
&lt;p&gt;Regexp代表一个编译好的正则表达式．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Regexp struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Compile(expr string) (*Regexp, error)

func CompilePOSIX(expr string) (*Regexp, error)

func MustCompile(str string) *Regexp

func MustCompilePOSIX(str string) *Regexp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;regexpsyntax&#34;&gt;regexp/syntax&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;indexsuffixarray&#34;&gt;index/suffixarray&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>GSL_system</title>
        <link>https://canuxcheng.com/post/gsl_system/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_system/</guid>
        <description>&lt;h1 id=&#34;os&#34;&gt;os&lt;/h1&gt;
&lt;p&gt;提供了操作系统的不依赖平台的接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;os&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# flag 参数
const (
    O_RDONLY int = syscall.O_RDONLY
    O_WRONLY int = syscall.O_WRONLY
    O_RDWR int = syscall.O_RDWR
    O_CREATE int = syscall.O_CREATE # 不存在就创建
    O_APPEND int = syscall.O_APPEND # 追加写入
    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件
    O_EXCL int = syscall.O_EXCL
    O_SYNC int = syscall.O_SYNC
)

const (
    SEEK_SET int = 0
    SEEK_CUR int = 1
    SEEK_END int = 2
)

const (
    // 操作系统指定的路径分隔符
    PathSeperator = &#39;/&#39;
    // 操作系统指定的表分隔符
    PathListSeparator = &#39;:&#39;
)

// 操作系统空设备的名字
const DevNull = &amp;quot;/dev/null&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var (
    ErrInvalid = errors.New(&amp;quot;invalid argument&amp;quot;)
    ...
)

// 指向标准输入／输出／错误的文件描述符
var (
    Stdin = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)
    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)
    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)
)

// 保存了命令行参数，第一个是程序名
var Args []string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回内核提供的主机名
func Hostname() (name string, err error)

// 当前程序以给出的状态码马上退出，defer不会执行
func Exit(code int)

// 返回key=value格式的环境变量的字符串的切片拷贝
func Environ() []string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件相关的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func IsExist(err error) bool // 文件存在返回true
func IsNotExist(err error) bool // 文件不存在返回true

func IsPathSeparator(c uint8) bool
...
func SameFile(fi1, fi2 FileInfo) bool
func Getwd() (dir string, err error)
func Chdir(dir string) error
func Chmod(name string, mode FileMode) error
func Chown(name string, uid, gid int) error
...
func Mkdir(name string, perm FileMode) error // 创建单个目录
func MkdirAll(path string, perm FileMode) error // 创建多级目录
func Rename(oldpath, newpath string) error
func Truncate(name string, size int64) error
func Remove(name string) error
func RemoveAll(path string) error
func Readlink(name string) (string, error)
func Symlink(oldname, newname string) error // 创建符号连接
func Link(oldname, newname string) error // 创建硬连接
func TempDir() string // 返回一个用于保管临时文件的默认目录

// 从filename指定的文件读取数据并返回, 成功返回文件内容和nil
func ReadFile(filename string) ([]byte, error)

// 向filename指定文件写入数据，如果文件存在先清空文件，如果不存在创建文件.
func WriteFile(filename string, data []byte, perm os.FileMode) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;signal&#34;&gt;Signal&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Signal interface {
    String() string
    Signal()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;variable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var (
    Interrupt Signal = syscall.SIGINT
    Kill Signal = syscall.SIGKILL
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;filemode&#34;&gt;FileMode&lt;/h2&gt;
&lt;p&gt;代表文件模式和权限位．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FileMode uint32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;constant:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    ModeDir    FileMode = 1 &amp;lt;&amp;lt; (32 - 1 - iota) // d: 目录
    ...
    ModeType = ModeDir | ModeSymlink | ModeNamePipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (m FileMode) IsDir() bool
func (m FileMode) IsRegular() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fileinfo&#34;&gt;FileInfo&lt;/h2&gt;
&lt;p&gt;用来描述一个文件对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FileInfo interface {
    Name() string
    Size() int64
    Mode() FileMode
    ModeTime() time.Time
    IsDir() bool
    Sys() interface{}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取一个文件对象
func Stat(name string) (fi FileInfo, err error)

func Lstat(name string) (fi FileInfo, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;
&lt;p&gt;表示一个打开的文件对象&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type File struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 采用flag=os.O_RDWR和perm=0666模式创建一个名为name的文件, 返回读写文件句柄
// 文件已存在就截断
func Create(name string) (file *File, err error)

// 打开指定文件，返回只读文件句柄, flag=os.O_RDONLY
func Open(name string) (file *File, err error)

// 指定flag和perm创建／打开文件
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)

// 使用给定的文件描述服和名称创建一个文件.
func NewFile(fd uintptr, name string) *File

// 返回一对关联的文件对象
func Pipe() (r *File, w *File, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 从文件f中最多读取len(b)字节数据写入b, 返回读取的字节数
// 返回0, io.EOF, 表示读取0个字节,文件终止．
func (f *File) Read(b []byte) (n int, err error)

func (f *File) ReadAt(b []byte, off int64) (n int, err error)

// 向文件f写入len(b)字节数据b，返回写入字节数
func (f *File) Write(b []byte) (n int, err error)

func (f *File) WriteAt(b []byte, off int64) (ret int, err error)

func (f *File) WriteString(s string) (ret int, err error)

func (f *File) Close() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;process&#34;&gt;Process&lt;/h2&gt;
&lt;p&gt;保存一个被StarProcess创建的进程的信息&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Process struct {
    Pid int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 启动一个新进程
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)

// 查找一个运行中的进程
func FindProcess(pid int) (p *Process, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 向进程发送信号
func (p *Process) Signal(sig Signal) error

// 阻塞直到进程退出
func (p *Process) Wait() (*ProcessState, error)

// 让进程立刻退出
func (p *Process) Kill() error

// 释放进程绑定的资源
func (p *Process) Release() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;processstate&#34;&gt;ProcessState&lt;/h2&gt;
&lt;p&gt;保管Wait函数报告的某个已退出进程的信息．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ProcessState struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个已退出的进程的id
func (p *ProcessState) Pid() int

// 报告进程是否已退出
func (p *ProcessState) Exited() bool

// 报告进程是否成功退出
func (p *ProcessState) Success() bool

// 返回已退出进程及其子进程耗费的系统cpu时间
func (p *ProcessState) SystemTime() time.Duration

// 返回已退出进程及其子进程耗费的用户cpu时间
func (p *ProcessState) UserTime() time.Duration

func (p *ProcessState) Sys() interface{}

func (p *ProcessState) SysUsage() interface{}

func (p *ProcessState) String() string
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;procattr&#34;&gt;ProcAttr&lt;/h2&gt;
&lt;p&gt;保存被StratProcess启动的新进程的属性&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ProcAttr struct {
    Dir string
    Env []string
    Files []*File
    Sys *syscall.SysProcAttr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;osexec&#34;&gt;os/exec&lt;/h1&gt;
&lt;p&gt;执行外部命令，包装了os.StartProcess函数，提供更高级的接口.&lt;/p&gt;
&lt;h2 id=&#34;variable&#34;&gt;variable&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ErrNotFound = errors.New(&amp;quot;executable file not found in $PATH&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 在环境变量指定的目录中搜索可执行文件file
func LookPath(file string) (string, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmd&#34;&gt;Cmd&lt;/h2&gt;
&lt;p&gt;表示一个准备执行或执行中的外部命令&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cmd struct {
    Path string
    Args []string
    Env []string
    Dir string
    stdin io.Reader
    Stdout io.Writer
    Stderr io.Writer
    ExtraFiles []*os.File
    SysProcAttr *syscall.SysProcAttr
    Process *os.Process
    ProcessState *os.ProcessState
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 返回*Cmd
func Command(name string, arg ***string) *Cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 同步：执行命令，并阻塞直到完成
func (c *Cmd) Run() error

// 异步：开始执行命令，不阻塞直接返回，
func (c *Cmd) Start() error
// 阻塞通过Start执行的命令直到完成，设置状态码并释放资源．
func (c *Cmd) Wait() error

func (c *Cmd) StdinPipe() (io.WriteCloser, error)
func (c *Cmd) StdoutPipe() (io.ReadCloser, error)
func (c *Cmd) StderrPipe() (io.ReadCloser, error)

// 执行命令并返回stdout的切片
func (c *Cmd) Output() ([]byte, error)
// 执行命令并返回stdout和stderr合并后的切片
func (c *Cmd) CombinedOutput() ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ossignal&#34;&gt;os/signal&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;osuser&#34;&gt;os/user&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;syscall&#34;&gt;syscall&lt;/h1&gt;
&lt;p&gt;提供了操作系统级别的调用．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;syscall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants-1&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    AF_ALG    = 0x26
    ...
)

// 定义异常
const (
    E2BIG    = Errno(0x70)
    ...
)

// 定义信号
const (
    SIGABRT    = Signal(0x6)
    ...
)

const (
    SYS_READ    = 0
    ...
)

const (
    SizeofSockaddrInet4    = 0x10
    ...
)

const (
    IFA_UNSPEC    = 0x0
    ...
)

const (
    SizeofSockFilter    = 0x8
    ...
)

const (
    VINTR    = 0x0
    ...
)

const ImplementsGetwd = true

const PathMax = 0x1000

const SizeofInotifyEvent = 0x10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-1&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var (
    Stdin = 0
    Stdout = 1
    Stderr = 2
)

var ForkLock sync.RWMutex

var SocketDisableIPv6 bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;others&#34;&gt;others&lt;/h2&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;io&#34;&gt;io&lt;/h1&gt;
&lt;p&gt;提供了对IO原语的基本接口&lt;/p&gt;
&lt;p&gt;go1.16 删除了io/ioutil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-2&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 放无法获取更多输入时Read方法返回os.EOF
var EOF = errors.New(&amp;quot;EOF&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-2&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func ReadAll(r io.Reader) ([]byte, error)
func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)
func ReadFull(r Reader, buf []byte) (n int, err error)

// 将src数据拷贝到dst, 直到EOF或出错，返回拷贝的字节数
func Copy(dst Writer, src Reader) (written int64, err error)

// 类似Copy，不过只拷贝n个字节.
func CopyN(dst Writer, src Reader, n int64) (written int64, err error)

func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)

// 将字符串s写入w
func WriteString(w Writer, s string) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;
&lt;p&gt;用于包装基本的读取方法&lt;/p&gt;
&lt;p&gt;os.File(os.Stdout, os.Stdin. os.Stderr), bytes.Buffer 和 bufio.Reader 都是io.Reader接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;writer&#34;&gt;Writer&lt;/h2&gt;
&lt;p&gt;用于包装基本的写入方法&lt;/p&gt;
&lt;p&gt;os.File(os.Stdin, os.Stderr, os.Stdin), bytes.Buffer 和 bufio.Writer, net/http.ResponseWriter 都是io.Writer接口&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Writer interface {
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;closer&#34;&gt;Closer&lt;/h2&gt;
&lt;p&gt;用于包装基本的关闭方法&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Closer interface {
    Close() error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;seeker&#34;&gt;Seeker&lt;/h2&gt;
&lt;p&gt;用于包装基本的移位方法&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;readwriter&#34;&gt;ReadWriter&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bufio&#34;&gt;bufio&lt;/h1&gt;
&lt;p&gt;bufio实现了有缓冲的IO&lt;/p&gt;
&lt;h2 id=&#34;constants-2&#34;&gt;constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    // 用于缓冲一个token
    MaxScanTokenSize = 64 * 1024
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;variables-3&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 会被Scanner返回的错误
var (
    ErrInvalidUnreadByte = errors.New(&amp;quot;bufio: invalid use of UnreadByte&amp;quot;)
    ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-3&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)

func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)

// 将每一行文本去掉末尾的换行标记，然后作为一个token返回
func ScanLines (data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reader-1&#34;&gt;Reader&lt;/h2&gt;
&lt;p&gt;给io.Reader接口对象附加缓冲&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewReader(rd io.Reader) *Reader

func NewReaderSize(rd io.Reader, size int) *Reader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Reader) Read(p []byte) (n int, err error)
// 读取直到第一次遇到delim字节，返回一个包含已读取数据和delim字节的字符串
// 当且仅当返回的切片不以delim结尾时，返回非nil错误
func (b *Reader) ReadString(delim byte) (line string, err error)
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)

func (b *Reader) ReadByte() (c byte, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;writer-1&#34;&gt;Writer&lt;/h2&gt;
&lt;p&gt;给io.Writer接口对象提供缓冲&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Writer struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewWriter(w io.Writer) *Writer

func NewWriterSize(w io.Writer, size int) *Writer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (b *Writer) Write(p []byte) (nn int, err error)
func (b *Writer) WriteString(s string) (int, error)
func (b *Writer) WriteByte(c byte) error
func (b *Writer) WriteRune(r rune) (size int, err error)

func (b *Writer) Flush() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;readwriter-1&#34;&gt;ReadWriter&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ReadWriter struct {
    *Reader
    *Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func NewReadWriter(r *Reader, w *Writer) *ReadWriter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;提供了方便的读取数据接口&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建并返回一个从r读取数据的Scanner，默认分割函数是ScanLines
func NewScanner(r io.Reader) *Scanner
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置s的分割函数
func (s *Scanner) Split(split SplitFunc)

// 获取当前位置的token, 并让Scanner的扫描位置移动到下一个token.
func (s *Scanner) Scan() bool

// 返回最近一次Scan调用生成的token.
func (s *Scanner) Bytes() []byte

// 创建一个字符串保存Bytes返回的token,并返回
func (s *Scanner) Text() string

// 返回Scanner遇到的第一个非EOF错误
func (s *Scanner) Err() error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;splitfunc&#34;&gt;SplitFunc&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;fmt&#34;&gt;fmt&lt;/h1&gt;
&lt;p&gt;实现了类似于C的printf/scanf的格式化IO.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;fmt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通用占位符:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%v    相应值的默认格式
%#v   相应值的go语法表示
%T    相应值的类型的go语法表示
%%    字面上的百分号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%t    true/false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%b    二进制表示
%c    相应的unicode码点所表示的字符
%d    十进制表示
%o    八进制表示
%q    单引号包围的字符字面值
%x    十六进制(字母小写)
%X    十六进制(字母大写)
%U    unicode格式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浮点数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%b    无小数部分的，指数为二的幂的科学计数法．
%e    科学计数法
%E    科学计数法
%f    有小数点，而无指数
%g    根据情况选择%e 或 %f
%G    根据情况选择E% 或 %f

%[宽度]Type
%.[精度]Type
%[宽度].[精度]Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串与字节切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%s    字符串或切片的字节
%q    双引号包围的字符串
%x    十六进制(小写字母)
%X    十六进制(大写字母)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%p    十六进制表示(0x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-4&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回一个包含该格式化字符串的错误
func Errorf(format string, a ...interface{}) error

// 写入到STDOUT, 返回写入字节数
// 默认格式化
func Print(a ...interface{}) (n int, err error)
// 默认格式化，自动结尾添加换行符
func Println(a ...interface{}) (n int, err error)
// 指定格式化
func Printf(format string, a ...interface{}) (n int, err error)

// 写入到w, 返回写入字节数
// w: os.File bufio.Writer
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

// 返回该字符串
func Sprint(a ...interface{}) string
func Sprintln(a ...interface{}) string
func Sprintf(format string, a ...interface{}) string

// 从STDIN扫描文本存入a,返回成功扫描的个数
// 换行视为空白，获取len(a)个条目才停止扫描
func Scan(a ...interface{}) (n int, err error)
// 换行才停止扫描
func Scanln(a ...interface{}) (n int, err error)
// 根据空格分割的条目格式化写入指定参数a
func Scanf(format string, a ...interface{}) (n int, err error)

// 从r扫描文本存入a, 返回成功扫描的条目
// r: os.File bufio.Reader
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)

// 从字符串str扫描文本存入a,  返回扫描成功的条目
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stringer&#34;&gt;Stringer&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stringer initerface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gostringer&#34;&gt;GoStringer&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type GoStringer interface {
    GoString() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;state&#34;&gt;State&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type State interface {
    Write(b []byte) (ret int, err error)
    Width() (wid int, ok bool)
    Precision() (prec int, ok bool)
    Flag(c int) bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;formatter&#34;&gt;Formatter&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Formatter interface {
    Format(f State, c rune)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanstate&#34;&gt;ScanState&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ScanState interface {
    ReadRune() (r rune, size int, err error)
    UnreadRune() error
    SkipSpace()
    Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
    Width() (wid int, ok bool)
    Read(buf []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scanner-1&#34;&gt;Scanner&lt;/h2&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Scanner interface {
    Scan(state ScanState, verb rune) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;log&#34;&gt;log&lt;/h1&gt;
&lt;p&gt;实现了简单的日志服务.&lt;/p&gt;
&lt;h2 id=&#34;constants-3&#34;&gt;Constants&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const (
    Ldate        = 1 &amp;lt;&amp;lt; iota     // 日期
    Ltime              // 时间
    Lmicroseconds      // 微秒
    Llongfile          // 绝对文件名和行好 /path/to/file.go:13
    Lshortfile         // 文件名和行好, 覆盖上面字段 file.go:13
    LstdFlags    = Ldate | Ltime      // 标准logger的初始值
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-5&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func Printf(format string, v ...interface{})
func Print(v ...interface{})
func Println(v ...interface{})

// 下列函数在Print...函数基础上再调用os.Exit(1)
func Fatalf(format string, v ...interface{})
func Fatal(v ...interface{})
func Fatalln(v ...interface{})

// 下列函数在Print...函数基础上再调用panic(...)
// panic会执行当前函数的defer, 然后退出当前函数，返回到调用者，
// 调用函数会执行defer, 直到应用程序退出.最后panic.
func Panicf(format string, v ...interface{})
func Panic(v ...interface{})
func Panicln(v ...interface{})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;logger&#34;&gt;Logger&lt;/h2&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Logger struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个Logger.
func New(out io.Writer, prefix string, flag int) *Logger
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (l *Logger) Flags() int
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;flag&#34;&gt;flag&lt;/h1&gt;
&lt;p&gt;实现了命令行参数解析&lt;/p&gt;
&lt;p&gt;第三方包:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/alecthomas/kingpin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/alecthomas/kingpin&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;variables-4&#34;&gt;variables&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

//
var ErrHelp = errors.New(&amp;quot;flag: help requested&amp;quot;)

//
var Usage = func() {
    fmt.Fprintf(os.Stderr, &amp;quot;Usage of %s:\n&amp;quot;, os.Args[0])
    PrintDefaults()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-6&#34;&gt;functions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 返回已被设置的flag数量
func NFlag() int
// 返回已注册flag的结构体指针
func Lookup(name string) *Flag

// 非flag参数不能在flag参数前面指定，否则flag参数不会被解析．
// 返回非flag参数个数
func NArg() int
// 返回所有非flag参数
func Args() []string
// 返回第i个非flag参数, i=0 就是第一个参数，而不是程序名称
func Arg(i int) string

// 向Stderr写入所有注册好的flag的默认值
func PrintDefaults()

// 从os.Args[1:] 中解析注册的flag.
func Parse()
// 返回是否Parse是否被调用过
func Parsed() bool

// 按照字典顺序遍历flag，并对每个flag调用fn, 只针对解析时设置了的flag
func Visit(fn func(*Flag))
// 按照字典顺序遍历flag,　并对每个flag调用fn, 针对所有flag.
func VisitAll(fn func(*Flag))

// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 返回一个保存了该flag的值的指针
func Bool(name string, value bool, usage string) *bool
// 用指定的名称，默认值，帮助信息注册一个bool类型的flag
// 将flag值保存到指针p指向的变量
func BoolVar(p *bool, name string, value bool, usage string)

func Int
func IntVar
func Int64
func Int64Var

func Uint
func UintVar
func Uint64
func Uint64Var

func Float64
func Float64Var

func String
func StringVar

// time.Duration类型
func Duration
func DurationVar

// 用指定的名字，帮助信息，注册一个flag，类型由value决定
func Var(value Value, name string, usage string)
// 设置已注册的flag的值
func Set(name, value string) error
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;errorhandling&#34;&gt;ErrorHandling&lt;/h2&gt;
&lt;p&gt;定义如何处理flag解析错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type ErrorHandling int

const (
    ContinueOnError ErrorHandling = iota
    ExitOnError
    PanicOnError
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flag-1&#34;&gt;Flag&lt;/h2&gt;
&lt;p&gt;定义一个flag&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Flag struct {
    Name     string
    Usage    string
    Value    Value
    DefValue string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flagset&#34;&gt;FlagSet&lt;/h2&gt;
&lt;p&gt;代表一个已注册flag集合.&lt;/p&gt;
&lt;p&gt;FlagSet零值没有名字，默认采用ContinueOnError.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type FlagSet struct {
    Usage func()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;functions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个新的FlagSet叫name，采用errorHandling为错误处理策略
func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设置f的名字和错误处理策略.
func (f *FlagSet) Init(name string, errorHandling ErrorHandling)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;
&lt;p&gt;用于将动态值保存在flag里.&lt;/p&gt;
&lt;p&gt;interface:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Value interface {
    String() string
    Set(string) error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getter&#34;&gt;Getter&lt;/h2&gt;
&lt;hr&gt;
&lt;h1 id=&#34;logrus&#34;&gt;logrus&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sirupsen/logrus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sirupsen/logrus&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cobra&#34;&gt;cobra&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/spf13/cobra&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GSL_test</title>
        <link>https://canuxcheng.com/post/gsl_test/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/gsl_test/</guid>
        <description>&lt;h1 id=&#34;testing&#34;&gt;testing&lt;/h1&gt;
&lt;p&gt;go的测试由go test命令和testing包组成．&lt;/p&gt;
&lt;p&gt;测试程序命名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XXX.go # 测试文件和源码放在一个包中
XXX_test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试程序结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;testing&amp;quot;

# 单元测试
# go test 会自动执行
func TestXXX(t *testing.T) {}

# 性能测试
# go test XXX_test.go -test.bench=&amp;quot;.*&amp;quot;  压力测试需要指定才能执行
func BenchmarkXXX(b *testing.B) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;
&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;
&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;
&lt;h2 id=&#34;t&#34;&gt;T&lt;/h2&gt;
&lt;p&gt;管理测试状态并支持格式化测试的日志．&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type T struct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将当前测试标识为失败，但继续执行该文件剩下的测试
func (c *T) Fail()

// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.
func (c *T) FailNow()

// 用于报告测试函数是否失败
func (c *T) Failed() bool

func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})

# 相当于Log/Logf之后调用Fail.(当前case失败)
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})

# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})

func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;b&#34;&gt;B&lt;/h2&gt;
&lt;p&gt;管理基准测试的计时行为，并指示应该迭代的运行测试多少次.&lt;/p&gt;
&lt;p&gt;struct:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type B struct {
    N int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool

func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})

func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})

func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})

func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;testingiotest&#34;&gt;testing/iotest&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;testingquick&#34;&gt;testing/quick&lt;/h1&gt;
&lt;hr&gt;
&lt;h1 id=&#34;gotests&#34;&gt;gotests&lt;/h1&gt;
&lt;p&gt;通过源代码自动生成测试代码，可以用命令行，也可以用goland等的插件．&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cweill/gotests&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cweill/gotests&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/cweill/gotests/...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>OOP</title>
        <link>https://canuxcheng.com/post/go_oop/</link>
        <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
        
        <guid>https://canuxcheng.com/post/go_oop/</guid>
        <description>&lt;h1 id=&#34;go面向对象&#34;&gt;Go面向对象&lt;/h1&gt;
&lt;p&gt;golang不是传统的面向对象编程，而是通过struct, method, interface, embedding实现面向对象的核心功能.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;方法method&#34;&gt;方法/method&lt;/h2&gt;
&lt;p&gt;go中没有类，但是可以为结构体定义方法．&lt;/p&gt;
&lt;p&gt;方法就是一类带有特殊的　接收者参数　的函数．&lt;/p&gt;
&lt;p&gt;只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．&lt;/p&gt;
&lt;p&gt;除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．&lt;/p&gt;
&lt;p&gt;方法有两种接收者,值接收者和指针接收者.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Vertex struct {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值接收者:&lt;/p&gt;
&lt;p&gt;值接收者操作的是值的副本.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (v Vertex) MethodName() rType {
    ...
}

var v Vertex
v.MethodName() // 操作值的副本

# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换
vp := new(Vertex)
vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针接收者：&lt;/p&gt;
&lt;p&gt;指针接收者，调用方法的时候操作的是该指针指向的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指针接收者的方法可以修改接收者指向的值
func (v *Vertex) MethodName() rType {
    ...
}

vp := new(Vertex)
vp.MethodName() // 操作实际的值

# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.
var v Vertex
v.MethodName() // (&amp;amp;v).MethodName() , 操作的是实际的值
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口/Interface&lt;/h2&gt;
&lt;p&gt;接口是引用类型. zero value is nil.&lt;/p&gt;
&lt;p&gt;接口类型是由一组方法签名定义的集合, 任何实现了这些方法的类型，自动被认为实现了这个接口。．&lt;/p&gt;
&lt;p&gt;某个类型实现了该接口的所有方法签名，就算实现了该接口,无需显示申明实现了哪个接口.&lt;/p&gt;
&lt;p&gt;接口可以匿名嵌入其它接口，或嵌入到结构中．&lt;/p&gt;
&lt;p&gt;一般只有一个方法的接口命名为MethodName + &amp;rsquo;er&#39;.&lt;/p&gt;
&lt;p&gt;接口存储两个数据接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iTable, 包含存储值的类型信息以及和该值关联的方法.&lt;/li&gt;
&lt;li&gt;指向存储的值的指针.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Speaker interface {
    Speak()
}

type Animal struct {
    Name string
}

func (a Animal) Speak() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值接收者方法:&lt;/p&gt;
&lt;p&gt;接口类型的值为值或指针都可以调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s SName) MethodName() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针接收者方法:&lt;/p&gt;
&lt;p&gt;接口类型的值必须为指针才能调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (s *SName) MethodName() {
    ...
}

s := &amp;amp;SName{...}
// i = &amp;amp;SName{...} //接口变量能保存实现了该接口的任意类型的对象
i = s
i.MethodName()

# 接口类型为值时，调用失败
var s SName
i = s
i.MethodName() // 调用失败
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;空接口：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有类型都实现了空接口.&lt;/p&gt;
&lt;p&gt;指定了零个方法的接口值被称为空接口,一般用来处理未知类型的值.&lt;/p&gt;
&lt;p&gt;当接口储存的类型和对象都为nil，接口才为nil&lt;/p&gt;
&lt;p&gt;以空接口为参数的函数可以接收任意类型的值作为参数.&lt;/p&gt;
&lt;p&gt;如果一个函数返回空接口就可以返回任意类型的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x interface{}
x = 43
x = &amp;quot;hello&amp;quot;

# 空接口可以保存任何类型的值
var i interface{}
# 空接口作为形参
func FuncName(i interface{}) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;指针的类型断言/comma-ok断言：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;断言接口值i保存了具体类型Type, 并将底层类型为Type的值赋予变量t.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只返回一个值，断言失败会触发panic.
t := i.(Type)

返回两个值，断言成功返回true, 失败返回false.
var x interface{} = &amp;quot;hello&amp;quot;
str, ok := x.(string) // ok=true
num, ok := x.(int) // ok=false 断言失败

// i.(type) 是固定写法
switch v := i.(type) {
case string:
    fmt.Println(&amp;quot;string&amp;quot;)
case int:
    fmt.Println(&amp;quot;int&amp;quot;)
default:
    fmt.Println(&amp;quot;unknown type&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;嵌入接口:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口中可以嵌入其它接口，这样实现了该接口的对象就隐式包含嵌入接口的所有方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Reader interface {
    Read()
}

type Writer interface {
    Write()
}

type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;封装encapsulation&#34;&gt;封装Encapsulation&lt;/h2&gt;
&lt;p&gt;小写字母开头的标识符（类型/属性/方法&amp;hellip;)是未公开的，只能在当前包引用，不能在其它包引用。&lt;/p&gt;
&lt;p&gt;可以通过创建工厂函数对外暴露未公开的标识符:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标识符才有公开或未公开属性，值没有&lt;/li&gt;
&lt;li&gt;短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量；显示声明的变量不能引用未公开类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过工厂函数返回未公开类型的值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type privateType  Type
func New(args) privateType {
    return privateType(args)
}
# packageB
import packageA
func main() {
    b := packageA.New(args) // 返回一个值，而不是标识符
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公开类型的未公开属性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type Public struct {
    private Type
}

# packageB
import packageA
func main() {
    b := packageA.Public{
        private: value, // panic, 公开类型的未公开属性不能通过字面量直接赋值
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型嵌套中的未公开类型的公开属性会提升到外部类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# packageA
type inner struct { // inner private
    In Type  // In public
}
type Outer struct {
    inner
    Out Type
}

# packageB
import packageA
func main() {
    b := packageA.Outer{
        Out: value, // 外部类型中的未公开内部类型不能通过字面量直接赋值
    }
    b.In = value // 内部类型的公开属性提升到外部类型。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多态polymorphism&#34;&gt;多态Polymorphism&lt;/h2&gt;
&lt;p&gt;golang多态通过interface实现。&lt;/p&gt;
&lt;p&gt;形式参数是接口的函数，叫做多态函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func FuncName(iVar IName) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有实现了接口的方法的实体类型，就可以作为参数传给多态函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Speaker interface {
    Speak()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Dog struct{}
func (d Dog) Speak() {
    fmt.Println(&amp;quot;dog&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Cat struct{}
func (c Cat) Speak() {
    fmt.Println(&amp;quot;cat&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多态函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func makeSound(s Speaker) {
    s.Speak()
}

func main() {
    var d Dog
    var c Cat
    makeSound(d) // dog
    makeSound(c) // cat
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;继承inheritance&#34;&gt;继承Inheritance&lt;/h2&gt;
&lt;p&gt;golang没有继承，但是可以通过结构体嵌套实现继承行为。&lt;/p&gt;
&lt;p&gt;如果外部类型实现同名的属性或方法，就会覆盖内部类型的属性或方法（不过内部类型的属性和方法还在，可以通过内部类型访问）&lt;/p&gt;
&lt;p&gt;内部类型实现的接口，也会自动提升到外部类型。只要内部类型实现了某接口，外部类型相当于也实现了该接口。&lt;/p&gt;
&lt;p&gt;如果匿名字段实现了一个方法，那么包含这个匿名字段的结构也可以调用该方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Inner struct {
    in Type
}

func (i *Inner) InnerMethod() {}

type Outer struct {
    Inner    // 只需要类型名称，不需要声明变量
    out Type
    ...
}

outer := Outer{}

outer.Inner.InnerMethod() //始终可以访问内部类型的方法，即使外部类型实现同名方法
outer.Inner.in // 同上

outer.InnerMethod() //如果外部类型没有实现同名方法，就是内部类型方法，否则是外部类型方法
outer.in // 同上
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;反射reflection&#34;&gt;反射Reflection&lt;/h2&gt;
&lt;p&gt;反射就是检查程序在运行时的状态.&lt;/p&gt;
&lt;p&gt;使用反射一般使用标准库reflect.&lt;/p&gt;
&lt;p&gt;Go 的反射通过 reflect.TypeOf() 和 reflect.ValueOf() 在运行时检查或操作对象，是实现泛型、序列化、ORM、接口断言等动态功能的基础。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;reflect&amp;quot;
x := 123
t := reflect.TypeOf(x)   // int
v := reflect.ValueOf(x)  // 123
k := t.Kind()            // reflect.Int
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
