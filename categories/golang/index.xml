<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Morgoth</title>
    <link>https://canuxcheng.com/categories/golang/</link>
    <description>Recent content in Golang on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Apr 2019 21:42:07 +0800</lastBuildDate>
    <atom:link href="https://canuxcheng.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Package</title>
      <link>https://canuxcheng.com/post/go_package/</link>
      <pubDate>Tue, 23 Apr 2019 21:42:07 +0800</pubDate>
      <guid>https://canuxcheng.com/post/go_package/</guid>
      <description></description>
    </item>
    <item>
      <title>Contribution</title>
      <link>https://canuxcheng.com/post/go_oss/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_oss/</guid>
      <description>&lt;h1 id=&#34;golang-contribution&#34;&gt;Golang Contribution&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://go.dev/doc/contribute&#34;&gt;https://go.dev/doc/contribute&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建google账号&#34;&gt;创建google账号&lt;/h2&gt;&#xA;&lt;p&gt;推荐申请一个google邮箱。&lt;/p&gt;&#xA;&lt;p&gt;在开发机配置git&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ git config --global user.email name@example.com   &#xA;$ git config user.email name@example.com            &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;签cla&#34;&gt;签CLA&lt;/h2&gt;&#xA;&lt;p&gt;个人开发者需要签署CLA。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cla.developers.google.com/about/google-individual&#34;&gt;https://cla.developers.google.com/about/google-individual&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;配置git认证&#34;&gt;配置git认证&lt;/h2&gt;&#xA;&lt;p&gt;点击“Generate Password”， 用google邮箱登陆，根据提示配置git。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://go.googlesource.com/&#34;&gt;https://go.googlesource.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建gerrit账号&#34;&gt;创建gerrit账号&lt;/h2&gt;&#xA;&lt;p&gt;用google邮箱登陆即可。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://go-review.googlesource.com/dashboard/self&#34;&gt;https://go-review.googlesource.com/dashboard/self&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装git-codereview&#34;&gt;安装git-codereview&lt;/h2&gt;&#xA;&lt;p&gt;windows:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/review/git-codereview@latest&#xA;$ git --exec-path&#xA;&#xA;&amp;gt; copy git-codereview.exe from GOBIN to Git\mingw64\libexec\git-core&#xA;&#xA;$ git codereview help&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;linux/mac:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/review/git-codereview@latest&#xA;$ git codereview help&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;选取修改的cl&#34;&gt;选取修改的CL&lt;/h2&gt;&#xA;&lt;p&gt;从github选取一个还没有人提交CL(change log/list)的Issue进行修改。&lt;/p&gt;&#xA;&lt;p&gt;issue三种类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NeedsInvestigation&lt;/li&gt;&#xA;&lt;li&gt;NeedsDecision&lt;/li&gt;&#xA;&lt;li&gt;NeedsFix    选这个里面还没有CL的做&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22&#34;&gt;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3ANeedsFix+NOT+%22golang.org%2Fcl%22&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;提交patch&#34;&gt;提交patch&lt;/h2&gt;&#xA;&lt;p&gt;支持github或者gerrit提交patch。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Debug</title>
      <link>https://canuxcheng.com/post/go_debug/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_debug/</guid>
      <description>&lt;h1 id=&#34;gdb&#34;&gt;gdb&lt;/h1&gt;&#xA;&lt;h1 id=&#34;delve&#34;&gt;delve&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/derekparker/delve&#34;&gt;https://github.com/derekparker/delve&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Devops</title>
      <link>https://canuxcheng.com/post/go_devops/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_devops/</guid>
      <description>&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;&#xA;&lt;p&gt;go有三种安装方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;源码安装&lt;/li&gt;&#xA;&lt;li&gt;标准包安装&lt;/li&gt;&#xA;&lt;li&gt;第三方工具安装&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;GOROOT:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOROOT 就是go的安装目录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;windows标准包安装go:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;msi指定安装路径，自动添加%GOROOT%/bin到环境变量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;linux标准包安装go:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;下载.tar.gz包解压到/usr/local/go&#xA;GOROOT=/usr/local/go&#xA;export PATH=$PATH:/usr/local/go/bin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;验证安装：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go --help&#xA;$ go version&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;第三方工具gvm安装go:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/moovweb/gvm&#34;&gt;http://github.com/moovweb/gvm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ gvm install go1.9.2&#xA;$ gvm use go1.9.2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;gopath&#34;&gt;GOPATH&lt;/h1&gt;&#xA;&lt;p&gt;gopath用来存放go源码，go的可运行文件，以及相应的编译之后的包文件．&lt;/p&gt;&#xA;&lt;p&gt;GOPATH 从go1.1到1.7都需要设置，而且不能是go的安装目录, go1.8开始有默认值:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOPATH=$USERPROFILE%go&#xA;GOPATH=$HOME/go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;gopath结构：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;src    存放源码&#xA;pkg    编译后的库文件&#xA;bin    编译后生成的可执行文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;gopath有多个值时用冒号分开即可.&lt;/p&gt;&#xA;&lt;h1 id=&#34;gobin&#34;&gt;GOBIN&lt;/h1&gt;&#xA;&lt;p&gt;默认值&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOBIN=$HOME/go/bin&#xA;export PATH=$PATH:$HOME/go/bin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;go get 和 go install 安装的二进制到GOBIN。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go命令&#34;&gt;go命令&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go help [command]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;get&lt;/p&gt;</description>
    </item>
    <item>
      <title>Document</title>
      <link>https://canuxcheng.com/post/go_document/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_document/</guid>
      <description>&lt;h1 id=&#34;document&#34;&gt;Document&lt;/h1&gt;&#xA;&lt;p&gt;go文档相关&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://godoc.org/&#34;&gt;https://godoc.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;go文档的两种方式:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go doc&lt;/li&gt;&#xA;&lt;li&gt;godoc&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;go-doc&#34;&gt;go doc&lt;/h1&gt;&#xA;&lt;p&gt;直接在命令行查看文档&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go doc [package/symbol]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;godoc&#34;&gt;godoc&lt;/h1&gt;&#xA;&lt;p&gt;go自带的文档命令行接口,在浏览器查看文档&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;godoc package [name ...]&#xA;godoc -http=:6060&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过github的项目文档在:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;https://godoc.org&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;godev&#34;&gt;go.dev&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev&#34;&gt;https://pkg.go.dev&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go</title>
      <link>https://canuxcheng.com/post/go/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go/</guid>
      <description>&lt;h1 id=&#34;go概述&#34;&gt;Go概述&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;https://golang.org/ref/spec&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;go语言表达能力强，简洁，清晰，高效．&lt;/p&gt;&#xA;&lt;p&gt;go是一个快速的，静态的，强类型的，编译型语言．&lt;/p&gt;&#xA;&lt;p&gt;go具有高并发和垃圾回收功能.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go基本语法&#34;&gt;Go基本语法&lt;/h1&gt;&#xA;&lt;p&gt;go源程序叫*.go&lt;/p&gt;&#xA;&lt;p&gt;go大小写敏感&lt;/p&gt;&#xA;&lt;p&gt;go程序都是由包组成，程序的入口是main包中的main函数，每个程序有且只有一个．&lt;/p&gt;&#xA;&lt;p&gt;go中只有首字母大写的名称才能从包中导出．&lt;/p&gt;&#xA;&lt;p&gt;go的类型在变量名后面．&lt;/p&gt;&#xA;&lt;p&gt;go函数外的每个语句都必须以关键字开始.&lt;/p&gt;&#xA;&lt;p&gt;go标识符(函数名／变量名／常量名／类型名／语句标号／包名)以字母或下划线开头，后面还可以包含数字,不能用关键字.&lt;/p&gt;&#xA;&lt;p&gt;go使用大括号{}表示一个代码块.&lt;/p&gt;&#xA;&lt;p&gt;go使用分号;表示一个语句结束, 一般一行写多个语句才需要显示添加分号．&lt;/p&gt;&#xA;&lt;p&gt;go的包名一般是小写的单个单词(文件所在的最后一层目录名).&lt;/p&gt;&#xA;&lt;p&gt;go一般使用驼峰命名法.&lt;/p&gt;&#xA;&lt;p&gt;go没有逗号操作符.&lt;/p&gt;&#xA;&lt;p&gt;go中++/&amp;ndash;是语句不是表达式．&lt;/p&gt;&#xA;&lt;p&gt;go中大写字母开头的变量或函数是公有的，小写字母开头的是包私有的.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go注释&#34;&gt;Go注释&lt;/h1&gt;&#xA;&lt;p&gt;单行注释：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// comment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;多行注释：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/* comment */&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go关键字&#34;&gt;Go关键字&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;var const &#xA;break continue for if else switch case default goto fallthrough&#xA;func return defer&#xA;package import&#xA;range type struct map&#xA;interface&#xA;select go chan&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go运算符和优先级&#34;&gt;Go运算符和优先级&lt;/h1&gt;&#xA;&lt;p&gt;go中的运算都是从左到右结合．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;^    #&#xA;!    # 逻辑非&#xA;&#xA;*&#xA;/    # 结果取整数&#xA;%&#xA;&amp;lt;&amp;lt;   # 位运算，左移&#xA;&amp;gt;&amp;gt;   # 位运算，右移&#xA;&amp;amp;    # 位运算，　按位与&#xA;&amp;amp;^   #&#xA;&#xA;+&#xA;-&#xA;|    # 位运算,按位或&#xA;^    # 位运算,按位异或&#xA;&#xA;==&#xA;!=&#xA;&amp;lt;&#xA;&amp;lt;=&#xA;&amp;gt;&#xA;&amp;gt;=&#xA;&#xA;&amp;lt;- # chan运算符&#xA;&#xA;&amp;amp;&amp;amp;   # 逻辑与&#xA;||   # 逻辑或&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go数据类型&#34;&gt;Go数据类型&lt;/h1&gt;&#xA;&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;&#xA;&lt;p&gt;定义/申明变量:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go_Concurrency</title>
      <link>https://canuxcheng.com/post/go_concurrency/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_concurrency/</guid>
      <description>&lt;h1 id=&#34;并发concurrency&#34;&gt;并发/concurrency&lt;/h1&gt;&#xA;&lt;p&gt;CSP: communicating sequential processes, 通信顺序进程。&lt;/p&gt;&#xA;&lt;p&gt;go的并发同步模型来自CSP泛型。CSP是一种消息传递模型，用于在goroutine之间同步和传递数据的类型是channel.&lt;/p&gt;&#xA;&lt;p&gt;concurrency:并发,同时管理很多事情，可以执行到一半就暂停去做其他事情.有同时执行的能力，但不一定要同时执行.并发属于代码。&lt;/p&gt;&#xA;&lt;p&gt;所以如果是单个cpu，每次只能运行一个goroutine,如果是多cpu,就是并行,每个cpu都可以跑goroutine.&lt;/p&gt;&#xA;&lt;p&gt;parallelism: 并行,让不同的代码在不同的物理处理器上同时执行. 并行属于运行中的程序。并行是时间或者上下文的概念。&lt;/p&gt;&#xA;&lt;p&gt;process: 进程, 是系统资源和调度的基本单位，包括内存，句柄，线程等。&lt;/p&gt;&#xA;&lt;p&gt;thread: 线程,是cpu调度和分配的基本单位,每个进程至少包含一个线程，初始线程就是主线程，每个线程绑定到一个逻辑cpu上运行。&lt;/p&gt;&#xA;&lt;p&gt;co-routine: 协程，大量线程会消耗内存和cpu调度，将线程分为内核态线程和用户态线程，每个用户态线程绑定到内核态线程，但是cpu不知道用户态线程的存在，我们把用户态线程叫协程。&lt;/p&gt;&#xA;&lt;p&gt;goroutine: go语言的协程，是并行的，通过channel来通信.&lt;/p&gt;&#xA;&lt;p&gt;GMP: goroutine的实现模型。&lt;/p&gt;&#xA;&lt;p&gt;G: goroutine。&lt;/p&gt;&#xA;&lt;p&gt;M: thread，代表一个内核态线程，golang默认10000个，SetMaxThreads可以设置，P创建M，一个P可以创建多个M如果之前的阻塞了。&lt;/p&gt;&#xA;&lt;p&gt;P: processor, 包含了可运行的协程队列，由GOMAXPROCS确定个数，然后创建对应个数的P。&lt;/p&gt;&#xA;&lt;p&gt;不要通过共享内存通信，通过通信来共享内存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;goroutines&#34;&gt;goroutines&lt;/h2&gt;&#xA;&lt;p&gt;go关键字会启动一个新的goroutine并执行.&lt;/p&gt;&#xA;&lt;p&gt;每个goroutine会绑定到一个逻辑处理器上运行，每个逻辑处理器会绑定到单个操作系统线程。&lt;/p&gt;&#xA;&lt;p&gt;当goroutine阻塞，就会把goroutine和线程从逻辑处理器上分离，然后创建一个新的线程绑定到该逻辑处理器，并继续运行队列中的其它goroutine.&lt;/p&gt;&#xA;&lt;p&gt;当阻塞的goroutine恢复，会再次进入队列，和该goroutine绑定的线程也会保存下来.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go FuncName(...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;主进程main结束了，goroutine也结束．&lt;/p&gt;&#xA;&lt;h2 id=&#34;竟态&#34;&gt;竟态&lt;/h2&gt;&#xA;&lt;p&gt;race condition: 竞争状态，多个goroutine同时操作同一资源.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 检测竞争状态&#xA;$ go build -race&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;所以要解决goroutine间的消息传递和同步的问题.&lt;/p&gt;&#xA;&lt;p&gt;通过通信共享内存，而不是通过共享内存而通信,说明解决并发问题优先使用chan，而不是sync包。&lt;/p&gt;&#xA;&lt;p&gt;channel还是mutex,选择的依据是他们的能力/特性.&lt;/p&gt;&#xA;&lt;p&gt;channel的能力是让数据流动起来，擅长的是数据流动的场景:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传递数据的所有权，即把某个数据发送给其他协程&lt;/li&gt;&#xA;&lt;li&gt;分发任务，每个任务都是一个数据&lt;/li&gt;&#xA;&lt;li&gt;交流异步结果，结果是一个数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;sync的能力是数据不动，某段时间只给一个协程访问数据的权限擅长数据位置固定的场景:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缓存&lt;/li&gt;&#xA;&lt;li&gt;状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;&#xA;&lt;p&gt;goroutine通过channel来传递消息.&lt;/p&gt;&#xA;&lt;p&gt;channels是引用类型,chan是线程安全的，并且不会有数据冲突。&lt;/p&gt;&#xA;&lt;p&gt;channel可以共享内置类型，命名类型，结构类型，引用类型的值或指针.&lt;/p&gt;&#xA;&lt;p&gt;chan通过make来创建，通过close来关闭．&lt;/p&gt;&#xA;&lt;p&gt;chan是先进先出的.&lt;/p&gt;&#xA;&lt;p&gt;如果chan指定了容量(有缓存), 就是异步，非阻塞模式．&lt;/p&gt;&#xA;&lt;p&gt;默认是无缓存的，同步的,　阻塞模式.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_builtin</title>
      <link>https://canuxcheng.com/post/gsl_builtin/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_builtin/</guid>
      <description>&lt;h1 id=&#34;builtin&#34;&gt;builtin&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/builtin/&#34;&gt;https://golang.org/pkg/builtin/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;go的builtin package.&lt;/p&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;true&#xA;false&#xA;iota&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;p&gt;pointer, slice, map, channel, func, interface的零值：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;nil&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分配并初始化各种类型的对象, 返回一个指针．&#xA;new(Type) *Type&#xA;&#xA;# 分配并初始化一个Slice/Map/Channel的对象,返回相同类型的对象.&#xA;make(t Type, size ...IntegerType) Type&#xA;&#xA;# 返回容量，　Array/ArrayPointer/Slice/Channel&#xA;cap(v Type) int&#xA;&#xA;# 返回长度，　String/Array/ArrayPointer/Slice/Map/Channel&#xA;len(v Type) int&#xA;&#xA;print(args ...Type)&#xA;&#xA;println(args ...Type)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;complex:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 把两个浮点数构造成一个复数&#xA;complex(r, i FloatType) ComplexType&#xA;&#xA;# 返回复数c的实部&#xA;real(c ComplexType) FloatType&#xA;&#xA;# 返回复数c的虚部&#xA;imag(c ComplexType) FloatType&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;slice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 向切片末尾追加元素，返回新的切片．切片长度增加.&#xA;# 如果长度超过底层数组长度，就创建了一个新的底层数组. 否则底层数组不变．&#xA;# 在元素不超过1000的情况下，自动创建的底层数组容量翻倍.&#xA;append(slice []Type, elems ...Type) []Type&#xA;&#xA;# 复制一个切片, 返回复制的元素的个数&#xA;copy(dst, src []Type) int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;map:&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_concurrency</title>
      <link>https://canuxcheng.com/post/gsl_concurrency/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_concurrency/</guid>
      <description>&lt;h1 id=&#34;sync&#34;&gt;sync&lt;/h1&gt;&#xA;&lt;p&gt;sync用于goroutine同步.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;locker&#34;&gt;Locker&lt;/h2&gt;&#xA;&lt;p&gt;一个可以加锁和解锁的接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Locker interface {&#xA;    Lock()&#xA;    Unlock()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pool&#34;&gt;Pool&lt;/h2&gt;&#xA;&lt;p&gt;Pool是一个可以分别存取的临时对象的集合。&lt;/p&gt;&#xA;&lt;h2 id=&#34;once&#34;&gt;Once&lt;/h2&gt;&#xA;&lt;p&gt;只执行一次动作的对象(单例模式)&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Once struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 只有第一次调用才执行&#xA;func (o *Once) Do(f func())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;&#xA;&lt;p&gt;互斥锁,锁和线程无关，可以由不同的线程加锁和解锁.&lt;/p&gt;&#xA;&lt;p&gt;Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。&lt;/p&gt;&#xA;&lt;p&gt;同一时刻只能有一个线程进入临界区.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Mutex struct {}&#xA;&#xA;Mutex&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 加锁，如果已经加锁，阻塞至m解锁．&#xA;func (m *Mutex) Lock()&#xA;&#xA;// 解锁，如果没有加锁，导致panic&#xA;func (m *Mutex) Unlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;rwmutex&#34;&gt;RWMutex&lt;/h2&gt;&#xA;&lt;p&gt;读写互斥锁,可以由不同的线程加锁和解锁.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type RWMutex struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 锁定为写入状态，禁止其它线程读写，一次只能有一个线程持有。&#xA;func (rw *RWMutex) Lock()&#xA;&#xA;// 解除写入锁定，如果没有加锁，导致panic&#xA;func (rw *RWMutex) Unlock()&#xA;&#xA;// 锁定为读取状态，禁止其他线程写入，多个线程可以同时持有读锁。&#xA;func (rw *RWMutex) RLock()&#xA;&#xA;// 解除读取锁，如果没有加锁，导致panic.&#xA;func (rw *RWMutex) RUnlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cond&#34;&gt;Cond&lt;/h2&gt;&#xA;&lt;p&gt;条件变量.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_cryptographic</title>
      <link>https://canuxcheng.com/post/gsl_cryptographic/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_cryptographic/</guid>
      <description>&lt;h1 id=&#34;crypto&#34;&gt;crypto&lt;/h1&gt;&#xA;&lt;p&gt;收集了常用的密码常量&lt;/p&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;RegisterHash(h Hash, f func() hash.Hash)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;publickey&#34;&gt;PublicKey&lt;/h2&gt;&#xA;&lt;p&gt;interface:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type PublicKey interface{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;privatekey&#34;&gt;PrivateKey&lt;/h2&gt;&#xA;&lt;p&gt;interface:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type PrivateKey interface{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Hash uint&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func (h Hash) Avaliable() bool&#xA;func (h Hash) Size() int&#xA;func (h Hash) New() hash.Hash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;cryptocipher&#34;&gt;crypto/cipher&lt;/h1&gt;&#xA;&lt;p&gt;用于包装底层块加密算法的实现.&lt;/p&gt;&#xA;&lt;h2 id=&#34;block&#34;&gt;Block&lt;/h2&gt;&#xA;&lt;p&gt;代表一个使用特定密钥的底层　加／解密器．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Block interface {&#xA;    BlockSize() int&#xA;    Encrypt(dst, src []byte)&#xA;    Decrypt(dst, src []byte)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;blockmode&#34;&gt;BlockMode&lt;/h2&gt;&#xA;&lt;p&gt;代表一个工作在块模式(CBC, ECB等)的加／解密器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type BlockMode interface {&#xA;    BlockSize() int&#xA;    CryptBlocks(dst, src []byte)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_data</title>
      <link>https://canuxcheng.com/post/gsl_data/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_data/</guid>
      <description>&lt;h1 id=&#34;time&#34;&gt;time&lt;/h1&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;p&gt;const:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    ANSIC       = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;&#xA;    Unixdate    = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;&#xA;    RFC3339     = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;&#xA;    ...&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 阻塞go程d代表的时间段&#xA;func Sleep(d Duration)&#xA;&#xA;func After(d Duration) &amp;lt;- chan Time&#xA;&#xA;func Tick(d Duration) &amp;lt;- chan Time&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;time-1&#34;&gt;Time&lt;/h2&gt;&#xA;&lt;p&gt;代表一个纳秒精度的时间点.&lt;/p&gt;&#xA;&lt;p&gt;零值是January 1, year 1, 00:00:00.000000000 UTC.&lt;/p&gt;&#xA;&lt;p&gt;struct:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type  Time struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 格式化一个时间, eg:　2009-11-10 15:00:00 -0800 PST&#xA;func date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time&#xA;&#xA;// 返回当前本地时间, eg: 2018-03-18 12:16:55.842029 +0800 CST m=+0.001962301&#xA;func Now() Time&#xA;&#xA;func Parse(layout, value s tring) (Time, error)&#xA;&#xA;func ParseInLocation(layout, value string, loc *Location) (Time, error)&#xA;&#xA;func Unix(sec int64, nsec int64) Time&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;methods:&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_database</title>
      <link>https://canuxcheng.com/post/gsl_database/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_database/</guid>
      <description>&lt;h1 id=&#34;databasesql&#34;&gt;database/sql&lt;/h1&gt;&#xA;&lt;p&gt;使用该包，必须提供一个数据库驱动&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/SQLDrivers&#34;&gt;https://github.com/golang/go/wiki/SQLDrivers&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;mssql driver:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/denisenkom/go-mssqldb&#34;&gt;https://github.com/denisenkom/go-mssqldb&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;mysql driver:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/go-sql-driver/mysql&#34;&gt;https://github.com/go-sql-driver/mysql&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;postgresql driver:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/lib/pq&#34;&gt;https://github.com/lib/pq&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jackc/pgx&#34;&gt;https://github.com/jackc/pgx&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// QueryRow 没有返回row时，调用返回值的Scan方法会返回该变量&#xA;var ErrNoRows = errors.New(&amp;quot;sql: no rows in result set&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 注册并命名一个数据库，在Open中使用该命名启用该驱动&#xA;// 如果注册同一名称两次或者driver参数为nil, 会导致panic.&#xA;Register(name string, driver driver.Driver)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;db&#34;&gt;DB&lt;/h2&gt;&#xA;&lt;p&gt;DB是一个数据库句柄，代表一个具有零到多个底层连接的连接池．&lt;/p&gt;&#xA;&lt;p&gt;可以安全的被多个go程同时使用．&lt;/p&gt;&#xA;&lt;p&gt;struct:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type DB struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;functions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 验证数据库驱动和参数,并不创建和数据库的连接．&#xA;// driverName: mssql, mysql, postgres&#xA;// mssql dataSourceName: &amp;quot;server=%s;port=%d;database=%s;user id=%s;password=%s&amp;quot;&#xA;// mysql dataSourceName: &amp;quot;user:password@tcp(server:port)/database&amp;quot;&#xA;Open(driverName, dataSourceName string) (*DB, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;methods:&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_file</title>
      <link>https://canuxcheng.com/post/gsl_file/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_file/</guid>
      <description>&lt;h1 id=&#34;path&#34;&gt;path&lt;/h1&gt;&#xA;&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool&#xA;func Join(elem ...string) string&#xA;func Split(path string) (dir, file string)&#xA;func Join(elem ...string) string&#xA;func Dir(path string) string&#xA;func Base(path string) string&#xA;func Ext(path string) string &#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;pathfilepath&#34;&gt;path/filepath&lt;/h1&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;Constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    Separator = os.PathSeparator&#xA;    ListSeparator = os.PathListSeparator&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variable&#34;&gt;Variable&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;var ErrBadPattern = errors.New(&amp;quot;Syntax error in pattern&amp;quot;)&#xA;&#xA;var SkipDir = errors.New(&amp;quot;skip this diractory&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;func IsAbs(path string) bool&#xA;func Abs(path string) (string, error)&#xA;&#xA;// 返回 targpath 相对于 basepath 的 路径 （相当于返回 targpath - basepath), 实际就是文件名.&#xA;func Rel(basepath, targpath string) (string, error)&#xA;&#xA;func Split(path string) (dir, file string)&#xA;func Join(elem ...string) string&#xA;func Dir(path string) string&#xA;func Base(path string) string&#xA;func Ext(path string) string) // 包括小数点&#xA;func Walk(root string, walkFn WalkFunc) error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;walkfunc&#34;&gt;WalkFunc&lt;/h2&gt;&#xA;&lt;p&gt;调用Walk时会对每个目录和文件调用该函数.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_golang</title>
      <link>https://canuxcheng.com/post/gsl_golang/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_golang/</guid>
      <description>&lt;h1 id=&#34;runtime&#34;&gt;runtime&lt;/h1&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 指定编译器&#xA;const Compiler = &amp;quot;gc&amp;quot;/&amp;quot;gccgo&amp;quot;&#xA;&#xA;// 处理器架构: 386/amd64/arm&#xA;const GOARCH string = theGoarch&#xA;&#xA;// 操作系统: linux/freebsd/darwin/win&#xA;const GOOS string = theGoos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;var MemProfileRate int = 512 * 1024&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;func GOROOT() string&#xA;func Version() string&#xA;&#xA;// 返回本地机器的逻辑cpu个数&#xA;func NumCPU() int&#xA;&#xA;//更改调度器可以使用的逻辑cpu数量, 默认只用一个cpu.&#xA;func GOMAXPROCS(n int) int&#xA;&#xA;// 使当前goroutine让出绑定的cpu,其它goroutine可以继续执行.&#xA;// 当前goroutine放回队列等待继续执行.&#xA;func Gosched()&#xA;&#xA;// 终止当前goroutine,终止前执行所有defer.&#xA;func Goexit()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;runtimedebug&#34;&gt;runtime/debug&lt;/h1&gt;&#xA;&lt;h2 id=&#34;function&#34;&gt;function&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 设置最大线程数，默认1000.&#xA;func SetMaxThreads(threads int) int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;runtimecgo&#34;&gt;runtime/cgo&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;runtimepprof&#34;&gt;runtime/pprof&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;runtimerace&#34;&gt;runtime/race&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;runtimetrace&#34;&gt;runtime/trace&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go&#34;&gt;go&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;expvar&#34;&gt;expvar&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;context&#34;&gt;context&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;unsafe&#34;&gt;unsafe&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;errors&#34;&gt;errors&lt;/h1&gt;&#xA;&lt;h2 id=&#34;function-1&#34;&gt;function&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 使用字符串创建一个错误, 返回一个error&#xA;func New(text string) error&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>GSL_math</title>
      <link>https://canuxcheng.com/post/gsl_math/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_math/</guid>
      <description>&lt;h1 id=&#34;math&#34;&gt;math&lt;/h1&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;mathbig&#34;&gt;math/big&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;mathcmplx&#34;&gt;math/cmplx&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;mathrand&#34;&gt;math/rand&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;sort&#34;&gt;sort&lt;/h1&gt;&#xA;&lt;h2 id=&#34;functions-1&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;func Ints(a []int)&#xA;func IntAreSorted(a []int) bool&#xA;func SearchInts(a []int, x int) int&#xA;&#xA;func Float64s(a []float64)&#xA;func Float64sArerSorted(a []float64) bool&#xA;func SearchFloat64s(a []float64, x float64) int&#xA;&#xA;func Strings(a []string)&#xA;func StringsAreSorted(a []string) bool&#xA;func SearchStrings(a []string, x string) int&#xA;&#xA;func Sort(data Interface)&#xA;func Stable(data Interface)&#xA;func IsSorted(data Interface) bool&#xA;func Reverse(data Interface) Interface&#xA;// 二分查找&#xA;func Search(n int, f func(int) bool) int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;interface&#34;&gt;Interface&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Interface interface {&#xA;    Len() int&#xA;    Less(i, j int) bool&#xA;    Swap(i, j int)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;initslice&#34;&gt;InitSlice&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;type InitSlice []int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;float64slice&#34;&gt;Float64Slice&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Float64Slice []float64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;stringslice&#34;&gt;StringSlice&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;type StringSlice []string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>GSL_multimedia</title>
      <link>https://canuxcheng.com/post/gsl_multimedia/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_multimedia/</guid>
      <description>&lt;h1 id=&#34;image&#34;&gt;image&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;mime&#34;&gt;mime&lt;/h1&gt;</description>
    </item>
    <item>
      <title>GSL_network</title>
      <link>https://canuxcheng.com/post/gsl_network/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_network/</guid>
      <description>&lt;h1 id=&#34;net&#34;&gt;net&lt;/h1&gt;&#xA;&lt;p&gt;网络IO接口，包括TCP/IP, UDP, SOCKET, DNS&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;net&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    IPv4len = 4&#xA;    IPv6len = 16&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;addr&#34;&gt;Addr&lt;/h2&gt;&#xA;&lt;p&gt;代表一个网络终端地址．&lt;/p&gt;&#xA;&lt;p&gt;TCPAddr, UDPAddr, IPAddr, UnixAddr 都实现了该接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Addr interface {&#xA;    Network() string&#xA;    String() string&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;tcpaddr&#34;&gt;TCPAddr&lt;/h2&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func ResolveTCPAddr(net, addr string) (*TCPAddr, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;udpaddr&#34;&gt;UDPAddr&lt;/h2&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func ResolveUDPAddr(net, addr string) (*UDPAddr, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ipaddr&#34;&gt;IPAddr&lt;/h2&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func ResolveIPAddr(net, addr string) (*IPAddr, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;unixaddr&#34;&gt;UnixAddr&lt;/h2&gt;&#xA;&lt;p&gt;function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func ResolveUnixAddr(net, addr string) (*UnixAddr, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;conn&#34;&gt;Conn&lt;/h2&gt;&#xA;&lt;p&gt;该接口代表通用的面向流的网络连接．&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_oop</title>
      <link>https://canuxcheng.com/post/gsl_oop/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_oop/</guid>
      <description>&lt;h1 id=&#34;reflect&#34;&gt;reflect&lt;/h1&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;p&gt;const:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;const (&#xA;    SelectSend&#xA;    SelectRecv&#xA;    SelectDefault&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 将src拷贝到dst, 直到src被耗尽或dst被装满.&#xA;func Copy(dst, src Value) int&#xA;&#xA;// 判断两个值是否深度一致&#xA;func DeepEqual(a1, a2 interface{}) bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;kind&#34;&gt;Kind&lt;/h2&gt;&#xA;&lt;p&gt;表示Type类型值表示的具体分类.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Kind uint&#xA;&#xA;const (&#xA;    Invalid Kind = iota&#xA;    Bool&#xA;    Int&#xA;    ...&#xA;    Uint&#xA;    ...&#xA;    Float...&#xA;    Complex...&#xA;    Array&#xA;    Chan&#xA;    Func&#xA;    Interface&#xA;    Map&#xA;    Ptr&#xA;    Slice&#xA;    String&#xA;    Struct&#xA;    UnsafePointer&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func (k Kind) String() string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;stringheader&#34;&gt;StringHeader&lt;/h2&gt;&#xA;&lt;h2 id=&#34;sliceheader&#34;&gt;SliceHeader&lt;/h2&gt;&#xA;&lt;h2 id=&#34;structfield&#34;&gt;StructField&lt;/h2&gt;&#xA;&lt;h2 id=&#34;structtag&#34;&gt;StructTag&lt;/h2&gt;&#xA;&lt;h2 id=&#34;chandir&#34;&gt;ChanDir&lt;/h2&gt;&#xA;&lt;h2 id=&#34;selectdir&#34;&gt;SelectDir&lt;/h2&gt;&#xA;&lt;h2 id=&#34;selectcase&#34;&gt;SelectCase&lt;/h2&gt;&#xA;&lt;h2 id=&#34;method&#34;&gt;Method&lt;/h2&gt;&#xA;&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;&#xA;&lt;p&gt;用来表示一个go类型.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_string</title>
      <link>https://canuxcheng.com/post/gsl_string/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_string/</guid>
      <description>&lt;h1 id=&#34;strings&#34;&gt;strings&lt;/h1&gt;&#xA;&lt;p&gt;实现了用于操作字符的函数.&lt;/p&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;func EqualFold(s, t string) bool&#xA;&#xA;func HasPrefix(s, prefix string) bool&#xA;func HasSuffix(s, suffix string) bool&#xA;&#xA;func Count(s, sep string) int&#xA;&#xA;func Contains(s, substr string) bool&#xA;...&#xA;&#xA;func Index(s, sep string) int&#xA;...&#xA;&#xA;func LastIndex(s, sep string) int&#xA;...&#xA;&#xA;func title(s string) string&#xA;&#xA;func ToLower(s string) string&#xA;...&#xA;&#xA;// 返回count个string&#xA;func Repeat(s string, count int) string&#xA;&#xA;func Replace(s, old, new string, n int) string&#xA;&#xA;func Map(mapping func(rune) rune, s string) string&#xA;&#xA;func Trim(s string, cutset string) string&#xA;...&#xA;&#xA;// 返回将字符串按照空白分割的多个字符串&#xA;func Fields(s string) []string&#xA;// 按照f作为分隔符来分割字符串，返回切片&#xA;func FieldsFunc(s string, f func(rune) bool) []string&#xA;&#xA;func Split(s, sep string) []string&#xA;...&#xA;&#xA;// 将一系列字符串连接为一个字符串，之间用sep来分割.&#xA;func Join(a []string, sep string) string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;&#xA;&lt;h2 id=&#34;replacer&#34;&gt;Replacer&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;bytes&#34;&gt;bytes&lt;/h1&gt;&#xA;&lt;p&gt;实现了操作[]bytes的常用函数.&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_system</title>
      <link>https://canuxcheng.com/post/gsl_system/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_system/</guid>
      <description>&lt;h1 id=&#34;os&#34;&gt;os&lt;/h1&gt;&#xA;&lt;p&gt;提供了操作系统的不依赖平台的接口&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;os&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# flag 参数&#xA;const (&#xA;    O_RDONLY int = syscall.O_RDONLY&#xA;    O_WRONLY int = syscall.O_WRONLY&#xA;    O_RDWR int = syscall.O_RDWR&#xA;    O_CREATE int = syscall.O_CREATE # 不存在就创建&#xA;    O_APPEND int = syscall.O_APPEND # 追加写入&#xA;    O_TRUNC int = syscall.O_TRUNC # 打开时清空文件&#xA;    O_EXCL int = syscall.O_EXCL&#xA;    O_SYNC int = syscall.O_SYNC&#xA;)&#xA;&#xA;const (&#xA;    SEEK_SET int = 0&#xA;    SEEK_CUR int = 1&#xA;    SEEK_END int = 2&#xA;)&#xA;&#xA;const (&#xA;    // 操作系统指定的路径分隔符&#xA;    PathSeperator = &#39;/&#39;&#xA;    // 操作系统指定的表分隔符&#xA;    PathListSeparator = &#39;:&#39;&#xA;)&#xA;&#xA;// 操作系统空设备的名字&#xA;const DevNull = &amp;quot;/dev/null&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;var (&#xA;    ErrInvalid = errors.New(&amp;quot;invalid argument&amp;quot;)&#xA;    ...&#xA;)&#xA;&#xA;// 指向标准输入／输出／错误的文件描述符&#xA;var (&#xA;    Stdin = NewFile(uintptr(syscall.Stdin), &amp;quot;/dev/stdin&amp;quot;)&#xA;    Stdout = NewFile(uintptr(syscall.Stdout), &amp;quot;/dev/stdout&amp;quot;)&#xA;    Stderr = NewFile(uintptr(syscall.Stderr), &amp;quot;/dev/stderr&amp;quot;)&#xA;)&#xA;&#xA;// 保存了命令行参数，第一个是程序名&#xA;var Args []string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 返回内核提供的主机名&#xA;func Hostname() (name string, err error)&#xA;&#xA;// 当前程序以给出的状态码马上退出，defer不会执行&#xA;func Exit(code int)&#xA;&#xA;// 返回key=value格式的环境变量的字符串的切片拷贝&#xA;func Environ() []string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;文件相关的操作&lt;/p&gt;</description>
    </item>
    <item>
      <title>GSL_test</title>
      <link>https://canuxcheng.com/post/gsl_test/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/gsl_test/</guid>
      <description>&lt;h1 id=&#34;testing&#34;&gt;testing&lt;/h1&gt;&#xA;&lt;p&gt;go的测试由go test命令和testing包组成．&lt;/p&gt;&#xA;&lt;p&gt;测试程序命名：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;XXX.go # 测试文件和源码放在一个包中&#xA;XXX_test.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;测试程序结构：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import &amp;quot;testing&amp;quot;&#xA;&#xA;# 单元测试&#xA;# go test 会自动执行&#xA;func TestXXX(t *testing.T) {}&#xA;&#xA;# 性能测试&#xA;# go test XXX_test.go -test.bench=&amp;quot;.*&amp;quot;  压力测试需要指定才能执行&#xA;func BenchmarkXXX(b *testing.B) {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;constants&#34;&gt;constants&lt;/h2&gt;&#xA;&lt;h2 id=&#34;variables&#34;&gt;variables&lt;/h2&gt;&#xA;&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;&#xA;&lt;h2 id=&#34;t&#34;&gt;T&lt;/h2&gt;&#xA;&lt;p&gt;管理测试状态并支持格式化测试的日志．&lt;/p&gt;&#xA;&lt;p&gt;struct:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type T struct {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;methods:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 将当前测试标识为失败，但继续执行该文件剩下的测试&#xA;func (c *T) Fail()&#xA;&#xA;// 将当前测试标识为失败，并停止执行该测试, 继续执行下一个测试文件.&#xA;func (c *T) FailNow()&#xA;&#xA;// 用于报告测试函数是否失败&#xA;func (c *T) Failed() bool&#xA;&#xA;func (c *T) Log(args ...interface{})&#xA;func (c *T) Logf(format string, args ...interface{})&#xA;&#xA;# 相当于Log/Logf之后调用Fail.(当前case失败)&#xA;func (c *T) Error(args ...interface{})&#xA;func (c *T) Errorf(format string, args ...interface{})&#xA;&#xA;# 相当于Log/Logf之后调用FailNow.(当前测试文件失败)&#xA;func (c *T) Fatal(args ...interface{})&#xA;func (c *T) Fatalf(format string, args ...interface{})&#xA;&#xA;func (c *T) Skip(args ...interface{})&#xA;func (c *T) SkipNow()&#xA;func (c *T) Skipf(format string, args ...interface{})&#xA;func (c *T) Skipped() bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;b&#34;&gt;B&lt;/h2&gt;&#xA;&lt;p&gt;管理基准测试的计时行为，并指示应该迭代的运行测试多少次.&lt;/p&gt;</description>
    </item>
    <item>
      <title>OOP</title>
      <link>https://canuxcheng.com/post/go_oop/</link>
      <pubDate>Mon, 01 Jan 2018 10:49:21 +0000</pubDate>
      <guid>https://canuxcheng.com/post/go_oop/</guid>
      <description>&lt;h1 id=&#34;go面向对象&#34;&gt;Go面向对象&lt;/h1&gt;&#xA;&lt;p&gt;golang通过方法和接口实现面向对象.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;方法method&#34;&gt;方法/method&lt;/h1&gt;&#xA;&lt;p&gt;go中没有类，但是可以为结构体定义方法．&lt;/p&gt;&#xA;&lt;p&gt;方法就是一类带有特殊的　接收者参数　的函数．&lt;/p&gt;&#xA;&lt;p&gt;只能为同一包内定义的类型的接收者申明方法，不能为其它包内定义的类型的接收者申明方法．&lt;/p&gt;&#xA;&lt;p&gt;除了结构体还可以为非结构体申明方法，但是不能为内建类型申明方法．&lt;/p&gt;&#xA;&lt;p&gt;方法有两种接收者,值接收者和指针接收者.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type Vertex struct {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;值接收者:&lt;/p&gt;&#xA;&lt;p&gt;值接收者操作的是值的副本.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func (v Vertex) MethodName() rType {&#xA;    ...&#xA;}&#xA;&#xA;var v Vertex&#xA;v.MethodName() // 操作值的副本&#xA;&#xA;# 使用指针接收者来调用值接收者的方法，编译器会自动做类型转换&#xA;vp := new(Vertex)&#xA;vp.MethodName() // 指针被解引用为值,(*vp).MethodName(),操作的是指针指向的值的副本.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;指针接收者：&lt;/p&gt;&#xA;&lt;p&gt;指针接收者，调用方法的时候操作的是该指针指向的值.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 指针接收者的方法可以修改接收者指向的值&#xA;func (v *Vertex) MethodName() rType {&#xA;    ...&#xA;}&#xA;&#xA;vp := new(Vertex)&#xA;vp.MethodName() // 操作实际的值&#xA;&#xA;# 使用值接收者来调用指针接收者的方法，编译器会自动做类型转换.&#xA;var v Vertex&#xA;v.MethodName() // (&amp;amp;v).MethodName() , 操作的是实际的值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;接口interface&#34;&gt;接口/Interface&lt;/h1&gt;&#xA;&lt;p&gt;接口是引用类型.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
