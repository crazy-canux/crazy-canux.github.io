<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CNCF on Morgoth</title>
    <link>https://canuxcheng.com/categories/cncf/</link>
    <description>Recent content in CNCF on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Oct 2023 20:03:39 +0800</lastBuildDate>
    <atom:link href="https://canuxcheng.com/categories/cncf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Security</title>
      <link>https://canuxcheng.com/post/k8s_security/</link>
      <pubDate>Thu, 19 Oct 2023 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_security/</guid>
      <description>&lt;h1 id=&#34;k8s-security&#34;&gt;K8S Security&lt;/h1&gt;&#xA;&lt;h2 id=&#34;tetragon&#34;&gt;Tetragon&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cilium/tetragon&#34;&gt;https://github.com/cilium/tetragon&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;falco&#34;&gt;Falco&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/falcosecurity/falco&#34;&gt;https://github.com/falcosecurity/falco&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Gateway</title>
      <link>https://canuxcheng.com/post/k8s_apigateway/</link>
      <pubDate>Fri, 04 Aug 2023 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_apigateway/</guid>
      <description>&lt;h1 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api&#34;&gt;https://github.com/kubernetes-sigs/gateway-api&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;GatewayClass没有namespace&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;emissary ingress&lt;/li&gt;&#xA;&lt;li&gt;kong&lt;/li&gt;&#xA;&lt;li&gt;higress&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Application</title>
      <link>https://canuxcheng.com/post/cncf_application/</link>
      <pubDate>Sat, 04 Dec 2021 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/cncf_application/</guid>
      <description>&lt;h1 id=&#34;application-definition--image-build&#34;&gt;Application Definition &amp;amp; Image Build&lt;/h1&gt;&#xA;&lt;p&gt;application choreography.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;helm&lt;/li&gt;&#xA;&lt;li&gt;backstage&lt;/li&gt;&#xA;&lt;li&gt;buildpack.io&lt;/li&gt;&#xA;&lt;li&gt;operatorframework&lt;/li&gt;&#xA;&lt;li&gt;dapr&lt;/li&gt;&#xA;&lt;li&gt;kubevela&lt;/li&gt;&#xA;&lt;li&gt;kubevirt&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;backstage&#34;&gt;backstage&lt;/h2&gt;</description>
    </item>
    <item>
      <title>KubeVirt</title>
      <link>https://canuxcheng.com/post/k8s_kubevirt/</link>
      <pubDate>Mon, 10 May 2021 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_kubevirt/</guid>
      <description>&lt;h1 id=&#34;kubevirt&#34;&gt;KubeVirt&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubevirt.io/quickstart_cloud/&#34;&gt;https://kubevirt.io/quickstart_cloud/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://quay.io/organization/kubevirt&#34;&gt;https://quay.io/organization/kubevirt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html&#34;&gt;https://docs.fedoraproject.org/en-US/quick-docs/using-nested-virtualization-in-kvm/index.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;virtctl&#34;&gt;virtctl&lt;/h2&gt;&#xA;&lt;h2 id=&#34;vm&#34;&gt;VM&lt;/h2&gt;&#xA;&lt;p&gt;创建vm&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: kubevirt.io/v1&#xA;kind: VirtualMachine&#xA;metadata:&#xA;name: testvm&#xA;spec:&#xA;running: false&#xA;template:&#xA;    metadata:&#xA;    labels:&#xA;        kubevirt.io/size: small&#xA;        kubevirt.io/domain: testvm&#xA;    spec:&#xA;    domain:&#xA;        devices:&#xA;        disks:&#xA;            - name: containerdisk&#xA;            disk:&#xA;                bus: virtio&#xA;            - name: cloudinitdisk&#xA;            disk:&#xA;                bus: virtio&#xA;        interfaces:&#xA;        - name: default&#xA;            masquerade: {}&#xA;        resources:&#xA;        requests:&#xA;            memory: 64M&#xA;    networks:&#xA;    - name: default&#xA;        pod: {}&#xA;    volumes:&#xA;        - name: containerdisk&#xA;        containerDisk:&#xA;            image: quay.io/kubevirt/cirros-container-disk-demo&#xA;        - name: cloudinitdisk&#xA;        cloudInitNoCloud:&#xA;            userDataBase64: SGkuXG4=&#xA;    nodeSelector:&#xA;        kubernetes.io/arch: arm64&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>AWS Containers</title>
      <link>https://canuxcheng.com/post/aws_containers/</link>
      <pubDate>Fri, 23 Apr 2021 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/aws_containers/</guid>
      <description>&lt;h1 id=&#34;aws-containers&#34;&gt;AWS Containers&lt;/h1&gt;&#xA;&lt;h2 id=&#34;ecr&#34;&gt;ECR&lt;/h2&gt;&#xA;&lt;p&gt;Elastic Container Registry.&lt;/p&gt;&#xA;&lt;h2 id=&#34;ecs-anywhere&#34;&gt;ECS Anywhere&lt;/h2&gt;&#xA;&lt;h2 id=&#34;ecs&#34;&gt;ECS&lt;/h2&gt;&#xA;&lt;p&gt;Elastic Container Service.&lt;/p&gt;&#xA;&lt;h2 id=&#34;eks-distro&#34;&gt;EKS Distro&lt;/h2&gt;&#xA;&lt;h2 id=&#34;eks-anywhere&#34;&gt;EKS Anywhere&lt;/h2&gt;&#xA;&lt;h2 id=&#34;eks&#34;&gt;EKS&lt;/h2&gt;&#xA;&lt;p&gt;Elastic Kubernetes Service.&lt;/p&gt;&#xA;&lt;h3 id=&#34;通过aws-cli创建eks&#34;&gt;通过AWS CLI创建EKS&lt;/h3&gt;&#xA;&lt;p&gt;通过MC创建的资源都可以通过CLI(aws)创建.&lt;/p&gt;&#xA;&lt;p&gt;创建具有公有和私有子网且符合 Amazon EKS 要求的 Amazon VPC&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ aws cloudformation create-stack \&#xA;--stack-name my-eks-vpc-stack \&#xA;--region region-code \&#xA;--template-url https://amazon-eks.s3.us-west-2.amazonaws.com/cloudformation/2020-10-29/amazon-eks-vpc-private-subnets.yaml &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;创建集群 IAM 角色并向其附加所需的 Amazon EKS IAM 托管策略&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 创建EKS IAM role&#xA;aws iam create-role \&#xA;--role-name my-EKSClusterRole \&#xA;--assume-role-policy-document file://cluster-role-trust-policy.json&amp;quot; \&#xA;--permissions-boundary arn:aws:iam::&amp;lt;Your AWS ID&amp;gt;:policy/ProjAdminsPermBoundaryv2&#xA;&#xA;{&#xA;    &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,&#xA;    &amp;quot;Statement&amp;quot;: [&#xA;        {&#xA;            &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,&#xA;            &amp;quot;Principal&amp;quot;: {&#xA;                &amp;quot;Service&amp;quot;: &amp;quot;eks.amazonaws.com&amp;quot;&#xA;            },&#xA;            &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;,&#xA;            &amp;quot;Condition&amp;quot;: {}&#xA;        }&#xA;    ]&#xA;}&#xA;&#xA;// 绑定role和eks策略&#xA;aws iam attach-role-policy \&#xA;--policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy \&#xA;--role-name my-EKSClusterRole&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;创建EKS cluster:&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S CNI</title>
      <link>https://canuxcheng.com/post/k8s_cni/</link>
      <pubDate>Thu, 26 Mar 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_cni/</guid>
      <description>&lt;h1 id=&#34;network-add-ons&#34;&gt;Network add-ons&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/containernetworking&#34;&gt;https://github.com/containernetworking&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;flannel&lt;/li&gt;&#xA;&lt;li&gt;cilium&lt;/li&gt;&#xA;&lt;li&gt;calico&lt;/li&gt;&#xA;&lt;li&gt;vpc-cni (aws)&lt;/li&gt;&#xA;&lt;li&gt;kube-router&lt;/li&gt;&#xA;&lt;li&gt;weavenet&lt;/li&gt;&#xA;&lt;li&gt;antrea&lt;/li&gt;&#xA;&lt;li&gt;romana&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;cilium&#34;&gt;cilium&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cilium/cilium&#34;&gt;https://github.com/cilium/cilium&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;flannel&#34;&gt;Flannel&lt;/h2&gt;&#xA;&lt;p&gt;flannel是k8s最常用的网络插件.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/coreos/flannel&#34;&gt;https://github.com/coreos/flannel&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在所有node上部署cni-plugin:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/containernetworking/plugins/releases&#34;&gt;https://github.com/containernetworking/plugins/releases&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /opt/cni/bin&#xA;// 下载并解压所有插件命令到该目录.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;network-addon(master上操作即可):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;veryfy:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ kubectl get nodes&#xA;$ kubectl get pod --all-namespaces&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;删除插件:&lt;/p&gt;&#xA;&lt;p&gt;删除插件会影响已经部署的pod.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 删除flannel &#xA;$ kubectl delete -f X.yml  &#xA;$ sudo systemctl stop kubelet docker&#xA;&#xA;// 第二步，在node节点清理flannel网络留下的文件&#xA;ifconfig cni0 down&#xA;ip link delete cni0 &#xA;ifconfig flannel.1 down&#xA;ip link delete flannel.1 &#xA;rm -rf /var/lib/cni /etc/cni /run/flannel&#xA;$ sudo rm -rf /var/lib/kubelet /var/lib/etcd&#xA;&#xA;// 重启kubelet&#xA;$ sudo systemctl start kubelet docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;修改配置:&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S CSI</title>
      <link>https://canuxcheng.com/post/k8s_csi/</link>
      <pubDate>Wed, 25 Mar 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_csi/</guid>
      <description>&lt;h1 id=&#34;csi&#34;&gt;CSI&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/container-storage-interface/spec&#34;&gt;https://github.com/container-storage-interface/spec&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;rook&lt;/li&gt;&#xA;&lt;li&gt;cubefs&lt;/li&gt;&#xA;&lt;li&gt;longhorn&lt;/li&gt;&#xA;&lt;li&gt;ceph&lt;/li&gt;&#xA;&lt;li&gt;minio&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;卷volume&#34;&gt;卷Volume&lt;/h2&gt;&#xA;&lt;p&gt;和docker中的一样。&lt;/p&gt;&#xA;&lt;p&gt;volume支持的卷类型有: awsEBS, azureDisk, azureFile, gcePD, secret, configMap, emptyDir, hostPath, local, nfs等.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: test-ebs&#xA;spec:&#xA;  containers:&#xA;  - image: k8s.gcr.io/test-webserver&#xA;    name: test-container&#xA;    volumeMounts:&#xA;    - mountPath: /test-ebs&#xA;      name: test-volume&#xA;  volumes:&#xA;  - name: test-volume&#xA;    # 此 AWS EBS 卷必须已经存在&#xA;    awsElasticBlockStore:&#xA;      volumeID: &amp;quot;&amp;lt;volume-id&amp;gt;&amp;quot;&#xA;      fsType: ext4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;AWS的EBS和EFS需要安装驱动:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&#34;&gt;https://github.com/kubernetes-sigs/aws-ebs-csi-driver&lt;/a&gt;&#xA;&lt;a href=&#34;https://github.com/kubernetes-sigs/aws-efs-csi-driver&#34;&gt;https://github.com/kubernetes-sigs/aws-efs-csi-driver&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;存储类storageclass&#34;&gt;存储类StorageClass&lt;/h2&gt;&#xA;&lt;p&gt;storageclass没有namespace.&lt;/p&gt;&#xA;&lt;p&gt;每个存储类包含provisioner, parameters和reclaimPolicy.&lt;/p&gt;&#xA;&lt;p&gt;内置provisioner的卷插件:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;awsEBS&lt;/li&gt;&#xA;&lt;li&gt;azureFile&lt;/li&gt;&#xA;&lt;li&gt;azureDisk&lt;/li&gt;&#xA;&lt;li&gt;gcePD&lt;/li&gt;&#xA;&lt;li&gt;openstack cinder&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;没有provisioner的卷类型可以使用外部插件或者自己开发.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner&#34;&gt;https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubectl</title>
      <link>https://canuxcheng.com/post/k8s_kubectl/</link>
      <pubDate>Fri, 10 Jan 2020 20:58:01 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_kubectl/</guid>
      <description>&lt;h1 id=&#34;kubectl&#34;&gt;kubectl&lt;/h1&gt;&#xA;&lt;p&gt;kubectl是kubernetes的管理工具.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/#kubectl&#34;&gt;https://kubernetes.io/docs/tasks/tools/#kubectl&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cloudnativelabs/kube-shell&#34;&gt;https://github.com/cloudnativelabs/kube-shell&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jonmosco/kube-ps1&#34;&gt;https://github.com/jonmosco/kube-ps1&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ahmetb/kubectx&#34;&gt;https://github.com/ahmetb/kubectx&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在master上通过kubectl命令管理集群.&lt;/p&gt;&#xA;&lt;p&gt;kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.24 版本的客户端能与 v1.23、 v1.24 和 v1.25 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl options # 查看所有命令可用选项&#xA;&#xA;--kubeconfig&#xA;kubectl --kubeconfig=$HOME/.kube.config (default)&#xA;&#xA;-n/--namespace&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;basic-command&#34;&gt;basic command&lt;/h2&gt;&#xA;&lt;p&gt;create:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 通过yaml或json文件创建资源&#xA;$ kubectl create -f FILENAME [options]&#xA;&#xA;options:&#xA;-f/--filename&#xA;&#xA;kubectl create secret tls kubernetes-dashboard-tls --key ca.key --cert ca.crt -n kubernetes-dashboard&#xA;&#xA;// 输出一个资源的yaml格式.&#xA;kubectl create deployment &amp;lt;name&amp;gt; --image=&amp;lt;img-name&amp;gt; --dry-run=client --output=yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;delete:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 删除资源&#xA;$ kubectl delete (-f FILENAME | -k DICT | TYPE [(NAME|-l label|--all)]) [optiions]&#xA;&#xA;options:&#xA;-f/--filename&#xA;--all  &#xA;--all-namespaces&#xA;--force&#xA;&#xA;$ kubectl delete pods --all&#xA;$ kubectl delete pod &amp;lt;name&amp;gt;&#xA;// 删除指定ns下所有资源.&#xA;$ kubectl delete all --all -n {namespace}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;删除带有finalizers字段的对象，对象实际被更新了，没有真的被删除。可以通过patch来删除。&lt;/p&gt;</description>
    </item>
    <item>
      <title>CI/CD</title>
      <link>https://canuxcheng.com/post/k8s_cicd/</link>
      <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_cicd/</guid>
      <description>&lt;h1 id=&#34;continuous-integration--delivery&#34;&gt;Continuous Integration &amp;amp; Delivery&lt;/h1&gt;&#xA;&lt;h2 id=&#34;argo-cd&#34;&gt;argo-cd&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/argoproj/argo-cd&#34;&gt;https://github.com/argoproj/argo-cd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;flux-cd&#34;&gt;flux-cd&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fluxcd/flux&#34;&gt;https://github.com/fluxcd/flux&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Contribution</title>
      <link>https://canuxcheng.com/post/k8s_oss/</link>
      <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_oss/</guid>
      <description>&lt;h1 id=&#34;kubernetes-contribution&#34;&gt;Kubernetes Contribution&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/guide/contributor-cheatsheet/README-zh.md&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建google账号&#34;&gt;创建google账号&lt;/h2&gt;&#xA;&lt;p&gt;推荐申请一个google邮箱。&lt;/p&gt;&#xA;&lt;p&gt;在开发机配置git&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ git config --global user.email name@gmail.com   &#xA;$ git config user.email name@gmail.com            &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;签cla并阅读coc&#34;&gt;签CLA并阅读CoC&lt;/h2&gt;&#xA;&lt;p&gt;个人开发者需要签署CLA, 选择individual contributors并用github账号登陆，然后去邮箱授权；之后重新进入，再去邮箱签字。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://identity.linuxfoundation.org/projects/cncf&#34;&gt;https://identity.linuxfoundation.org/projects/cncf&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;读一下CoC和CV&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34;&gt;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/values.md&#34;&gt;https://github.com/kubernetes/community/blob/master/values.md&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;配置开发环境&#34;&gt;配置开发环境&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/README.md#setting-up-your-dev-environment-coding-and-debugging&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以在docker里面编译，也可以直接在操作系统上编译。&lt;/p&gt;&#xA;&lt;p&gt;在docker里面编译&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md&#34;&gt;https://github.com/kubernetes/kubernetes/blob/ae9ca48f01ddb03731e7903cfe91ef3db9ce8990/build/README.md&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;build/run.sh make 只编译linux平台&#xA;build/run.sh make cross 编译所有平台&#xA;build/run.sh make kubectl KUBE_BUILD_PLATFORMS=darwin/amd64 编译指定平台的指定组件&#xA;&#xA;build/run.sh make test 单元测试&#xA;build/run.sh make test-integration 集成测试&#xA;build/run.sh make test-cmd  命令行测试&#xA;&#xA;build/copy-output.sh 将编译的binary从_output/dockerized/bin拷贝到本地&#xA;&#xA;build/make-clean.sh 清空_output&#xA;&#xA;build.shell.sh 交互模式进入编译的container&#xA;&#xA;build/release.sh 编译，测试，打包，kubernetes.tar.gz&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在操作系统上编译&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/development.md#building-kubernetes-on-a-local-osshell-environment&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装依赖&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;sudo apt-get install build-essential&#xA;// apt: docker, rsync, jq, go, &#xA;// python: pyyaml,&#xA;&#xA;// 安装etcd用于集成测试&#xA;./hack/install-etcd.sh&#xA;export PATH=&amp;quot;$GOPATH/src/k8s.io/kubernetes/third_party/etcd:${PATH}&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;编译和测试&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S API</title>
      <link>https://canuxcheng.com/post/k8s_api/</link>
      <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_api/</guid>
      <description>&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;&#xA;&lt;p&gt;api-server统一的操作入口.&lt;/p&gt;&#xA;&lt;p&gt;kubectl, UI, 等都是通过api-server操作资源.&lt;/p&gt;&#xA;&lt;p&gt;payload可以是json，也可以是yaml.&lt;/p&gt;&#xA;&lt;p&gt;yaml文件中#表示行注释。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;yaml&#34;&gt;yaml&lt;/h1&gt;&#xA;&lt;p&gt;部署k8s可以通过yaml文件来配置资源.&lt;/p&gt;&#xA;&lt;p&gt;资源对象组成部分:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: &#xA;kind: &#xA;metadata: 元数据&#xA;spec: 期望的状态&#xA;status: 观测到的状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看apiVersion:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl api-versions&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看Kind:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl api-resources&#xA;&#xA;# In a namespace&#xA;kubectl api-resources --namespaced=true&#xA;&#xA;# Not in a namespace&#xA;kubectl api-resources --namespaced=false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;metadata:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;metadata:&#xA;&#xA;  name:&#xA;  namespace:&#xA;&#xA;  labels/标签: 用户筛选资源，唯一的资源组合方法, 可以使用selector来查询.&#xA;&#xA;  annotations/注解: 存储资源的非标识性信息，扩展资源的spec/status.&#xA;&#xA;  ownerReference/关系: 方便反向查找创建资源的对象，方便进行级联删除。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;spec:&lt;/p&gt;&#xA;&lt;p&gt;status:&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;调度抢占驱逐&#34;&gt;调度，抢占，驱逐&lt;/h1&gt;&#xA;&lt;p&gt;taints: 污点，使节点排斥特定pod。应用于node。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;taints:&#xA;- effect: NoSchedule&#xA;  key: kubernetes.io/arch&#xA;  value: arm64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;tolerations: 容忍度，使pod被吸引到特定节点。应用于pod。&#xA;这个只能让pod能部署到加了污点的node，pod也能部署到其它没有加污点的node。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Operator</title>
      <link>https://canuxcheng.com/post/k8s_operator/</link>
      <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_operator/</guid>
      <description>&lt;h1 id=&#34;operator&#34;&gt;Operator&lt;/h1&gt;&#xA;&lt;p&gt;TPR(Third Party Resource) 在k8s 1.7 被集成，并命名为CRD(Custom Resource Definition).&lt;/p&gt;&#xA;&lt;p&gt;通过CRD，K8S可以动态的添加和管理资源，controller跟踪这些资源。&lt;/p&gt;&#xA;&lt;p&gt;CRD+custom Controller = decalartive API(声明式API),一般分为通用性controller和operator.&lt;/p&gt;&#xA;&lt;p&gt;通用型controller一般用于平台需求，operator一般用于部署特定应用.&lt;/p&gt;&#xA;&lt;p&gt;用于开发operator的工具有kubebuilder和operator-sdk, 他们都是基于controller-runtime开发.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/operator-framework/awesome-operators&#34;&gt;https://github.com/operator-framework/awesome-operators&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index&#34;&gt;https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/operators/index&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://operatorhub.io/&#34;&gt;https://operatorhub.io/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;开发示例:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/sample-controller&#34;&gt;https://github.com/kubernetes/sample-controller&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;operator的build三种模式:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go&lt;/li&gt;&#xA;&lt;li&gt;ansible&lt;/li&gt;&#xA;&lt;li&gt;helm&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;operator的run三种模式:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在集群外部本地运行（开发测试).&lt;/li&gt;&#xA;&lt;li&gt;作为deployment在集群内部运行.&lt;/li&gt;&#xA;&lt;li&gt;通过OLM部署.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;operator-sdk&#34;&gt;operator-sdk&lt;/h1&gt;&#xA;&lt;p&gt;redhat的operator-sdk可以方便的开发opeartor.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/operator-framework/operator-sdk&#34;&gt;https://github.com/operator-framework/operator-sdk&lt;/a&gt;&#xA;&lt;a href=&#34;https://sdk.operatorframework.io/docs/installation/&#34;&gt;https://sdk.operatorframework.io/docs/installation/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;kubebuilder&#34;&gt;kubebuilder&lt;/h1&gt;&#xA;&lt;p&gt;sig维护的kubebuilder也能方便的开发operator.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kubebuilder&#34;&gt;https://github.com/kubernetes-sigs/kubebuilder&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service Discovery</title>
      <link>https://canuxcheng.com/post/k8s_servicediscovery/</link>
      <pubDate>Fri, 10 Jan 2020 20:55:52 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_servicediscovery/</guid>
      <description>&lt;h1 id=&#34;coordination--service-discovery&#34;&gt;Coordination &amp;amp; Service Discovery&lt;/h1&gt;&#xA;&lt;p&gt;微服务的服务注册和服务发现.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;coredns&lt;/li&gt;&#xA;&lt;li&gt;etcd&lt;/li&gt;&#xA;&lt;li&gt;zookeeper&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;etcd&#34;&gt;Etcd&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/etcd-io/etcd&#34;&gt;https://github.com/etcd-io/etcd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;类似的有consul和zoomkeeper.&lt;/p&gt;&#xA;&lt;h3 id=&#34;etcdctl&#34;&gt;etcdctl&lt;/h3&gt;&#xA;&lt;p&gt;使用证书访问:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ etcdctl \&#xA;--cacert=/etc/kubernetes/pki/etcd/ca.crt \&#xA;--cert=/etc/kubernetes/pki/etcd/server.crt  \&#xA;--key=/etc/kubernetes/pki/etcd/server.key \&#xA;--insecure-skip-tls-verify=true \&#xA;&amp;lt;command&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看所有key&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ etcdctl get / --prefix --keys-only&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;zookeeper&#34;&gt;zookeeper&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Compose</title>
      <link>https://canuxcheng.com/post/cncf_compose/</link>
      <pubDate>Sat, 04 Jan 2020 21:53:40 +0800</pubDate>
      <guid>https://canuxcheng.com/post/cncf_compose/</guid>
      <description>&lt;h1 id=&#34;docker-compose&#34;&gt;docker-compose&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/docker/compose&#34;&gt;https://github.com/docker/compose&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过一个yaml文件来管理容器中的服务，包括网络和存储。&lt;/p&gt;&#xA;&lt;p&gt;安装:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;https://docs.docker.com/compose/install/&#xA;$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose&#xA;$ sudo chmod +x /usr/local/bin/docker-compose&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;docker-compose命令&#34;&gt;docker-compose命令&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker-compose [-f &amp;lt;arg&amp;gt;...] [options] [COMMAND] [ARGS...]&#xA;-f/--file&#xA;-p/--project-name # 默认目录名&#xA;-H/--host&#xA;&#xA;# 拉取compose文件中指定的镜像&#xA;$ docker-compose -f service.yml pull&#xA;&#xA;# 根据docker-compose.yml把stack打包成一个Distributed Application Bundles文件.&#xA;$ docker-compose bundle -o &amp;lt;project name&amp;gt;.dab&#xA;&#xA;$ docker-compose start [servoce...]&#xA;$ docker-compose stop [service...]&#xA;$ docker-compose restart [service...]&#xA;$ docker-compose up -d [service...]&#xA;$ docker-compose down -v&#xA;&#xA;$ docker-compose logs -f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;docker-composeyml&#34;&gt;docker-compose.yml&lt;/h1&gt;&#xA;&lt;p&gt;compose中的变量：&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Access Control</title>
      <link>https://canuxcheng.com/post/k8s_accesscontrol/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_accesscontrol/</guid>
      <description>&lt;h1 id=&#34;api-access-control&#34;&gt;API Access Control&lt;/h1&gt;&#xA;&lt;h2 id=&#34;admission-controllers&#34;&gt;Admission Controllers&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mutatingadmissionwebhook&#34;&gt;MutatingAdmissionWebhook&lt;/h3&gt;&#xA;&lt;h3 id=&#34;validatingadmissionwebhook&#34;&gt;ValidatingAdmissionWebhook&lt;/h3&gt;&#xA;&lt;h3 id=&#34;validatingwebhookconfiguration&#34;&gt;ValidatingWebhookConfiguration&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1&#xA;kind: ValidatingWebhookConfiguration&#xA;metadata:&#xA;  annotations:&#xA;    meta.helm.sh/release-name: ingress-nginx-internal&#xA;    meta.helm.sh/release-namespace: ingress-nginx&#xA;  labels:&#xA;    app.kubernetes.io/component: admission-webhook&#xA;    app.kubernetes.io/instance: ingress-nginx-internal&#xA;    app.kubernetes.io/managed-by: Helm&#xA;    app.kubernetes.io/name: ingress-nginx&#xA;    app.kubernetes.io/part-of: ingress-nginx&#xA;    app.kubernetes.io/version: 1.9.1&#xA;    helm.sh/chart: ingress-nginx-4.8.1&#xA;  name: ingress-nginx-internal-admission&#xA;webhooks:&#xA;- admissionReviewVersions:&#xA;  - v1&#xA;  clientConfig:&#xA;    caBundle: &#xA;    service:&#xA;      name: ingress-nginx-internal-controller-admission&#xA;      namespace: ingress-nginx&#xA;      path: /networking/v1/ingresses&#xA;      port: 443&#xA;  failurePolicy: Fail&#xA;  matchPolicy: Equivalent&#xA;  name: validate.nginx.ingress.kubernetes.io&#xA;  namespaceSelector: {}&#xA;  objectSelector: {}&#xA;  rules:&#xA;  - apiGroups:&#xA;    - networking.k8s.io&#xA;    apiVersions:&#xA;    - v1&#xA;    operations:&#xA;    - CREATE&#xA;    - UPDATE&#xA;    resources:&#xA;    - ingresses&#xA;    scope: &#39;*&#39;&#xA;  sideEffects: None&#xA;  timeoutSeconds: 10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mutatingwebhookconfiguration&#34;&gt;MutatingWebhookConfiguration&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1&#xA;kind: MutatingWebhookConfiguration&#xA;metadata:&#xA;  annotations:&#xA;    meta.helm.sh/release-name: vault-secrets-webhook&#xA;    meta.helm.sh/release-namespace: vault-secrets-webhook&#xA;  labels:&#xA;    app.kubernetes.io/managed-by: Helm&#xA;  name: vault-secrets-webhook&#xA;webhooks:&#xA;- admissionReviewVersions:&#xA;  - v1beta1&#xA;  clientConfig:&#xA;    caBundle:&#xA;    service:&#xA;      name: vault-secrets-webhook&#xA;      namespace: vault-secrets-webhook&#xA;      path: /pods&#xA;      port: 443&#xA;  failurePolicy: Ignore&#xA;  matchPolicy: Equivalent&#xA;  name: pods.vault-secrets-webhook.admission.banzaicloud.com&#xA;  namespaceSelector:&#xA;    matchExpressions:&#xA;    - key: name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - vault-secrets-webhook&#xA;  objectSelector:&#xA;    matchExpressions:&#xA;    - key: security.banzaicloud.io/mutate&#xA;      operator: NotIn&#xA;      values:&#xA;      - skip&#xA;  reinvocationPolicy: Never&#xA;  rules:&#xA;  - apiGroups:&#xA;    - &#39;*&#39;&#xA;    apiVersions:&#xA;    - &#39;*&#39;&#xA;    operations:&#xA;    - CREATE&#xA;    resources:&#xA;    - pods&#xA;    scope: &#39;*&#39;&#xA;  sideEffects: NoneOnDryRun&#xA;  timeoutSeconds: 10&#xA;- admissionReviewVersions:&#xA;  - v1beta1&#xA;  clientConfig:&#xA;    caBundle:&#xA;    service:&#xA;      name: vault-secrets-webhook&#xA;      namespace: vault-secrets-webhook&#xA;      path: /secrets&#xA;      port: 443&#xA;  failurePolicy: Ignore&#xA;  matchPolicy: Equivalent&#xA;  name: secrets.vault-secrets-webhook.admission.banzaicloud.com&#xA;  namespaceSelector:&#xA;    matchExpressions:&#xA;    - key: name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - vault-secrets-webhook&#xA;  objectSelector:&#xA;    matchExpressions:&#xA;    - key: owner&#xA;      operator: NotIn&#xA;      values:&#xA;      - helm&#xA;    - key: security.banzaicloud.io/mutate&#xA;      operator: NotIn&#xA;      values:&#xA;      - skip&#xA;  reinvocationPolicy: Never&#xA;  rules:&#xA;  - apiGroups:&#xA;    - &#39;*&#39;&#xA;    apiVersions:&#xA;    - &#39;*&#39;&#xA;    operations:&#xA;    - CREATE&#xA;    - UPDATE&#xA;    resources:&#xA;    - secrets&#xA;    scope: &#39;*&#39;&#xA;  sideEffects: NoneOnDryRun&#xA;  timeoutSeconds: 10&#xA;- admissionReviewVersions:&#xA;  - v1beta1&#xA;  clientConfig:&#xA;    caBundle:&#xA;    service:&#xA;      name: vault-secrets-webhook&#xA;      namespace: vault-secrets-webhook&#xA;      path: /configmaps&#xA;      port: 443&#xA;  failurePolicy: Ignore&#xA;  matchPolicy: Equivalent&#xA;  name: configmaps.vault-secrets-webhook.admission.banzaicloud.com&#xA;  namespaceSelector:&#xA;    matchExpressions:&#xA;    - key: name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - kube-system&#xA;    - key: kubernetes.io/metadata.name&#xA;      operator: NotIn&#xA;      values:&#xA;      - vault-secrets-webhook&#xA;  objectSelector:&#xA;    matchExpressions:&#xA;    - key: owner&#xA;      operator: NotIn&#xA;      values:&#xA;      - helm&#xA;    - key: security.banzaicloud.io/mutate&#xA;      operator: NotIn&#xA;      values:&#xA;      - skip&#xA;  reinvocationPolicy: Never&#xA;  rules:&#xA;  - apiGroups:&#xA;    - &#39;*&#39;&#xA;    apiVersions:&#xA;    - &#39;*&#39;&#xA;    operations:&#xA;    - CREATE&#xA;    - UPDATE&#xA;    resources:&#xA;    - configmaps&#xA;    scope: &#39;*&#39;&#xA;  sideEffects: NoneOnDryRun&#xA;  timeoutSeconds: 10&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Automation &amp; Configuration</title>
      <link>https://canuxcheng.com/post/cncf_platform/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/cncf_platform/</guid>
      <description>&lt;h1 id=&#34;automation--configuration&#34;&gt;Automation &amp;amp; Configuration&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cloud Custodian&lt;/li&gt;&#xA;&lt;li&gt;kubeedge&lt;/li&gt;&#xA;&lt;li&gt;pulumi&lt;/li&gt;&#xA;&lt;li&gt;terraform&lt;/li&gt;&#xA;&lt;li&gt;opentofu&lt;/li&gt;&#xA;&lt;li&gt;kratix&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;platform orchestration.&lt;/p&gt;&#xA;&lt;h2 id=&#34;kratix&#34;&gt;kratix&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Dashboard</title>
      <link>https://canuxcheng.com/post/k8s_dashboard/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_dashboard/</guid>
      <description>&lt;h1 id=&#34;dashboard-add-ons&#34;&gt;dashboard add-ons&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kubernetes-dashboard&lt;/li&gt;&#xA;&lt;li&gt;lens&lt;/li&gt;&#xA;&lt;li&gt;octant&lt;/li&gt;&#xA;&lt;li&gt;weave scope&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;kubernetes-dashboard&#34;&gt;kubernetes-dashboard&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/dashboard&#34;&gt;https://github.com/kubernetes/dashboard&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 部署dashboard&#xA;$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml&#xA;&#xA;// check&#xA;$ kubectl -n kubernetes-dashboard get pods --watch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;1&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 删除已安装的dashboard&#xA;$ kubectl delete ns kubernetes-dashboard&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dashboard-arguments&#34;&gt;dashboard arguments&lt;/h3&gt;&#xA;&lt;p&gt;使用basic auth:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;--enable-skip-login&#xA;--enable-insecure-login&#xA;--system-banner=&amp;quot;Welcome to Kubernetes&amp;quot;&#xA;--authentication-mode=&amp;quot;basic&amp;quot; // 默认是 token 登陆.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;access-control&#34;&gt;access control&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;kubeconfig&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;authorization header&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;token&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;basic&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;username/password login&lt;/p&gt;&#xA;&lt;h3 id=&#34;access-dashboard&#34;&gt;access dashboard&lt;/h3&gt;&#xA;&lt;p&gt;本机访问&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ kubectl proxy&#xA;#&amp;gt; http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;远程访问&lt;/p&gt;&#xA;&lt;p&gt;port-forward:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443 --address 0.0.0.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;nodePort:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Key Management</title>
      <link>https://canuxcheng.com/post/k8s_km/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_km/</guid>
      <description>&lt;h1 id=&#34;key-management&#34;&gt;Key Management&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spiffe&lt;/li&gt;&#xA;&lt;li&gt;spire&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Microservivce</title>
      <link>https://canuxcheng.com/post/k8s_microservice/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_microservice/</guid>
      <description>&lt;h1 id=&#34;microservivce&#34;&gt;Microservivce&lt;/h1&gt;&#xA;&lt;p&gt;微服务是一种架构。&lt;/p&gt;&#xA;&lt;p&gt;常见的架构:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Monolithic application 单体应用.&lt;/li&gt;&#xA;&lt;li&gt;SOA(service-oriented architecture) 面向服务的体系结构.&lt;/li&gt;&#xA;&lt;li&gt;MicroServices 微服务.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;微服务架构的服务治理包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;service registry 服务注册&lt;/li&gt;&#xA;&lt;li&gt;service discovery 服务发现&lt;/li&gt;&#xA;&lt;li&gt;observability 可观测性(metrics,logging,trace)&lt;/li&gt;&#xA;&lt;li&gt;流量管理&lt;/li&gt;&#xA;&lt;li&gt;安全&lt;/li&gt;&#xA;&lt;li&gt;控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;微服务应用可以通过容器化(docker, k8s)部署，也可以通过serverless方式部署.&lt;/p&gt;&#xA;&lt;p&gt;不同的语言有不同的微服务框架.&#xA;java的dubbo, sprint boot.&#xA;golang的go-kit,  go-zero, kratos.&#xA;python的zappa, nameko.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;dapr&#34;&gt;Dapr&lt;/h2&gt;&#xA;&lt;p&gt;Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheduling &amp; Orchestration</title>
      <link>https://canuxcheng.com/post/cncf_orchestration/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/cncf_orchestration/</guid>
      <description>&lt;h1 id=&#34;scheduling--orchestration&#34;&gt;Scheduling &amp;amp; Orchestration&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;docker swarm.&lt;/li&gt;&#xA;&lt;li&gt;KEDA&lt;/li&gt;&#xA;&lt;li&gt;Crossplane&lt;/li&gt;&#xA;&lt;li&gt;Knative&lt;/li&gt;&#xA;&lt;li&gt;Kubeflow&lt;/li&gt;&#xA;&lt;li&gt;Volcano&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;crossplane&#34;&gt;Crossplane&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Serverless</title>
      <link>https://canuxcheng.com/post/k8s_serverless/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_serverless/</guid>
      <description>&lt;h1 id=&#34;serverless&#34;&gt;Serverless&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;knative&#34;&gt;Knative&lt;/h2&gt;&#xA;&lt;p&gt;Knative is a developer-focused serverless application layer which is a great complement to the existing Kubernetes application constructs. Knative consists of three components: an HTTP-triggered autoscaling container runtime called “Knative Serving”, a CloudEvents-over-HTTP asynchronous routing layer called “Knative Eventing”, and a developer-focused function framework which leverages the Serving and Eventing components, called &amp;ldquo;Knative Functions&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service Mesh</title>
      <link>https://canuxcheng.com/post/k8s_servicemesh/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_servicemesh/</guid>
      <description>&lt;h1 id=&#34;service-mesh&#34;&gt;Service Mesh&lt;/h1&gt;&#xA;&lt;p&gt;servivce mesh是cncf基于sidecar推出的下一代面向云原生的微服务架构，是微服务基础设施, 用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性.&lt;/p&gt;&#xA;&lt;p&gt;sidecar: 边车模式，就是把业务无关的功能，日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制和服务调用可视化等独立出来。&lt;/p&gt;&#xA;&lt;p&gt;特点:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用程序通信的中间层&lt;/li&gt;&#xA;&lt;li&gt;轻量级网络代理&lt;/li&gt;&#xA;&lt;li&gt;应用程序无感知&lt;/li&gt;&#xA;&lt;li&gt;解耦应用程序的重试、超时、监控、追踪和服务发现.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Service Mesh是建立在物理或者虚拟网络层之上的，基于策略的微服务的流量控制，与一般的网络协议不同的是它有以下几个特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发者驱动&lt;/li&gt;&#xA;&lt;li&gt;可配置策略&lt;/li&gt;&#xA;&lt;li&gt;服务优先的网络配置而不是协议&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;linkerd&#34;&gt;Linkerd&lt;/h2&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Service Proxy</title>
      <link>https://canuxcheng.com/post/k8s_proxy/</link>
      <pubDate>Sat, 04 Jan 2020 20:03:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_proxy/</guid>
      <description>&lt;h1 id=&#34;service-proxy&#34;&gt;Service Proxy&lt;/h1&gt;&#xA;&lt;p&gt;ingress =&amp;gt; gateway api&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;envoy&lt;/li&gt;&#xA;&lt;li&gt;contour&lt;/li&gt;&#xA;&lt;li&gt;traefik proxy&lt;/li&gt;&#xA;&lt;li&gt;haproxy&lt;/li&gt;&#xA;&lt;li&gt;metaLB&lt;/li&gt;&#xA;&lt;li&gt;nginx&lt;/li&gt;&#xA;&lt;li&gt;openelb&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;ingress-controller&#34;&gt;ingress controller&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ingress-nginx(nginx)&lt;/li&gt;&#xA;&lt;li&gt;aws-load-balancer-controller(alb)&lt;/li&gt;&#xA;&lt;li&gt;ingress-gce&lt;/li&gt;&#xA;&lt;li&gt;Traefik&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The kubernetes.io/ingress.class annotation is deprecated from kubernetes v1.22+.通过IngressClasses来选择ingress controller。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ingressClassName: nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ingress 语法&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;apiVersion: networking.k8s.io/v1&#xA;kind: Ingress&#xA;metadata:&#xA;  name: minimal-ingress&#xA;  annotations:&#xA;    nginx.ingress.kubernetes.io/rewrite-target: /&#xA;spec:&#xA;  ingressClassName: nginx-example&#xA;  defaultBackend:&#xA;    resource:&#xA;      apiGroup: k8s.example.com&#xA;      kind: StorageBucket&#xA;      name: static-assets&#xA;  rules:&#xA;  - http:&#xA;      paths:&#xA;      - path: /testpath&#xA;        pathType: Prefix&#xA;        backend:&#xA;          service:&#xA;            name: test&#xA;            port:&#xA;              number: 80&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ImplementationSpecific：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 pathType 处理或者与 Prefix 或 Exact 类型作相同处理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubeadm</title>
      <link>https://canuxcheng.com/post/k8s_kubeadm/</link>
      <pubDate>Mon, 30 Dec 2019 21:47:17 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_kubeadm/</guid>
      <description>&lt;h1 id=&#34;kubeadm&#34;&gt;kubeadm&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubeadm&#34;&gt;https://github.com/kubernetes/kubeadm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;kubeadm是k8s自带的部署集群的工具.&lt;/p&gt;&#xA;&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;&#xA;&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&#34;&gt;https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装runtime&#34;&gt;安装runtime&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&#34;&gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;默认的cgroup驱动时cgroupfs,如果系统是systemd，就会有两个cgroup driver，会出问题.&lt;/p&gt;&#xA;&lt;p&gt;如果修改cgroup driver需要同时修改CRI和kubelet.&lt;/p&gt;&#xA;&lt;p&gt;修改containerd的cgroup driver:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/containerd/config.toml&#xA;#disabled_plugins = [&amp;quot;cri&amp;quot;]&#xA;[plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.runc.options]&#xA;  SystemdCgroup = true&#xA;&#xA;$ sudo systemctl restart containerd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;修改kubelet的cgroup driver(kubeadm-config.yaml):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# kubeadm-config.yaml&#xA;kind: ClusterConfiguration&#xA;apiVersion: kubeadm.k8s.io/v1beta3&#xA;kubernetesVersion: v1.21.0    // kubelet --version&#xA;---&#xA;apiVersion: kubelet.config.k8s.io/v1beta1&#xA;kind: KubeletConfiguration&#xA;cgroupDriver: systemd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;安装kubeadm-kubelet-kubectl&#34;&gt;安装kubeadm, kubelet, kubectl&lt;/h2&gt;&#xA;&lt;p&gt;在每台机器上安装 kubeadm, kubelet, kubectl:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get update&#xA;$ sudo apt-get install -y apt-transport-https ca-certificates curl&#xA;$ sudo curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - &#xA;$ echo &amp;quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&amp;quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list&#xA;$ sudo apt-get update&#xA;$ sudo apt-get --yes --allow-unauthenticated install kubeadm kubelet kubectl&#xA;$ sudo apt-mark hold kubelet kubeadm kubectl&#xA;$ sudo systemctl enable kubelet&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;kubeadm-cli&#34;&gt;Kubeadm CLI&lt;/h1&gt;&#xA;&lt;p&gt;init:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Minikube</title>
      <link>https://canuxcheng.com/post/k8s_minikube/</link>
      <pubDate>Mon, 30 Dec 2019 21:47:17 +0800</pubDate>
      <guid>https://canuxcheng.com/post/k8s_minikube/</guid>
      <description>&lt;h1 id=&#34;minikube&#34;&gt;minikube&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/setup/learning-environment/minikube/&#34;&gt;https://kubernetes.io/zh/docs/setup/learning-environment/minikube/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;minikube 能快速创建k8s的开发集群，支持在虚拟机上创建，也支持裸机创建.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 在裸机上创建：&#xA;sudo minikube start --vm-driver=none&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Image</title>
      <link>https://canuxcheng.com/post/cncf_image/</link>
      <pubDate>Tue, 03 Dec 2019 21:50:47 +0800</pubDate>
      <guid>https://canuxcheng.com/post/cncf_image/</guid>
      <description>&lt;h1 id=&#34;image&#34;&gt;image&lt;/h1&gt;&#xA;&lt;p&gt;容器镜像&lt;/p&gt;&#xA;&lt;p&gt;docker image driver: aufs, btrfs, devicemapper, overlay.&lt;/p&gt;&#xA;&lt;h2 id=&#34;multi-platform-images&#34;&gt;multi-platform images&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/build/building/multi-platform/&#34;&gt;https://docs.docker.com/build/building/multi-platform/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;qemu&#34;&gt;qemu&lt;/h3&gt;&#xA;&lt;p&gt;使用qume:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 安装bitfmt&#xA;docker run --privileged --rm tonistiigi/binfmt --install all&#xA;&#xA;// 查看支持的平台&#xA;ls -l /proc/sys/fs/binfmt_misc/qemu-*&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;multiple-native-nodes&#34;&gt;multiple native nodes&lt;/h3&gt;&#xA;&lt;p&gt;安装&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// linux&#xA;sudo apt install docker-buildx-plugin&#xA;&#xA;// mac&#xA;brew install docker-buildx&#xA;mkdir -p ~/.docker/cli-plugins&#xA;ln -sfn $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx&#xA;docker buildx install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看版本&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker buildx version&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;管理builder instance&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker buildx create&#xA;--append 添加node到builder实例。&#xA;--leave 从builder实例删除node&#xA;--driver Driver to use(&amp;quot;docker&amp;quot;, &amp;quot;docker-container&amp;quot;, &amp;quot;kubernetes&amp;quot;)&#xA;--name&#xA;--use&#xA;--node&#xA;--platform &#xA;--bootstrap 启动实例（以容器的形式启动）&#xA;&#xA;// 以本地是amd64为例，创建一个实例.&#xA;docker buildx create --use --bootstrap --platform linux/amd64,linux/amd64/v2,linux/amd64/v3,linux/arm64,linux/arm/v7,linux/arm/v6 --name canux-builder&#xA;&#xA;// 如果没有qumu，可以把不同平台的远程机器加到builder实例.&#xA;docker buildx create \&#xA;--name local_remote_builder \&#xA;--append --node &amp;lt;my-arm-server&amp;gt; \&#xA;--platform linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/mips64le,linux/mips64,linux/arm/v7,linux/arm/v6 \&#xA;ssh://user@&amp;lt;my-arm-server&amp;gt; &#xA;&#xA;docker buildx rm&#xA;&#xA;docker buildx stop&#xA;&#xA;docker buildx inspect&#xA;&#xA;docker buildx use&#xA;&#xA;// 查看当前可用的builders&#xA;docker buildx ls&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;构建多平台镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title>Helm</title>
      <link>https://canuxcheng.com/post/k8s_helm/</link>
      <pubDate>Thu, 05 Sep 2019 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/k8s_helm/</guid>
      <description>&lt;h1 id=&#34;helm&#34;&gt;Helm&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/helm/helm&#34;&gt;https://github.com/helm/helm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;helm2有两个组件:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;helm: 客户端&lt;/li&gt;&#xA;&lt;li&gt;tiller: 服务端(helm3被移除)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;概念:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;chart: helm包，包含运行一个应用所需的镜像，依赖和资源.&lt;/li&gt;&#xA;&lt;li&gt;repository: 用于发布和存储chart的仓库.&lt;/li&gt;&#xA;&lt;li&gt;release: 在k8s集群上运行的一个chart实例.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;repository有哪些:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;charts: OSS, public, 已经被artifacthub取代, &lt;a href=&#34;https://github.com/helm/charts&#34;&gt;https://github.com/helm/charts&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;artifacthub: OSS, public,  &lt;a href=&#34;https://artifacthub.io/&#34;&gt;https://artifacthub.io/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;chartmuseum: OSS, private, self-host, &lt;a href=&#34;https://github.com/helm/chartmuseum&#34;&gt;https://github.com/helm/chartmuseum&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;harbor: OSS, private, self-host.&lt;/li&gt;&#xA;&lt;li&gt;artifactory(jfrog): enterprise, private, self-host.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;&#xA;&lt;p&gt;helm和kubectl一样，访问指定配置的k8s集群。&lt;/p&gt;&#xA;&lt;p&gt;helm2需要安装tiller并且执行helm init初始化,helm不需要tiller.&lt;/p&gt;&#xA;&lt;p&gt;本地二进制安装helm3+:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -&#xA;sudo apt-get install apt-transport-https --yes&#xA;echo &amp;quot;deb https://baltocdn.com/helm/stable/debian/ all main&amp;quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list&#xA;sudo apt-get update&#xA;sudo apt-get install helm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;&#xA;&lt;h3 id=&#34;repo管理&#34;&gt;repo管理&lt;/h3&gt;&#xA;&lt;p&gt;查看有哪些repo,默认没有repo&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S CRI</title>
      <link>https://canuxcheng.com/post/k8s_cri/</link>
      <pubDate>Wed, 05 Jun 2019 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/k8s_cri/</guid>
      <description>&lt;h1 id=&#34;cri&#34;&gt;CRI&lt;/h1&gt;&#xA;&lt;p&gt;CRI: Container Runtime Intarface&lt;/p&gt;&#xA;&lt;p&gt;定义了k8s和container runtime进行交互的接口.&lt;/p&gt;&#xA;&lt;p&gt;是k8s与container交互的标准.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&#34;&gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;containerd&lt;/li&gt;&#xA;&lt;li&gt;cri-o&lt;/li&gt;&#xA;&lt;li&gt;rkt&lt;/li&gt;&#xA;&lt;li&gt;kata&lt;/li&gt;&#xA;&lt;li&gt;rancher&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;docker&#34;&gt;docker&lt;/h2&gt;&#xA;&lt;p&gt;k8s_1.20 开始警告不再支持docker.&lt;/p&gt;&#xA;&lt;p&gt;k8s_1.23 开始移除dockershim.&lt;/p&gt;&#xA;&lt;p&gt;/var/run/dockerhsim.sock&lt;/p&gt;&#xA;&lt;h2 id=&#34;containerd&#34;&gt;containerd&lt;/h2&gt;&#xA;&lt;p&gt;/run/container/containerd.sock&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/containerd/containerd&#34;&gt;https://github.com/containerd/containerd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装配置:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd&#34;&gt;https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;cri-o&#34;&gt;CRI-O&lt;/h2&gt;&#xA;&lt;p&gt;redhat.&lt;/p&gt;&#xA;&lt;p&gt;/var/run/crio/crio.sock&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cri-o/cri-o&#34;&gt;https://github.com/cri-o/cri-o&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;kata&#34;&gt;kata&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kata-containers/runtime&#34;&gt;https://github.com/kata-containers/runtime&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;rkt&#34;&gt;rkt&lt;/h2&gt;&#xA;&lt;p&gt;redhat(coreos)&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rkt/rkt&#34;&gt;https://github.com/rkt/rkt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Container</title>
      <link>https://canuxcheng.com/post/cncf_container/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/cncf_container/</guid>
      <description>&lt;h1 id=&#34;container&#34;&gt;Container&lt;/h1&gt;&#xA;&lt;p&gt;OCI: Open Container Initiative.&lt;/p&gt;&#xA;&lt;p&gt;CRI: Container Runtime Interface.&lt;/p&gt;&#xA;&lt;p&gt;CNI: Container Network Interface.&lt;/p&gt;&#xA;&lt;p&gt;CSI: Container Storage Interface.&lt;/p&gt;&#xA;&lt;h1 id=&#34;oci&#34;&gt;OCI&lt;/h1&gt;&#xA;&lt;p&gt;Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作.&lt;/p&gt;&#xA;&lt;p&gt;是container的标准.&lt;/p&gt;&#xA;&lt;p&gt;目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.opencontainers.org/&#34;&gt;https://www.opencontainers.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;runc&#34;&gt;runc&lt;/h2&gt;&#xA;&lt;p&gt;docker(libcontainer)&lt;/p&gt;&#xA;&lt;p&gt;runc支持OCI.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;https://github.com/opencontainers/runc&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;rkt&#34;&gt;rkt&lt;/h2&gt;&#xA;&lt;p&gt;redhat(coreos)&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rkt/rkt&#34;&gt;https://github.com/rkt/rkt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;tools&#34;&gt;tools&lt;/h1&gt;&#xA;&lt;h2 id=&#34;dumb-init&#34;&gt;dumb-init&lt;/h2&gt;&#xA;&lt;p&gt;管理pid=1的进程的子进程:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Yelp/dumb-init&#34;&gt;https://github.com/Yelp/dumb-init&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;baseimage-docker&#34;&gt;baseimage-docker&lt;/h2&gt;&#xA;&lt;p&gt;处理container中运行多个进程的问题:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/phusion/baseimage-docker&#34;&gt;https://github.com/phusion/baseimage-docker&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;watchtower&#34;&gt;watchtower&lt;/h2&gt;&#xA;&lt;p&gt;根据registry中的更新自动更新 container:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/containrrr/watchtower/&#34;&gt;https://github.com/containrrr/watchtower/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;hadolint&#34;&gt;hadolint&lt;/h2&gt;&#xA;&lt;p&gt;dockerfile 语法检查:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hadolint/hadolint&#34;&gt;https://github.com/hadolint/hadolint&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;gosu&#34;&gt;gosu&lt;/h2&gt;&#xA;&lt;p&gt;权限管理&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tianon/gosu&#34;&gt;https://github.com/tianon/gosu&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;swarm-cronjob&#34;&gt;swarm-cronjob&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/crazy-max/swarm-cronjob&#34;&gt;https://github.com/crazy-max/swarm-cronjob&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;misc&#34;&gt;misc&lt;/h1&gt;&#xA;&lt;p&gt;get host ip(docker/docker_gwbridge) from container:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ip route | awk &#39;/default/ { print $3 }&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>https://canuxcheng.com/post/cncf_docker/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/cncf_docker/</guid>
      <description>&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://store.docker.com/&#34;&gt;https://store.docker.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/&#34;&gt;https://hub.docker.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/docker&#34;&gt;https://github.com/docker&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/moby/moby&#34;&gt;https://github.com/moby/moby&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Docker是一个容器引擎, 分为社区版CE, 和企业版EE, Docker不是虚拟机, 也不依赖虚拟化技术．&lt;/p&gt;&#xA;&lt;p&gt;docker-cli -&amp;gt; dockerd -&amp;gt; containerd -&amp;gt; shim -&amp;gt; runc&lt;/p&gt;&#xA;&lt;p&gt;containerd是容器运行时管理引擎.&lt;/p&gt;&#xA;&lt;p&gt;shim用于管理容器生命周期.&lt;/p&gt;&#xA;&lt;p&gt;Docker包括三个基本概念:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仓库repository,集中存放镜像文件的场所,docker hub/store是最大的公开仓库．&lt;/li&gt;&#xA;&lt;li&gt;镜像image, 镜像是一个文件系统.&lt;/li&gt;&#xA;&lt;li&gt;容器container, 容器是镜像的运行的实例．&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;修改docker存储路径:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ service docker stop&#xA;$ mv /var/lib/docker /opt/ssd/docker&#xA;$ ln -s /opt/ssd/docker /var/lib/docker&#xA;$ service docker start&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Install:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;windows:&#xA;&amp;lt;https://docs.docker.com/docker-for-windows/install/&amp;gt;&#xA;&#xA;linux:&#xA;&amp;lt;https://docs.docker.com/engine/install/ubuntu/&amp;gt;&#xA;&#xA;mac:&#xA;&amp;lt;https://github.com/abiosoft/colima/blob/main/docs/FAQ.md#docker&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;config&#34;&gt;config&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file&#34;&gt;https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;docker配置文件:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/etc/docker/daemon.json&#xA;/lib/systemd/system/docker.service&#xA;&#xA;{&#xA;    // debug&#xA;    &amp;quot;debug&amp;quot;: true,&#xA;    &#xA;    &amp;quot;data-root&amp;quot;： &amp;quot;/var/lib/docker&amp;quot;,&#xA;    &#xA;    &amp;quot;features&amp;quot;: {&#xA;        &amp;quot;buildkit&amp;quot;: true&#xA;    },&#xA;&#xA;    //容器访问外网:&#xA;    ip-forward=true 会设置 net.ipv4.ip_forward=1, 才能访问外网&#xA;    // 容器之间访问:&#xA;    icc=true, &#xA;    iptables=true  会修改iptables的forward策略为accept,&#xA;&#xA;    // 修改默认docker0&#xA;    &amp;quot;bridge&amp;quot;:&#xA;    &amp;quot;bip&amp;quot;: &amp;quot;10.0.0.1/16&amp;quot;  // subnet + gateway&#xA;    &amp;quot;fixed-cidr&amp;quot;: &amp;quot;10.41.0.0/24&amp;quot; // iprange&#xA;    &amp;quot;fixed-cidr-v6&amp;quot;: &amp;quot;&amp;quot;,&#xA;    &amp;quot;mtu&amp;quot;: 1500&#xA;    &amp;quot;default-gateway&amp;quot;:&#xA;&#x9;&amp;quot;default-gateway-v6&amp;quot;: &amp;quot;&amp;quot;,&#xA;&#xA;    // 修改默认dns&#xA;    &amp;quot;dns&amp;quot; : [&#xA;        &amp;quot;114.114.114.114&amp;quot;,&#xA;        &amp;quot;8.8.8.8&amp;quot;&#xA;    ]&#xA;    &amp;quot;dns-opts&amp;quot;: [],&#xA;    &amp;quot;dns-search&amp;quot;: [],&#xA;&#xA;    // ipv6&#xA;    &amp;quot;ipv6&amp;quot;: true&#xA;&#xA;    // private registry&#xA;  &#x9;&amp;quot;insecure-registries&amp;quot;: [],&#xA;&#xA;    // 修改registry&#xA;    &amp;quot;registry-mirrors&amp;quot;: [&#xA;        &amp;quot;https://registry.docker-cn.com&amp;quot;,&#xA;        &amp;quot;https://z4yd270h.mirror.aliyuncs.com&amp;quot;,&#xA;        &amp;quot;http://f1361db2.m.daocloud.io&amp;quot;,&#xA;        &amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;&#xA;    ]&#xA;&#xA;    &amp;quot;hosts&amp;quot;: [],&#xA;    &amp;quot;log-level&amp;quot;: &amp;quot;&amp;quot;,&#xA;    &amp;quot;tls&amp;quot;: true,&#xA;    &amp;quot;tlsverify&amp;quot;: true,&#xA;    &amp;quot;tlscacert&amp;quot;: &amp;quot;&amp;quot;,&#xA;    &amp;quot;tlscert&amp;quot;: &amp;quot;&amp;quot;,&#xA;    &amp;quot;tlskey&amp;quot;: &amp;quot;&amp;quot;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;proxy for pull image from google(gcr):&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes</title>
      <link>https://canuxcheng.com/post/kubernetes/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/kubernetes/</guid>
      <description>&lt;h1 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubeadm&#34;&gt;https://github.com/kubernetes/kubeadm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kops&#34;&gt;https://github.com/kubernetes/kops&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray&#34;&gt;https://github.com/kubernetes-sigs/kubespray&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;kubernetes简称k8s, 是开源的容器编排工具。&lt;/p&gt;&#xA;&lt;p&gt;安装单机版k8s:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;minikube&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安装k8s集群:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kubeadm (k8s内置的，类似于docker swarm mode, 没有HA)&lt;/li&gt;&#xA;&lt;li&gt;kops (目前主要支持aws等云平台, 国内不友好)&lt;/li&gt;&#xA;&lt;li&gt;kubespray (通过ansible部署, 国内不友好)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;k8s发行版：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;openshift-okd(redhat)&lt;/li&gt;&#xA;&lt;li&gt;rancher&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;k8s集群组成&#34;&gt;k8s集群组成&lt;/h1&gt;&#xA;&lt;h2 id=&#34;master&#34;&gt;master&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;aip-server, 提供资源操作唯一入口&lt;/li&gt;&#xA;&lt;li&gt;scheduler, 负责资源调度&lt;/li&gt;&#xA;&lt;li&gt;controller-manager, 负责维护集群状态&lt;/li&gt;&#xA;&lt;li&gt;etcd(可以部署单独集群), 保存整个集群的状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;node&#34;&gt;node&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;kubelet, 负责维护容器生命周期, 还包括CNI CVI&lt;/li&gt;&#xA;&lt;li&gt;kube-proxy, 为service提供cluster内部的服务发现和负载均衡&lt;/li&gt;&#xA;&lt;li&gt;CRI(containerd), 创建pod&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;addons&#34;&gt;addons&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;coredns&lt;/li&gt;&#xA;&lt;li&gt;flannel/cilium/calico&lt;/li&gt;&#xA;&lt;li&gt;dashboard, web-gui&lt;/li&gt;&#xA;&lt;li&gt;metrics-server, 取代heapster，用于cpu/memory监控&lt;/li&gt;&#xA;&lt;li&gt;ingress-nginx, 为服务提供外网入口&lt;/li&gt;&#xA;&lt;li&gt;federation, 提供跨可用区的集群&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;&#xA;&lt;p&gt;k8s包含的重要概念:&lt;/p&gt;&#xA;&lt;p&gt;-: nodes, 运行pod的物理机或虚拟机.&#xA;-: namespace, 对资源和对象的抽象集合．pods/deployments/services都属于某个ns.&#xA;-: pods,一组紧密关联的容器集合，共享pid,ipc,network,uts,namespace.&lt;/p&gt;&#xA;&lt;p&gt;k8s业务类型:&lt;/p&gt;&#xA;&lt;p&gt;-: long-running 长期伺服型 -&amp;gt; RC, RS, Deployment&#xA;-: batch 批处理型-&amp;gt; Job&#xA;-: node-daemon 节点后台支撑型-&amp;gt; DaemonSet&#xA;-: stateful application 有状态应用型-&amp;gt; StatefulSet&lt;/p&gt;</description>
    </item>
    <item>
      <title>Namespace</title>
      <link>https://canuxcheng.com/post/cncf_ns/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/cncf_ns/</guid>
      <description>&lt;h1 id=&#34;ns&#34;&gt;NS&lt;/h1&gt;&#xA;&lt;p&gt;namespace 是 Linux 内核用来隔离内核资源的方式&lt;/p&gt;&#xA;&lt;p&gt;Linux namespace资源：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Mount: 挂载点&lt;/li&gt;&#xA;&lt;li&gt;Network: 网络设备/协议栈/端口&lt;/li&gt;&#xA;&lt;li&gt;IPC: 进程间通信&lt;/li&gt;&#xA;&lt;li&gt;USR: 用户和用户组&lt;/li&gt;&#xA;&lt;li&gt;PID: 进程&lt;/li&gt;&#xA;&lt;li&gt;UTS: 主机名和域名&lt;/li&gt;&#xA;&lt;li&gt;Cgroup: 控制组&lt;/li&gt;&#xA;&lt;li&gt;Time&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;cgroup&#34;&gt;Cgroup&lt;/h1&gt;&#xA;&lt;p&gt;Cgroup: Control Groups.是linux下用于对一个或一组进程资源控制和监控的机制.可以管理cpu, memory,diskIO 等资源.不同资源的具体管理工作由相应的cgrouup子系统来实现.&lt;/p&gt;&#xA;&lt;p&gt;cgroup在不同的系统资源管理子系统中以层级树(Hierarchy)的方式来组织管理, 每个cgroup可以包含其它子cgroup.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;ls -l /sys/fs/cgroup&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;cgroup子系统:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cpu&lt;/li&gt;&#xA;&lt;li&gt;cpuacct&lt;/li&gt;&#xA;&lt;li&gt;cpuset&lt;/li&gt;&#xA;&lt;li&gt;memory&lt;/li&gt;&#xA;&lt;li&gt;blkio&lt;/li&gt;&#xA;&lt;li&gt;devices&lt;/li&gt;&#xA;&lt;li&gt;freezer&lt;/li&gt;&#xA;&lt;li&gt;ns&lt;/li&gt;&#xA;&lt;li&gt;pid&lt;/li&gt;&#xA;&lt;li&gt;net_cls&lt;/li&gt;&#xA;&lt;li&gt;net_prio&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;lsns&#34;&gt;lsns&lt;/h1&gt;&#xA;&lt;p&gt;查看系统的namespace&lt;/p&gt;&#xA;&lt;p&gt;ns类型: mnt, net, ipc, user, pid, uts, cgroup&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$lsns -l&#xA;$lsns -t net&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;unshare&#34;&gt;unshare&lt;/h1&gt;&#xA;&lt;p&gt;使用非共享的NS运行程序&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// 创建unshare 的 ns类型.&#xA;$unshare -f -m/-n/-i/-U/-p/-u/-C ... &#xA;&#xA;// 在net类型的namespace执行sleep命令&#xA;$unshare -fn sleep 10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;nsenter&#34;&gt;nsenter&lt;/h1&gt;&#xA;&lt;p&gt;ns enter: Namespace enter.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Registry</title>
      <link>https://canuxcheng.com/post/cncf_registry/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/cncf_registry/</guid>
      <description>&lt;h1 id=&#34;container-registry&#34;&gt;Container Registry&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker Hub Registry&lt;/li&gt;&#xA;&lt;li&gt;Google Container Registry (gcr.io)&lt;/li&gt;&#xA;&lt;li&gt;RedHat Quay Registry (quay.io)&lt;/li&gt;&#xA;&lt;li&gt;GitHub Docker Packages (docker.pkg.github.com)(Deprecated)&lt;/li&gt;&#xA;&lt;li&gt;GitHub Container Registry (ghcr.io)&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes Registry(registry.k8s.io =&amp;gt; k8s.gcr.io)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;harbor&#34;&gt;Harbor&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/goharbor/harbor&#34;&gt;https://github.com/goharbor/harbor&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Habor是由VMWare中国团队开源的容器镜像仓库, 用于存储和分发docker镜像的registry服务器.&lt;/p&gt;&#xA;&lt;p&gt;安装步骤:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;下载并解压安装包, &lt;a href=&#34;https://github.com/goharbor/harbor/releases&#34;&gt;https://github.com/goharbor/harbor/releases&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;配置harbor.cfg;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;修改配置:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;vim harbor.yml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行安装程序:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;./install.sh --with-notary --with-clair --with-chartmuseum&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;修改web的port:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ vim /data/harbor/docker-compose.yml&#xA;proxy:&#xA;  ports:&#xA;    - 8080:80 # 默认http是80&#xA;    - 4433:443 # 默认https是443&#xA;$ vim /data/harbor/harbor.yml&#xA;hostname = ip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;管理harbor:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# cd /data/harbor&#xA;# docker-compose down -v 　停止并删除container&#xA;&#xA;&amp;gt; 更新配置&#xA;# ./prepare --with-notary --with-clair --with-chartmuseum&#xA;&#xA;&amp;gt; 启动&#xA;# docker-compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;docker使用harbor&#34;&gt;docker使用harbor&lt;/h2&gt;&#xA;&lt;p&gt;Deploy a plain HTTP registry:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Swarm</title>
      <link>https://canuxcheng.com/post/swarm/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/swarm/</guid>
      <description>&lt;h1 id=&#34;swarm&#34;&gt;Swarm&lt;/h1&gt;&#xA;&lt;p&gt;docker swarm 是 docker内置的容器编排工具。&lt;/p&gt;&#xA;&lt;p&gt;从docker1.12开始swarm内置于docker engine.&lt;/p&gt;&#xA;&lt;p&gt;swarm mode具有内置kv存储，服务发现，负载均衡，路由网格，动态伸缩，滚动更新，安全传输等功能。&lt;/p&gt;&#xA;&lt;p&gt;swarm: 老版本的swarm, 需要kv store, 可以作为独立的container运行, 已废弃, 已经被docker swarm mode 代替.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/docker/swarm&#34;&gt;https://github.com/docker/swarm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;swarmkit:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/docker/swarmkit&#34;&gt;https://github.com/docker/swarmkit&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;swarm命令&#34;&gt;swarm命令&lt;/h1&gt;&#xA;&lt;p&gt;创建集群&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker swarm init&#xA;--advertise-addr &amp;lt;ip&amp;gt; 多网卡情况下指定manager的ip&#xA;&#xA;docker swarm join --token &amp;lt;token&amp;gt; &amp;lt;host:port&amp;gt;&#xA;&#xA;# 查看token&#xA;docker swarm join-token manager   获取添加manager命令&#xA;docker swarm join-token worker   获取添加worker命令&#xA;docker swarm join-token -q worker&#xA;&#xA;docker swarm leave -f/--force&#xA;&#xA;docker swarm update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;管理节点&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker node ls&#xA;docker node ls --format &amp;quot;{{.Hostname}}&amp;quot;&#xA;​&#xA;docker node rm&#xA;​&#xA;docker node inspect&#xA;​&#xA;# 查看node上运行的tasks/container&#xA;docker node ps -f/--filter NODE&#xA;​&#xA;# 添加label, node.labels.role=api&#xA;docker node update --label-add role=api node1&#xA;# 删除label&#xA;docker node update --label-rm role node1&#xA;​&#xA;# 活跃节点&#xA;docker node update --availability active node1&#xA;# 指定该节点满载,不再分派任务,关闭已有任务并重新分派.&#xA;docker node update --availability drain node1&#xA;# 已有任务继续运行,不分配新任务.&#xA;docker node update --availability pause node1&#xA;&#xA;# 查看所有node和label&#xA;docker node ls -q | xargs docker node inspect -f &#39;{{ .ID }} [{{ .Description.Hostname }}]: {{ .Spec.Labels }}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;service&lt;/p&gt;</description>
    </item>
    <item>
      <title>Swarm CNI</title>
      <link>https://canuxcheng.com/post/swarm_cni/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/swarm_cni/</guid>
      <description>&lt;h1 id=&#34;cni&#34;&gt;CNI&lt;/h1&gt;&#xA;&lt;p&gt;CNI: Container Network Intarface&lt;/p&gt;&#xA;&lt;h2 id=&#34;单台host上的container通信&#34;&gt;单台host上的container通信&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;none&lt;/li&gt;&#xA;&lt;li&gt;host&lt;/li&gt;&#xA;&lt;li&gt;bridge&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;多台host之间的container通信&#34;&gt;多台host之间的container通信&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;overlay&lt;/li&gt;&#xA;&lt;li&gt;macvlan&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;提供overlaymacvlan的网络服务&#34;&gt;提供overlay/macvlan的网络服务&lt;/h3&gt;&#xA;&lt;p&gt;vxlan encapsulated:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;canal&lt;/li&gt;&#xA;&lt;li&gt;flannel&lt;/li&gt;&#xA;&lt;li&gt;weave&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;bgp unencapsulated:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;calico&lt;/li&gt;&#xA;&lt;li&gt;romana&lt;/li&gt;&#xA;&lt;li&gt;cilium&lt;/li&gt;&#xA;&lt;li&gt;kube-router&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;docker网络管理&#34;&gt;Docker网络管理&lt;/h1&gt;&#xA;&lt;p&gt;查看:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ docker network ls # 查看所有网络&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;默认支持的三种模式:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 默认启动的容器都是桥接(docker0)，重启后容器的ip就变了。&#xA;docker run --network bridge  ...&#xA;docker run --network host ... # 容器和主机使用相同的ip&#xA;docker run --network none ... # 容器不会分配局域网的ip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;创建:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker network create -d &amp;lt;driver&amp;gt; ... [name]&#xA;-d/--driver # 默认是bridge, 可选overlay/macvlan&#xA;--subnet  # CIDR格式&#xA;--gateway&#xA;--ip-range&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;使用:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Swarm CSI</title>
      <link>https://canuxcheng.com/post/swarm_csi/</link>
      <pubDate>Thu, 05 Apr 2018 22:02:31 +0000</pubDate>
      <guid>https://canuxcheng.com/post/swarm_csi/</guid>
      <description>&lt;h1 id=&#34;csi&#34;&gt;CSI&lt;/h1&gt;&#xA;&lt;p&gt;CSI: Container Storage Interface&lt;/p&gt;&#xA;&lt;p&gt;CSI提供容器的数据持久化服务.&lt;/p&gt;&#xA;&lt;p&gt;容器管理数据的两种方式：&lt;/p&gt;&#xA;&lt;p&gt;数据卷(Volumes)&lt;/p&gt;&#xA;&lt;p&gt;挂载主机目录(bind mounts)&lt;/p&gt;&#xA;&lt;p&gt;临时文件系统(tmpfs)&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据存储原理&#34;&gt;数据存储原理&lt;/h2&gt;&#xA;&lt;p&gt;如果container上目录不存在，docker会自动创建&lt;/p&gt;&#xA;&lt;p&gt;如果container目录存在且有内容，会被host上的目录覆盖掉，但不会被删除.&lt;/p&gt;&#xA;&lt;h2 id=&#34;volumes&#34;&gt;Volumes&lt;/h2&gt;&#xA;&lt;p&gt;如果host上目录不存在，docker会自动创建&lt;/p&gt;&#xA;&lt;p&gt;volumes是被设计用来持久化数据的，它的生命周期独立于容器.数据卷通过docker volume命令管理的，位于/var/lib/docker/volumes/下面.&lt;/p&gt;&#xA;&lt;p&gt;Docker不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。&lt;/p&gt;&#xA;&lt;p&gt;创建:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ docker volume create &amp;lt;volume-name&amp;gt;&#xA;$ docker volume rm &amp;lt;volume-name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;使用：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -v/--volume myvolume:/var/lib/app ...&#xA;$ docker run --mount source=myvolume,target=/var/lib/app ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;bind-mount&#34;&gt;Bind mount&lt;/h2&gt;&#xA;&lt;p&gt;如果host上目录不存在会报错，需要提前创建.&lt;/p&gt;&#xA;&lt;p&gt;bind mount就是直接将host路径挂在到docker．&lt;/p&gt;&#xA;&lt;p&gt;source和target都是文件，即可挂载单个文件.&lt;/p&gt;&#xA;&lt;p&gt;使用:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ docker run -v/--volume /opt/app:/var/lib/app:ro ...&#xA;$ docker run --mount type=bind,source=/opt/app,target=/var/lib/app,readonly ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;tmpfs&#34;&gt;tmpfs&lt;/h2&gt;&#xA;&lt;p&gt;tmpfs是临时文件系统，也叫内存文件系统，就是将数据存在内存上。&lt;/p&gt;&#xA;&lt;p&gt;tmpfs只能用于linux, 多个容器也不能共享，容器停止数据就销毁。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
