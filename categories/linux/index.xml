<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Morgoth</title>
    <link>https://canuxcheng.com/categories/linux/</link>
    <description>Recent content in Linux on Morgoth</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jul 2020 21:18:33 +0000</lastBuildDate>
    <atom:link href="https://canuxcheng.com/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BitBake</title>
      <link>https://canuxcheng.com/post/linux_bitbake/</link>
      <pubDate>Sun, 12 Jul 2020 21:18:33 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_bitbake/</guid>
      <description>&lt;h1 id=&#34;bitbake&#34;&gt;BitBake&lt;/h1&gt;&#xA;&lt;p&gt;bitbake是类似于make的构建工具，主要用于OpenEmbedded和yocto构建linux发行版.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/openembedded/bitbake&#34;&gt;https://github.com/openembedded/bitbake&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;bitbake:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ bitbake python -c devshell/devpyshell&#xA;$ bitbake python -c clean/cleanall/cleanstate&#xA;$ bitbake python -c compile&#xA;$ bitbake python -c fetch/fetchall&#xA;&#xA;# 查找下载地址&#xA;$ bitbake -e python | grep ^SRC_URI&#xA;&#xA;# 根据文件查找包名&#xA;bitbake&amp;gt; oe-pkgdata-util find-path /usr/bin/python3&#xA;&#xA;# 包名查找recipe&#xA;bitbake&amp;gt; oe-pkgdata-util lookup-recipe python3-core&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;openembedded&#34;&gt;openembedded&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/openembedded/openembedded-core&#34;&gt;https://github.com/openembedded/openembedded-core&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;yoctopoky&#34;&gt;yocto(poky)&lt;/h1&gt;&#xA;&lt;p&gt;poky是一个开源的最小构建示例，内置bitbake，可直接编译.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/&#34;&gt;http://git.yoctoproject.org/cgit/cgit.cgi/poky/log/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers&#34;&gt;http://git.yoctoproject.org/cgit/cgit.cgi/meta-virtualization/tree/recipes-containers&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/crazy-canux/poky&#34;&gt;https://github.com/crazy-canux/poky&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;toaster&#34;&gt;toaster&lt;/h1&gt;</description>
    </item>
    <item>
      <title>kernel</title>
      <link>https://canuxcheng.com/post/linux_kernel/</link>
      <pubDate>Wed, 27 May 2020 22:29:00 +0800</pubDate>
      <guid>https://canuxcheng.com/post/linux_kernel/</guid>
      <description>&lt;h1 id=&#34;kernel&#34;&gt;Kernel&lt;/h1&gt;&#xA;&lt;h1 id=&#34;command&#34;&gt;command&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;lsmod 查看已加载的模块    # /proc/modules&#xA;rmmod &amp;lt;name&amp;gt; 删除模块&#xA;&#xA;modprobe -c 查看已编译可加载的内核模块&#xA;modprobe &amp;lt;name&amp;gt; 加载模块 # /etc/modules&#xA;modprobe -r &amp;lt;name&amp;gt; 删除模块&#xA;&#xA;// modprobe 重启就没了&#xA;echo &amp;quot;ipmi_devintf&amp;quot; &amp;gt;&amp;gt; /etc/modules&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux Security</title>
      <link>https://canuxcheng.com/post/linux_security/</link>
      <pubDate>Sun, 24 May 2020 15:30:42 +0800</pubDate>
      <guid>https://canuxcheng.com/post/linux_security/</guid>
      <description>&lt;h1 id=&#34;selinux&#34;&gt;SeLinux&lt;/h1&gt;&#xA;&lt;p&gt;Security-Enhanced Linux&lt;/p&gt;&#xA;&lt;h1 id=&#34;seccomp&#34;&gt;SecComp&lt;/h1&gt;&#xA;&lt;p&gt;Secure computing mode (seccomp) is a Linux kernel feature.&lt;/p&gt;&#xA;&lt;h1 id=&#34;apparmor&#34;&gt;AppArmor&lt;/h1&gt;&#xA;&lt;p&gt;AppArmor (Application Armor) is a Linux security module that protects an operating system and its applications from security threats.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Init</title>
      <link>https://canuxcheng.com/post/linux_init/</link>
      <pubDate>Sun, 03 Feb 2019 14:04:05 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_init/</guid>
      <description>&lt;h1 id=&#34;linux-init&#34;&gt;Linux Init&lt;/h1&gt;&#xA;&lt;p&gt;linux系统启动的第一个进程,pid=1的进程.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ ls -l /sbin/init&#xA;$ sudo readlink /sbin/init&#xA;/sbin/init -&amp;gt; upstart&#xA;/sbin/init -&amp;gt; /lib/systemd/systemd&#xA;&#xA;/etc/init.d&#xA;The directory containing System V init scripts.&#xA;通过service命令操作&#xA;&#xA;/etc/init&#xA;The directory containing upstart jobs.&#xA;通过initctl命令操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;systemd&#34;&gt;systemd&lt;/h1&gt;&#xA;&lt;p&gt;sytemd是upstart的替代版本．通过查看/sbin/init指向systemd还是upstart.&lt;/p&gt;&#xA;&lt;p&gt;service文件位置:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/etc/systemd/system/***.service&#xA;/lib/systemd/system/*.service&#xA;/usr/lib/systemd/system/*.service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;service文件编写:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.unit.html#&#34;&gt;https://www.freedesktop.org/software/systemd/man/systemd.unit.html#&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[Unit]&#xA;Description=details&#xA;After=containerd.service # 之前启动&#xA;Before= # 之后运行&#xA;Bindsto= #&#xA;Wants=containerd.service # 弱依赖&#xA;Requires= # 强依赖&#xA;StartLimitInterval=10s&#xA;StartLimitBurst=5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.service.html#&#34;&gt;https://www.freedesktop.org/software/systemd/man/systemd.service.html#&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[Service]&#xA;Type=simple/notify/dbus/forking/idle/oneshot&#xA;ExecStartPre=&#xA;ExecStart=&#xA;ExecStartPost=&#xA;ExecStop=&#xA;ExecStopPost=&#xA;ExecReload=&#xA;KillMode=node/mixed/process/control-group&#xA;Restart=no/on-success/on-failure/on-abnormal/on-abort/on-watchdog/always # always总是开机启动，即使systemctl enable.&#xA;RestartSec=3s # 重启之前等待的时间.&#xA;TimeoutSec=  # TimeoutStartSec+TimeoutStopSec&#xA;LimitNOFILE=49152 # 限制单个service的fd&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;systemctl命令:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>https://canuxcheng.com/post/linux_makefile/</link>
      <pubDate>Thu, 12 Jan 2017 21:18:33 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_makefile/</guid>
      <description>&lt;h1 id=&#34;make&#34;&gt;Make&lt;/h1&gt;&#xA;&lt;p&gt;make的作用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;控制源代码的编译&lt;/li&gt;&#xA;&lt;li&gt;手册页的编写&lt;/li&gt;&#xA;&lt;li&gt;将应用程序安装到目标目录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;make的使用规则：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果工程没有编译过，需要编译所有源文件和链接所有目标文件．&lt;/li&gt;&#xA;&lt;li&gt;如果工程里某几个目标文件被修改，只需要编译修改的源文件，并链接所有目标文件．&lt;/li&gt;&#xA;&lt;li&gt;如果头文件被修改，只需要编译引用了被修改的头文件的源文件，并链接所有目标文件．&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;makefile文件查找顺序：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前目录找makefile&lt;/li&gt;&#xA;&lt;li&gt;当前目录找Makefile&lt;/li&gt;&#xA;&lt;li&gt;当前目录找GNUmakefile&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;make命令&#34;&gt;make命令&lt;/h1&gt;&#xA;&lt;p&gt;make命令会执行当前目录的makefile/Makefile/GNUmakefile文件．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;make [options] [target] ...&#xA;-f FILE, --file=FILE, --makefile=FILE    # 指定makefile文件&#xA;-n, --just-print, --dry-run, --recon # 只打印，不执行&#xA;-k, --keep-going　# 忽略错误继续执行&#xA;&#xA;make&#xA;make all&#xA;make install&#xA;make clean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;make的工作顺序：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读入所有makefile文件&lt;/li&gt;&#xA;&lt;li&gt;读入include的其它makefile文件&lt;/li&gt;&#xA;&lt;li&gt;初始化变量&lt;/li&gt;&#xA;&lt;li&gt;推导隐晦规则，分析所有规则&lt;/li&gt;&#xA;&lt;li&gt;为所有目标文件创建依赖关系链&lt;/li&gt;&#xA;&lt;li&gt;根据依赖关系决定哪些目标需要重新生成&lt;/li&gt;&#xA;&lt;li&gt;执行生成的命令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;makefile语法&#34;&gt;makefile语法&lt;/h1&gt;&#xA;&lt;p&gt;make命令执行makefile文件时，会比较target和prerequisites的时间戳，如果后者比前者新，或者前者不存在，就会执行command,否则会跳过command.&lt;/p&gt;&#xA;&lt;p&gt;其中#表示注释，\表示续行．@表示该命令的执行不会打印到stdout,-表示忽略错误继续执行．&lt;/p&gt;&#xA;&lt;p&gt;makefile中的command必须以tab开头，target和prerequisites有多个时用空格分开．&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# comment&#xA;target...: prerequisites...&#xA;    command&#xA;    command1 too \&#xA;    long&#xA;    @command2&#xA;    -command3&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;makefile变量赋值:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;var=val&#xA;var := val  覆盖之前的值&#xA;var ?= val  如果没有被赋值过，就赋值&#xA;var += val  添加一个值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过命令定义变量：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Awk</title>
      <link>https://canuxcheng.com/post/shell_awk/</link>
      <pubDate>Wed, 14 Dec 2016 00:55:37 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_awk/</guid>
      <description>&lt;h1 id=&#34;awk&#34;&gt;awk&lt;/h1&gt;&#xA;&lt;p&gt;awk 是一门编程语言&lt;/p&gt;&#xA;&lt;p&gt;awk/nawk/gawk/mawk：比sed更高级的流编辑工具，是sed和grep的升级版，主要用于数据流处理。&lt;/p&gt;&#xA;&lt;p&gt;nawk： new awk。&lt;/p&gt;&#xA;&lt;p&gt;mawk： awk的解释器&lt;/p&gt;&#xA;&lt;p&gt;gawk是gnu的awk，功能更全面。&lt;/p&gt;&#xA;&lt;p&gt;awk命令格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;awk [-v var=value [-F *] [–] &#39;/pattern/ {action}&#39;  file&#xA;awk [-v var=value [-F *] [-f scriptfile ...] [–] file&#xA;awk [-v var=value [-F *] [-] &#39;BEGIN {} /pattern/ {action} END {}&#39;  file&#xA;BEGIN { }  在读取输入之前就操作&#xA;END { }    在读物输入之后操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;awk的指令需要用单引号包围；&#xA;模式需要用/pattern/包围；&#xA;过程需要用{command1；command2}包围，多个过程需要用；隔开。&lt;/p&gt;&#xA;&lt;p&gt;脚本中传递参数格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;awk [-f scriptfile]OR[&#39;/pattern/{action}&#39;] val1=value1 val2=value2 … file1   vala=valuea valb=valueb... file2 ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果通过shell传参数，把value改成$n即可。&#xA;可以通过命令返回值作为参数value。&#xA;也可以使用环境变量作为value，也可以给awk的环境变量赋值。&#xA;可以在任何位置定义变量（‘ ‘ 之后；-v之后；BEGIN中；{}中；END中）。&#xA;只有在-v和在BEGIN中定义的变量能在BEGIN中使用。&#xA;在END中定义的变量只能在END中使用，其它位置定义的变量都可以在{}中使用。&#xA;在任何位置定义的变量在END中都可以使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Package</title>
      <link>https://canuxcheng.com/post/linux_package/</link>
      <pubDate>Tue, 07 Jun 2016 16:57:45 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_package/</guid>
      <description>&lt;h1 id=&#34;dpkg&#34;&gt;DPKG&lt;/h1&gt;&#xA;&lt;p&gt;debian的包管理机制。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;dpkg-1&#34;&gt;dpkg&lt;/h2&gt;&#xA;&lt;p&gt;dpkg的本地前端工具。&lt;/p&gt;&#xA;&lt;h3 id=&#34;deb---debian-binary-package-format&#34;&gt;deb - Debian binary package format&lt;/h3&gt;&#xA;&lt;h3 id=&#34;dpkg---package-manager-for-debian&#34;&gt;dpkg - package manager for Debian&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;dpkg&#xA;dpkg -X  ./xxx.deb  xxx  # 将deb包解压到xxx目录&#xA;dpkg -e  ./xxx.deb  xxx/DEBIAN # 将control信息解压&#xA;dpkg -l | grep pkg # 查看安装的包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dpkg-reconfigure---reconfigure-an-already-installed-package&#34;&gt;dpkg-reconfigure - reconfigure an already installed package&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;dpkg-reconfigure&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dpkg-deb---debian-package-archive-deb-manipulation-tool&#34;&gt;dpkg-deb - Debian package archive (.deb) manipulation tool&lt;/h3&gt;&#xA;&lt;p&gt;目录结构, DEBIAN/control是必需的&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;|- debian_root&#xA;   |- DEBIAN&#xA;      |- control&#xA;      |- preinst/preinstallation # 解压deb包之前执行&#xA;      |- prerm/preremove&#xA;      |- postinst/postinstallation # 解压完成之后执行，通常用来配置&#xA;      |- postrm/postremove&#xA;      |- copyright&#xA;      |- changelog&#xA;      |- conffiles&#xA;   |- etc&#xA;      |- init.d/systemd&#xA;         |- &amp;lt;service&amp;gt;&#xA;      |- logrotate.d&#xA;         |- &amp;lt;service&amp;gt;&#xA;   |- user/local/...&#xA;   |- opt/...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;control:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Find</title>
      <link>https://canuxcheng.com/post/shell_find/</link>
      <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_find/</guid>
      <description>&lt;h1 id=&#34;find&#34;&gt;find&lt;/h1&gt;&#xA;&lt;p&gt;Find     查找，用于在目录中查找。&#xA;find  path  options  tests  actions&#xA;path 路径&#xA;options 选项&#xA;tests 测试&#xA;actions 动作&lt;/p&gt;&#xA;&lt;p&gt;optioins选项:&#xA;-follow&#xA;-depth&#xA;-maxdepth&#xA;-mindepth&#xA;find   dir  -mindepth  n     指定最小的目录深度，至少从dir往下n级目录开始往下搜索，dir和n级之间的忽略。&#xA;find   dir   -maxdepth  n      指定最大目录深度，不搜索n级之后的目录。&lt;/p&gt;&#xA;&lt;p&gt;test选项很多：&#xA;-newer   pattern   比pattern文件要新&#xA;-user    pattern      文件属主是pattern&#xA;-name   pattern    查找和type匹配的&#xA;-iname  pattern    查找和type匹配的，会忽略大小写&#xA;-iwholename&#xA;-path   pattern     按照文件路径匹配&#xA;-type   c           c是文件类型，按照文件类型匹配文件&#xA;-size   +/-    nk/c/w/k/b/M/G    匹配大于或小于n  kb/..  的文件&#xA;-perm   XXX       基于文件权限的匹配&#xA;find dir  –atime/mtime/ctime    +/-n    根据时间累匹配，atime表示访问时间，mtime表示修改时间，ctime表示变化时间，+表示大于，-表示小于，单位是天。&#xA;-a/-and   pattern&#xA;-o/-or     pattern&#xA;！/-not    pattern&#xA;find  dir  !  test   pattern   列出所有没有按照-options  pattern模式的项&#xA;(&amp;hellip;)    使用括号需要用引号来引用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grep</title>
      <link>https://canuxcheng.com/post/shell_grep/</link>
      <pubDate>Wed, 20 Apr 2016 13:55:36 +0800</pubDate>
      <guid>https://canuxcheng.com/post/shell_grep/</guid>
      <description>&lt;h1 id=&#34;grep&#34;&gt;grep&lt;/h1&gt;&#xA;&lt;p&gt;grep相关的命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;grep&#xA;egrep == grep -E&#xA;fgrep == grep -F&#xA;rgrep == grep -r&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;grep:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;grep [OPTIONS] PATTERN [FILE/DIR...]&#xA;grep [OPTIONS] [-e PATTERN | -f FILE] [FILE/DIR...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;options:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Matcher Selection&#xA;-G, --basic-regexp grep默认只支持BRE, 只能使用基本的RE&#xA;-E, --extended-regexp 选择ERE, 可以使用扩展的RE&#xA;# grep -E &amp;quot;pattern1|pattern2&amp;quot; 比如支持或运算&#xA;-F, --fixed-strings&#xA;-P, --perl-regexp perl RE&#xA;&#xA;# Matching Control&#xA;-e PATTERN, --regexp=PATTERN    可以指定多个pattern&#xA;# grep -e pattern1 -e pattern2 filename 相当于或运算，满足一个就被过滤出来&#xA;-f FILE, --file=FILE    文件的每一行就是一个pattern.&#xA;-i, --ignore-case    忽略大小写&#xA;-v, --invert-match   忽略含有pattern的行&#xA;-w, --word-regexp    精确匹配一个单词&#xA;-x, --line-regexp    精确匹配一行&#xA;-y&#xA;&#xA;# General Output Control&#xA;-c, --count    统计匹配到的行数&#xA;--color[=WHEN], --colour[=WHEN]    输出匹配的pattern高亮&#xA;-L, --files-without-match    列出没有匹配到的文件名&#xA;-l, --files-with-matches    列出匹配到的文件的文件名&#xA;# grep -rl pattern1 | xargs grep -r pattern2    相当于与运算，过滤同时满足两个pattern&#xA;-m NUM, --max-count=NUM&#xA;-o, --only-matching    只输出匹配的部分&#xA;# grep -o pattern filename | wc -l 统计匹配的行数&#xA;-q, --quiet, --silent    不打印查找的结果&#xA;-s, --no-messages&#xA;&#xA;# Output Line Prefix Control&#xA;-b, --byte-offset    打印匹配的字符数或偏移量&#xA;-H, --with-filename&#xA;-h, --no-filename&#xA;--label=LABEL&#xA;-n, --line-number    打印匹配的行的行号&#xA;-T, --initial-tab&#xA;-u, --unix-byte-offsets&#xA;-Z, --null&#xA;&#xA;# Context Line Control&#xA;-A NUM, --after-context=NUM    打印匹配到的行的后NUM行&#xA;-B NUM, --before-context=NUM    打印匹配到的行的前NUM行j&#xA;-C NUM, -NUM, --context=NUM    打印匹配到的行的前NUM行和后NUM行&#xA;&#xA;# File and Directory Selection&#xA;-a, --text&#xA;--binary-files=TYPE&#xA;-D ACTION, --devices=ACTION&#xA;-d ACTION, --directories=ACTION&#xA;--exclude=GLOB    排除查找指定的文件&#xA;--exclude-from=FILE&#xA;--exclude-dir=DIR   排除查找指定的目录&#xA;-I&#xA;--include=GLOB     指定查找的文件&#xA;-r, --recursive    递归查找&#xA;-R, --dereference-recursive    递归查找&#xA;# grep -nR/-nr pattern filename    阅读源码可以递归查找并打印行号&#xA;&#xA;# Other Options&#xA;--line-buffered&#xA;--mmap&#xA;-U, --binary&#xA;-z, --null-data&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ack&#34;&gt;ack&lt;/h1&gt;&#xA;&lt;p&gt;ack/ack2是grep的升级版&lt;/p&gt;</description>
    </item>
    <item>
      <title>Admin</title>
      <link>https://canuxcheng.com/post/linux_admin/</link>
      <pubDate>Fri, 15 Apr 2016 09:41:39 +0800</pubDate>
      <guid>https://canuxcheng.com/post/linux_admin/</guid>
      <description>&lt;h1 id=&#34;linux-admin&#34;&gt;Linux Admin&lt;/h1&gt;&#xA;&lt;p&gt;dpkg: ubuntu, debian.&lt;/p&gt;&#xA;&lt;p&gt;rpm: fedora, centos, redhat.&lt;/p&gt;&#xA;&lt;p&gt;zypper: suse.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;linux系统常用的安装和配置&#34;&gt;Linux系统常用的安装和配置&lt;/h1&gt;&#xA;&lt;h2 id=&#34;terminalizer&#34;&gt;terminalizer&lt;/h2&gt;&#xA;&lt;p&gt;终端录制工具&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/faressoft/terminalizer&#34;&gt;https://github.com/faressoft/terminalizer&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;virtualbox&#34;&gt;virtualbox&lt;/h2&gt;&#xA;&lt;p&gt;开机自动挂载共享文件夹&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 手动挂在命令, 需要安装增强功能&#xA;$ mount -t vboxsf FolderNameOnWindows /path/on/linux&#xA;&#xA;# 实现开机自动挂载&#xA;$ sudo vim /etc/rc.local&#xA;mount.vboxsf -w ShareFolderNameOnWindows MountPointOnLinux&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;xrdp&#34;&gt;xrdp&lt;/h2&gt;&#xA;&lt;p&gt;从windows的RDP远程连接linux.&lt;/p&gt;&#xA;&lt;p&gt;use RDP on windows to connect to ubuntu16.04.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo dpkg -i tigervncserver_1.6...deb # download and install tigervncserver first.&#xA;sudo apt-get install -f&#xA;sudo apt-get instal xrdp -y&#xA;echo unity &amp;gt; ~/.xsession&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;use RDP on windows to connect to ubuntu14.04.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Regular Expression</title>
      <link>https://canuxcheng.com/post/regularexpression/</link>
      <pubDate>Sat, 02 Apr 2016 11:16:16 +0000</pubDate>
      <guid>https://canuxcheng.com/post/regularexpression/</guid>
      <description>&lt;h1 id=&#34;re&#34;&gt;RE&lt;/h1&gt;&#xA;&lt;p&gt;在线检测：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.regexpal.com/&#34;&gt;https://www.regexpal.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;RE分为BRE(basic RE), ERE(extended RE), SRE(simpla RE).&lt;/p&gt;&#xA;&lt;p&gt;在BRE中+?(){}|没有特殊含义，除非用\转义．&lt;/p&gt;&#xA;&lt;p&gt;在ERE中+?(){}被保留有特殊含义，除非用\转义才表示普通字符．&lt;/p&gt;&#xA;&lt;p&gt;命令find, grep, sed, awk等都可以使用正则表达式．&lt;/p&gt;&#xA;&lt;p&gt;特殊字符含义：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;()      对正则表达式分组, ERE&#xA;\n      再匹配前面的分组n次&#xA;&#xA;.       匹配任意单个字符, 换行符除外&#xA;^tux    匹配以tux开始的行&#xA;tux$    匹配以tux结束的行&#xA;&#xA;*+?{}特殊字符是贪婪匹配模式,也就是尽可能多的匹配&#xA;*           匹配前面一个字符0次或多次，包括前面这个字符本身&#xA;+           匹配前面一个字符1次或多次，包括前面这个字符, ERE&#xA;?           匹配前面一个字符0次或1次，包括前面这个字符, ERE&#xA;{n}         匹配前面一个字符n次，包括前面这个字符, ERE&#xA;{min,}      匹配前面一个字符至少min次，包括前面这个字符, ERE&#xA;{min,max}   匹配前面一个字符至少min次，最多max次，包括前面这个字符, ERE&#xA;&#xA;下面是非贪婪匹配模式&#xA;*?    匹配0个或多个&#xA;+?    匹配1个或多个&#xA;??    匹配０个或１个&#xA;{n}?        只匹配n个&#xA;{min,}?     至少min个&#xA;{min,max}?  至少min个，最多max个&#xA;&#xA;[abc]   匹配包含在[]中的任意一个字符，除了\, ^, -三个特殊字符&#xA;[^abc]  匹配不包含在[]中的任意一个字符(和上面相反)&#xA;[a-z]   匹配[]中指定范围内的任意一个字符&#xA;[abc\?] 用＼转义[]中的特殊字符&#xA;&#xA;|       表示逻辑或, ERE&#xA;&#xA;\       转义字符，将特殊字符转义成普通字符&#xA;&#xA;小括号表示分组&#xA;(...)&#xA;(?...)&#xA;(?iLmsux)&#xA;(?:...)&#xA;(?P&amp;lt;name&amp;gt;...)&#xA;(?P=name)&#xA;(?#...)&#xA;(?=...)&#xA;(?!...)&#xA;(?&amp;lt;=...)&#xA;(?&amp;lt;!...)&#xA;(?(id/name)yes-pattern|no-pattern)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;匹配前面一个字符０次，包括前面这个字符，也就是说０次表示不匹配前面这个字符．&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sed</title>
      <link>https://canuxcheng.com/post/shell_sed/</link>
      <pubDate>Sat, 02 Apr 2016 11:15:57 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_sed/</guid>
      <description>&lt;h1 id=&#34;sed&#34;&gt;sed&lt;/h1&gt;&#xA;&lt;p&gt;sed：stream editor  流编辑器 ，主要用于文本处理。&lt;/p&gt;&#xA;&lt;p&gt;sed命令格式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sed   -options   ’expression1;expression2’     file           执行多个命令&#xA;sed   -options   [-e ‘expression1’] [-e ‘expression2’]  file  执行多个命令&#xA;sed   -options   [-f   scriptfile]   file                     通过脚本执行命令&#xA;sed   -options   [-f   scriptfile]   file  &amp;gt;  newfile  #sed修改后重定向到新文件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;sed指令需要用单引号包围。使用双引号“”可以传递变量。&#xA;Sed默认并没有修改文件file中的数据。&#xA;sed默认在stdout输出文件的所有行。&#xA;Sed地址需要使用/address/来包围。&#xA;sed使用正则表达式可以用\BRE\包围，如果模式包含/，那么可以使用除了换行符之外的所有字符包围。&lt;/p&gt;&#xA;&lt;p&gt;options：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;-e：指定多个命令或脚本&#xA;-f：指定执行命令的脚本&#xA;-n：阻止自动输出，p可以打印匹配的行。&#xA;-i: 直接修改读入的文件的内容.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;experssion：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;expression：指令由模式和过程组成。&#xA;[address]/[line-address][!]command[arguments]&#xA;[address]表示地址，一般用模式进行寻址，address缺省表示整个文件寻址，两个地址用，隔开。&#xA;[line-address]表示只能是一个地址。&#xA;[!] 表示不匹配该地址的所有行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Command:&lt;/p&gt;&#xA;&lt;p&gt;sed有25个命令。&lt;/p&gt;&#xA;&lt;p&gt;使用大括号{}在一个地址中做嵌套操作：例如：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/address1/,/address2/{&#xA;    /^$/d&#xA;    s/string1/string2/&#xA;    …&#xA;}             // 单独一行，后面不能有空格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;s命令：替换，替换模式空间中的行。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sed &#39;[address]s/oldpattern/newpattern/[flag]&#39; filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;flag:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shell</title>
      <link>https://canuxcheng.com/post/shell/</link>
      <pubDate>Fri, 01 Apr 2016 20:42:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell/</guid>
      <description>&lt;h1 id=&#34;shell&#34;&gt;Shell&lt;/h1&gt;&#xA;&lt;p&gt;Linux的shell有很多种,大多数linux发行版的默认登录shell是BASH。&lt;/p&gt;&#xA;&lt;p&gt;查看当前使用的shell：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;echo $SHELL&#xA;echo $0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看安装了哪些shell：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cat /etc/shells&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;设置登陆shell:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$chsh -s $(which shellname)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;shell分为登陆shell和交互式shell:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 输出有i的就是交互shell&#xA;$echo $-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;非交互登陆shell:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先运行系统配置文件/etc/profile(调用/etc/bash.bashrc和/etc/profile.d/*.sh)&lt;/li&gt;&#xA;&lt;li&gt;然后运行用户配置文件~/.profile(调用~/.bashrc和~/bin)&lt;/li&gt;&#xA;&lt;li&gt;最后退出用户登陆~/.bash_logout&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;交互非登陆shell:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先运行/etc/bash.bashrc(调用/etc/bash_completion(调用/etc/bash_completion.d/*.sh))&lt;/li&gt;&#xA;&lt;li&gt;然后运行~/.bashrc(调用~/.bash_aliases和~/bash.d和~/bin)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;shell相关项目&#34;&gt;shell相关项目&lt;/h1&gt;&#xA;&lt;h2 id=&#34;bash-it&#34;&gt;bash-it&lt;/h2&gt;&#xA;&lt;p&gt;大部分发行版默认使用bash,无需额外安装。&lt;/p&gt;&#xA;&lt;p&gt;bash的优化项目bash-it：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Bash-it/bash-it&#34;&gt;https://github.com/Bash-it/bash-it&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;zsh&#34;&gt;zsh&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.zsh.org/&#34;&gt;http://www.zsh.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;oh-my-zsh&#34;&gt;oh-my-zsh&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;fish-shell&#34;&gt;fish-shell&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fish-shell/fish-shell&#34;&gt;https://github.com/fish-shell/fish-shell&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;oh-my-fish&#34;&gt;oh-my-fish&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/oh-my-fish/oh-my-fish&#34;&gt;https://github.com/oh-my-fish/oh-my-fish&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;thefuck&#34;&gt;thefuck&lt;/h2&gt;&#xA;&lt;p&gt;一个纠正shell命令输错的命令&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nvbn/thefuck&#34;&gt;https://github.com/nvbn/thefuck&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;shellcheck&#34;&gt;shellcheck&lt;/h2&gt;&#xA;&lt;p&gt;一个debug脚本的工具．&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/koalaman/shellcheck&#34;&gt;https://github.com/koalaman/shellcheck&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;shell-script&#34;&gt;shell script&lt;/h1&gt;&#xA;&lt;p&gt;基本语法&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash&#xA;&#xA;command1 &amp;amp;&amp;amp; command2    # 当command1执行成功（返回0)才会执行command2&#xA;command1 || command2    # 当command1执行失败（返回非0)才会执行command2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;shell注释&#34;&gt;shell注释&lt;/h2&gt;&#xA;&lt;p&gt;单行注释：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# comment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;多行注释：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Coreutils</title>
      <link>https://canuxcheng.com/post/shell_coreutils/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_coreutils/</guid>
      <description>&lt;h1 id=&#34;linux的外部命令&#34;&gt;Linux的外部命令&lt;/h1&gt;&#xA;&lt;p&gt;Linux外部命令的项目是coreutils。&lt;/p&gt;&#xA;&lt;p&gt;外部命令在coreutils目录中&lt;/p&gt;&#xA;&lt;p&gt;查看外部命令所在目录：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;echo $PATH&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;外部命令在下列目录中：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;~/bin # 用户自定义&#xA;&#xA;/sbin&#xA;&#xA;/bin&#xA;&#xA;/usr/sbin&#xA;&#xA;/usr/bin&#xA;&#xA;/usr/local/sbin&#xA;&#xA;/usr/local/bin&#xA;&#xA;/usr/games&#xA;&#xA;/usr/local/games&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看外部命令手册的在线手册：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;man [command]&#xA;info [command]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;自定义外部命令：&lt;/p&gt;&#xA;&lt;p&gt;添加$PATH变量，然后放到该目录。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;系统管理&#34;&gt;系统管理&lt;/h1&gt;&#xA;&lt;p&gt;cpu/mem/load&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 查看cpu/mem/swap/system信息&#xA;vmstat&#xA;vmstat 1&#xA;&#xA;# 查看进程消耗的cpu/mem/swap/system等系统信息&#xA;top&#xA;top -H  # 查看线程&#xA;%cpu = cputime/realtime * 100%&#xA;cpu_usage = %cpu/cpu-number&#xA;%mem = RES/physicalMem * 100%&#xA;&#xA;htop&#xA;$ sudo apt-get install htop&#xA;&#xA;$ sudo apt-get install sysstat (包括pidstat)&#xA;pidstat -u -p pid // cpu&#xA;pidstat -r -p pid //mem&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;cpu/load:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Utils</title>
      <link>https://canuxcheng.com/post/shell_utils/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:25 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_utils/</guid>
      <description>&lt;h1 id=&#34;linux的第三方命令&#34;&gt;Linux的第三方命令&lt;/h1&gt;&#xA;&lt;p&gt;Linux外部命令的项目是coreutils.&lt;/p&gt;&#xA;&lt;p&gt;外部命令在coreutils目录中.&lt;/p&gt;&#xA;&lt;p&gt;第三方命令(相当于外部命令)．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;文件和目录管理&#34;&gt;文件和目录管理&lt;/h1&gt;&#xA;&lt;p&gt;autojump:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wting/autojump&#34;&gt;https://github.com/wting/autojump&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;fasd:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clvv/fasd&#34;&gt;https://github.com/clvv/fasd&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;fzf:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;压缩备份&#34;&gt;压缩备份&lt;/h1&gt;&#xA;&lt;h1 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h1&gt;&#xA;&lt;h1 id=&#34;设备管理&#34;&gt;设备管理&lt;/h1&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>Builtins</title>
      <link>https://canuxcheng.com/post/shell_builtins/</link>
      <pubDate>Thu, 31 Mar 2016 21:51:03 +0000</pubDate>
      <guid>https://canuxcheng.com/post/shell_builtins/</guid>
      <description>&lt;h1 id=&#34;linux内置命令&#34;&gt;Linux内置命令&lt;/h1&gt;&#xA;&lt;p&gt;内置命令在bash/builtins目录中&lt;/p&gt;&#xA;&lt;p&gt;shell命令分为内置命令和外部命令.&lt;/p&gt;&#xA;&lt;p&gt;查看一个命令是内置命令还是外部命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;type -a [command]&#xA;&#xA;提示&amp;quot;[command] is a shell builtin&amp;quot;就表示是内置命令，否则就是外部命令。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看所有内置命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;help&#xA;enable -a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查看内置命令的帮助：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;help [command]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre&gt;&lt;code&gt;type&#xA;enable&#xA;help&#xA;&#xA;caller&#xA;alias&#xA;bg&#xA;bind&#xA;break&#xA;builtin&#xA;command&#xA;compgen&#xA;complete&#xA;compopt&#xA;continue&#xA;declare&#xA;disown&#xA;let&#xA;local&#xA;logout&#xA;mapfile&#xA;popd&#xA;printf&#xA;pushd&#xA;read&#xA;readarray&#xA;readonly&#xA;return&#xA;shift&#xA;shopt&#xA;source&#xA;suspend&#xA;times&#xA;trap&#xA;true&#xA;typeset&#xA;ulimit&#xA;umask&#xA;unalias&#xA;unset&#xA;wait&#xA;eval&#xA;exec&#xA;exit&#xA;export&#xA;false&#xA;fc&#xA;fg&#xA;getopts&#xA;hash&#xA;history&#xA;jobs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;路径相关:&lt;/p&gt;</description>
    </item>
    <item>
      <title>FileSystem</title>
      <link>https://canuxcheng.com/post/linux_filesystem/</link>
      <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_filesystem/</guid>
      <description>&lt;h1 id=&#34;vfs&#34;&gt;VFS&lt;/h1&gt;&#xA;&lt;p&gt;Linux采用虚拟文件系统，支持多个文件系统协议．&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;extext2ext3ext4&#34;&gt;ext/ext2/ext3/ext4&lt;/h1&gt;&#xA;&lt;h1 id=&#34;jfs2&#34;&gt;JFS2&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ramfs&#34;&gt;ramfs&lt;/h1&gt;&#xA;&lt;p&gt;linux的VM(虚拟内存)包括ramfs和swap.&lt;/p&gt;&#xA;&lt;p&gt;对内存的支持&lt;/p&gt;&#xA;&lt;h1 id=&#34;swap&#34;&gt;swap&lt;/h1&gt;&#xA;&lt;p&gt;交换分区，当内存不足，会把内存上暂时不运行的程序保存到swap，获取部分内存空间运行．&lt;/p&gt;&#xA;&lt;h1 id=&#34;tmpfs&#34;&gt;tmpfs&lt;/h1&gt;&#xA;&lt;p&gt;临时文件系统, 优先使用ramfs,　其次使用swap.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 挂载tmpfs&#xA;mount -t tmpfs -o size=1024m tmpfs /path/to/mount&#xA;# /etc/fstab　&#xA;tmpfs /dev/shm tmpfs,defaults,size=512m 0 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;vfatfatntfs&#34;&gt;vfat/fat/ntfs&lt;/h1&gt;&#xA;&lt;p&gt;windows文件系统&lt;/p&gt;&#xA;&lt;h1 id=&#34;cifssmbfs&#34;&gt;cifs/smbfs&lt;/h1&gt;&#xA;&lt;h1 id=&#34;nfs&#34;&gt;nfs&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Firewall</title>
      <link>https://canuxcheng.com/post/linux_firewall/</link>
      <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_firewall/</guid>
      <description>&lt;h1 id=&#34;firewall&#34;&gt;Firewall&lt;/h1&gt;&#xA;&lt;p&gt;UFW: linux防火墙配置工具，底层还是调用iptables.&lt;/p&gt;&#xA;&lt;p&gt;filewall: centos的防火墙命令, 底层还是调用iptables.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;selinux&#34;&gt;SELinux&lt;/h1&gt;&#xA;&lt;p&gt;Security-Enhanced-Linux&lt;/p&gt;&#xA;&lt;p&gt;本地安全&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;netfilter&#34;&gt;Netfilter&lt;/h1&gt;&#xA;&lt;p&gt;网络安全&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;iptables&#34;&gt;iptables&lt;/h1&gt;&#xA;&lt;p&gt;通过iptables操作Netfilter实现应用层安全.&lt;/p&gt;&#xA;&lt;p&gt;table:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;filter 默认表&#xA;nat&#xA;mangle&#xA;raw&#xA;security&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;filter&#34;&gt;filter&lt;/h2&gt;&#xA;&lt;p&gt;chain:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;INPUT&#xA;FORWARD&#xA;OUTPUT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nat&#34;&gt;nat&lt;/h2&gt;&#xA;&lt;p&gt;chain:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;INPUT&#xA;OUTPUT&#xA;PREROUTING&#xA;POSTROUTING&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;postrouting:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;snat: 内网主机访问外网经过路由时，源ip会发生变化。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;prerouting:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;dnat:  外网访问内网经过路由时，目的ip会发生变化。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;iptables命令&#34;&gt;iptables命令&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;-L/--list  [chain [ rulenum]]&#xA;-S/--list-rules [chain [rulenum]]&#xA;-Z/--zero [chain [rulenum]]&#xA;&#xA;-A/--append chain&#xA;-C/--check chain&#xA;-N/--new chain&#xA;&#xA;-F/--flush [chain] // 删除chain中的rules.&#xA;-X/--delete-chain [chain] // 删除自定义chain.&#xA;&#xA;-R/--replace chain rulenum&#xA;-D/--delete chain [rulenum]&#xA;-I/--insert chain [rulenum]&#xA;&#xA;-P/--policy chain target&#xA;&#xA;-E/--rename-chain old-chain new-chain&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;tables:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grub</title>
      <link>https://canuxcheng.com/post/linux_grub/</link>
      <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_grub/</guid>
      <description>&lt;h1 id=&#34;grub&#34;&gt;Grub&lt;/h1&gt;&#xA;&lt;p&gt;引导程序。&lt;/p&gt;&#xA;&lt;p&gt;linux/unix的引导程序有lilo和grub。&lt;/p&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;&#xA;&lt;p&gt;修改grub:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo vim /boot/grub/grub.cfg&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux</title>
      <link>https://canuxcheng.com/post/linux/</link>
      <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux/</guid>
      <description>&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;&#xA;&lt;p&gt;Linux严格讲指的是Linux这一类操作系统的内核。&lt;/p&gt;&#xA;&lt;p&gt;Linux内核的github：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux内核的站点：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/&#34;&gt;https://www.kernel.org/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;商业化的linux系统：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;redhat enterprise linux&lt;/li&gt;&#xA;&lt;li&gt;suse enterprise linux&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;免费的服务器版本：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;centos (rhel的免费版服务器版)&lt;/li&gt;&#xA;&lt;li&gt;open suse&lt;/li&gt;&#xA;&lt;li&gt;debian/ubuntu&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;免费的桌面版本：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;fedora (原来的redhat desktop linux)&lt;/li&gt;&#xA;&lt;li&gt;open suse&lt;/li&gt;&#xA;&lt;li&gt;debian/ubuntu&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;linux桌面环境&#34;&gt;Linux桌面环境&lt;/h1&gt;&#xA;&lt;p&gt;X windows&lt;/p&gt;&#xA;&lt;p&gt;KDE&lt;/p&gt;&#xA;&lt;p&gt;GNOME2(Mate)&lt;/p&gt;&#xA;&lt;p&gt;GNOME3(Mate/Cinnamon)&lt;/p&gt;&#xA;&lt;p&gt;Unity&lt;/p&gt;&#xA;&lt;p&gt;xface&lt;/p&gt;&#xA;&lt;p&gt;lxde&lt;/p&gt;&#xA;&lt;p&gt;enlightenment(&lt;a href=&#34;https://www.enlightenment.org/start&#34;&gt;https://www.enlightenment.org/start&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;h1 id=&#34;linux桌面管理器&#34;&gt;Linux桌面管理器：&lt;/h1&gt;&#xA;&lt;p&gt;xDM&lt;/p&gt;&#xA;&lt;p&gt;gDM(gnome)&lt;/p&gt;&#xA;&lt;p&gt;kDM(kde)&lt;/p&gt;&#xA;&lt;p&gt;lightDM&lt;/p&gt;&#xA;&lt;h1 id=&#34;linux编程&#34;&gt;Linux编程&lt;/h1&gt;&#xA;&lt;h2 id=&#34;linux程序调用结构&#34;&gt;Linux程序调用结构：&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应用程序(包括shell外部命令)/Shell命令(也就是shell内部命令)&lt;/li&gt;&#xA;&lt;li&gt;C标准库glibc(包括ISO C和POSIC封装的系统系统调用)&lt;/li&gt;&#xA;&lt;li&gt;Linux系统调用&lt;/li&gt;&#xA;&lt;li&gt;Linux内核&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;查看手册&#34;&gt;查看手册：&lt;/h2&gt;&#xA;&lt;p&gt;查看man帮助:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ man man&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;手册章节:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Executable programs or shell commands&lt;/li&gt;&#xA;&lt;li&gt;System calls (functions provided by the kernel)&lt;/li&gt;&#xA;&lt;li&gt;Library calls (functions within program libraries)&lt;/li&gt;&#xA;&lt;li&gt;Special files (usually found in /dev)&lt;/li&gt;&#xA;&lt;li&gt;File formats and conventions eg /etc/passwd&lt;/li&gt;&#xA;&lt;li&gt;Games&lt;/li&gt;&#xA;&lt;li&gt;Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)&lt;/li&gt;&#xA;&lt;li&gt;System administration commands (usually only for root)&lt;/li&gt;&#xA;&lt;li&gt;Kernel routines [Non standard]&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;查看shell命令&lt;/p&gt;</description>
    </item>
    <item>
      <title>Monitoring</title>
      <link>https://canuxcheng.com/post/linux_monitoring/</link>
      <pubDate>Thu, 31 Mar 2016 21:48:59 +0000</pubDate>
      <guid>https://canuxcheng.com/post/linux_monitoring/</guid>
      <description>&lt;h1 id=&#34;inode&#34;&gt;inode&lt;/h1&gt;</description>
    </item>
  </channel>
</rss>
